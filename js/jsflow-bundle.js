(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],2:[function(require,module,exports){

},{}],3:[function(require,module,exports){
(function (Buffer){
var toString = Object.prototype.toString

var isModern = (
  typeof Buffer.alloc === 'function' &&
  typeof Buffer.allocUnsafe === 'function' &&
  typeof Buffer.from === 'function'
)

function isArrayBuffer (input) {
  return toString.call(input).slice(8, -1) === 'ArrayBuffer'
}

function fromArrayBuffer (obj, byteOffset, length) {
  byteOffset >>>= 0

  var maxLength = obj.byteLength - byteOffset

  if (maxLength < 0) {
    throw new RangeError("'offset' is out of bounds")
  }

  if (length === undefined) {
    length = maxLength
  } else {
    length >>>= 0

    if (length > maxLength) {
      throw new RangeError("'length' is out of bounds")
    }
  }

  return isModern
    ? Buffer.from(obj.slice(byteOffset, byteOffset + length))
    : new Buffer(new Uint8Array(obj.slice(byteOffset, byteOffset + length)))
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  return isModern
    ? Buffer.from(string, encoding)
    : new Buffer(string, encoding)
}

function bufferFrom (value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (isArrayBuffer(value)) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  return isModern
    ? Buffer.from(value)
    : new Buffer(value)
}

module.exports = bufferFrom

}).call(this,require("buffer").Buffer)

},{"buffer":4}],4:[function(require,module,exports){
(function (Buffer){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol.for === 'function')
    ? Symbol.for('nodejs.util.inspect.custom')
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    var proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable = (function () {
  var alphabet = '0123456789abcdef'
  var table = new Array(256)
  for (var i = 0; i < 16; ++i) {
    var i16 = i * 16
    for (var j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()

}).call(this,require("buffer").Buffer)

},{"base64-js":1,"buffer":4,"ieee754":25}],5:[function(require,module,exports){
(function (global){
/*
  Copyright (C) 2012-2014 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2015 Ingvar Stepanyan <me@rreverser.com>
  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>
  Copyright (C) 2012-2013 Michael Ficarra <escodegen.copyright@michael.ficarra.me>
  Copyright (C) 2012-2013 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2013 Irakli Gozalishvili <rfobic@gmail.com>
  Copyright (C) 2012 Robert Gust-Bardon <donate@robert.gust-bardon.org>
  Copyright (C) 2012 John Freeman <jfreeman08@gmail.com>
  Copyright (C) 2011-2012 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*global exports:true, require:true, global:true*/
(function () {
    'use strict';

    var Syntax,
        Precedence,
        BinaryPrecedence,
        SourceNode,
        estraverse,
        esutils,
        base,
        indent,
        json,
        renumber,
        hexadecimal,
        quotes,
        escapeless,
        newline,
        space,
        parentheses,
        semicolons,
        safeConcatenation,
        directive,
        extra,
        parse,
        sourceMap,
        sourceCode,
        preserveBlankLines,
        FORMAT_MINIFY,
        FORMAT_DEFAULTS;

    estraverse = require('estraverse');
    esutils = require('esutils');

    Syntax = estraverse.Syntax;

    // Generation is done by generateExpression.
    function isExpression(node) {
        return CodeGenerator.Expression.hasOwnProperty(node.type);
    }

    // Generation is done by generateStatement.
    function isStatement(node) {
        return CodeGenerator.Statement.hasOwnProperty(node.type);
    }

    Precedence = {
        Sequence: 0,
        Yield: 1,
        Assignment: 1,
        Conditional: 2,
        ArrowFunction: 2,
        LogicalOR: 3,
        LogicalAND: 4,
        BitwiseOR: 5,
        BitwiseXOR: 6,
        BitwiseAND: 7,
        Equality: 8,
        Relational: 9,
        BitwiseSHIFT: 10,
        Additive: 11,
        Multiplicative: 12,
        Exponentiation: 13,
        Await: 14,
        Unary: 14,
        Postfix: 15,
        Call: 16,
        New: 17,
        TaggedTemplate: 18,
        Member: 19,
        Primary: 20
    };

    BinaryPrecedence = {
        '||': Precedence.LogicalOR,
        '&&': Precedence.LogicalAND,
        '|': Precedence.BitwiseOR,
        '^': Precedence.BitwiseXOR,
        '&': Precedence.BitwiseAND,
        '==': Precedence.Equality,
        '!=': Precedence.Equality,
        '===': Precedence.Equality,
        '!==': Precedence.Equality,
        'is': Precedence.Equality,
        'isnt': Precedence.Equality,
        '<': Precedence.Relational,
        '>': Precedence.Relational,
        '<=': Precedence.Relational,
        '>=': Precedence.Relational,
        'in': Precedence.Relational,
        'instanceof': Precedence.Relational,
        '<<': Precedence.BitwiseSHIFT,
        '>>': Precedence.BitwiseSHIFT,
        '>>>': Precedence.BitwiseSHIFT,
        '+': Precedence.Additive,
        '-': Precedence.Additive,
        '*': Precedence.Multiplicative,
        '%': Precedence.Multiplicative,
        '/': Precedence.Multiplicative,
        '**': Precedence.Exponentiation
    };

    //Flags
    var F_ALLOW_IN = 1,
        F_ALLOW_CALL = 1 << 1,
        F_ALLOW_UNPARATH_NEW = 1 << 2,
        F_FUNC_BODY = 1 << 3,
        F_DIRECTIVE_CTX = 1 << 4,
        F_SEMICOLON_OPT = 1 << 5;

    //Expression flag sets
    //NOTE: Flag order:
    // F_ALLOW_IN
    // F_ALLOW_CALL
    // F_ALLOW_UNPARATH_NEW
    var E_FTT = F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW,
        E_TTF = F_ALLOW_IN | F_ALLOW_CALL,
        E_TTT = F_ALLOW_IN | F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW,
        E_TFF = F_ALLOW_IN,
        E_FFT = F_ALLOW_UNPARATH_NEW,
        E_TFT = F_ALLOW_IN | F_ALLOW_UNPARATH_NEW;

    //Statement flag sets
    //NOTE: Flag order:
    // F_ALLOW_IN
    // F_FUNC_BODY
    // F_DIRECTIVE_CTX
    // F_SEMICOLON_OPT
    var S_TFFF = F_ALLOW_IN,
        S_TFFT = F_ALLOW_IN | F_SEMICOLON_OPT,
        S_FFFF = 0x00,
        S_TFTF = F_ALLOW_IN | F_DIRECTIVE_CTX,
        S_TTFF = F_ALLOW_IN | F_FUNC_BODY;

    function getDefaultOptions() {
        // default options
        return {
            indent: null,
            base: null,
            parse: null,
            comment: false,
            format: {
                indent: {
                    style: '    ',
                    base: 0,
                    adjustMultilineComment: false
                },
                newline: '\n',
                space: ' ',
                json: false,
                renumber: false,
                hexadecimal: false,
                quotes: 'single',
                escapeless: false,
                compact: false,
                parentheses: true,
                semicolons: true,
                safeConcatenation: false,
                preserveBlankLines: false
            },
            moz: {
                comprehensionExpressionStartsWithAssignment: false,
                starlessGenerator: false
            },
            sourceMap: null,
            sourceMapRoot: null,
            sourceMapWithCode: false,
            directive: false,
            raw: true,
            verbatim: null,
            sourceCode: null
        };
    }

    function stringRepeat(str, num) {
        var result = '';

        for (num |= 0; num > 0; num >>>= 1, str += str) {
            if (num & 1) {
                result += str;
            }
        }

        return result;
    }

    function hasLineTerminator(str) {
        return (/[\r\n]/g).test(str);
    }

    function endsWithLineTerminator(str) {
        var len = str.length;
        return len && esutils.code.isLineTerminator(str.charCodeAt(len - 1));
    }

    function merge(target, override) {
        var key;
        for (key in override) {
            if (override.hasOwnProperty(key)) {
                target[key] = override[key];
            }
        }
        return target;
    }

    function updateDeeply(target, override) {
        var key, val;

        function isHashObject(target) {
            return typeof target === 'object' && target instanceof Object && !(target instanceof RegExp);
        }

        for (key in override) {
            if (override.hasOwnProperty(key)) {
                val = override[key];
                if (isHashObject(val)) {
                    if (isHashObject(target[key])) {
                        updateDeeply(target[key], val);
                    } else {
                        target[key] = updateDeeply({}, val);
                    }
                } else {
                    target[key] = val;
                }
            }
        }
        return target;
    }

    function generateNumber(value) {
        var result, point, temp, exponent, pos;

        if (value !== value) {
            throw new Error('Numeric literal whose value is NaN');
        }
        if (value < 0 || (value === 0 && 1 / value < 0)) {
            throw new Error('Numeric literal whose value is negative');
        }

        if (value === 1 / 0) {
            return json ? 'null' : renumber ? '1e400' : '1e+400';
        }

        result = '' + value;
        if (!renumber || result.length < 3) {
            return result;
        }

        point = result.indexOf('.');
        if (!json && result.charCodeAt(0) === 0x30  /* 0 */ && point === 1) {
            point = 0;
            result = result.slice(1);
        }
        temp = result;
        result = result.replace('e+', 'e');
        exponent = 0;
        if ((pos = temp.indexOf('e')) > 0) {
            exponent = +temp.slice(pos + 1);
            temp = temp.slice(0, pos);
        }
        if (point >= 0) {
            exponent -= temp.length - point - 1;
            temp = +(temp.slice(0, point) + temp.slice(point + 1)) + '';
        }
        pos = 0;
        while (temp.charCodeAt(temp.length + pos - 1) === 0x30  /* 0 */) {
            --pos;
        }
        if (pos !== 0) {
            exponent -= pos;
            temp = temp.slice(0, pos);
        }
        if (exponent !== 0) {
            temp += 'e' + exponent;
        }
        if ((temp.length < result.length ||
                    (hexadecimal && value > 1e12 && Math.floor(value) === value && (temp = '0x' + value.toString(16)).length < result.length)) &&
                +temp === value) {
            result = temp;
        }

        return result;
    }

    // Generate valid RegExp expression.
    // This function is based on https://github.com/Constellation/iv Engine

    function escapeRegExpCharacter(ch, previousIsBackslash) {
        // not handling '\' and handling \u2028 or \u2029 to unicode escape sequence
        if ((ch & ~1) === 0x2028) {
            return (previousIsBackslash ? 'u' : '\\u') + ((ch === 0x2028) ? '2028' : '2029');
        } else if (ch === 10 || ch === 13) {  // \n, \r
            return (previousIsBackslash ? '' : '\\') + ((ch === 10) ? 'n' : 'r');
        }
        return String.fromCharCode(ch);
    }

    function generateRegExp(reg) {
        var match, result, flags, i, iz, ch, characterInBrack, previousIsBackslash;

        result = reg.toString();

        if (reg.source) {
            // extract flag from toString result
            match = result.match(/\/([^/]*)$/);
            if (!match) {
                return result;
            }

            flags = match[1];
            result = '';

            characterInBrack = false;
            previousIsBackslash = false;
            for (i = 0, iz = reg.source.length; i < iz; ++i) {
                ch = reg.source.charCodeAt(i);

                if (!previousIsBackslash) {
                    if (characterInBrack) {
                        if (ch === 93) {  // ]
                            characterInBrack = false;
                        }
                    } else {
                        if (ch === 47) {  // /
                            result += '\\';
                        } else if (ch === 91) {  // [
                            characterInBrack = true;
                        }
                    }
                    result += escapeRegExpCharacter(ch, previousIsBackslash);
                    previousIsBackslash = ch === 92;  // \
                } else {
                    // if new RegExp("\\\n') is provided, create /\n/
                    result += escapeRegExpCharacter(ch, previousIsBackslash);
                    // prevent like /\\[/]/
                    previousIsBackslash = false;
                }
            }

            return '/' + result + '/' + flags;
        }

        return result;
    }

    function escapeAllowedCharacter(code, next) {
        var hex;

        if (code === 0x08  /* \b */) {
            return '\\b';
        }

        if (code === 0x0C  /* \f */) {
            return '\\f';
        }

        if (code === 0x09  /* \t */) {
            return '\\t';
        }

        hex = code.toString(16).toUpperCase();
        if (json || code > 0xFF) {
            return '\\u' + '0000'.slice(hex.length) + hex;
        } else if (code === 0x0000 && !esutils.code.isDecimalDigit(next)) {
            return '\\0';
        } else if (code === 0x000B  /* \v */) { // '\v'
            return '\\x0B';
        } else {
            return '\\x' + '00'.slice(hex.length) + hex;
        }
    }

    function escapeDisallowedCharacter(code) {
        if (code === 0x5C  /* \ */) {
            return '\\\\';
        }

        if (code === 0x0A  /* \n */) {
            return '\\n';
        }

        if (code === 0x0D  /* \r */) {
            return '\\r';
        }

        if (code === 0x2028) {
            return '\\u2028';
        }

        if (code === 0x2029) {
            return '\\u2029';
        }

        throw new Error('Incorrectly classified character');
    }

    function escapeDirective(str) {
        var i, iz, code, quote;

        quote = quotes === 'double' ? '"' : '\'';
        for (i = 0, iz = str.length; i < iz; ++i) {
            code = str.charCodeAt(i);
            if (code === 0x27  /* ' */) {
                quote = '"';
                break;
            } else if (code === 0x22  /* " */) {
                quote = '\'';
                break;
            } else if (code === 0x5C  /* \ */) {
                ++i;
            }
        }

        return quote + str + quote;
    }

    function escapeString(str) {
        var result = '', i, len, code, singleQuotes = 0, doubleQuotes = 0, single, quote;

        for (i = 0, len = str.length; i < len; ++i) {
            code = str.charCodeAt(i);
            if (code === 0x27  /* ' */) {
                ++singleQuotes;
            } else if (code === 0x22  /* " */) {
                ++doubleQuotes;
            } else if (code === 0x2F  /* / */ && json) {
                result += '\\';
            } else if (esutils.code.isLineTerminator(code) || code === 0x5C  /* \ */) {
                result += escapeDisallowedCharacter(code);
                continue;
            } else if (!esutils.code.isIdentifierPartES5(code) && (json && code < 0x20  /* SP */ || !json && !escapeless && (code < 0x20  /* SP */ || code > 0x7E  /* ~ */))) {
                result += escapeAllowedCharacter(code, str.charCodeAt(i + 1));
                continue;
            }
            result += String.fromCharCode(code);
        }

        single = !(quotes === 'double' || (quotes === 'auto' && doubleQuotes < singleQuotes));
        quote = single ? '\'' : '"';

        if (!(single ? singleQuotes : doubleQuotes)) {
            return quote + result + quote;
        }

        str = result;
        result = quote;

        for (i = 0, len = str.length; i < len; ++i) {
            code = str.charCodeAt(i);
            if ((code === 0x27  /* ' */ && single) || (code === 0x22  /* " */ && !single)) {
                result += '\\';
            }
            result += String.fromCharCode(code);
        }

        return result + quote;
    }

    /**
     * flatten an array to a string, where the array can contain
     * either strings or nested arrays
     */
    function flattenToString(arr) {
        var i, iz, elem, result = '';
        for (i = 0, iz = arr.length; i < iz; ++i) {
            elem = arr[i];
            result += Array.isArray(elem) ? flattenToString(elem) : elem;
        }
        return result;
    }

    /**
     * convert generated to a SourceNode when source maps are enabled.
     */
    function toSourceNodeWhenNeeded(generated, node) {
        if (!sourceMap) {
            // with no source maps, generated is either an
            // array or a string.  if an array, flatten it.
            // if a string, just return it
            if (Array.isArray(generated)) {
                return flattenToString(generated);
            } else {
                return generated;
            }
        }
        if (node == null) {
            if (generated instanceof SourceNode) {
                return generated;
            } else {
                node = {};
            }
        }
        if (node.loc == null) {
            return new SourceNode(null, null, sourceMap, generated, node.name || null);
        }
        return new SourceNode(node.loc.start.line, node.loc.start.column, (sourceMap === true ? node.loc.source || null : sourceMap), generated, node.name || null);
    }

    function noEmptySpace() {
        return (space) ? space : ' ';
    }

    function join(left, right) {
        var leftSource,
            rightSource,
            leftCharCode,
            rightCharCode;

        leftSource = toSourceNodeWhenNeeded(left).toString();
        if (leftSource.length === 0) {
            return [right];
        }

        rightSource = toSourceNodeWhenNeeded(right).toString();
        if (rightSource.length === 0) {
            return [left];
        }

        leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
        rightCharCode = rightSource.charCodeAt(0);

        if ((leftCharCode === 0x2B  /* + */ || leftCharCode === 0x2D  /* - */) && leftCharCode === rightCharCode ||
            esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode) ||
            leftCharCode === 0x2F  /* / */ && rightCharCode === 0x69  /* i */) { // infix word operators all start with `i`
            return [left, noEmptySpace(), right];
        } else if (esutils.code.isWhiteSpace(leftCharCode) || esutils.code.isLineTerminator(leftCharCode) ||
                esutils.code.isWhiteSpace(rightCharCode) || esutils.code.isLineTerminator(rightCharCode)) {
            return [left, right];
        }
        return [left, space, right];
    }

    function addIndent(stmt) {
        return [base, stmt];
    }

    function withIndent(fn) {
        var previousBase;
        previousBase = base;
        base += indent;
        fn(base);
        base = previousBase;
    }

    function calculateSpaces(str) {
        var i;
        for (i = str.length - 1; i >= 0; --i) {
            if (esutils.code.isLineTerminator(str.charCodeAt(i))) {
                break;
            }
        }
        return (str.length - 1) - i;
    }

    function adjustMultilineComment(value, specialBase) {
        var array, i, len, line, j, spaces, previousBase, sn;

        array = value.split(/\r\n|[\r\n]/);
        spaces = Number.MAX_VALUE;

        // first line doesn't have indentation
        for (i = 1, len = array.length; i < len; ++i) {
            line = array[i];
            j = 0;
            while (j < line.length && esutils.code.isWhiteSpace(line.charCodeAt(j))) {
                ++j;
            }
            if (spaces > j) {
                spaces = j;
            }
        }

        if (typeof specialBase !== 'undefined') {
            // pattern like
            // {
            //   var t = 20;  /*
            //                 * this is comment
            //                 */
            // }
            previousBase = base;
            if (array[1][spaces] === '*') {
                specialBase += ' ';
            }
            base = specialBase;
        } else {
            if (spaces & 1) {
                // /*
                //  *
                //  */
                // If spaces are odd number, above pattern is considered.
                // We waste 1 space.
                --spaces;
            }
            previousBase = base;
        }

        for (i = 1, len = array.length; i < len; ++i) {
            sn = toSourceNodeWhenNeeded(addIndent(array[i].slice(spaces)));
            array[i] = sourceMap ? sn.join('') : sn;
        }

        base = previousBase;

        return array.join('\n');
    }

    function generateComment(comment, specialBase) {
        if (comment.type === 'Line') {
            if (endsWithLineTerminator(comment.value)) {
                return '//' + comment.value;
            } else {
                // Always use LineTerminator
                var result = '//' + comment.value;
                if (!preserveBlankLines) {
                    result += '\n';
                }
                return result;
            }
        }
        if (extra.format.indent.adjustMultilineComment && /[\n\r]/.test(comment.value)) {
            return adjustMultilineComment('/*' + comment.value + '*/', specialBase);
        }
        return '/*' + comment.value + '*/';
    }

    function addComments(stmt, result) {
        var i, len, comment, save, tailingToStatement, specialBase, fragment,
            extRange, range, prevRange, prefix, infix, suffix, count;

        if (stmt.leadingComments && stmt.leadingComments.length > 0) {
            save = result;

            if (preserveBlankLines) {
                comment = stmt.leadingComments[0];
                result = [];

                extRange = comment.extendedRange;
                range = comment.range;

                prefix = sourceCode.substring(extRange[0], range[0]);
                count = (prefix.match(/\n/g) || []).length;
                if (count > 0) {
                    result.push(stringRepeat('\n', count));
                    result.push(addIndent(generateComment(comment)));
                } else {
                    result.push(prefix);
                    result.push(generateComment(comment));
                }

                prevRange = range;

                for (i = 1, len = stmt.leadingComments.length; i < len; i++) {
                    comment = stmt.leadingComments[i];
                    range = comment.range;

                    infix = sourceCode.substring(prevRange[1], range[0]);
                    count = (infix.match(/\n/g) || []).length;
                    result.push(stringRepeat('\n', count));
                    result.push(addIndent(generateComment(comment)));

                    prevRange = range;
                }

                suffix = sourceCode.substring(range[1], extRange[1]);
                count = (suffix.match(/\n/g) || []).length;
                result.push(stringRepeat('\n', count));
            } else {
                comment = stmt.leadingComments[0];
                result = [];
                if (safeConcatenation && stmt.type === Syntax.Program && stmt.body.length === 0) {
                    result.push('\n');
                }
                result.push(generateComment(comment));
                if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                    result.push('\n');
                }

                for (i = 1, len = stmt.leadingComments.length; i < len; ++i) {
                    comment = stmt.leadingComments[i];
                    fragment = [generateComment(comment)];
                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                        fragment.push('\n');
                    }
                    result.push(addIndent(fragment));
                }
            }

            result.push(addIndent(save));
        }

        if (stmt.trailingComments) {

            if (preserveBlankLines) {
                comment = stmt.trailingComments[0];
                extRange = comment.extendedRange;
                range = comment.range;

                prefix = sourceCode.substring(extRange[0], range[0]);
                count = (prefix.match(/\n/g) || []).length;

                if (count > 0) {
                    result.push(stringRepeat('\n', count));
                    result.push(addIndent(generateComment(comment)));
                } else {
                    result.push(prefix);
                    result.push(generateComment(comment));
                }
            } else {
                tailingToStatement = !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
                specialBase = stringRepeat(' ', calculateSpaces(toSourceNodeWhenNeeded([base, result, indent]).toString()));
                for (i = 0, len = stmt.trailingComments.length; i < len; ++i) {
                    comment = stmt.trailingComments[i];
                    if (tailingToStatement) {
                        // We assume target like following script
                        //
                        // var t = 20;  /**
                        //               * This is comment of t
                        //               */
                        if (i === 0) {
                            // first case
                            result = [result, indent];
                        } else {
                            result = [result, specialBase];
                        }
                        result.push(generateComment(comment, specialBase));
                    } else {
                        result = [result, addIndent(generateComment(comment))];
                    }
                    if (i !== len - 1 && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                        result = [result, '\n'];
                    }
                }
            }
        }

        return result;
    }

    function generateBlankLines(start, end, result) {
        var j, newlineCount = 0;

        for (j = start; j < end; j++) {
            if (sourceCode[j] === '\n') {
                newlineCount++;
            }
        }

        for (j = 1; j < newlineCount; j++) {
            result.push(newline);
        }
    }

    function parenthesize(text, current, should) {
        if (current < should) {
            return ['(', text, ')'];
        }
        return text;
    }

    function generateVerbatimString(string) {
        var i, iz, result;
        result = string.split(/\r\n|\n/);
        for (i = 1, iz = result.length; i < iz; i++) {
            result[i] = newline + base + result[i];
        }
        return result;
    }

    function generateVerbatim(expr, precedence) {
        var verbatim, result, prec;
        verbatim = expr[extra.verbatim];

        if (typeof verbatim === 'string') {
            result = parenthesize(generateVerbatimString(verbatim), Precedence.Sequence, precedence);
        } else {
            // verbatim is object
            result = generateVerbatimString(verbatim.content);
            prec = (verbatim.precedence != null) ? verbatim.precedence : Precedence.Sequence;
            result = parenthesize(result, prec, precedence);
        }

        return toSourceNodeWhenNeeded(result, expr);
    }

    function CodeGenerator() {
    }

    // Helpers.

    CodeGenerator.prototype.maybeBlock = function(stmt, flags) {
        var result, noLeadingComment, that = this;

        noLeadingComment = !extra.comment || !stmt.leadingComments;

        if (stmt.type === Syntax.BlockStatement && noLeadingComment) {
            return [space, this.generateStatement(stmt, flags)];
        }

        if (stmt.type === Syntax.EmptyStatement && noLeadingComment) {
            return ';';
        }

        withIndent(function () {
            result = [
                newline,
                addIndent(that.generateStatement(stmt, flags))
            ];
        });

        return result;
    };

    CodeGenerator.prototype.maybeBlockSuffix = function (stmt, result) {
        var ends = endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
        if (stmt.type === Syntax.BlockStatement && (!extra.comment || !stmt.leadingComments) && !ends) {
            return [result, space];
        }
        if (ends) {
            return [result, base];
        }
        return [result, newline, base];
    };

    function generateIdentifier(node) {
        return toSourceNodeWhenNeeded(node.name, node);
    }

    function generateAsyncPrefix(node, spaceRequired) {
        return node.async ? 'async' + (spaceRequired ? noEmptySpace() : space) : '';
    }

    function generateStarSuffix(node) {
        var isGenerator = node.generator && !extra.moz.starlessGenerator;
        return isGenerator ? '*' + space : '';
    }

    function generateMethodPrefix(prop) {
        var func = prop.value, prefix = '';
        if (func.async) {
            prefix += generateAsyncPrefix(func, !prop.computed);
        }
        if (func.generator) {
            // avoid space before method name
            prefix += generateStarSuffix(func) ? '*' : '';
        }
        return prefix;
    }

    CodeGenerator.prototype.generatePattern = function (node, precedence, flags) {
        if (node.type === Syntax.Identifier) {
            return generateIdentifier(node);
        }
        return this.generateExpression(node, precedence, flags);
    };

    CodeGenerator.prototype.generateFunctionParams = function (node) {
        var i, iz, result, hasDefault;

        hasDefault = false;

        if (node.type === Syntax.ArrowFunctionExpression &&
                !node.rest && (!node.defaults || node.defaults.length === 0) &&
                node.params.length === 1 && node.params[0].type === Syntax.Identifier) {
            // arg => { } case
            result = [generateAsyncPrefix(node, true), generateIdentifier(node.params[0])];
        } else {
            result = node.type === Syntax.ArrowFunctionExpression ? [generateAsyncPrefix(node, false)] : [];
            result.push('(');
            if (node.defaults) {
                hasDefault = true;
            }
            for (i = 0, iz = node.params.length; i < iz; ++i) {
                if (hasDefault && node.defaults[i]) {
                    // Handle default values.
                    result.push(this.generateAssignment(node.params[i], node.defaults[i], '=', Precedence.Assignment, E_TTT));
                } else {
                    result.push(this.generatePattern(node.params[i], Precedence.Assignment, E_TTT));
                }
                if (i + 1 < iz) {
                    result.push(',' + space);
                }
            }

            if (node.rest) {
                if (node.params.length) {
                    result.push(',' + space);
                }
                result.push('...');
                result.push(generateIdentifier(node.rest));
            }

            result.push(')');
        }

        return result;
    };

    CodeGenerator.prototype.generateFunctionBody = function (node) {
        var result, expr;

        result = this.generateFunctionParams(node);

        if (node.type === Syntax.ArrowFunctionExpression) {
            result.push(space);
            result.push('=>');
        }

        if (node.expression) {
            result.push(space);
            expr = this.generateExpression(node.body, Precedence.Assignment, E_TTT);
            if (expr.toString().charAt(0) === '{') {
                expr = ['(', expr, ')'];
            }
            result.push(expr);
        } else {
            result.push(this.maybeBlock(node.body, S_TTFF));
        }

        return result;
    };

    CodeGenerator.prototype.generateIterationForStatement = function (operator, stmt, flags) {
        var result = ['for' + (stmt.await ? noEmptySpace() + 'await' : '') + space + '('], that = this;
        withIndent(function () {
            if (stmt.left.type === Syntax.VariableDeclaration) {
                withIndent(function () {
                    result.push(stmt.left.kind + noEmptySpace());
                    result.push(that.generateStatement(stmt.left.declarations[0], S_FFFF));
                });
            } else {
                result.push(that.generateExpression(stmt.left, Precedence.Call, E_TTT));
            }

            result = join(result, operator);
            result = [join(
                result,
                that.generateExpression(stmt.right, Precedence.Assignment, E_TTT)
            ), ')'];
        });
        result.push(this.maybeBlock(stmt.body, flags));
        return result;
    };

    CodeGenerator.prototype.generatePropertyKey = function (expr, computed) {
        var result = [];

        if (computed) {
            result.push('[');
        }

        result.push(this.generateExpression(expr, Precedence.Sequence, E_TTT));

        if (computed) {
            result.push(']');
        }

        return result;
    };

    CodeGenerator.prototype.generateAssignment = function (left, right, operator, precedence, flags) {
        if (Precedence.Assignment < precedence) {
            flags |= F_ALLOW_IN;
        }

        return parenthesize(
            [
                this.generateExpression(left, Precedence.Call, flags),
                space + operator + space,
                this.generateExpression(right, Precedence.Assignment, flags)
            ],
            Precedence.Assignment,
            precedence
        );
    };

    CodeGenerator.prototype.semicolon = function (flags) {
        if (!semicolons && flags & F_SEMICOLON_OPT) {
            return '';
        }
        return ';';
    };

    // Statements.

    CodeGenerator.Statement = {

        BlockStatement: function (stmt, flags) {
            var range, content, result = ['{', newline], that = this;

            withIndent(function () {
                // handle functions without any code
                if (stmt.body.length === 0 && preserveBlankLines) {
                    range = stmt.range;
                    if (range[1] - range[0] > 2) {
                        content = sourceCode.substring(range[0] + 1, range[1] - 1);
                        if (content[0] === '\n') {
                            result = ['{'];
                        }
                        result.push(content);
                    }
                }

                var i, iz, fragment, bodyFlags;
                bodyFlags = S_TFFF;
                if (flags & F_FUNC_BODY) {
                    bodyFlags |= F_DIRECTIVE_CTX;
                }

                for (i = 0, iz = stmt.body.length; i < iz; ++i) {
                    if (preserveBlankLines) {
                        // handle spaces before the first line
                        if (i === 0) {
                            if (stmt.body[0].leadingComments) {
                                range = stmt.body[0].leadingComments[0].extendedRange;
                                content = sourceCode.substring(range[0], range[1]);
                                if (content[0] === '\n') {
                                    result = ['{'];
                                }
                            }
                            if (!stmt.body[0].leadingComments) {
                                generateBlankLines(stmt.range[0], stmt.body[0].range[0], result);
                            }
                        }

                        // handle spaces between lines
                        if (i > 0) {
                            if (!stmt.body[i - 1].trailingComments  && !stmt.body[i].leadingComments) {
                                generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);
                            }
                        }
                    }

                    if (i === iz - 1) {
                        bodyFlags |= F_SEMICOLON_OPT;
                    }

                    if (stmt.body[i].leadingComments && preserveBlankLines) {
                        fragment = that.generateStatement(stmt.body[i], bodyFlags);
                    } else {
                        fragment = addIndent(that.generateStatement(stmt.body[i], bodyFlags));
                    }

                    result.push(fragment);
                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                        if (preserveBlankLines && i < iz - 1) {
                            // don't add a new line if there are leading coments
                            // in the next statement
                            if (!stmt.body[i + 1].leadingComments) {
                                result.push(newline);
                            }
                        } else {
                            result.push(newline);
                        }
                    }

                    if (preserveBlankLines) {
                        // handle spaces after the last line
                        if (i === iz - 1) {
                            if (!stmt.body[i].trailingComments) {
                                generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);
                            }
                        }
                    }
                }
            });

            result.push(addIndent('}'));
            return result;
        },

        BreakStatement: function (stmt, flags) {
            if (stmt.label) {
                return 'break ' + stmt.label.name + this.semicolon(flags);
            }
            return 'break' + this.semicolon(flags);
        },

        ContinueStatement: function (stmt, flags) {
            if (stmt.label) {
                return 'continue ' + stmt.label.name + this.semicolon(flags);
            }
            return 'continue' + this.semicolon(flags);
        },

        ClassBody: function (stmt, flags) {
            var result = [ '{', newline], that = this;

            withIndent(function (indent) {
                var i, iz;

                for (i = 0, iz = stmt.body.length; i < iz; ++i) {
                    result.push(indent);
                    result.push(that.generateExpression(stmt.body[i], Precedence.Sequence, E_TTT));
                    if (i + 1 < iz) {
                        result.push(newline);
                    }
                }
            });

            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
            }
            result.push(base);
            result.push('}');
            return result;
        },

        ClassDeclaration: function (stmt, flags) {
            var result, fragment;
            result  = ['class'];
            if (stmt.id) {
                result = join(result, this.generateExpression(stmt.id, Precedence.Sequence, E_TTT));
            }
            if (stmt.superClass) {
                fragment = join('extends', this.generateExpression(stmt.superClass, Precedence.Unary, E_TTT));
                result = join(result, fragment);
            }
            result.push(space);
            result.push(this.generateStatement(stmt.body, S_TFFT));
            return result;
        },

        DirectiveStatement: function (stmt, flags) {
            if (extra.raw && stmt.raw) {
                return stmt.raw + this.semicolon(flags);
            }
            return escapeDirective(stmt.directive) + this.semicolon(flags);
        },

        DoWhileStatement: function (stmt, flags) {
            // Because `do 42 while (cond)` is Syntax Error. We need semicolon.
            var result = join('do', this.maybeBlock(stmt.body, S_TFFF));
            result = this.maybeBlockSuffix(stmt.body, result);
            return join(result, [
                'while' + space + '(',
                this.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
                ')' + this.semicolon(flags)
            ]);
        },

        CatchClause: function (stmt, flags) {
            var result, that = this;
            withIndent(function () {
                var guard;

                if (stmt.param) {
                    result = [
                        'catch' + space + '(',
                        that.generateExpression(stmt.param, Precedence.Sequence, E_TTT),
                        ')'
                    ];

                    if (stmt.guard) {
                        guard = that.generateExpression(stmt.guard, Precedence.Sequence, E_TTT);
                        result.splice(2, 0, ' if ', guard);
                    }
                } else {
                    result = ['catch'];
                }
            });
            result.push(this.maybeBlock(stmt.body, S_TFFF));
            return result;
        },

        DebuggerStatement: function (stmt, flags) {
            return 'debugger' + this.semicolon(flags);
        },

        EmptyStatement: function (stmt, flags) {
            return ';';
        },

        ExportDefaultDeclaration: function (stmt, flags) {
            var result = [ 'export' ], bodyFlags;

            bodyFlags = (flags & F_SEMICOLON_OPT) ? S_TFFT : S_TFFF;

            // export default HoistableDeclaration[Default]
            // export default AssignmentExpression[In] ;
            result = join(result, 'default');
            if (isStatement(stmt.declaration)) {
                result = join(result, this.generateStatement(stmt.declaration, bodyFlags));
            } else {
                result = join(result, this.generateExpression(stmt.declaration, Precedence.Assignment, E_TTT) + this.semicolon(flags));
            }
            return result;
        },

        ExportNamedDeclaration: function (stmt, flags) {
            var result = [ 'export' ], bodyFlags, that = this;

            bodyFlags = (flags & F_SEMICOLON_OPT) ? S_TFFT : S_TFFF;

            // export VariableStatement
            // export Declaration[Default]
            if (stmt.declaration) {
                return join(result, this.generateStatement(stmt.declaration, bodyFlags));
            }

            // export ExportClause[NoReference] FromClause ;
            // export ExportClause ;
            if (stmt.specifiers) {
                if (stmt.specifiers.length === 0) {
                    result = join(result, '{' + space + '}');
                } else if (stmt.specifiers[0].type === Syntax.ExportBatchSpecifier) {
                    result = join(result, this.generateExpression(stmt.specifiers[0], Precedence.Sequence, E_TTT));
                } else {
                    result = join(result, '{');
                    withIndent(function (indent) {
                        var i, iz;
                        result.push(newline);
                        for (i = 0, iz = stmt.specifiers.length; i < iz; ++i) {
                            result.push(indent);
                            result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));
                            if (i + 1 < iz) {
                                result.push(',' + newline);
                            }
                        }
                    });
                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                        result.push(newline);
                    }
                    result.push(base + '}');
                }

                if (stmt.source) {
                    result = join(result, [
                        'from' + space,
                        // ModuleSpecifier
                        this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
                        this.semicolon(flags)
                    ]);
                } else {
                    result.push(this.semicolon(flags));
                }
            }
            return result;
        },

        ExportAllDeclaration: function (stmt, flags) {
            // export * FromClause ;
            return [
                'export' + space,
                '*' + space,
                'from' + space,
                // ModuleSpecifier
                this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
                this.semicolon(flags)
            ];
        },

        ExpressionStatement: function (stmt, flags) {
            var result, fragment;

            function isClassPrefixed(fragment) {
                var code;
                if (fragment.slice(0, 5) !== 'class') {
                    return false;
                }
                code = fragment.charCodeAt(5);
                return code === 0x7B  /* '{' */ || esutils.code.isWhiteSpace(code) || esutils.code.isLineTerminator(code);
            }

            function isFunctionPrefixed(fragment) {
                var code;
                if (fragment.slice(0, 8) !== 'function') {
                    return false;
                }
                code = fragment.charCodeAt(8);
                return code === 0x28 /* '(' */ || esutils.code.isWhiteSpace(code) || code === 0x2A  /* '*' */ || esutils.code.isLineTerminator(code);
            }

            function isAsyncPrefixed(fragment) {
                var code, i, iz;
                if (fragment.slice(0, 5) !== 'async') {
                    return false;
                }
                if (!esutils.code.isWhiteSpace(fragment.charCodeAt(5))) {
                    return false;
                }
                for (i = 6, iz = fragment.length; i < iz; ++i) {
                    if (!esutils.code.isWhiteSpace(fragment.charCodeAt(i))) {
                        break;
                    }
                }
                if (i === iz) {
                    return false;
                }
                if (fragment.slice(i, i + 8) !== 'function') {
                    return false;
                }
                code = fragment.charCodeAt(i + 8);
                return code === 0x28 /* '(' */ || esutils.code.isWhiteSpace(code) || code === 0x2A  /* '*' */ || esutils.code.isLineTerminator(code);
            }

            result = [this.generateExpression(stmt.expression, Precedence.Sequence, E_TTT)];
            // 12.4 '{', 'function', 'class' is not allowed in this position.
            // wrap expression with parentheses
            fragment = toSourceNodeWhenNeeded(result).toString();
            if (fragment.charCodeAt(0) === 0x7B  /* '{' */ ||  // ObjectExpression
                    isClassPrefixed(fragment) ||
                    isFunctionPrefixed(fragment) ||
                    isAsyncPrefixed(fragment) ||
                    (directive && (flags & F_DIRECTIVE_CTX) && stmt.expression.type === Syntax.Literal && typeof stmt.expression.value === 'string')) {
                result = ['(', result, ')' + this.semicolon(flags)];
            } else {
                result.push(this.semicolon(flags));
            }
            return result;
        },

        ImportDeclaration: function (stmt, flags) {
            // ES6: 15.2.1 valid import declarations:
            //     - import ImportClause FromClause ;
            //     - import ModuleSpecifier ;
            var result, cursor, that = this;

            // If no ImportClause is present,
            // this should be `import ModuleSpecifier` so skip `from`
            // ModuleSpecifier is StringLiteral.
            if (stmt.specifiers.length === 0) {
                // import ModuleSpecifier ;
                return [
                    'import',
                    space,
                    // ModuleSpecifier
                    this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
                    this.semicolon(flags)
                ];
            }

            // import ImportClause FromClause ;
            result = [
                'import'
            ];
            cursor = 0;

            // ImportedBinding
            if (stmt.specifiers[cursor].type === Syntax.ImportDefaultSpecifier) {
                result = join(result, [
                        this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)
                ]);
                ++cursor;
            }

            if (stmt.specifiers[cursor]) {
                if (cursor !== 0) {
                    result.push(',');
                }

                if (stmt.specifiers[cursor].type === Syntax.ImportNamespaceSpecifier) {
                    // NameSpaceImport
                    result = join(result, [
                            space,
                            this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)
                    ]);
                } else {
                    // NamedImports
                    result.push(space + '{');

                    if ((stmt.specifiers.length - cursor) === 1) {
                        // import { ... } from "...";
                        result.push(space);
                        result.push(this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT));
                        result.push(space + '}' + space);
                    } else {
                        // import {
                        //    ...,
                        //    ...,
                        // } from "...";
                        withIndent(function (indent) {
                            var i, iz;
                            result.push(newline);
                            for (i = cursor, iz = stmt.specifiers.length; i < iz; ++i) {
                                result.push(indent);
                                result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));
                                if (i + 1 < iz) {
                                    result.push(',' + newline);
                                }
                            }
                        });
                        if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                            result.push(newline);
                        }
                        result.push(base + '}' + space);
                    }
                }
            }

            result = join(result, [
                'from' + space,
                // ModuleSpecifier
                this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
                this.semicolon(flags)
            ]);
            return result;
        },

        VariableDeclarator: function (stmt, flags) {
            var itemFlags = (flags & F_ALLOW_IN) ? E_TTT : E_FTT;
            if (stmt.init) {
                return [
                    this.generateExpression(stmt.id, Precedence.Assignment, itemFlags),
                    space,
                    '=',
                    space,
                    this.generateExpression(stmt.init, Precedence.Assignment, itemFlags)
                ];
            }
            return this.generatePattern(stmt.id, Precedence.Assignment, itemFlags);
        },

        VariableDeclaration: function (stmt, flags) {
            // VariableDeclarator is typed as Statement,
            // but joined with comma (not LineTerminator).
            // So if comment is attached to target node, we should specialize.
            var result, i, iz, node, bodyFlags, that = this;

            result = [ stmt.kind ];

            bodyFlags = (flags & F_ALLOW_IN) ? S_TFFF : S_FFFF;

            function block() {
                node = stmt.declarations[0];
                if (extra.comment && node.leadingComments) {
                    result.push('\n');
                    result.push(addIndent(that.generateStatement(node, bodyFlags)));
                } else {
                    result.push(noEmptySpace());
                    result.push(that.generateStatement(node, bodyFlags));
                }

                for (i = 1, iz = stmt.declarations.length; i < iz; ++i) {
                    node = stmt.declarations[i];
                    if (extra.comment && node.leadingComments) {
                        result.push(',' + newline);
                        result.push(addIndent(that.generateStatement(node, bodyFlags)));
                    } else {
                        result.push(',' + space);
                        result.push(that.generateStatement(node, bodyFlags));
                    }
                }
            }

            if (stmt.declarations.length > 1) {
                withIndent(block);
            } else {
                block();
            }

            result.push(this.semicolon(flags));

            return result;
        },

        ThrowStatement: function (stmt, flags) {
            return [join(
                'throw',
                this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)
            ), this.semicolon(flags)];
        },

        TryStatement: function (stmt, flags) {
            var result, i, iz, guardedHandlers;

            result = ['try', this.maybeBlock(stmt.block, S_TFFF)];
            result = this.maybeBlockSuffix(stmt.block, result);

            if (stmt.handlers) {
                // old interface
                for (i = 0, iz = stmt.handlers.length; i < iz; ++i) {
                    result = join(result, this.generateStatement(stmt.handlers[i], S_TFFF));
                    if (stmt.finalizer || i + 1 !== iz) {
                        result = this.maybeBlockSuffix(stmt.handlers[i].body, result);
                    }
                }
            } else {
                guardedHandlers = stmt.guardedHandlers || [];

                for (i = 0, iz = guardedHandlers.length; i < iz; ++i) {
                    result = join(result, this.generateStatement(guardedHandlers[i], S_TFFF));
                    if (stmt.finalizer || i + 1 !== iz) {
                        result = this.maybeBlockSuffix(guardedHandlers[i].body, result);
                    }
                }

                // new interface
                if (stmt.handler) {
                    if (Array.isArray(stmt.handler)) {
                        for (i = 0, iz = stmt.handler.length; i < iz; ++i) {
                            result = join(result, this.generateStatement(stmt.handler[i], S_TFFF));
                            if (stmt.finalizer || i + 1 !== iz) {
                                result = this.maybeBlockSuffix(stmt.handler[i].body, result);
                            }
                        }
                    } else {
                        result = join(result, this.generateStatement(stmt.handler, S_TFFF));
                        if (stmt.finalizer) {
                            result = this.maybeBlockSuffix(stmt.handler.body, result);
                        }
                    }
                }
            }
            if (stmt.finalizer) {
                result = join(result, ['finally', this.maybeBlock(stmt.finalizer, S_TFFF)]);
            }
            return result;
        },

        SwitchStatement: function (stmt, flags) {
            var result, fragment, i, iz, bodyFlags, that = this;
            withIndent(function () {
                result = [
                    'switch' + space + '(',
                    that.generateExpression(stmt.discriminant, Precedence.Sequence, E_TTT),
                    ')' + space + '{' + newline
                ];
            });
            if (stmt.cases) {
                bodyFlags = S_TFFF;
                for (i = 0, iz = stmt.cases.length; i < iz; ++i) {
                    if (i === iz - 1) {
                        bodyFlags |= F_SEMICOLON_OPT;
                    }
                    fragment = addIndent(this.generateStatement(stmt.cases[i], bodyFlags));
                    result.push(fragment);
                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                        result.push(newline);
                    }
                }
            }
            result.push(addIndent('}'));
            return result;
        },

        SwitchCase: function (stmt, flags) {
            var result, fragment, i, iz, bodyFlags, that = this;
            withIndent(function () {
                if (stmt.test) {
                    result = [
                        join('case', that.generateExpression(stmt.test, Precedence.Sequence, E_TTT)),
                        ':'
                    ];
                } else {
                    result = ['default:'];
                }

                i = 0;
                iz = stmt.consequent.length;
                if (iz && stmt.consequent[0].type === Syntax.BlockStatement) {
                    fragment = that.maybeBlock(stmt.consequent[0], S_TFFF);
                    result.push(fragment);
                    i = 1;
                }

                if (i !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                    result.push(newline);
                }

                bodyFlags = S_TFFF;
                for (; i < iz; ++i) {
                    if (i === iz - 1 && flags & F_SEMICOLON_OPT) {
                        bodyFlags |= F_SEMICOLON_OPT;
                    }
                    fragment = addIndent(that.generateStatement(stmt.consequent[i], bodyFlags));
                    result.push(fragment);
                    if (i + 1 !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                        result.push(newline);
                    }
                }
            });
            return result;
        },

        IfStatement: function (stmt, flags) {
            var result, bodyFlags, semicolonOptional, that = this;
            withIndent(function () {
                result = [
                    'if' + space + '(',
                    that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
                    ')'
                ];
            });
            semicolonOptional = flags & F_SEMICOLON_OPT;
            bodyFlags = S_TFFF;
            if (semicolonOptional) {
                bodyFlags |= F_SEMICOLON_OPT;
            }
            if (stmt.alternate) {
                result.push(this.maybeBlock(stmt.consequent, S_TFFF));
                result = this.maybeBlockSuffix(stmt.consequent, result);
                if (stmt.alternate.type === Syntax.IfStatement) {
                    result = join(result, ['else ', this.generateStatement(stmt.alternate, bodyFlags)]);
                } else {
                    result = join(result, join('else', this.maybeBlock(stmt.alternate, bodyFlags)));
                }
            } else {
                result.push(this.maybeBlock(stmt.consequent, bodyFlags));
            }
            return result;
        },

        ForStatement: function (stmt, flags) {
            var result, that = this;
            withIndent(function () {
                result = ['for' + space + '('];
                if (stmt.init) {
                    if (stmt.init.type === Syntax.VariableDeclaration) {
                        result.push(that.generateStatement(stmt.init, S_FFFF));
                    } else {
                        // F_ALLOW_IN becomes false.
                        result.push(that.generateExpression(stmt.init, Precedence.Sequence, E_FTT));
                        result.push(';');
                    }
                } else {
                    result.push(';');
                }

                if (stmt.test) {
                    result.push(space);
                    result.push(that.generateExpression(stmt.test, Precedence.Sequence, E_TTT));
                    result.push(';');
                } else {
                    result.push(';');
                }

                if (stmt.update) {
                    result.push(space);
                    result.push(that.generateExpression(stmt.update, Precedence.Sequence, E_TTT));
                    result.push(')');
                } else {
                    result.push(')');
                }
            });

            result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
            return result;
        },

        ForInStatement: function (stmt, flags) {
            return this.generateIterationForStatement('in', stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);
        },

        ForOfStatement: function (stmt, flags) {
            return this.generateIterationForStatement('of', stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);
        },

        LabeledStatement: function (stmt, flags) {
            return [stmt.label.name + ':', this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF)];
        },

        Program: function (stmt, flags) {
            var result, fragment, i, iz, bodyFlags;
            iz = stmt.body.length;
            result = [safeConcatenation && iz > 0 ? '\n' : ''];
            bodyFlags = S_TFTF;
            for (i = 0; i < iz; ++i) {
                if (!safeConcatenation && i === iz - 1) {
                    bodyFlags |= F_SEMICOLON_OPT;
                }

                if (preserveBlankLines) {
                    // handle spaces before the first line
                    if (i === 0) {
                        if (!stmt.body[0].leadingComments) {
                            generateBlankLines(stmt.range[0], stmt.body[i].range[0], result);
                        }
                    }

                    // handle spaces between lines
                    if (i > 0) {
                        if (!stmt.body[i - 1].trailingComments && !stmt.body[i].leadingComments) {
                            generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);
                        }
                    }
                }

                fragment = addIndent(this.generateStatement(stmt.body[i], bodyFlags));
                result.push(fragment);
                if (i + 1 < iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                    if (preserveBlankLines) {
                        if (!stmt.body[i + 1].leadingComments) {
                            result.push(newline);
                        }
                    } else {
                        result.push(newline);
                    }
                }

                if (preserveBlankLines) {
                    // handle spaces after the last line
                    if (i === iz - 1) {
                        if (!stmt.body[i].trailingComments) {
                            generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);
                        }
                    }
                }
            }
            return result;
        },

        FunctionDeclaration: function (stmt, flags) {
            return [
                generateAsyncPrefix(stmt, true),
                'function',
                generateStarSuffix(stmt) || noEmptySpace(),
                stmt.id ? generateIdentifier(stmt.id) : '',
                this.generateFunctionBody(stmt)
            ];
        },

        ReturnStatement: function (stmt, flags) {
            if (stmt.argument) {
                return [join(
                    'return',
                    this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)
                ), this.semicolon(flags)];
            }
            return ['return' + this.semicolon(flags)];
        },

        WhileStatement: function (stmt, flags) {
            var result, that = this;
            withIndent(function () {
                result = [
                    'while' + space + '(',
                    that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
                    ')'
                ];
            });
            result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
            return result;
        },

        WithStatement: function (stmt, flags) {
            var result, that = this;
            withIndent(function () {
                result = [
                    'with' + space + '(',
                    that.generateExpression(stmt.object, Precedence.Sequence, E_TTT),
                    ')'
                ];
            });
            result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
            return result;
        }

    };

    merge(CodeGenerator.prototype, CodeGenerator.Statement);

    // Expressions.

    CodeGenerator.Expression = {

        SequenceExpression: function (expr, precedence, flags) {
            var result, i, iz;
            if (Precedence.Sequence < precedence) {
                flags |= F_ALLOW_IN;
            }
            result = [];
            for (i = 0, iz = expr.expressions.length; i < iz; ++i) {
                result.push(this.generateExpression(expr.expressions[i], Precedence.Assignment, flags));
                if (i + 1 < iz) {
                    result.push(',' + space);
                }
            }
            return parenthesize(result, Precedence.Sequence, precedence);
        },

        AssignmentExpression: function (expr, precedence, flags) {
            return this.generateAssignment(expr.left, expr.right, expr.operator, precedence, flags);
        },

        ArrowFunctionExpression: function (expr, precedence, flags) {
            return parenthesize(this.generateFunctionBody(expr), Precedence.ArrowFunction, precedence);
        },

        ConditionalExpression: function (expr, precedence, flags) {
            if (Precedence.Conditional < precedence) {
                flags |= F_ALLOW_IN;
            }
            return parenthesize(
                [
                    this.generateExpression(expr.test, Precedence.LogicalOR, flags),
                    space + '?' + space,
                    this.generateExpression(expr.consequent, Precedence.Assignment, flags),
                    space + ':' + space,
                    this.generateExpression(expr.alternate, Precedence.Assignment, flags)
                ],
                Precedence.Conditional,
                precedence
            );
        },

        LogicalExpression: function (expr, precedence, flags) {
            return this.BinaryExpression(expr, precedence, flags);
        },

        BinaryExpression: function (expr, precedence, flags) {
            var result, leftPrecedence, rightPrecedence, currentPrecedence, fragment, leftSource;
            currentPrecedence = BinaryPrecedence[expr.operator];
            leftPrecedence = expr.operator === '**' ? Precedence.Postfix : currentPrecedence;
            rightPrecedence = expr.operator === '**' ? currentPrecedence : currentPrecedence + 1;

            if (currentPrecedence < precedence) {
                flags |= F_ALLOW_IN;
            }

            fragment = this.generateExpression(expr.left, leftPrecedence, flags);

            leftSource = fragment.toString();

            if (leftSource.charCodeAt(leftSource.length - 1) === 0x2F /* / */ && esutils.code.isIdentifierPartES5(expr.operator.charCodeAt(0))) {
                result = [fragment, noEmptySpace(), expr.operator];
            } else {
                result = join(fragment, expr.operator);
            }

            fragment = this.generateExpression(expr.right, rightPrecedence, flags);

            if (expr.operator === '/' && fragment.toString().charAt(0) === '/' ||
            expr.operator.slice(-1) === '<' && fragment.toString().slice(0, 3) === '!--') {
                // If '/' concats with '/' or `<` concats with `!--`, it is interpreted as comment start
                result.push(noEmptySpace());
                result.push(fragment);
            } else {
                result = join(result, fragment);
            }

            if (expr.operator === 'in' && !(flags & F_ALLOW_IN)) {
                return ['(', result, ')'];
            }
            return parenthesize(result, currentPrecedence, precedence);
        },

        CallExpression: function (expr, precedence, flags) {
            var result, i, iz;
            // F_ALLOW_UNPARATH_NEW becomes false.
            result = [this.generateExpression(expr.callee, Precedence.Call, E_TTF)];
            result.push('(');
            for (i = 0, iz = expr['arguments'].length; i < iz; ++i) {
                result.push(this.generateExpression(expr['arguments'][i], Precedence.Assignment, E_TTT));
                if (i + 1 < iz) {
                    result.push(',' + space);
                }
            }
            result.push(')');

            if (!(flags & F_ALLOW_CALL)) {
                return ['(', result, ')'];
            }
            return parenthesize(result, Precedence.Call, precedence);
        },

        NewExpression: function (expr, precedence, flags) {
            var result, length, i, iz, itemFlags;
            length = expr['arguments'].length;

            // F_ALLOW_CALL becomes false.
            // F_ALLOW_UNPARATH_NEW may become false.
            itemFlags = (flags & F_ALLOW_UNPARATH_NEW && !parentheses && length === 0) ? E_TFT : E_TFF;

            result = join(
                'new',
                this.generateExpression(expr.callee, Precedence.New, itemFlags)
            );

            if (!(flags & F_ALLOW_UNPARATH_NEW) || parentheses || length > 0) {
                result.push('(');
                for (i = 0, iz = length; i < iz; ++i) {
                    result.push(this.generateExpression(expr['arguments'][i], Precedence.Assignment, E_TTT));
                    if (i + 1 < iz) {
                        result.push(',' + space);
                    }
                }
                result.push(')');
            }

            return parenthesize(result, Precedence.New, precedence);
        },

        MemberExpression: function (expr, precedence, flags) {
            var result, fragment;

            // F_ALLOW_UNPARATH_NEW becomes false.
            result = [this.generateExpression(expr.object, Precedence.Call, (flags & F_ALLOW_CALL) ? E_TTF : E_TFF)];

            if (expr.computed) {
                result.push('[');
                result.push(this.generateExpression(expr.property, Precedence.Sequence, flags & F_ALLOW_CALL ? E_TTT : E_TFT));
                result.push(']');
            } else {
                if (expr.object.type === Syntax.Literal && typeof expr.object.value === 'number') {
                    fragment = toSourceNodeWhenNeeded(result).toString();
                    // When the following conditions are all true,
                    //   1. No floating point
                    //   2. Don't have exponents
                    //   3. The last character is a decimal digit
                    //   4. Not hexadecimal OR octal number literal
                    // we should add a floating point.
                    if (
                            fragment.indexOf('.') < 0 &&
                            !/[eExX]/.test(fragment) &&
                            esutils.code.isDecimalDigit(fragment.charCodeAt(fragment.length - 1)) &&
                            !(fragment.length >= 2 && fragment.charCodeAt(0) === 48)  // '0'
                            ) {
                        result.push(' ');
                    }
                }
                result.push('.');
                result.push(generateIdentifier(expr.property));
            }

            return parenthesize(result, Precedence.Member, precedence);
        },

        MetaProperty: function (expr, precedence, flags) {
            var result;
            result = [];
            result.push(typeof expr.meta === "string" ? expr.meta : generateIdentifier(expr.meta));
            result.push('.');
            result.push(typeof expr.property === "string" ? expr.property : generateIdentifier(expr.property));
            return parenthesize(result, Precedence.Member, precedence);
        },

        UnaryExpression: function (expr, precedence, flags) {
            var result, fragment, rightCharCode, leftSource, leftCharCode;
            fragment = this.generateExpression(expr.argument, Precedence.Unary, E_TTT);

            if (space === '') {
                result = join(expr.operator, fragment);
            } else {
                result = [expr.operator];
                if (expr.operator.length > 2) {
                    // delete, void, typeof
                    // get `typeof []`, not `typeof[]`
                    result = join(result, fragment);
                } else {
                    // Prevent inserting spaces between operator and argument if it is unnecessary
                    // like, `!cond`
                    leftSource = toSourceNodeWhenNeeded(result).toString();
                    leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
                    rightCharCode = fragment.toString().charCodeAt(0);

                    if (((leftCharCode === 0x2B  /* + */ || leftCharCode === 0x2D  /* - */) && leftCharCode === rightCharCode) ||
                            (esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode))) {
                        result.push(noEmptySpace());
                        result.push(fragment);
                    } else {
                        result.push(fragment);
                    }
                }
            }
            return parenthesize(result, Precedence.Unary, precedence);
        },

        YieldExpression: function (expr, precedence, flags) {
            var result;
            if (expr.delegate) {
                result = 'yield*';
            } else {
                result = 'yield';
            }
            if (expr.argument) {
                result = join(
                    result,
                    this.generateExpression(expr.argument, Precedence.Yield, E_TTT)
                );
            }
            return parenthesize(result, Precedence.Yield, precedence);
        },

        AwaitExpression: function (expr, precedence, flags) {
            var result = join(
                expr.all ? 'await*' : 'await',
                this.generateExpression(expr.argument, Precedence.Await, E_TTT)
            );
            return parenthesize(result, Precedence.Await, precedence);
        },

        UpdateExpression: function (expr, precedence, flags) {
            if (expr.prefix) {
                return parenthesize(
                    [
                        expr.operator,
                        this.generateExpression(expr.argument, Precedence.Unary, E_TTT)
                    ],
                    Precedence.Unary,
                    precedence
                );
            }
            return parenthesize(
                [
                    this.generateExpression(expr.argument, Precedence.Postfix, E_TTT),
                    expr.operator
                ],
                Precedence.Postfix,
                precedence
            );
        },

        FunctionExpression: function (expr, precedence, flags) {
            var result = [
                generateAsyncPrefix(expr, true),
                'function'
            ];
            if (expr.id) {
                result.push(generateStarSuffix(expr) || noEmptySpace());
                result.push(generateIdentifier(expr.id));
            } else {
                result.push(generateStarSuffix(expr) || space);
            }
            result.push(this.generateFunctionBody(expr));
            return result;
        },

        ArrayPattern: function (expr, precedence, flags) {
            return this.ArrayExpression(expr, precedence, flags, true);
        },

        ArrayExpression: function (expr, precedence, flags, isPattern) {
            var result, multiline, that = this;
            if (!expr.elements.length) {
                return '[]';
            }
            multiline = isPattern ? false : expr.elements.length > 1;
            result = ['[', multiline ? newline : ''];
            withIndent(function (indent) {
                var i, iz;
                for (i = 0, iz = expr.elements.length; i < iz; ++i) {
                    if (!expr.elements[i]) {
                        if (multiline) {
                            result.push(indent);
                        }
                        if (i + 1 === iz) {
                            result.push(',');
                        }
                    } else {
                        result.push(multiline ? indent : '');
                        result.push(that.generateExpression(expr.elements[i], Precedence.Assignment, E_TTT));
                    }
                    if (i + 1 < iz) {
                        result.push(',' + (multiline ? newline : space));
                    }
                }
            });
            if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
            }
            result.push(multiline ? base : '');
            result.push(']');
            return result;
        },

        RestElement: function(expr, precedence, flags) {
            return '...' + this.generatePattern(expr.argument);
        },

        ClassExpression: function (expr, precedence, flags) {
            var result, fragment;
            result = ['class'];
            if (expr.id) {
                result = join(result, this.generateExpression(expr.id, Precedence.Sequence, E_TTT));
            }
            if (expr.superClass) {
                fragment = join('extends', this.generateExpression(expr.superClass, Precedence.Unary, E_TTT));
                result = join(result, fragment);
            }
            result.push(space);
            result.push(this.generateStatement(expr.body, S_TFFT));
            return result;
        },

        MethodDefinition: function (expr, precedence, flags) {
            var result, fragment;
            if (expr['static']) {
                result = ['static' + space];
            } else {
                result = [];
            }
            if (expr.kind === 'get' || expr.kind === 'set') {
                fragment = [
                    join(expr.kind, this.generatePropertyKey(expr.key, expr.computed)),
                    this.generateFunctionBody(expr.value)
                ];
            } else {
                fragment = [
                    generateMethodPrefix(expr),
                    this.generatePropertyKey(expr.key, expr.computed),
                    this.generateFunctionBody(expr.value)
                ];
            }
            return join(result, fragment);
        },

        Property: function (expr, precedence, flags) {
            if (expr.kind === 'get' || expr.kind === 'set') {
                return [
                    expr.kind, noEmptySpace(),
                    this.generatePropertyKey(expr.key, expr.computed),
                    this.generateFunctionBody(expr.value)
                ];
            }

            if (expr.shorthand) {
                if (expr.value.type === "AssignmentPattern") {
                    return this.AssignmentPattern(expr.value, Precedence.Sequence, E_TTT);
                }
                return this.generatePropertyKey(expr.key, expr.computed);
            }

            if (expr.method) {
                return [
                    generateMethodPrefix(expr),
                    this.generatePropertyKey(expr.key, expr.computed),
                    this.generateFunctionBody(expr.value)
                ];
            }

            return [
                this.generatePropertyKey(expr.key, expr.computed),
                ':' + space,
                this.generateExpression(expr.value, Precedence.Assignment, E_TTT)
            ];
        },

        ObjectExpression: function (expr, precedence, flags) {
            var multiline, result, fragment, that = this;

            if (!expr.properties.length) {
                return '{}';
            }
            multiline = expr.properties.length > 1;

            withIndent(function () {
                fragment = that.generateExpression(expr.properties[0], Precedence.Sequence, E_TTT);
            });

            if (!multiline) {
                // issues 4
                // Do not transform from
                //   dejavu.Class.declare({
                //       method2: function () {}
                //   });
                // to
                //   dejavu.Class.declare({method2: function () {
                //       }});
                if (!hasLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                    return [ '{', space, fragment, space, '}' ];
                }
            }

            withIndent(function (indent) {
                var i, iz;
                result = [ '{', newline, indent, fragment ];

                if (multiline) {
                    result.push(',' + newline);
                    for (i = 1, iz = expr.properties.length; i < iz; ++i) {
                        result.push(indent);
                        result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));
                        if (i + 1 < iz) {
                            result.push(',' + newline);
                        }
                    }
                }
            });

            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
            }
            result.push(base);
            result.push('}');
            return result;
        },

        AssignmentPattern: function(expr, precedence, flags) {
            return this.generateAssignment(expr.left, expr.right, '=', precedence, flags);
        },

        ObjectPattern: function (expr, precedence, flags) {
            var result, i, iz, multiline, property, that = this;
            if (!expr.properties.length) {
                return '{}';
            }

            multiline = false;
            if (expr.properties.length === 1) {
                property = expr.properties[0];
                if (property.value.type !== Syntax.Identifier) {
                    multiline = true;
                }
            } else {
                for (i = 0, iz = expr.properties.length; i < iz; ++i) {
                    property = expr.properties[i];
                    if (!property.shorthand) {
                        multiline = true;
                        break;
                    }
                }
            }
            result = ['{', multiline ? newline : '' ];

            withIndent(function (indent) {
                var i, iz;
                for (i = 0, iz = expr.properties.length; i < iz; ++i) {
                    result.push(multiline ? indent : '');
                    result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));
                    if (i + 1 < iz) {
                        result.push(',' + (multiline ? newline : space));
                    }
                }
            });

            if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
            }
            result.push(multiline ? base : '');
            result.push('}');
            return result;
        },

        ThisExpression: function (expr, precedence, flags) {
            return 'this';
        },

        Super: function (expr, precedence, flags) {
            return 'super';
        },

        Identifier: function (expr, precedence, flags) {
            return generateIdentifier(expr);
        },

        ImportDefaultSpecifier: function (expr, precedence, flags) {
            return generateIdentifier(expr.id || expr.local);
        },

        ImportNamespaceSpecifier: function (expr, precedence, flags) {
            var result = ['*'];
            var id = expr.id || expr.local;
            if (id) {
                result.push(space + 'as' + noEmptySpace() + generateIdentifier(id));
            }
            return result;
        },

        ImportSpecifier: function (expr, precedence, flags) {
            var imported = expr.imported;
            var result = [ imported.name ];
            var local = expr.local;
            if (local && local.name !== imported.name) {
                result.push(noEmptySpace() + 'as' + noEmptySpace() + generateIdentifier(local));
            }
            return result;
        },

        ExportSpecifier: function (expr, precedence, flags) {
            var local = expr.local;
            var result = [ local.name ];
            var exported = expr.exported;
            if (exported && exported.name !== local.name) {
                result.push(noEmptySpace() + 'as' + noEmptySpace() + generateIdentifier(exported));
            }
            return result;
        },

        Literal: function (expr, precedence, flags) {
            var raw;
            if (expr.hasOwnProperty('raw') && parse && extra.raw) {
                try {
                    raw = parse(expr.raw).body[0].expression;
                    if (raw.type === Syntax.Literal) {
                        if (raw.value === expr.value) {
                            return expr.raw;
                        }
                    }
                } catch (e) {
                    // not use raw property
                }
            }

            if (expr.regex) {
              return '/' + expr.regex.pattern + '/' + expr.regex.flags;
            }

            if (expr.value === null) {
                return 'null';
            }

            if (typeof expr.value === 'string') {
                return escapeString(expr.value);
            }

            if (typeof expr.value === 'number') {
                return generateNumber(expr.value);
            }

            if (typeof expr.value === 'boolean') {
                return expr.value ? 'true' : 'false';
            }

            return generateRegExp(expr.value);
        },

        GeneratorExpression: function (expr, precedence, flags) {
            return this.ComprehensionExpression(expr, precedence, flags);
        },

        ComprehensionExpression: function (expr, precedence, flags) {
            // GeneratorExpression should be parenthesized with (...), ComprehensionExpression with [...]
            // Due to https://bugzilla.mozilla.org/show_bug.cgi?id=883468 position of expr.body can differ in Spidermonkey and ES6

            var result, i, iz, fragment, that = this;
            result = (expr.type === Syntax.GeneratorExpression) ? ['('] : ['['];

            if (extra.moz.comprehensionExpressionStartsWithAssignment) {
                fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);
                result.push(fragment);
            }

            if (expr.blocks) {
                withIndent(function () {
                    for (i = 0, iz = expr.blocks.length; i < iz; ++i) {
                        fragment = that.generateExpression(expr.blocks[i], Precedence.Sequence, E_TTT);
                        if (i > 0 || extra.moz.comprehensionExpressionStartsWithAssignment) {
                            result = join(result, fragment);
                        } else {
                            result.push(fragment);
                        }
                    }
                });
            }

            if (expr.filter) {
                result = join(result, 'if' + space);
                fragment = this.generateExpression(expr.filter, Precedence.Sequence, E_TTT);
                result = join(result, [ '(', fragment, ')' ]);
            }

            if (!extra.moz.comprehensionExpressionStartsWithAssignment) {
                fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);

                result = join(result, fragment);
            }

            result.push((expr.type === Syntax.GeneratorExpression) ? ')' : ']');
            return result;
        },

        ComprehensionBlock: function (expr, precedence, flags) {
            var fragment;
            if (expr.left.type === Syntax.VariableDeclaration) {
                fragment = [
                    expr.left.kind, noEmptySpace(),
                    this.generateStatement(expr.left.declarations[0], S_FFFF)
                ];
            } else {
                fragment = this.generateExpression(expr.left, Precedence.Call, E_TTT);
            }

            fragment = join(fragment, expr.of ? 'of' : 'in');
            fragment = join(fragment, this.generateExpression(expr.right, Precedence.Sequence, E_TTT));

            return [ 'for' + space + '(', fragment, ')' ];
        },

        SpreadElement: function (expr, precedence, flags) {
            return [
                '...',
                this.generateExpression(expr.argument, Precedence.Assignment, E_TTT)
            ];
        },

        TaggedTemplateExpression: function (expr, precedence, flags) {
            var itemFlags = E_TTF;
            if (!(flags & F_ALLOW_CALL)) {
                itemFlags = E_TFF;
            }
            var result = [
                this.generateExpression(expr.tag, Precedence.Call, itemFlags),
                this.generateExpression(expr.quasi, Precedence.Primary, E_FFT)
            ];
            return parenthesize(result, Precedence.TaggedTemplate, precedence);
        },

        TemplateElement: function (expr, precedence, flags) {
            // Don't use "cooked". Since tagged template can use raw template
            // representation. So if we do so, it breaks the script semantics.
            return expr.value.raw;
        },

        TemplateLiteral: function (expr, precedence, flags) {
            var result, i, iz;
            result = [ '`' ];
            for (i = 0, iz = expr.quasis.length; i < iz; ++i) {
                result.push(this.generateExpression(expr.quasis[i], Precedence.Primary, E_TTT));
                if (i + 1 < iz) {
                    result.push('${' + space);
                    result.push(this.generateExpression(expr.expressions[i], Precedence.Sequence, E_TTT));
                    result.push(space + '}');
                }
            }
            result.push('`');
            return result;
        },

        ModuleSpecifier: function (expr, precedence, flags) {
            return this.Literal(expr, precedence, flags);
        },

        ImportExpression: function(expr, precedence, flag) {
            return parenthesize([
                'import(',
                this.generateExpression(expr.source, Precedence.Assignment, E_TTT),
                ')'
            ], Precedence.Call, precedence);
        },

    };

    merge(CodeGenerator.prototype, CodeGenerator.Expression);

    CodeGenerator.prototype.generateExpression = function (expr, precedence, flags) {
        var result, type;

        type = expr.type || Syntax.Property;

        if (extra.verbatim && expr.hasOwnProperty(extra.verbatim)) {
            return generateVerbatim(expr, precedence);
        }

        result = this[type](expr, precedence, flags);


        if (extra.comment) {
            result = addComments(expr, result);
        }
        return toSourceNodeWhenNeeded(result, expr);
    };

    CodeGenerator.prototype.generateStatement = function (stmt, flags) {
        var result,
            fragment;

        result = this[stmt.type](stmt, flags);

        // Attach comments

        if (extra.comment) {
            result = addComments(stmt, result);
        }

        fragment = toSourceNodeWhenNeeded(result).toString();
        if (stmt.type === Syntax.Program && !safeConcatenation && newline === '' &&  fragment.charAt(fragment.length - 1) === '\n') {
            result = sourceMap ? toSourceNodeWhenNeeded(result).replaceRight(/\s+$/, '') : fragment.replace(/\s+$/, '');
        }

        return toSourceNodeWhenNeeded(result, stmt);
    };

    function generateInternal(node) {
        var codegen;

        codegen = new CodeGenerator();
        if (isStatement(node)) {
            return codegen.generateStatement(node, S_TFFF);
        }

        if (isExpression(node)) {
            return codegen.generateExpression(node, Precedence.Sequence, E_TTT);
        }

        throw new Error('Unknown node type: ' + node.type);
    }

    function generate(node, options) {
        var defaultOptions = getDefaultOptions(), result, pair;

        if (options != null) {
            // Obsolete options
            //
            //   `options.indent`
            //   `options.base`
            //
            // Instead of them, we can use `option.format.indent`.
            if (typeof options.indent === 'string') {
                defaultOptions.format.indent.style = options.indent;
            }
            if (typeof options.base === 'number') {
                defaultOptions.format.indent.base = options.base;
            }
            options = updateDeeply(defaultOptions, options);
            indent = options.format.indent.style;
            if (typeof options.base === 'string') {
                base = options.base;
            } else {
                base = stringRepeat(indent, options.format.indent.base);
            }
        } else {
            options = defaultOptions;
            indent = options.format.indent.style;
            base = stringRepeat(indent, options.format.indent.base);
        }
        json = options.format.json;
        renumber = options.format.renumber;
        hexadecimal = json ? false : options.format.hexadecimal;
        quotes = json ? 'double' : options.format.quotes;
        escapeless = options.format.escapeless;
        newline = options.format.newline;
        space = options.format.space;
        if (options.format.compact) {
            newline = space = indent = base = '';
        }
        parentheses = options.format.parentheses;
        semicolons = options.format.semicolons;
        safeConcatenation = options.format.safeConcatenation;
        directive = options.directive;
        parse = json ? null : options.parse;
        sourceMap = options.sourceMap;
        sourceCode = options.sourceCode;
        preserveBlankLines = options.format.preserveBlankLines && sourceCode !== null;
        extra = options;

        if (sourceMap) {
            if (!exports.browser) {
                // We assume environment is node.js
                // And prevent from including source-map by browserify
                SourceNode = require('source-map').SourceNode;
            } else {
                SourceNode = global.sourceMap.SourceNode;
            }
        }

        result = generateInternal(node);

        if (!sourceMap) {
            pair = {code: result.toString(), map: null};
            return options.sourceMapWithCode ? pair : pair.code;
        }


        pair = result.toStringWithSourceMap({
            file: options.file,
            sourceRoot: options.sourceMapRoot
        });

        if (options.sourceContent) {
            pair.map.setSourceContent(options.sourceMap,
                                      options.sourceContent);
        }

        if (options.sourceMapWithCode) {
            return pair;
        }

        return pair.map.toString();
    }

    FORMAT_MINIFY = {
        indent: {
            style: '',
            base: 0
        },
        renumber: true,
        hexadecimal: true,
        quotes: 'auto',
        escapeless: true,
        compact: true,
        parentheses: false,
        semicolons: false
    };

    FORMAT_DEFAULTS = getDefaultOptions().format;

    exports.version = require('./package.json').version;
    exports.generate = generate;
    exports.attachComments = estraverse.attachComments;
    exports.Precedence = updateDeeply({}, Precedence);
    exports.browser = false;
    exports.FORMAT_MINIFY = FORMAT_MINIFY;
    exports.FORMAT_DEFAULTS = FORMAT_DEFAULTS;
}());
/* vim: set sw=4 ts=4 et tw=80 : */

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./package.json":17,"estraverse":19,"esutils":24,"source-map":16}],6:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = require('./util');
var has = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
function ArraySet() {
  this._array = [];
  this._set = hasNativeMap ? new Map() : Object.create(null);
}

/**
 * Static method for creating ArraySet instances from an existing array.
 */
ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet();
  for (var i = 0, len = aArray.length; i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }
  return set;
};

/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */
ArraySet.prototype.size = function ArraySet_size() {
  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};

/**
 * Add the given string to this set.
 *
 * @param String aStr
 */
ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
  var idx = this._array.length;
  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }
  if (!isDuplicate) {
    if (hasNativeMap) {
      this._set.set(aStr, idx);
    } else {
      this._set[sStr] = idx;
    }
  }
};

/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */
ArraySet.prototype.has = function ArraySet_has(aStr) {
  if (hasNativeMap) {
    return this._set.has(aStr);
  } else {
    var sStr = util.toSetString(aStr);
    return has.call(this._set, sStr);
  }
};

/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */
ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
  if (hasNativeMap) {
    var idx = this._set.get(aStr);
    if (idx >= 0) {
        return idx;
    }
  } else {
    var sStr = util.toSetString(aStr);
    if (has.call(this._set, sStr)) {
      return this._set[sStr];
    }
  }

  throw new Error('"' + aStr + '" is not in the set.');
};

/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */
ArraySet.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }
  throw new Error('No element indexed by ' + aIdx);
};

/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */
ArraySet.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

exports.ArraySet = ArraySet;

},{"./util":15}],7:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var base64 = require('./base64');

// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

var VLQ_BASE_SHIFT = 5;

// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
  return aValue < 0
    ? ((-aValue) << 1) + 1
    : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative
    ? -shifted
    : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
exports.encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;

  var vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;
    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }
    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};

/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }

    digit = base64.decode(aStr.charCodeAt(aIndex++));
    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }

    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};

},{"./base64":8}],8:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
exports.encode = function (number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};

/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
exports.decode = function (charCode) {
  var bigA = 65;     // 'A'
  var bigZ = 90;     // 'Z'

  var littleA = 97;  // 'a'
  var littleZ = 122; // 'z'

  var zero = 48;     // '0'
  var nine = 57;     // '9'

  var plus = 43;     // '+'
  var slash = 47;    // '/'

  var littleOffset = 26;
  var numberOffset = 52;

  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
  if (bigA <= charCode && charCode <= bigZ) {
    return (charCode - bigA);
  }

  // 26 - 51: abcdefghijklmnopqrstuvwxyz
  if (littleA <= charCode && charCode <= littleZ) {
    return (charCode - littleA + littleOffset);
  }

  // 52 - 61: 0123456789
  if (zero <= charCode && charCode <= nine) {
    return (charCode - zero + numberOffset);
  }

  // 62: +
  if (charCode == plus) {
    return 62;
  }

  // 63: /
  if (charCode == slash) {
    return 63;
  }

  // Invalid base64 digit.
  return -1;
};

},{}],9:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

exports.GREATEST_LOWER_BOUND = 1;
exports.LEAST_UPPER_BOUND = 2;

/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */
function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
  // This function terminates when one of the following is true:
  //
  //   1. We find the exact element we are looking for.
  //
  //   2. We did not find the exact element, but we can return the index of
  //      the next-closest element.
  //
  //   3. We did not find the exact element, and there is no next-closest
  //      element than the one we are searching for, so we return -1.
  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
  var cmp = aCompare(aNeedle, aHaystack[mid], true);
  if (cmp === 0) {
    // Found the element we are looking for.
    return mid;
  }
  else if (cmp > 0) {
    // Our needle is greater than aHaystack[mid].
    if (aHigh - mid > 1) {
      // The element is in the upper half.
      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
    }

    // The exact needle element was not found in this haystack. Determine if
    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return aHigh < aHaystack.length ? aHigh : -1;
    } else {
      return mid;
    }
  }
  else {
    // Our needle is less than aHaystack[mid].
    if (mid - aLow > 1) {
      // The element is in the lower half.
      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
    }

    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return mid;
    } else {
      return aLow < 0 ? -1 : aLow;
    }
  }
}

/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */
exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
  if (aHaystack.length === 0) {
    return -1;
  }

  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
  if (index < 0) {
    return -1;
  }

  // We have found either the exact element, or the next-closest element than
  // the one we are searching for. However, there may be more than one such
  // element. Make sure we always return the smallest of these.
  while (index - 1 >= 0) {
    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
      break;
    }
    --index;
  }

  return index;
};

},{}],10:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = require('./util');

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA ||
         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function MappingList() {
  this._array = [];
  this._sorted = true;
  // Serves as infimum
  this._last = {generatedLine: -1, generatedColumn: 0};
}

/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
MappingList.prototype.unsortedForEach =
  function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };

/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
MappingList.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;
    this._array.push(aMapping);
  } else {
    this._sorted = false;
    this._array.push(aMapping);
  }
};

/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
MappingList.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util.compareByGeneratedPositionsInflated);
    this._sorted = true;
  }
  return this._array;
};

exports.MappingList = MappingList;

},{"./util":15}],11:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

// It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.

/**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */
function swap(ary, x, y) {
  var temp = ary[x];
  ary[x] = ary[y];
  ary[y] = temp;
}

/**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */
function randomIntInRange(low, high) {
  return Math.round(low + (Math.random() * (high - low)));
}

/**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */
function doQuickSort(ary, comparator, p, r) {
  // If our lower bound is less than our upper bound, we (1) partition the
  // array into two pieces and (2) recurse on each half. If it is not, this is
  // the empty array and our base case.

  if (p < r) {
    // (1) Partitioning.
    //
    // The partitioning chooses a pivot between `p` and `r` and moves all
    // elements that are less than or equal to the pivot to the before it, and
    // all the elements that are greater than it after it. The effect is that
    // once partition is done, the pivot is in the exact place it will be when
    // the array is put in sorted order, and it will not need to be moved
    // again. This runs in O(n) time.

    // Always choose a random pivot so that an input array which is reverse
    // sorted does not cause O(n^2) running time.
    var pivotIndex = randomIntInRange(p, r);
    var i = p - 1;

    swap(ary, pivotIndex, r);
    var pivot = ary[r];

    // Immediately after `j` is incremented in this loop, the following hold
    // true:
    //
    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
    //
    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
    for (var j = p; j < r; j++) {
      if (comparator(ary[j], pivot) <= 0) {
        i += 1;
        swap(ary, i, j);
      }
    }

    swap(ary, i + 1, j);
    var q = i + 1;

    // (2) Recurse on each half.

    doQuickSort(ary, comparator, p, q - 1);
    doQuickSort(ary, comparator, q + 1, r);
  }
}

/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */
exports.quickSort = function (ary, comparator) {
  doQuickSort(ary, comparator, 0, ary.length - 1);
};

},{}],12:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = require('./util');
var binarySearch = require('./binary-search');
var ArraySet = require('./array-set').ArraySet;
var base64VLQ = require('./base64-vlq');
var quickSort = require('./quick-sort').quickSort;

function SourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  return sourceMap.sections != null
    ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)
    : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
}

SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
}

/**
 * The version of the source mapping spec that we are consuming.
 */
SourceMapConsumer.prototype._version = 3;

// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__generatedMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__generatedMappings;
  }
});

SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__originalMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__originalMappings;
  }
});

SourceMapConsumer.prototype._charIsMappingSeparator =
  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
SourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };

SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;

SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;

/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */
SourceMapConsumer.prototype.eachMapping =
  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

    var mappings;
    switch (order) {
    case SourceMapConsumer.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;
    case SourceMapConsumer.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
    }

    var sourceRoot = this.sourceRoot;
    mappings.map(function (mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);
      source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
      return {
        source: source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  };

/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number is 1-based.
 *   - column: Optional. the column number in the original source.
 *    The column number is 0-based.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *    line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *    The column number is 0-based.
 */
SourceMapConsumer.prototype.allGeneratedPositionsFor =
  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, 'line');

    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
    // returns the index of the closest mapping less than the needle. By
    // setting needle.originalColumn to 0, we thus find the last mapping for
    // the given line, provided such a mapping exists.
    var needle = {
      source: util.getArg(aArgs, 'source'),
      originalLine: line,
      originalColumn: util.getArg(aArgs, 'column', 0)
    };

    needle.source = this._findSourceIndex(needle.source);
    if (needle.source < 0) {
      return [];
    }

    var mappings = [];

    var index = this._findMapping(needle,
                                  this._originalMappings,
                                  "originalLine",
                                  "originalColumn",
                                  util.compareByOriginalPositions,
                                  binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (aArgs.column === undefined) {
        var originalLine = mapping.originalLine;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we found. Since
        // mappings are sorted, this is guaranteed to find all mappings for
        // the line we found.
        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we were searching for.
        // Since mappings are sorted, this is guaranteed to find all mappings for
        // the line we are searching for.
        while (mapping &&
               mapping.originalLine === line &&
               mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      }
    }

    return mappings;
  };

exports.SourceMapConsumer = SourceMapConsumer;

/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The first parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */
function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  var version = util.getArg(sourceMap, 'version');
  var sources = util.getArg(sourceMap, 'sources');
  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
  // requires the array) to play nice here.
  var names = util.getArg(sourceMap, 'names', []);
  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
  var mappings = util.getArg(sourceMap, 'mappings');
  var file = util.getArg(sourceMap, 'file', null);

  // Once again, Sass deviates from the spec and supplies the version as a
  // string rather than a number, so we use loose equality checking here.
  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  if (sourceRoot) {
    sourceRoot = util.normalize(sourceRoot);
  }

  sources = sources
    .map(String)
    // Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    .map(util.normalize)
    // Always ensure that absolute sources are internally stored relative to
    // the source root, if the source root is absolute. Not doing this would
    // be particularly problematic when the source root is a prefix of the
    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
    .map(function (source) {
      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
        ? util.relative(sourceRoot, source)
        : source;
    });

  // Pass `true` below to allow duplicate names and sources. While source maps
  // are intended to be compressed and deduplicated, the TypeScript compiler
  // sometimes generates source maps with duplicates in them. See Github issue
  // #72 and bugzil.la/889492.
  this._names = ArraySet.fromArray(names.map(String), true);
  this._sources = ArraySet.fromArray(sources, true);

  this._absoluteSources = this._sources.toArray().map(function (s) {
    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
  });

  this.sourceRoot = sourceRoot;
  this.sourcesContent = sourcesContent;
  this._mappings = mappings;
  this._sourceMapURL = aSourceMapURL;
  this.file = file;
}

BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

/**
 * Utility function to find the index of a source.  Returns -1 if not
 * found.
 */
BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
  var relativeSource = aSource;
  if (this.sourceRoot != null) {
    relativeSource = util.relative(this.sourceRoot, relativeSource);
  }

  if (this._sources.has(relativeSource)) {
    return this._sources.indexOf(relativeSource);
  }

  // Maybe aSource is an absolute URL as returned by |sources|.  In
  // this case we can't simply undo the transform.
  var i;
  for (i = 0; i < this._absoluteSources.length; ++i) {
    if (this._absoluteSources[i] == aSource) {
      return i;
    }
  }

  return -1;
};

/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @param String aSourceMapURL
 *        The URL at which the source map can be found (optional)
 * @returns BasicSourceMapConsumer
 */
BasicSourceMapConsumer.fromSourceMap =
  function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);

    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                            smc.sourceRoot);
    smc.file = aSourceMap._file;
    smc._sourceMapURL = aSourceMapURL;
    smc._absoluteSources = smc._sources.toArray().map(function (s) {
      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
    });

    // Because we are modifying the entries (by converting string sources and
    // names to indices into the sources and names ArraySets), we have to make
    // a copy of the entry or else bad things happen. Shared mutable state
    // strikes again! See github issue #191.

    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];

    for (var i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping;
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;

      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;

        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }

        destOriginalMappings.push(destMapping);
      }

      destGeneratedMappings.push(destMapping);
    }

    quickSort(smc.__originalMappings, util.compareByOriginalPositions);

    return smc;
  };

/**
 * The version of the source mapping spec that we are consuming.
 */
BasicSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
  get: function () {
    return this._absoluteSources.slice();
  }
});

/**
 * Provide the JIT with a nice shape / hidden class.
 */
function Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
BasicSourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;

    while (index < length) {
      if (aStr.charAt(index) === ';') {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
      }
      else if (aStr.charAt(index) === ',') {
        index++;
      }
      else {
        mapping = new Mapping();
        mapping.generatedLine = generatedLine;

        // Because each offset is encoded relative to the previous one,
        // many segments often have the same encoding. We can exploit this
        // fact by caching the parsed variable length fields of each segment,
        // allowing us to avoid a second parse if we encounter the same
        // segment again.
        for (end = index; end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }
        str = aStr.slice(index, end);

        segment = cachedSegments[str];
        if (segment) {
          index += str.length;
        } else {
          segment = [];
          while (index < end) {
            base64VLQ.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }

          if (segment.length === 2) {
            throw new Error('Found a source, but no line and column');
          }

          if (segment.length === 3) {
            throw new Error('Found a source and line, but no column');
          }

          cachedSegments[str] = segment;
        }

        // Generated column.
        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;

        if (segment.length > 1) {
          // Original source.
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];

          // Original line.
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          // Lines are stored 0-based
          mapping.originalLine += 1;

          // Original column.
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;

          if (segment.length > 4) {
            // Original name.
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }

        generatedMappings.push(mapping);
        if (typeof mapping.originalLine === 'number') {
          originalMappings.push(mapping);
        }
      }
    }

    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;

    quickSort(originalMappings, util.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };

/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */
BasicSourceMapConsumer.prototype._findMapping =
  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                         aColumnName, aComparator, aBias) {
    // To return the position we are searching for, we must first find the
    // mapping for the given position and then return the opposite position it
    // points to. Because the mappings are sorted, we can use binary search to
    // find the best mapping.

    if (aNeedle[aLineName] <= 0) {
      throw new TypeError('Line must be greater than or equal to 1, got '
                          + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError('Column must be greater than or equal to 0, got '
                          + aNeedle[aColumnName]);
    }

    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };

/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */
BasicSourceMapConsumer.prototype.computeColumnSpans =
  function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];

      // Mappings do not contain a field for the last generated columnt. We
      // can come up with an optimistic estimate, however, by assuming that
      // mappings are contiguous (i.e. given two consecutive mappings, the
      // first mapping ends where the second one starts).
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];

        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }

      // The last mapping for each line spans the entire line.
      mapping.lastGeneratedColumn = Infinity;
    }
  };

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
BasicSourceMapConsumer.prototype.originalPositionFor =
  function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._generatedMappings,
      "generatedLine",
      "generatedColumn",
      util.compareByGeneratedPositionsDeflated,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._generatedMappings[index];

      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, 'source', null);
        if (source !== null) {
          source = this._sources.at(source);
          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
        }
        var name = util.getArg(mapping, 'name', null);
        if (name !== null) {
          name = this._names.at(name);
        }
        return {
          source: source,
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: name
        };
      }
    }

    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
  function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() &&
      !this.sourcesContent.some(function (sc) { return sc == null; });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
BasicSourceMapConsumer.prototype.sourceContentFor =
  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }

    var index = this._findSourceIndex(aSource);
    if (index >= 0) {
      return this.sourcesContent[index];
    }

    var relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
    }

    var url;
    if (this.sourceRoot != null
        && (url = util.urlParse(this.sourceRoot))) {
      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
      // many users. We can help them out when they expect file:// URIs to
      // behave like it would if they were running a local HTTP server. See
      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
      if (url.scheme == "file"
          && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
      }

      if ((!url.path || url.path == "/")
          && this._sources.has("/" + relativeSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
      }
    }

    // This function is used recursively from
    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
    // don't want to throw if we can't find the source - we just want to
    // return null, so we provide a flag to exit gracefully.
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
BasicSourceMapConsumer.prototype.generatedPositionFor =
  function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, 'source');
    source = this._findSourceIndex(source);
    if (source < 0) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }

    var needle = {
      source: source,
      originalLine: util.getArg(aArgs, 'line'),
      originalColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      util.compareByOriginalPositions,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (mapping.source === needle.source) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }
    }

    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };

exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The first parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */
function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  var version = util.getArg(sourceMap, 'version');
  var sections = util.getArg(sourceMap, 'sections');

  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  this._sources = new ArraySet();
  this._names = new ArraySet();

  var lastOffset = {
    line: -1,
    column: 0
  };
  this._sections = sections.map(function (s) {
    if (s.url) {
      // The url field will require support for asynchronicity.
      // See https://github.com/mozilla/source-map/issues/16
      throw new Error('Support for url field in sections not implemented.');
    }
    var offset = util.getArg(s, 'offset');
    var offsetLine = util.getArg(offset, 'line');
    var offsetColumn = util.getArg(offset, 'column');

    if (offsetLine < lastOffset.line ||
        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
      throw new Error('Section offsets must be ordered and non-overlapping.');
    }
    lastOffset = offset;

    return {
      generatedOffset: {
        // The offset fields are 0-based, but we use 1-based indices when
        // encoding/decoding from VLQ.
        generatedLine: offsetLine + 1,
        generatedColumn: offsetColumn + 1
      },
      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
    }
  });
}

IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

/**
 * The version of the source mapping spec that we are consuming.
 */
IndexedSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
  get: function () {
    var sources = [];
    for (var i = 0; i < this._sections.length; i++) {
      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }
    return sources;
  }
});

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
IndexedSourceMapConsumer.prototype.originalPositionFor =
  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    // Find the section containing the generated position we're trying to map
    // to an original position.
    var sectionIndex = binarySearch.search(needle, this._sections,
      function(needle, section) {
        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
        if (cmp) {
          return cmp;
        }

        return (needle.generatedColumn -
                section.generatedOffset.generatedColumn);
      });
    var section = this._sections[sectionIndex];

    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }

    return section.consumer.originalPositionFor({
      line: needle.generatedLine -
        (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn -
        (section.generatedOffset.generatedLine === needle.generatedLine
         ? section.generatedOffset.generatedColumn - 1
         : 0),
      bias: aArgs.bias
    });
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function (s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
IndexedSourceMapConsumer.prototype.sourceContentFor =
  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      var content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based. 
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
IndexedSourceMapConsumer.prototype.generatedPositionFor =
  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      // Only consider this section if the requested source is in the list of
      // sources of the consumer.
      if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
        continue;
      }
      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line +
            (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column +
            (section.generatedOffset.generatedLine === generatedPosition.line
             ? section.generatedOffset.generatedColumn - 1
             : 0)
        };
        return ret;
      }
    }

    return {
      line: null,
      column: null
    };
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
IndexedSourceMapConsumer.prototype._parseMappings =
  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;
      for (var j = 0; j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];

        var source = section.consumer._sources.at(mapping.source);
        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
        this._sources.add(source);
        source = this._sources.indexOf(source);

        var name = null;
        if (mapping.name) {
          name = section.consumer._names.at(mapping.name);
          this._names.add(name);
          name = this._names.indexOf(name);
        }

        // The mappings coming from the consumer for the section have
        // generated positions relative to the start of the section, so we
        // need to offset them to be relative to the start of the concatenated
        // generated file.
        var adjustedMapping = {
          source: source,
          generatedLine: mapping.generatedLine +
            (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn +
            (section.generatedOffset.generatedLine === mapping.generatedLine
            ? section.generatedOffset.generatedColumn - 1
            : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: name
        };

        this.__generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === 'number') {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }

    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
  };

exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;

},{"./array-set":6,"./base64-vlq":7,"./binary-search":9,"./quick-sort":11,"./util":15}],13:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var base64VLQ = require('./base64-vlq');
var util = require('./util');
var ArraySet = require('./array-set').ArraySet;
var MappingList = require('./mapping-list').MappingList;

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }
  this._file = util.getArg(aArgs, 'file', null);
  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}

SourceMapGenerator.prototype._version = 3;

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
SourceMapGenerator.fromSourceMap =
  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };

        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var sourceRelative = sourceFile;
      if (sourceRoot !== null) {
        sourceRelative = util.relative(sourceRoot, sourceFile);
      }

      if (!generator._sources.has(sourceRelative)) {
        generator._sources.add(sourceRelative);
      }

      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
SourceMapGenerator.prototype.addMapping =
  function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);

    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }

    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  };

/**
 * Set the source content for a source file.
 */
SourceMapGenerator.prototype.setSourceContent =
  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
SourceMapGenerator.prototype.applySourceMap =
  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(
          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
          'or the source map\'s "file" property. Both were omitted.'
        );
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    var newSources = new ArraySet();
    var newNames = new ArraySet();

    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        // Check if it can be mapped by the source map, then update the mapping.
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          // Copy mapping
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source)
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }

      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }

    }, this);
    this._sources = newSources;
    this._names = newNames;

    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile = util.join(aSourceMapPath, sourceFile);
        }
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };

/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */
SourceMapGenerator.prototype._validateMapping =
  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                              aName) {
    // When aOriginal is truthy but has empty values for .line and .column,
    // it is most likely a programmer error. In this case we throw a very
    // specific error message to try to guide them the right way.
    // For example: https://github.com/Polymer/polymer-bundler/pull/519
    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
        throw new Error(
            'original.line and original.column are not numbers -- you probably meant to omit ' +
            'the original mapping entirely and only map the generated position. If so, pass ' +
            'null for the original mapping instead of an object with empty or null values.'
        );
    }

    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
        && aGenerated.line > 0 && aGenerated.column >= 0
        && !aOriginal && !aSource && !aName) {
      // Case 1.
      return;
    }
    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
             && aGenerated.line > 0 && aGenerated.column >= 0
             && aOriginal.line > 0 && aOriginal.column >= 0
             && aSource) {
      // Cases 2 and 3.
      return;
    }
    else {
      throw new Error('Invalid mapping: ' + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };

/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */
SourceMapGenerator.prototype._serializeMappings =
  function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;

    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = ''

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ';';
          previousGeneratedLine++;
        }
      }
      else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ',';
        }
      }

      next += base64VLQ.encode(mapping.generatedColumn
                                 - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;

        // lines are stored 0-based in SourceMap spec version 3
        next += base64VLQ.encode(mapping.originalLine - 1
                                   - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;

        next += base64VLQ.encode(mapping.originalColumn
                                   - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }

      result += next;
    }

    return result;
  };

SourceMapGenerator.prototype._generateSourcesContent =
  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
        ? this._sourcesContents[key]
        : null;
    }, this);
  };

/**
 * Externalize the source map.
 */
SourceMapGenerator.prototype.toJSON =
  function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }

    return map;
  };

/**
 * Render the source map being generated to a string.
 */
SourceMapGenerator.prototype.toString =
  function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };

exports.SourceMapGenerator = SourceMapGenerator;

},{"./array-set":6,"./base64-vlq":7,"./mapping-list":10,"./util":15}],14:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;
var util = require('./util');

// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
var REGEX_NEWLINE = /(\r?\n)/;

// Newline character code for charCodeAt() comparisons
var NEWLINE_CODE = 10;

// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
var isSourceNode = "$$$isSourceNode$$$";

/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */
function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
  this.children = [];
  this.sourceContents = {};
  this.line = aLine == null ? null : aLine;
  this.column = aColumn == null ? null : aColumn;
  this.source = aSource == null ? null : aSource;
  this.name = aName == null ? null : aName;
  this[isSourceNode] = true;
  if (aChunks != null) this.add(aChunks);
}

/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */
SourceNode.fromStringWithSourceMap =
  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    // The SourceNode we want to fill with the generated code
    // and the SourceMap
    var node = new SourceNode();

    // All even indices of this array are one line of the generated code,
    // while all odd indices are the newlines between two adjacent lines
    // (since `REGEX_NEWLINE` captures its match).
    // Processed fragments are accessed by calling `shiftNextLine`.
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var remainingLinesIndex = 0;
    var shiftNextLine = function() {
      var lineContents = getNextLine();
      // The last line of a file might not have a newline.
      var newLine = getNextLine() || "";
      return lineContents + newLine;

      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ?
            remainingLines[remainingLinesIndex++] : undefined;
      }
    };

    // We need to remember the position of "remainingLines"
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;

    // The generate SourceNodes we need a code range.
    // To extract it current and last mapping is used.
    // Here we store the last mapping.
    var lastMapping = null;

    aSourceMapConsumer.eachMapping(function (mapping) {
      if (lastMapping !== null) {
        // We add the code from "lastMapping" to "mapping":
        // First check if there is a new line in between.
        if (lastGeneratedLine < mapping.generatedLine) {
          // Associate first line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
          // The remaining code is added without mapping
        } else {
          // There is no new line in between.
          // Associate the code between "lastGeneratedColumn" and
          // "mapping.generatedColumn" with "lastMapping"
          var nextLine = remainingLines[remainingLinesIndex] || '';
          var code = nextLine.substr(0, mapping.generatedColumn -
                                        lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
                                              lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          // No more remaining code, continue
          lastMapping = mapping;
          return;
        }
      }
      // We add the generated code until the first mapping
      // to the SourceNode without any mapping.
      // Each line is added as separate string.
      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }
      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex] || '';
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this);
    // We have processed all mappings.
    if (remainingLinesIndex < remainingLines.length) {
      if (lastMapping) {
        // Associate the remaining code in the current line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
      }
      // and add the remaining lines without any mapping
      node.add(remainingLines.splice(remainingLinesIndex).join(""));
    }

    // Copy sourcesContent into SourceNode
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util.join(aRelativePath, sourceFile);
        }
        node.setSourceContent(sourceFile, content);
      }
    });

    return node;

    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        var source = aRelativePath
          ? util.join(aRelativePath, mapping.source)
          : mapping.source;
        node.add(new SourceNode(mapping.originalLine,
                                mapping.originalColumn,
                                source,
                                code,
                                mapping.name));
      }
    }
  };

/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.add = function SourceNode_add(aChunk) {
  if (Array.isArray(aChunk)) {
    aChunk.forEach(function (chunk) {
      this.add(chunk);
    }, this);
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    if (aChunk) {
      this.children.push(aChunk);
    }
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
  if (Array.isArray(aChunk)) {
    for (var i = aChunk.length-1; i >= 0; i--) {
      this.prepend(aChunk[i]);
    }
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    this.children.unshift(aChunk);
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walk = function SourceNode_walk(aFn) {
  var chunk;
  for (var i = 0, len = this.children.length; i < len; i++) {
    chunk = this.children[i];
    if (chunk[isSourceNode]) {
      chunk.walk(aFn);
    }
    else {
      if (chunk !== '') {
        aFn(chunk, { source: this.source,
                     line: this.line,
                     column: this.column,
                     name: this.name });
      }
    }
  }
};

/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */
SourceNode.prototype.join = function SourceNode_join(aSep) {
  var newChildren;
  var i;
  var len = this.children.length;
  if (len > 0) {
    newChildren = [];
    for (i = 0; i < len-1; i++) {
      newChildren.push(this.children[i]);
      newChildren.push(aSep);
    }
    newChildren.push(this.children[i]);
    this.children = newChildren;
  }
  return this;
};

/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */
SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
  var lastChild = this.children[this.children.length - 1];
  if (lastChild[isSourceNode]) {
    lastChild.replaceRight(aPattern, aReplacement);
  }
  else if (typeof lastChild === 'string') {
    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
  }
  else {
    this.children.push(''.replace(aPattern, aReplacement));
  }
  return this;
};

/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */
SourceNode.prototype.setSourceContent =
  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  };

/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walkSourceContents =
  function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length; i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }

    var sources = Object.keys(this.sourceContents);
    for (var i = 0, len = sources.length; i < len; i++) {
      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };

/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */
SourceNode.prototype.toString = function SourceNode_toString() {
  var str = "";
  this.walk(function (chunk) {
    str += chunk;
  });
  return str;
};

/**
 * Returns the string representation of this source node along with a source
 * map.
 */
SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
  var generated = {
    code: "",
    line: 1,
    column: 0
  };
  var map = new SourceMapGenerator(aArgs);
  var sourceMappingActive = false;
  var lastOriginalSource = null;
  var lastOriginalLine = null;
  var lastOriginalColumn = null;
  var lastOriginalName = null;
  this.walk(function (chunk, original) {
    generated.code += chunk;
    if (original.source !== null
        && original.line !== null
        && original.column !== null) {
      if(lastOriginalSource !== original.source
         || lastOriginalLine !== original.line
         || lastOriginalColumn !== original.column
         || lastOriginalName !== original.name) {
        map.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        });
      }
      lastOriginalSource = original.source;
      lastOriginalLine = original.line;
      lastOriginalColumn = original.column;
      lastOriginalName = original.name;
      sourceMappingActive = true;
    } else if (sourceMappingActive) {
      map.addMapping({
        generated: {
          line: generated.line,
          column: generated.column
        }
      });
      lastOriginalSource = null;
      sourceMappingActive = false;
    }
    for (var idx = 0, length = chunk.length; idx < length; idx++) {
      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
        generated.line++;
        generated.column = 0;
        // Mappings end at eol
        if (idx + 1 === length) {
          lastOriginalSource = null;
          sourceMappingActive = false;
        } else if (sourceMappingActive) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
      } else {
        generated.column++;
      }
    }
  });
  this.walkSourceContents(function (sourceFile, sourceContent) {
    map.setSourceContent(sourceFile, sourceContent);
  });

  return { code: generated.code, map: map };
};

exports.SourceNode = SourceNode;

},{"./source-map-generator":13,"./util":15}],15:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  } else {
    throw new Error('"' + aName + '" is a required argument.');
  }
}
exports.getArg = getArg;

var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;

function urlParse(aUrl) {
  var match = aUrl.match(urlRegexp);
  if (!match) {
    return null;
  }
  return {
    scheme: match[1],
    auth: match[2],
    host: match[3],
    port: match[4],
    path: match[5]
  };
}
exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
  var url = '';
  if (aParsedUrl.scheme) {
    url += aParsedUrl.scheme + ':';
  }
  url += '//';
  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + '@';
  }
  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }
  if (aParsedUrl.port) {
    url += ":" + aParsedUrl.port
  }
  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }
  return url;
}
exports.urlGenerate = urlGenerate;

/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */
function normalize(aPath) {
  var path = aPath;
  var url = urlParse(aPath);
  if (url) {
    if (!url.path) {
      return aPath;
    }
    path = url.path;
  }
  var isAbsolute = exports.isAbsolute(path);

  var parts = path.split(/\/+/);
  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
    part = parts[i];
    if (part === '.') {
      parts.splice(i, 1);
    } else if (part === '..') {
      up++;
    } else if (up > 0) {
      if (part === '') {
        // The first part is blank if the path is absolute. Trying to go
        // above the root is a no-op. Therefore we can remove all '..' parts
        // directly after the root.
        parts.splice(i + 1, up);
        up = 0;
      } else {
        parts.splice(i, 2);
        up--;
      }
    }
  }
  path = parts.join('/');

  if (path === '') {
    path = isAbsolute ? '/' : '.';
  }

  if (url) {
    url.path = path;
    return urlGenerate(url);
  }
  return path;
}
exports.normalize = normalize;

/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */
function join(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }
  if (aPath === "") {
    aPath = ".";
  }
  var aPathUrl = urlParse(aPath);
  var aRootUrl = urlParse(aRoot);
  if (aRootUrl) {
    aRoot = aRootUrl.path || '/';
  }

  // `join(foo, '//www.example.org')`
  if (aPathUrl && !aPathUrl.scheme) {
    if (aRootUrl) {
      aPathUrl.scheme = aRootUrl.scheme;
    }
    return urlGenerate(aPathUrl);
  }

  if (aPathUrl || aPath.match(dataUrlRegexp)) {
    return aPath;
  }

  // `join('http://', 'www.example.com')`
  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    aRootUrl.host = aPath;
    return urlGenerate(aRootUrl);
  }

  var joined = aPath.charAt(0) === '/'
    ? aPath
    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

  if (aRootUrl) {
    aRootUrl.path = joined;
    return urlGenerate(aRootUrl);
  }
  return joined;
}
exports.join = join;

exports.isAbsolute = function (aPath) {
  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
};

/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */
function relative(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  aRoot = aRoot.replace(/\/$/, '');

  // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.
  var level = 0;
  while (aPath.indexOf(aRoot + '/') !== 0) {
    var index = aRoot.lastIndexOf("/");
    if (index < 0) {
      return aPath;
    }

    // If the only part of the root that is left is the scheme (i.e. http://,
    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    // have exhausted all components, so the path is not relative to the root.
    aRoot = aRoot.slice(0, index);
    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
      return aPath;
    }

    ++level;
  }

  // Make sure we add a "../" for each component we removed from the root.
  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;

var supportsNullProto = (function () {
  var obj = Object.create(null);
  return !('__proto__' in obj);
}());

function identity (s) {
  return s;
}

/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */
function toSetString(aStr) {
  if (isProtoString(aStr)) {
    return '$' + aStr;
  }

  return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;

function fromSetString(aStr) {
  if (isProtoString(aStr)) {
    return aStr.slice(1);
  }

  return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;

function isProtoString(s) {
  if (!s) {
    return false;
  }

  var length = s.length;

  if (length < 9 /* "__proto__".length */) {
    return false;
  }

  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
      s.charCodeAt(length - 9) !== 95  /* '_' */) {
    return false;
  }

  for (var i = length - 10; i >= 0; i--) {
    if (s.charCodeAt(i) !== 36 /* '$' */) {
      return false;
    }
  }

  return true;
}

/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */
function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  var cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByOriginalPositions = compareByOriginalPositions;

/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */
function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

function strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
    return 0;
  }

  if (aStr1 === null) {
    return 1; // aStr2 !== null
  }

  if (aStr2 === null) {
    return -1; // aStr1 !== null
  }

  if (aStr1 > aStr2) {
    return 1;
  }

  return -1;
}

/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
function compareByGeneratedPositionsInflated(mappingA, mappingB) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

/**
 * Strip any JSON XSSI avoidance prefix from the string (as documented
 * in the source maps specification), and then parse the string as
 * JSON.
 */
function parseSourceMapInput(str) {
  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
}
exports.parseSourceMapInput = parseSourceMapInput;

/**
 * Compute the URL of a source given the the source root, the source's
 * URL, and the source map's URL.
 */
function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
  sourceURL = sourceURL || '';

  if (sourceRoot) {
    // This follows what Chrome does.
    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
      sourceRoot += '/';
    }
    // The spec says:
    //   Line 4: An optional source root, useful for relocating source
    //   files on a server or removing repeated values in the
    //   “sources” entry.  This value is prepended to the individual
    //   entries in the “source” field.
    sourceURL = sourceRoot + sourceURL;
  }

  // Historically, SourceMapConsumer did not take the sourceMapURL as
  // a parameter.  This mode is still somewhat supported, which is why
  // this code block is conditional.  However, it's preferable to pass
  // the source map URL to SourceMapConsumer, so that this function
  // can implement the source URL resolution algorithm as outlined in
  // the spec.  This block is basically the equivalent of:
  //    new URL(sourceURL, sourceMapURL).toString()
  // ... except it avoids using URL, which wasn't available in the
  // older releases of node still supported by this library.
  //
  // The spec says:
  //   If the sources are not absolute URLs after prepending of the
  //   “sourceRoot”, the sources are resolved relative to the
  //   SourceMap (like resolving script src in a html document).
  if (sourceMapURL) {
    var parsed = urlParse(sourceMapURL);
    if (!parsed) {
      throw new Error("sourceMapURL could not be parsed");
    }
    if (parsed.path) {
      // Strip the last path component, but keep the "/".
      var index = parsed.path.lastIndexOf('/');
      if (index >= 0) {
        parsed.path = parsed.path.substring(0, index + 1);
      }
    }
    sourceURL = join(urlGenerate(parsed), sourceURL);
  }

  return normalize(sourceURL);
}
exports.computeSourceURL = computeSourceURL;

},{}],16:[function(require,module,exports){
/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = require('./lib/source-map-generator').SourceMapGenerator;
exports.SourceMapConsumer = require('./lib/source-map-consumer').SourceMapConsumer;
exports.SourceNode = require('./lib/source-node').SourceNode;

},{"./lib/source-map-consumer":12,"./lib/source-map-generator":13,"./lib/source-node":14}],17:[function(require,module,exports){
module.exports={
  "_args": [
    [
      "escodegen@1.14.1",
      "/mnt/c/Users/dhn03/source/projects/jsflow/jsflow-master"
    ]
  ],
  "_from": "escodegen@1.14.1",
  "_id": "escodegen@1.14.1",
  "_inBundle": false,
  "_integrity": "sha512-Bmt7NcRySdIfNPfU2ZoXDrrXsG9ZjvDxcAlMfDUgRBjLOWTuIACXPBFJH7Z+cLb40JeQco5toikyc9t9P8E9SQ==",
  "_location": "/escodegen",
  "_phantomChildren": {},
  "_requested": {
    "type": "version",
    "registry": true,
    "raw": "escodegen@1.14.1",
    "name": "escodegen",
    "escapedName": "escodegen",
    "rawSpec": "1.14.1",
    "saveSpec": null,
    "fetchSpec": "1.14.1"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/escodegen/-/escodegen-1.14.1.tgz",
  "_spec": "1.14.1",
  "_where": "/mnt/c/Users/dhn03/source/projects/jsflow/jsflow-master",
  "bin": {
    "esgenerate": "bin/esgenerate.js",
    "escodegen": "bin/escodegen.js"
  },
  "bugs": {
    "url": "https://github.com/estools/escodegen/issues"
  },
  "dependencies": {
    "esprima": "^4.0.1",
    "estraverse": "^4.2.0",
    "esutils": "^2.0.2",
    "optionator": "^0.8.1",
    "source-map": "~0.6.1"
  },
  "description": "ECMAScript code generator",
  "devDependencies": {
    "acorn": "^7.1.0",
    "bluebird": "^3.4.7",
    "bower-registry-client": "^1.0.0",
    "chai": "^3.5.0",
    "commonjs-everywhere": "^0.9.7",
    "gulp": "^3.8.10",
    "gulp-eslint": "^3.0.1",
    "gulp-mocha": "^3.0.1",
    "semver": "^5.1.0"
  },
  "engines": {
    "node": ">=4.0"
  },
  "files": [
    "LICENSE.BSD",
    "README.md",
    "bin",
    "escodegen.js",
    "package.json"
  ],
  "homepage": "http://github.com/estools/escodegen",
  "license": "BSD-2-Clause",
  "main": "escodegen.js",
  "maintainers": [
    {
      "name": "Yusuke Suzuki",
      "email": "utatane.tea@gmail.com",
      "url": "http://github.com/Constellation"
    }
  ],
  "name": "escodegen",
  "optionalDependencies": {
    "source-map": "~0.6.1"
  },
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/estools/escodegen.git"
  },
  "scripts": {
    "build": "cjsify -a path: tools/entry-point.js > escodegen.browser.js",
    "build-min": "cjsify -ma path: tools/entry-point.js > escodegen.browser.min.js",
    "lint": "gulp lint",
    "release": "node tools/release.js",
    "test": "gulp travis",
    "unit-test": "gulp test"
  },
  "version": "1.14.1"
}

},{}],18:[function(require,module,exports){
/*
  Copyright (c) jQuery Foundation, Inc. and Contributors, All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function (root, factory) {
    'use strict';

    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
    // Rhino, and plain browser loading.

    /* istanbul ignore next */
    if (typeof define === 'function' && define.amd) {
        define(['exports'], factory);
    } else if (typeof exports !== 'undefined') {
        factory(exports);
    } else {
        factory((root.esprima = {}));
    }
}(this, function (exports) {
    'use strict';

    var Token,
        TokenName,
        FnExprTokens,
        Syntax,
        PlaceHolders,
        Messages,
        Regex,
        source,
        strict,
        index,
        lineNumber,
        lineStart,
        hasLineTerminator,
        lastIndex,
        lastLineNumber,
        lastLineStart,
        startIndex,
        startLineNumber,
        startLineStart,
        scanning,
        length,
        lookahead,
        state,
        extra,
        isBindingElement,
        isAssignmentTarget,
        firstCoverInitializedNameError;

    Token = {
        BooleanLiteral: 1,
        EOF: 2,
        Identifier: 3,
        Keyword: 4,
        NullLiteral: 5,
        NumericLiteral: 6,
        Punctuator: 7,
        StringLiteral: 8,
        RegularExpression: 9,
        Template: 10
    };

    TokenName = {};
    TokenName[Token.BooleanLiteral] = 'Boolean';
    TokenName[Token.EOF] = '<end>';
    TokenName[Token.Identifier] = 'Identifier';
    TokenName[Token.Keyword] = 'Keyword';
    TokenName[Token.NullLiteral] = 'Null';
    TokenName[Token.NumericLiteral] = 'Numeric';
    TokenName[Token.Punctuator] = 'Punctuator';
    TokenName[Token.StringLiteral] = 'String';
    TokenName[Token.RegularExpression] = 'RegularExpression';
    TokenName[Token.Template] = 'Template';

    // A function following one of those tokens is an expression.
    FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
                    'return', 'case', 'delete', 'throw', 'void',
                    // assignment operators
                    '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=',
                    '&=', '|=', '^=', ',',
                    // binary/unary operators
                    '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
                    '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
                    '<=', '<', '>', '!=', '!=='];

    Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        AssignmentPattern: 'AssignmentPattern',
        ArrayExpression: 'ArrayExpression',
        ArrayPattern: 'ArrayPattern',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ClassBody: 'ClassBody',
        ClassDeclaration: 'ClassDeclaration',
        ClassExpression: 'ClassExpression',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DoWhileStatement: 'DoWhileStatement',
        DebuggerStatement: 'DebuggerStatement',
        EmptyStatement: 'EmptyStatement',
        ExportAllDeclaration: 'ExportAllDeclaration',
        ExportDefaultDeclaration: 'ExportDefaultDeclaration',
        ExportNamedDeclaration: 'ExportNamedDeclaration',
        ExportSpecifier: 'ExportSpecifier',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForOfStatement: 'ForOfStatement',
        ForInStatement: 'ForInStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        ImportDeclaration: 'ImportDeclaration',
        ImportDefaultSpecifier: 'ImportDefaultSpecifier',
        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
        ImportSpecifier: 'ImportSpecifier',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        MetaProperty: 'MetaProperty',
        MethodDefinition: 'MethodDefinition',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        ObjectPattern: 'ObjectPattern',
        Program: 'Program',
        Property: 'Property',
        RestElement: 'RestElement',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SpreadElement: 'SpreadElement',
        Super: 'Super',
        SwitchCase: 'SwitchCase',
        SwitchStatement: 'SwitchStatement',
        TaggedTemplateExpression: 'TaggedTemplateExpression',
        TemplateElement: 'TemplateElement',
        TemplateLiteral: 'TemplateLiteral',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement',
        YieldExpression: 'YieldExpression'
    };

    PlaceHolders = {
        ArrowParameterPlaceHolder: 'ArrowParameterPlaceHolder'
    };

    // Error messages should be identical to V8.
    Messages = {
        UnexpectedToken: 'Unexpected token %0',
        UnexpectedNumber: 'Unexpected number',
        UnexpectedString: 'Unexpected string',
        UnexpectedIdentifier: 'Unexpected identifier',
        UnexpectedReserved: 'Unexpected reserved word',
        UnexpectedTemplate: 'Unexpected quasi %0',
        UnexpectedEOS: 'Unexpected end of input',
        NewlineAfterThrow: 'Illegal newline after throw',
        InvalidRegExp: 'Invalid regular expression',
        UnterminatedRegExp: 'Invalid regular expression: missing /',
        InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
        InvalidLHSInForIn: 'Invalid left-hand side in for-in',
        InvalidLHSInForLoop: 'Invalid left-hand side in for-loop',
        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
        NoCatchOrFinally: 'Missing catch or finally after try',
        UnknownLabel: 'Undefined label \'%0\'',
        Redeclaration: '%0 \'%1\' has already been declared',
        IllegalContinue: 'Illegal continue statement',
        IllegalBreak: 'Illegal break statement',
        IllegalReturn: 'Illegal return statement',
        StrictModeWith: 'Strict mode code may not include a with statement',
        StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
        StrictVarName: 'Variable name may not be eval or arguments in strict mode',
        StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
        StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
        StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
        StrictDelete: 'Delete of an unqualified identifier in strict mode.',
        StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
        StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
        StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
        StrictReservedWord: 'Use of future reserved word in strict mode',
        TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',
        ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',
        DefaultRestParameter: 'Unexpected token =',
        ObjectPatternAsRestParameter: 'Unexpected token {',
        DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',
        ConstructorSpecialMethod: 'Class constructor may not be an accessor',
        DuplicateConstructor: 'A class may only have one constructor',
        StaticPrototype: 'Classes may not have static property named prototype',
        MissingFromClause: 'Unexpected token',
        NoAsAfterImportNamespace: 'Unexpected token',
        InvalidModuleSpecifier: 'Unexpected token',
        IllegalImportDeclaration: 'Unexpected token',
        IllegalExportDeclaration: 'Unexpected token',
        DuplicateBinding: 'Duplicate binding %0'
    };

    // See also tools/generate-unicode-regex.js.
    Regex = {
        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierStart:
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/,

        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierPart:
        NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDD0-\uDDDA\uDE00-\uDE11\uDE13-\uDE37\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF01-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
    };

    // Ensure the condition is true, otherwise throw an error.
    // This is only to have a better contract semantic, i.e. another safety net
    // to catch a logic error. The condition shall be fulfilled in normal case.
    // Do NOT use this to enforce a certain condition on any user input.

    function assert(condition, message) {
        /* istanbul ignore if */
        if (!condition) {
            throw new Error('ASSERT: ' + message);
        }
    }

    function isDecimalDigit(ch) {
        return (ch >= 0x30 && ch <= 0x39);   // 0..9
    }

    function isHexDigit(ch) {
        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;
    }

    function isOctalDigit(ch) {
        return '01234567'.indexOf(ch) >= 0;
    }

    function octalToDecimal(ch) {
        // \0 is not octal escape sequence
        var octal = (ch !== '0'), code = '01234567'.indexOf(ch);

        if (index < length && isOctalDigit(source[index])) {
            octal = true;
            code = code * 8 + '01234567'.indexOf(source[index++]);

            // 3 digits are only allowed when string starts
            // with 0, 1, 2, 3
            if ('0123'.indexOf(ch) >= 0 &&
                    index < length &&
                    isOctalDigit(source[index])) {
                code = code * 8 + '01234567'.indexOf(source[index++]);
            }
        }

        return {
            code: code,
            octal: octal
        };
    }

    // ECMA-262 11.2 White Space

    function isWhiteSpace(ch) {
        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||
            (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);
    }

    // ECMA-262 11.3 Line Terminators

    function isLineTerminator(ch) {
        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);
    }

    // ECMA-262 11.6 Identifier Names and Identifiers

    function fromCodePoint(cp) {
        return (cp < 0x10000) ? String.fromCharCode(cp) :
            String.fromCharCode(0xD800 + ((cp - 0x10000) >> 10)) +
            String.fromCharCode(0xDC00 + ((cp - 0x10000) & 1023));
    }

    function isIdentifierStart(ch) {
        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
            (ch >= 0x61 && ch <= 0x7A) ||         // a..z
            (ch === 0x5C) ||                      // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch)));
    }

    function isIdentifierPart(ch) {
        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
            (ch >= 0x61 && ch <= 0x7A) ||         // a..z
            (ch >= 0x30 && ch <= 0x39) ||         // 0..9
            (ch === 0x5C) ||                      // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch)));
    }

    // ECMA-262 11.6.2.2 Future Reserved Words

    function isFutureReservedWord(id) {
        switch (id) {
        case 'enum':
        case 'export':
        case 'import':
        case 'super':
            return true;
        default:
            return false;
        }
    }

    function isStrictModeReservedWord(id) {
        switch (id) {
        case 'implements':
        case 'interface':
        case 'package':
        case 'private':
        case 'protected':
        case 'public':
        case 'static':
        case 'yield':
        case 'let':
            return true;
        default:
            return false;
        }
    }

    function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
    }

    // ECMA-262 11.6.2.1 Keywords

    function isKeyword(id) {
        switch (id.length) {
        case 2:
            return (id === 'if') || (id === 'in') || (id === 'do');
        case 3:
            return (id === 'var') || (id === 'for') || (id === 'new') ||
                (id === 'try') || (id === 'let');
        case 4:
            return (id === 'this') || (id === 'else') || (id === 'case') ||
                (id === 'void') || (id === 'with') || (id === 'enum');
        case 5:
            return (id === 'while') || (id === 'break') || (id === 'catch') ||
                (id === 'throw') || (id === 'const') || (id === 'yield') ||
                (id === 'class') || (id === 'super');
        case 6:
            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
                (id === 'switch') || (id === 'export') || (id === 'import');
        case 7:
            return (id === 'default') || (id === 'finally') || (id === 'extends');
        case 8:
            return (id === 'function') || (id === 'continue') || (id === 'debugger');
        case 10:
            return (id === 'instanceof');
        default:
            return false;
        }
    }

    // ECMA-262 11.4 Comments

    function addComment(type, value, start, end, loc) {
        var comment;

        assert(typeof start === 'number', 'Comment must have valid position');

        state.lastCommentStart = start;

        comment = {
            type: type,
            value: value
        };
        if (extra.range) {
            comment.range = [start, end];
        }
        if (extra.loc) {
            comment.loc = loc;
        }
        extra.comments.push(comment);
        if (extra.attachComment) {
            extra.leadingComments.push(comment);
            extra.trailingComments.push(comment);
        }
        if (extra.tokenize) {
            comment.type = comment.type + 'Comment';
            if (extra.delegate) {
                comment = extra.delegate(comment);
            }
            extra.tokens.push(comment);
        }
    }

    function skipSingleLineComment(offset) {
        var start, loc, ch, comment;

        start = index - offset;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart - offset
            }
        };

        while (index < length) {
            ch = source.charCodeAt(index);
            ++index;
            if (isLineTerminator(ch)) {
                hasLineTerminator = true;
                if (extra.comments) {
                    comment = source.slice(start + offset, index - 1);
                    loc.end = {
                        line: lineNumber,
                        column: index - lineStart - 1
                    };
                    addComment('Line', comment, start, index - 1, loc);
                }
                if (ch === 13 && source.charCodeAt(index) === 10) {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
                return;
            }
        }

        if (extra.comments) {
            comment = source.slice(start + offset, index);
            loc.end = {
                line: lineNumber,
                column: index - lineStart
            };
            addComment('Line', comment, start, index, loc);
        }
    }

    function skipMultiLineComment() {
        var start, loc, ch, comment;

        if (extra.comments) {
            start = index - 2;
            loc = {
                start: {
                    line: lineNumber,
                    column: index - lineStart - 2
                }
            };
        }

        while (index < length) {
            ch = source.charCodeAt(index);
            if (isLineTerminator(ch)) {
                if (ch === 0x0D && source.charCodeAt(index + 1) === 0x0A) {
                    ++index;
                }
                hasLineTerminator = true;
                ++lineNumber;
                ++index;
                lineStart = index;
            } else if (ch === 0x2A) {
                // Block comment ends with '*/'.
                if (source.charCodeAt(index + 1) === 0x2F) {
                    ++index;
                    ++index;
                    if (extra.comments) {
                        comment = source.slice(start + 2, index - 2);
                        loc.end = {
                            line: lineNumber,
                            column: index - lineStart
                        };
                        addComment('Block', comment, start, index, loc);
                    }
                    return;
                }
                ++index;
            } else {
                ++index;
            }
        }

        // Ran off the end of the file - the whole thing is a comment
        if (extra.comments) {
            loc.end = {
                line: lineNumber,
                column: index - lineStart
            };
            comment = source.slice(start + 2, index);
            addComment('Block', comment, start, index, loc);
        }
        tolerateUnexpectedToken();
    }

    function skipComment() {
        var ch, start;
        hasLineTerminator = false;

        start = (index === 0);
        while (index < length) {
            ch = source.charCodeAt(index);

            if (isWhiteSpace(ch)) {
                ++index;
            } else if (isLineTerminator(ch)) {
                hasLineTerminator = true;
                ++index;
                if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
                start = true;
            } else if (ch === 0x2F) { // U+002F is '/'
                ch = source.charCodeAt(index + 1);
                if (ch === 0x2F) {
                    ++index;
                    ++index;
                    skipSingleLineComment(2);
                    start = true;
                } else if (ch === 0x2A) {  // U+002A is '*'
                    ++index;
                    ++index;
                    skipMultiLineComment();
                } else {
                    break;
                }
            } else if (start && ch === 0x2D) { // U+002D is '-'
                // U+003E is '>'
                if ((source.charCodeAt(index + 1) === 0x2D) && (source.charCodeAt(index + 2) === 0x3E)) {
                    // '-->' is a single-line comment
                    index += 3;
                    skipSingleLineComment(3);
                } else {
                    break;
                }
            } else if (ch === 0x3C) { // U+003C is '<'
                if (source.slice(index + 1, index + 4) === '!--') {
                    ++index; // `<`
                    ++index; // `!`
                    ++index; // `-`
                    ++index; // `-`
                    skipSingleLineComment(4);
                } else {
                    break;
                }
            } else {
                break;
            }
        }
    }

    function scanHexEscape(prefix) {
        var i, len, ch, code = 0;

        len = (prefix === 'u') ? 4 : 2;
        for (i = 0; i < len; ++i) {
            if (index < length && isHexDigit(source[index])) {
                ch = source[index++];
                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
            } else {
                return '';
            }
        }
        return String.fromCharCode(code);
    }

    function scanUnicodeCodePointEscape() {
        var ch, code;

        ch = source[index];
        code = 0;

        // At least, one hex digit is required.
        if (ch === '}') {
            throwUnexpectedToken();
        }

        while (index < length) {
            ch = source[index++];
            if (!isHexDigit(ch)) {
                break;
            }
            code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
        }

        if (code > 0x10FFFF || ch !== '}') {
            throwUnexpectedToken();
        }

        return fromCodePoint(code);
    }

    function codePointAt(i) {
        var cp, first, second;

        cp = source.charCodeAt(i);
        if (cp >= 0xD800 && cp <= 0xDBFF) {
            second = source.charCodeAt(i + 1);
            if (second >= 0xDC00 && second <= 0xDFFF) {
                first = cp;
                cp = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
            }
        }

        return cp;
    }

    function getComplexIdentifier() {
        var cp, ch, id;

        cp = codePointAt(index);
        id = fromCodePoint(cp);
        index += id.length;

        // '\u' (U+005C, U+0075) denotes an escaped character.
        if (cp === 0x5C) {
            if (source.charCodeAt(index) !== 0x75) {
                throwUnexpectedToken();
            }
            ++index;
            if (source[index] === '{') {
                ++index;
                ch = scanUnicodeCodePointEscape();
            } else {
                ch = scanHexEscape('u');
                cp = ch.charCodeAt(0);
                if (!ch || ch === '\\' || !isIdentifierStart(cp)) {
                    throwUnexpectedToken();
                }
            }
            id = ch;
        }

        while (index < length) {
            cp = codePointAt(index);
            if (!isIdentifierPart(cp)) {
                break;
            }
            ch = fromCodePoint(cp);
            id += ch;
            index += ch.length;

            // '\u' (U+005C, U+0075) denotes an escaped character.
            if (cp === 0x5C) {
                id = id.substr(0, id.length - 1);
                if (source.charCodeAt(index) !== 0x75) {
                    throwUnexpectedToken();
                }
                ++index;
                if (source[index] === '{') {
                    ++index;
                    ch = scanUnicodeCodePointEscape();
                } else {
                    ch = scanHexEscape('u');
                    cp = ch.charCodeAt(0);
                    if (!ch || ch === '\\' || !isIdentifierPart(cp)) {
                        throwUnexpectedToken();
                    }
                }
                id += ch;
            }
        }

        return id;
    }

    function getIdentifier() {
        var start, ch;

        start = index++;
        while (index < length) {
            ch = source.charCodeAt(index);
            if (ch === 0x5C) {
                // Blackslash (U+005C) marks Unicode escape sequence.
                index = start;
                return getComplexIdentifier();
            } else if (ch >= 0xD800 && ch < 0xDFFF) {
                // Need to handle surrogate pairs.
                index = start;
                return getComplexIdentifier();
            }
            if (isIdentifierPart(ch)) {
                ++index;
            } else {
                break;
            }
        }

        return source.slice(start, index);
    }

    function scanIdentifier() {
        var start, id, type;

        start = index;

        // Backslash (U+005C) starts an escaped character.
        id = (source.charCodeAt(index) === 0x5C) ? getComplexIdentifier() : getIdentifier();

        // There is no keyword or literal with only one character.
        // Thus, it must be an identifier.
        if (id.length === 1) {
            type = Token.Identifier;
        } else if (isKeyword(id)) {
            type = Token.Keyword;
        } else if (id === 'null') {
            type = Token.NullLiteral;
        } else if (id === 'true' || id === 'false') {
            type = Token.BooleanLiteral;
        } else {
            type = Token.Identifier;
        }

        return {
            type: type,
            value: id,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }


    // ECMA-262 11.7 Punctuators

    function scanPunctuator() {
        var token, str;

        token = {
            type: Token.Punctuator,
            value: '',
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: index,
            end: index
        };

        // Check for most common single-character punctuators.
        str = source[index];
        switch (str) {

        case '(':
            if (extra.tokenize) {
                extra.openParenToken = extra.tokenValues.length;
            }
            ++index;
            break;

        case '{':
            if (extra.tokenize) {
                extra.openCurlyToken = extra.tokenValues.length;
            }
            state.curlyStack.push('{');
            ++index;
            break;

        case '.':
            ++index;
            if (source[index] === '.' && source[index + 1] === '.') {
                // Spread operator: ...
                index += 2;
                str = '...';
            }
            break;

        case '}':
            ++index;
            state.curlyStack.pop();
            break;
        case ')':
        case ';':
        case ',':
        case '[':
        case ']':
        case ':':
        case '?':
        case '~':
            ++index;
            break;

        default:
            // 4-character punctuator.
            str = source.substr(index, 4);
            if (str === '>>>=') {
                index += 4;
            } else {

                // 3-character punctuators.
                str = str.substr(0, 3);
                if (str === '===' || str === '!==' || str === '>>>' ||
                    str === '<<=' || str === '>>=') {
                    index += 3;
                } else {

                    // 2-character punctuators.
                    str = str.substr(0, 2);
                    if (str === '&&' || str === '||' || str === '==' || str === '!=' ||
                        str === '+=' || str === '-=' || str === '*=' || str === '/=' ||
                        str === '++' || str === '--' || str === '<<' || str === '>>' ||
                        str === '&=' || str === '|=' || str === '^=' || str === '%=' ||
                        str === '<=' || str === '>=' || str === '=>') {
                        index += 2;
                    } else {

                        // 1-character punctuators.
                        str = source[index];
                        if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {
                            ++index;
                        }
                    }
                }
            }
        }

        if (index === token.start) {
            throwUnexpectedToken();
        }

        token.end = index;
        token.value = str;
        return token;
    }

    // ECMA-262 11.8.3 Numeric Literals

    function scanHexLiteral(start) {
        var number = '';

        while (index < length) {
            if (!isHexDigit(source[index])) {
                break;
            }
            number += source[index++];
        }

        if (number.length === 0) {
            throwUnexpectedToken();
        }

        if (isIdentifierStart(source.charCodeAt(index))) {
            throwUnexpectedToken();
        }

        return {
            type: Token.NumericLiteral,
            value: parseInt('0x' + number, 16),
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    function scanBinaryLiteral(start) {
        var ch, number;

        number = '';

        while (index < length) {
            ch = source[index];
            if (ch !== '0' && ch !== '1') {
                break;
            }
            number += source[index++];
        }

        if (number.length === 0) {
            // only 0b or 0B
            throwUnexpectedToken();
        }

        if (index < length) {
            ch = source.charCodeAt(index);
            /* istanbul ignore else */
            if (isIdentifierStart(ch) || isDecimalDigit(ch)) {
                throwUnexpectedToken();
            }
        }

        return {
            type: Token.NumericLiteral,
            value: parseInt(number, 2),
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    function scanOctalLiteral(prefix, start) {
        var number, octal;

        if (isOctalDigit(prefix)) {
            octal = true;
            number = '0' + source[index++];
        } else {
            octal = false;
            ++index;
            number = '';
        }

        while (index < length) {
            if (!isOctalDigit(source[index])) {
                break;
            }
            number += source[index++];
        }

        if (!octal && number.length === 0) {
            // only 0o or 0O
            throwUnexpectedToken();
        }

        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
            throwUnexpectedToken();
        }

        return {
            type: Token.NumericLiteral,
            value: parseInt(number, 8),
            octal: octal,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    function isImplicitOctalLiteral() {
        var i, ch;

        // Implicit octal, unless there is a non-octal digit.
        // (Annex B.1.1 on Numeric Literals)
        for (i = index + 1; i < length; ++i) {
            ch = source[i];
            if (ch === '8' || ch === '9') {
                return false;
            }
            if (!isOctalDigit(ch)) {
                return true;
            }
        }

        return true;
    }

    function scanNumericLiteral() {
        var number, start, ch;

        ch = source[index];
        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),
            'Numeric literal must start with a decimal digit or a decimal point');

        start = index;
        number = '';
        if (ch !== '.') {
            number = source[index++];
            ch = source[index];

            // Hex number starts with '0x'.
            // Octal number starts with '0'.
            // Octal number in ES6 starts with '0o'.
            // Binary number in ES6 starts with '0b'.
            if (number === '0') {
                if (ch === 'x' || ch === 'X') {
                    ++index;
                    return scanHexLiteral(start);
                }
                if (ch === 'b' || ch === 'B') {
                    ++index;
                    return scanBinaryLiteral(start);
                }
                if (ch === 'o' || ch === 'O') {
                    return scanOctalLiteral(ch, start);
                }

                if (isOctalDigit(ch)) {
                    if (isImplicitOctalLiteral()) {
                        return scanOctalLiteral(ch, start);
                    }
                }
            }

            while (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }

        if (ch === '.') {
            number += source[index++];
            while (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }

        if (ch === 'e' || ch === 'E') {
            number += source[index++];

            ch = source[index];
            if (ch === '+' || ch === '-') {
                number += source[index++];
            }
            if (isDecimalDigit(source.charCodeAt(index))) {
                while (isDecimalDigit(source.charCodeAt(index))) {
                    number += source[index++];
                }
            } else {
                throwUnexpectedToken();
            }
        }

        if (isIdentifierStart(source.charCodeAt(index))) {
            throwUnexpectedToken();
        }

        return {
            type: Token.NumericLiteral,
            value: parseFloat(number),
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    // ECMA-262 11.8.4 String Literals

    function scanStringLiteral() {
        var str = '', quote, start, ch, unescaped, octToDec, octal = false;

        quote = source[index];
        assert((quote === '\'' || quote === '"'),
            'String literal must starts with a quote');

        start = index;
        ++index;

        while (index < length) {
            ch = source[index++];

            if (ch === quote) {
                quote = '';
                break;
            } else if (ch === '\\') {
                ch = source[index++];
                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
                    switch (ch) {
                    case 'u':
                    case 'x':
                        if (source[index] === '{') {
                            ++index;
                            str += scanUnicodeCodePointEscape();
                        } else {
                            unescaped = scanHexEscape(ch);
                            if (!unescaped) {
                                throw throwUnexpectedToken();
                            }
                            str += unescaped;
                        }
                        break;
                    case 'n':
                        str += '\n';
                        break;
                    case 'r':
                        str += '\r';
                        break;
                    case 't':
                        str += '\t';
                        break;
                    case 'b':
                        str += '\b';
                        break;
                    case 'f':
                        str += '\f';
                        break;
                    case 'v':
                        str += '\x0B';
                        break;
                    case '8':
                    case '9':
                        str += ch;
                        tolerateUnexpectedToken();
                        break;

                    default:
                        if (isOctalDigit(ch)) {
                            octToDec = octalToDecimal(ch);

                            octal = octToDec.octal || octal;
                            str += String.fromCharCode(octToDec.code);
                        } else {
                            str += ch;
                        }
                        break;
                    }
                } else {
                    ++lineNumber;
                    if (ch === '\r' && source[index] === '\n') {
                        ++index;
                    }
                    lineStart = index;
                }
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                break;
            } else {
                str += ch;
            }
        }

        if (quote !== '') {
            index = start;
            throwUnexpectedToken();
        }

        return {
            type: Token.StringLiteral,
            value: str,
            octal: octal,
            lineNumber: startLineNumber,
            lineStart: startLineStart,
            start: start,
            end: index
        };
    }

    // ECMA-262 11.8.6 Template Literal Lexical Components

    function scanTemplate() {
        var cooked = '', ch, start, rawOffset, terminated, head, tail, restore, unescaped;

        terminated = false;
        tail = false;
        start = index;
        head = (source[index] === '`');
        rawOffset = 2;

        ++index;

        while (index < length) {
            ch = source[index++];
            if (ch === '`') {
                rawOffset = 1;
                tail = true;
                terminated = true;
                break;
            } else if (ch === '$') {
                if (source[index] === '{') {
                    state.curlyStack.push('${');
                    ++index;
                    terminated = true;
                    break;
                }
                cooked += ch;
            } else if (ch === '\\') {
                ch = source[index++];
                if (!isLineTerminator(ch.charCodeAt(0))) {
                    switch (ch) {
                    case 'n':
                        cooked += '\n';
                        break;
                    case 'r':
                        cooked += '\r';
                        break;
                    case 't':
                        cooked += '\t';
                        break;
                    case 'u':
                    case 'x':
                        if (source[index] === '{') {
                            ++index;
                            cooked += scanUnicodeCodePointEscape();
                        } else {
                            restore = index;
                            unescaped = scanHexEscape(ch);
                            if (unescaped) {
                                cooked += unescaped;
                            } else {
                                index = restore;
                                cooked += ch;
                            }
                        }
                        break;
                    case 'b':
                        cooked += '\b';
                        break;
                    case 'f':
                        cooked += '\f';
                        break;
                    case 'v':
                        cooked += '\v';
                        break;

                    default:
                        if (ch === '0') {
                            if (isDecimalDigit(source.charCodeAt(index))) {
                                // Illegal: \01 \02 and so on
                                throwError(Messages.TemplateOctalLiteral);
                            }
                            cooked += '\0';
                        } else if (isOctalDigit(ch)) {
                            // Illegal: \1 \2
                            throwError(Messages.TemplateOctalLiteral);
                        } else {
                            cooked += ch;
                        }
                        break;
                    }
                } else {
                    ++lineNumber;
                    if (ch === '\r' && source[index] === '\n') {
                        ++index;
                    }
                    lineStart = index;
                }
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                ++lineNumber;
                if (ch === '\r' && source[index] === '\n') {
                    ++index;
                }
                lineStart = index;
                cooked += '\n';
            } else {
                cooked += ch;
            }
        }

        if (!terminated) {
            throwUnexpectedToken();
        }

        if (!head) {
            state.curlyStack.pop();
        }

        return {
            type: Token.Template,
            value: {
                cooked: cooked,
                raw: source.slice(start + 1, index - rawOffset)
            },
            head: head,
            tail: tail,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    // ECMA-262 11.8.5 Regular Expression Literals

    function testRegExp(pattern, flags) {
        // The BMP character to use as a replacement for astral symbols when
        // translating an ES6 "u"-flagged pattern to an ES5-compatible
        // approximation.
        // Note: replacing with '\uFFFF' enables false positives in unlikely
        // scenarios. For example, `[\u{1044f}-\u{10440}]` is an invalid
        // pattern that would not be detected by this substitution.
        var astralSubstitute = '\uFFFF',
            tmp = pattern;

        if (flags.indexOf('u') >= 0) {
            tmp = tmp
                // Replace every Unicode escape sequence with the equivalent
                // BMP character or a constant ASCII code point in the case of
                // astral symbols. (See the above note on `astralSubstitute`
                // for more information.)
                .replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function ($0, $1, $2) {
                    var codePoint = parseInt($1 || $2, 16);
                    if (codePoint > 0x10FFFF) {
                        throwUnexpectedToken(null, Messages.InvalidRegExp);
                    }
                    if (codePoint <= 0xFFFF) {
                        return String.fromCharCode(codePoint);
                    }
                    return astralSubstitute;
                })
                // Replace each paired surrogate with a single ASCII symbol to
                // avoid throwing on regular expressions that are only valid in
                // combination with the "u" flag.
                .replace(
                    /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
                    astralSubstitute
                );
        }

        // First, detect invalid regular expressions.
        try {
            RegExp(tmp);
        } catch (e) {
            throwUnexpectedToken(null, Messages.InvalidRegExp);
        }

        // Return a regular expression object for this pattern-flag pair, or
        // `null` in case the current environment doesn't support the flags it
        // uses.
        try {
            return new RegExp(pattern, flags);
        } catch (exception) {
            /* istanbul ignore next */
            return null;
        }
    }

    function scanRegExpBody() {
        var ch, str, classMarker, terminated, body;

        ch = source[index];
        assert(ch === '/', 'Regular expression literal must start with a slash');
        str = source[index++];

        classMarker = false;
        terminated = false;
        while (index < length) {
            ch = source[index++];
            str += ch;
            if (ch === '\\') {
                ch = source[index++];
                // ECMA-262 7.8.5
                if (isLineTerminator(ch.charCodeAt(0))) {
                    throwUnexpectedToken(null, Messages.UnterminatedRegExp);
                }
                str += ch;
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                throwUnexpectedToken(null, Messages.UnterminatedRegExp);
            } else if (classMarker) {
                if (ch === ']') {
                    classMarker = false;
                }
            } else {
                if (ch === '/') {
                    terminated = true;
                    break;
                } else if (ch === '[') {
                    classMarker = true;
                }
            }
        }

        if (!terminated) {
            throwUnexpectedToken(null, Messages.UnterminatedRegExp);
        }

        // Exclude leading and trailing slash.
        body = str.substr(1, str.length - 2);
        return {
            value: body,
            literal: str
        };
    }

    function scanRegExpFlags() {
        var ch, str, flags, restore;

        str = '';
        flags = '';
        while (index < length) {
            ch = source[index];
            if (!isIdentifierPart(ch.charCodeAt(0))) {
                break;
            }

            ++index;
            if (ch === '\\' && index < length) {
                ch = source[index];
                if (ch === 'u') {
                    ++index;
                    restore = index;
                    ch = scanHexEscape('u');
                    if (ch) {
                        flags += ch;
                        for (str += '\\u'; restore < index; ++restore) {
                            str += source[restore];
                        }
                    } else {
                        index = restore;
                        flags += 'u';
                        str += '\\u';
                    }
                    tolerateUnexpectedToken();
                } else {
                    str += '\\';
                    tolerateUnexpectedToken();
                }
            } else {
                flags += ch;
                str += ch;
            }
        }

        return {
            value: flags,
            literal: str
        };
    }

    function scanRegExp() {
        var start, body, flags, value;
        scanning = true;

        lookahead = null;
        skipComment();
        start = index;

        body = scanRegExpBody();
        flags = scanRegExpFlags();
        value = testRegExp(body.value, flags.value);
        scanning = false;
        if (extra.tokenize) {
            return {
                type: Token.RegularExpression,
                value: value,
                regex: {
                    pattern: body.value,
                    flags: flags.value
                },
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }

        return {
            literal: body.literal + flags.literal,
            value: value,
            regex: {
                pattern: body.value,
                flags: flags.value
            },
            start: start,
            end: index
        };
    }

    function collectRegex() {
        var pos, loc, regex, token;

        skipComment();

        pos = index;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            }
        };

        regex = scanRegExp();

        loc.end = {
            line: lineNumber,
            column: index - lineStart
        };

        /* istanbul ignore next */
        if (!extra.tokenize) {
            // Pop the previous token, which is likely '/' or '/='
            if (extra.tokens.length > 0) {
                token = extra.tokens[extra.tokens.length - 1];
                if (token.range[0] === pos && token.type === 'Punctuator') {
                    if (token.value === '/' || token.value === '/=') {
                        extra.tokens.pop();
                    }
                }
            }

            extra.tokens.push({
                type: 'RegularExpression',
                value: regex.literal,
                regex: regex.regex,
                range: [pos, index],
                loc: loc
            });
        }

        return regex;
    }

    function isIdentifierName(token) {
        return token.type === Token.Identifier ||
            token.type === Token.Keyword ||
            token.type === Token.BooleanLiteral ||
            token.type === Token.NullLiteral;
    }

    // Using the following algorithm:
    // https://github.com/mozilla/sweet.js/wiki/design

    function advanceSlash() {
        var regex, previous, check;

        function testKeyword(value) {
            return value && (value.length > 1) && (value[0] >= 'a') && (value[0] <= 'z');
        }

        previous = extra.tokenValues[extra.tokenValues.length - 1];
        regex = (previous !== null);

        switch (previous) {
        case 'this':
        case ']':
            regex = false;
            break;

        case ')':
            check = extra.tokenValues[extra.openParenToken - 1];
            regex = (check === 'if' || check === 'while' || check === 'for' || check === 'with');
            break;

        case '}':
            // Dividing a function by anything makes little sense,
            // but we have to check for that.
            regex = false;
            if (testKeyword(extra.tokenValues[extra.openCurlyToken - 3])) {
                // Anonymous function, e.g. function(){} /42
                check = extra.tokenValues[extra.openCurlyToken - 4];
                regex = check ? (FnExprTokens.indexOf(check) < 0) : false;
            } else if (testKeyword(extra.tokenValues[extra.openCurlyToken - 4])) {
                // Named function, e.g. function f(){} /42/
                check = extra.tokenValues[extra.openCurlyToken - 5];
                regex = check ? (FnExprTokens.indexOf(check) < 0) : true;
            }
        }

        return regex ? collectRegex() : scanPunctuator();
    }

    function advance() {
        var cp, token;

        if (index >= length) {
            return {
                type: Token.EOF,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: index,
                end: index
            };
        }

        cp = source.charCodeAt(index);

        if (isIdentifierStart(cp)) {
            token = scanIdentifier();
            if (strict && isStrictModeReservedWord(token.value)) {
                token.type = Token.Keyword;
            }
            return token;
        }

        // Very common: ( and ) and ;
        if (cp === 0x28 || cp === 0x29 || cp === 0x3B) {
            return scanPunctuator();
        }

        // String literal starts with single quote (U+0027) or double quote (U+0022).
        if (cp === 0x27 || cp === 0x22) {
            return scanStringLiteral();
        }

        // Dot (.) U+002E can also start a floating-point number, hence the need
        // to check the next character.
        if (cp === 0x2E) {
            if (isDecimalDigit(source.charCodeAt(index + 1))) {
                return scanNumericLiteral();
            }
            return scanPunctuator();
        }

        if (isDecimalDigit(cp)) {
            return scanNumericLiteral();
        }

        // Slash (/) U+002F can also start a regex.
        if (extra.tokenize && cp === 0x2F) {
            return advanceSlash();
        }

        // Template literals start with ` (U+0060) for template head
        // or } (U+007D) for template middle or template tail.
        if (cp === 0x60 || (cp === 0x7D && state.curlyStack[state.curlyStack.length - 1] === '${')) {
            return scanTemplate();
        }

        // Possible identifier start in a surrogate pair.
        if (cp >= 0xD800 && cp < 0xDFFF) {
            cp = codePointAt(index);
            if (isIdentifierStart(cp)) {
                return scanIdentifier();
            }
        }

        return scanPunctuator();
    }

    function collectToken() {
        var loc, token, value, entry;

        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            }
        };

        token = advance();
        loc.end = {
            line: lineNumber,
            column: index - lineStart
        };

        if (token.type !== Token.EOF) {
            value = source.slice(token.start, token.end);
            entry = {
                type: TokenName[token.type],
                value: value,
                range: [token.start, token.end],
                loc: loc
            };
            if (token.regex) {
                entry.regex = {
                    pattern: token.regex.pattern,
                    flags: token.regex.flags
                };
            }
            if (extra.tokenValues) {
                extra.tokenValues.push((entry.type === 'Punctuator' || entry.type === 'Keyword') ? entry.value : null);
            }
            if (extra.tokenize) {
                if (!extra.range) {
                    delete entry.range;
                }
                if (!extra.loc) {
                    delete entry.loc;
                }
                if (extra.delegate) {
                    entry = extra.delegate(entry);
                }
            }
            extra.tokens.push(entry);
        }

        return token;
    }

    function lex() {
        var token;
        scanning = true;

        lastIndex = index;
        lastLineNumber = lineNumber;
        lastLineStart = lineStart;

        skipComment();

        token = lookahead;

        startIndex = index;
        startLineNumber = lineNumber;
        startLineStart = lineStart;

        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();
        scanning = false;
        return token;
    }

    function peek() {
        scanning = true;

        skipComment();

        lastIndex = index;
        lastLineNumber = lineNumber;
        lastLineStart = lineStart;

        startIndex = index;
        startLineNumber = lineNumber;
        startLineStart = lineStart;

        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();
        scanning = false;
    }

    function Position() {
        this.line = startLineNumber;
        this.column = startIndex - startLineStart;
    }

    function SourceLocation() {
        this.start = new Position();
        this.end = null;
    }

    function WrappingSourceLocation(startToken) {
        this.start = {
            line: startToken.lineNumber,
            column: startToken.start - startToken.lineStart
        };
        this.end = null;
    }

    function Node() {
        if (extra.range) {
            this.range = [startIndex, 0];
        }
        if (extra.loc) {
            this.loc = new SourceLocation();
        }
    }

    function WrappingNode(startToken) {
        if (extra.range) {
            this.range = [startToken.start, 0];
        }
        if (extra.loc) {
            this.loc = new WrappingSourceLocation(startToken);
        }
    }

    WrappingNode.prototype = Node.prototype = {

        processComment: function () {
            var lastChild,
                innerComments,
                leadingComments,
                trailingComments,
                bottomRight = extra.bottomRightStack,
                i,
                comment,
                last = bottomRight[bottomRight.length - 1];

            if (this.type === Syntax.Program) {
                if (this.body.length > 0) {
                    return;
                }
            }
            /**
             * patch innnerComments for properties empty block
             * `function a() {/** comments **\/}`
             */

            if (this.type === Syntax.BlockStatement && this.body.length === 0) {
                innerComments = [];
                for (i = extra.leadingComments.length - 1; i >= 0; --i) {
                    comment = extra.leadingComments[i];
                    if (this.range[1] >= comment.range[1]) {
                        innerComments.unshift(comment);
                        extra.leadingComments.splice(i, 1);
                        extra.trailingComments.splice(i, 1);
                    }
                }
                if (innerComments.length) {
                    this.innerComments = innerComments;
                    //bottomRight.push(this);
                    return;
                }
            }

            if (extra.trailingComments.length > 0) {
                trailingComments = [];
                for (i = extra.trailingComments.length - 1; i >= 0; --i) {
                    comment = extra.trailingComments[i];
                    if (comment.range[0] >= this.range[1]) {
                        trailingComments.unshift(comment);
                        extra.trailingComments.splice(i, 1);
                    }
                }
                extra.trailingComments = [];
            } else {
                if (last && last.trailingComments && last.trailingComments[0].range[0] >= this.range[1]) {
                    trailingComments = last.trailingComments;
                    delete last.trailingComments;
                }
            }

            // Eating the stack.
            while (last && last.range[0] >= this.range[0]) {
                lastChild = bottomRight.pop();
                last = bottomRight[bottomRight.length - 1];
            }

            if (lastChild) {
                if (lastChild.leadingComments) {
                    leadingComments = [];
                    for (i = lastChild.leadingComments.length - 1; i >= 0; --i) {
                        comment = lastChild.leadingComments[i];
                        if (comment.range[1] <= this.range[0]) {
                            leadingComments.unshift(comment);
                            lastChild.leadingComments.splice(i, 1);
                        }
                    }

                    if (!lastChild.leadingComments.length) {
                        lastChild.leadingComments = undefined;
                    }
                }
            } else if (extra.leadingComments.length > 0) {
                leadingComments = [];
                for (i = extra.leadingComments.length - 1; i >= 0; --i) {
                    comment = extra.leadingComments[i];
                    if (comment.range[1] <= this.range[0]) {
                        leadingComments.unshift(comment);
                        extra.leadingComments.splice(i, 1);
                    }
                }
            }


            if (leadingComments && leadingComments.length > 0) {
                this.leadingComments = leadingComments;
            }
            if (trailingComments && trailingComments.length > 0) {
                this.trailingComments = trailingComments;
            }

            bottomRight.push(this);
        },

        finish: function () {
            if (extra.range) {
                this.range[1] = lastIndex;
            }
            if (extra.loc) {
                this.loc.end = {
                    line: lastLineNumber,
                    column: lastIndex - lastLineStart
                };
                if (extra.source) {
                    this.loc.source = extra.source;
                }
            }

            if (extra.attachComment) {
                this.processComment();
            }
        },

        finishArrayExpression: function (elements) {
            this.type = Syntax.ArrayExpression;
            this.elements = elements;
            this.finish();
            return this;
        },

        finishArrayPattern: function (elements) {
            this.type = Syntax.ArrayPattern;
            this.elements = elements;
            this.finish();
            return this;
        },

        finishArrowFunctionExpression: function (params, defaults, body, expression) {
            this.type = Syntax.ArrowFunctionExpression;
            this.id = null;
            this.params = params;
            this.defaults = defaults;
            this.body = body;
            this.generator = false;
            this.expression = expression;
            this.finish();
            return this;
        },

        finishAssignmentExpression: function (operator, left, right) {
            this.type = Syntax.AssignmentExpression;
            this.operator = operator;
            this.left = left;
            this.right = right;
            this.finish();
            return this;
        },

        finishAssignmentPattern: function (left, right) {
            this.type = Syntax.AssignmentPattern;
            this.left = left;
            this.right = right;
            this.finish();
            return this;
        },

        finishBinaryExpression: function (operator, left, right) {
            this.type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression : Syntax.BinaryExpression;
            this.operator = operator;
            this.left = left;
            this.right = right;
            this.finish();
            return this;
        },

        finishBlockStatement: function (body) {
            this.type = Syntax.BlockStatement;
            this.body = body;
            this.finish();
            return this;
        },

        finishBreakStatement: function (label) {
            this.type = Syntax.BreakStatement;
            this.label = label;
            this.finish();
            return this;
        },

        finishCallExpression: function (callee, args) {
            this.type = Syntax.CallExpression;
            this.callee = callee;
            this.arguments = args;
            this.finish();
            return this;
        },

        finishCatchClause: function (param, body) {
            this.type = Syntax.CatchClause;
            this.param = param;
            this.body = body;
            this.finish();
            return this;
        },

        finishClassBody: function (body) {
            this.type = Syntax.ClassBody;
            this.body = body;
            this.finish();
            return this;
        },

        finishClassDeclaration: function (id, superClass, body) {
            this.type = Syntax.ClassDeclaration;
            this.id = id;
            this.superClass = superClass;
            this.body = body;
            this.finish();
            return this;
        },

        finishClassExpression: function (id, superClass, body) {
            this.type = Syntax.ClassExpression;
            this.id = id;
            this.superClass = superClass;
            this.body = body;
            this.finish();
            return this;
        },

        finishConditionalExpression: function (test, consequent, alternate) {
            this.type = Syntax.ConditionalExpression;
            this.test = test;
            this.consequent = consequent;
            this.alternate = alternate;
            this.finish();
            return this;
        },

        finishContinueStatement: function (label) {
            this.type = Syntax.ContinueStatement;
            this.label = label;
            this.finish();
            return this;
        },

        finishDebuggerStatement: function () {
            this.type = Syntax.DebuggerStatement;
            this.finish();
            return this;
        },

        finishDoWhileStatement: function (body, test) {
            this.type = Syntax.DoWhileStatement;
            this.body = body;
            this.test = test;
            this.finish();
            return this;
        },

        finishEmptyStatement: function () {
            this.type = Syntax.EmptyStatement;
            this.finish();
            return this;
        },

        finishExpressionStatement: function (expression) {
            this.type = Syntax.ExpressionStatement;
            this.expression = expression;
            this.finish();
            return this;
        },

        finishForStatement: function (init, test, update, body) {
            this.type = Syntax.ForStatement;
            this.init = init;
            this.test = test;
            this.update = update;
            this.body = body;
            this.finish();
            return this;
        },

        finishForOfStatement: function (left, right, body) {
            this.type = Syntax.ForOfStatement;
            this.left = left;
            this.right = right;
            this.body = body;
            this.finish();
            return this;
        },

        finishForInStatement: function (left, right, body) {
            this.type = Syntax.ForInStatement;
            this.left = left;
            this.right = right;
            this.body = body;
            this.each = false;
            this.finish();
            return this;
        },

        finishFunctionDeclaration: function (id, params, defaults, body, generator) {
            this.type = Syntax.FunctionDeclaration;
            this.id = id;
            this.params = params;
            this.defaults = defaults;
            this.body = body;
            this.generator = generator;
            this.expression = false;
            this.finish();
            return this;
        },

        finishFunctionExpression: function (id, params, defaults, body, generator) {
            this.type = Syntax.FunctionExpression;
            this.id = id;
            this.params = params;
            this.defaults = defaults;
            this.body = body;
            this.generator = generator;
            this.expression = false;
            this.finish();
            return this;
        },

        finishIdentifier: function (name) {
            this.type = Syntax.Identifier;
            this.name = name;
            this.finish();
            return this;
        },

        finishIfStatement: function (test, consequent, alternate) {
            this.type = Syntax.IfStatement;
            this.test = test;
            this.consequent = consequent;
            this.alternate = alternate;
            this.finish();
            return this;
        },

        finishLabeledStatement: function (label, body) {
            this.type = Syntax.LabeledStatement;
            this.label = label;
            this.body = body;
            this.finish();
            return this;
        },

        finishLiteral: function (token) {
            this.type = Syntax.Literal;
            this.value = token.value;
            this.raw = source.slice(token.start, token.end);
            if (token.regex) {
                this.regex = token.regex;
            }
            this.finish();
            return this;
        },

        finishMemberExpression: function (accessor, object, property) {
            this.type = Syntax.MemberExpression;
            this.computed = accessor === '[';
            this.object = object;
            this.property = property;
            this.finish();
            return this;
        },

        finishMetaProperty: function (meta, property) {
            this.type = Syntax.MetaProperty;
            this.meta = meta;
            this.property = property;
            this.finish();
            return this;
        },

        finishNewExpression: function (callee, args) {
            this.type = Syntax.NewExpression;
            this.callee = callee;
            this.arguments = args;
            this.finish();
            return this;
        },

        finishObjectExpression: function (properties) {
            this.type = Syntax.ObjectExpression;
            this.properties = properties;
            this.finish();
            return this;
        },

        finishObjectPattern: function (properties) {
            this.type = Syntax.ObjectPattern;
            this.properties = properties;
            this.finish();
            return this;
        },

        finishPostfixExpression: function (operator, argument) {
            this.type = Syntax.UpdateExpression;
            this.operator = operator;
            this.argument = argument;
            this.prefix = false;
            this.finish();
            return this;
        },

        finishProgram: function (body, sourceType) {
            this.type = Syntax.Program;
            this.body = body;
            this.sourceType = sourceType;
            this.finish();
            return this;
        },

        finishProperty: function (kind, key, computed, value, method, shorthand) {
            this.type = Syntax.Property;
            this.key = key;
            this.computed = computed;
            this.value = value;
            this.kind = kind;
            this.method = method;
            this.shorthand = shorthand;
            this.finish();
            return this;
        },

        finishRestElement: function (argument) {
            this.type = Syntax.RestElement;
            this.argument = argument;
            this.finish();
            return this;
        },

        finishReturnStatement: function (argument) {
            this.type = Syntax.ReturnStatement;
            this.argument = argument;
            this.finish();
            return this;
        },

        finishSequenceExpression: function (expressions) {
            this.type = Syntax.SequenceExpression;
            this.expressions = expressions;
            this.finish();
            return this;
        },

        finishSpreadElement: function (argument) {
            this.type = Syntax.SpreadElement;
            this.argument = argument;
            this.finish();
            return this;
        },

        finishSwitchCase: function (test, consequent) {
            this.type = Syntax.SwitchCase;
            this.test = test;
            this.consequent = consequent;
            this.finish();
            return this;
        },

        finishSuper: function () {
            this.type = Syntax.Super;
            this.finish();
            return this;
        },

        finishSwitchStatement: function (discriminant, cases) {
            this.type = Syntax.SwitchStatement;
            this.discriminant = discriminant;
            this.cases = cases;
            this.finish();
            return this;
        },

        finishTaggedTemplateExpression: function (tag, quasi) {
            this.type = Syntax.TaggedTemplateExpression;
            this.tag = tag;
            this.quasi = quasi;
            this.finish();
            return this;
        },

        finishTemplateElement: function (value, tail) {
            this.type = Syntax.TemplateElement;
            this.value = value;
            this.tail = tail;
            this.finish();
            return this;
        },

        finishTemplateLiteral: function (quasis, expressions) {
            this.type = Syntax.TemplateLiteral;
            this.quasis = quasis;
            this.expressions = expressions;
            this.finish();
            return this;
        },

        finishThisExpression: function () {
            this.type = Syntax.ThisExpression;
            this.finish();
            return this;
        },

        finishThrowStatement: function (argument) {
            this.type = Syntax.ThrowStatement;
            this.argument = argument;
            this.finish();
            return this;
        },

        finishTryStatement: function (block, handler, finalizer) {
            this.type = Syntax.TryStatement;
            this.block = block;
            this.guardedHandlers = [];
            this.handlers = handler ? [handler] : [];
            this.handler = handler;
            this.finalizer = finalizer;
            this.finish();
            return this;
        },

        finishUnaryExpression: function (operator, argument) {
            this.type = (operator === '++' || operator === '--') ? Syntax.UpdateExpression : Syntax.UnaryExpression;
            this.operator = operator;
            this.argument = argument;
            this.prefix = true;
            this.finish();
            return this;
        },

        finishVariableDeclaration: function (declarations) {
            this.type = Syntax.VariableDeclaration;
            this.declarations = declarations;
            this.kind = 'var';
            this.finish();
            return this;
        },

        finishLexicalDeclaration: function (declarations, kind) {
            this.type = Syntax.VariableDeclaration;
            this.declarations = declarations;
            this.kind = kind;
            this.finish();
            return this;
        },

        finishVariableDeclarator: function (id, init) {
            this.type = Syntax.VariableDeclarator;
            this.id = id;
            this.init = init;
            this.finish();
            return this;
        },

        finishWhileStatement: function (test, body) {
            this.type = Syntax.WhileStatement;
            this.test = test;
            this.body = body;
            this.finish();
            return this;
        },

        finishWithStatement: function (object, body) {
            this.type = Syntax.WithStatement;
            this.object = object;
            this.body = body;
            this.finish();
            return this;
        },

        finishExportSpecifier: function (local, exported) {
            this.type = Syntax.ExportSpecifier;
            this.exported = exported || local;
            this.local = local;
            this.finish();
            return this;
        },

        finishImportDefaultSpecifier: function (local) {
            this.type = Syntax.ImportDefaultSpecifier;
            this.local = local;
            this.finish();
            return this;
        },

        finishImportNamespaceSpecifier: function (local) {
            this.type = Syntax.ImportNamespaceSpecifier;
            this.local = local;
            this.finish();
            return this;
        },

        finishExportNamedDeclaration: function (declaration, specifiers, src) {
            this.type = Syntax.ExportNamedDeclaration;
            this.declaration = declaration;
            this.specifiers = specifiers;
            this.source = src;
            this.finish();
            return this;
        },

        finishExportDefaultDeclaration: function (declaration) {
            this.type = Syntax.ExportDefaultDeclaration;
            this.declaration = declaration;
            this.finish();
            return this;
        },

        finishExportAllDeclaration: function (src) {
            this.type = Syntax.ExportAllDeclaration;
            this.source = src;
            this.finish();
            return this;
        },

        finishImportSpecifier: function (local, imported) {
            this.type = Syntax.ImportSpecifier;
            this.local = local || imported;
            this.imported = imported;
            this.finish();
            return this;
        },

        finishImportDeclaration: function (specifiers, src) {
            this.type = Syntax.ImportDeclaration;
            this.specifiers = specifiers;
            this.source = src;
            this.finish();
            return this;
        },

        finishYieldExpression: function (argument, delegate) {
            this.type = Syntax.YieldExpression;
            this.argument = argument;
            this.delegate = delegate;
            this.finish();
            return this;
        }
    };


    function recordError(error) {
        var e, existing;

        for (e = 0; e < extra.errors.length; e++) {
            existing = extra.errors[e];
            // Prevent duplicated error.
            /* istanbul ignore next */
            if (existing.index === error.index && existing.message === error.message) {
                return;
            }
        }

        extra.errors.push(error);
    }

    function constructError(msg, column) {
        var error = new Error(msg);
        try {
            throw error;
        } catch (base) {
            /* istanbul ignore else */
            if (Object.create && Object.defineProperty) {
                error = Object.create(base);
                Object.defineProperty(error, 'column', { value: column });
            }
        } finally {
            return error;
        }
    }

    function createError(line, pos, description) {
        var msg, column, error;

        msg = 'Line ' + line + ': ' + description;
        column = pos - (scanning ? lineStart : lastLineStart) + 1;
        error = constructError(msg, column);
        error.lineNumber = line;
        error.description = description;
        error.index = pos;
        return error;
    }

    // Throw an exception

    function throwError(messageFormat) {
        var args, msg;

        args = Array.prototype.slice.call(arguments, 1);
        msg = messageFormat.replace(/%(\d)/g,
            function (whole, idx) {
                assert(idx < args.length, 'Message reference must be in range');
                return args[idx];
            }
        );

        throw createError(lastLineNumber, lastIndex, msg);
    }

    function tolerateError(messageFormat) {
        var args, msg, error;

        args = Array.prototype.slice.call(arguments, 1);
        /* istanbul ignore next */
        msg = messageFormat.replace(/%(\d)/g,
            function (whole, idx) {
                assert(idx < args.length, 'Message reference must be in range');
                return args[idx];
            }
        );

        error = createError(lineNumber, lastIndex, msg);
        if (extra.errors) {
            recordError(error);
        } else {
            throw error;
        }
    }

    // Throw an exception because of the token.

    function unexpectedTokenError(token, message) {
        var value, msg = message || Messages.UnexpectedToken;

        if (token) {
            if (!message) {
                msg = (token.type === Token.EOF) ? Messages.UnexpectedEOS :
                    (token.type === Token.Identifier) ? Messages.UnexpectedIdentifier :
                    (token.type === Token.NumericLiteral) ? Messages.UnexpectedNumber :
                    (token.type === Token.StringLiteral) ? Messages.UnexpectedString :
                    (token.type === Token.Template) ? Messages.UnexpectedTemplate :
                    Messages.UnexpectedToken;

                if (token.type === Token.Keyword) {
                    if (isFutureReservedWord(token.value)) {
                        msg = Messages.UnexpectedReserved;
                    } else if (strict && isStrictModeReservedWord(token.value)) {
                        msg = Messages.StrictReservedWord;
                    }
                }
            }

            value = (token.type === Token.Template) ? token.value.raw : token.value;
        } else {
            value = 'ILLEGAL';
        }

        msg = msg.replace('%0', value);

        return (token && typeof token.lineNumber === 'number') ?
            createError(token.lineNumber, token.start, msg) :
            createError(scanning ? lineNumber : lastLineNumber, scanning ? index : lastIndex, msg);
    }

    function throwUnexpectedToken(token, message) {
        throw unexpectedTokenError(token, message);
    }

    function tolerateUnexpectedToken(token, message) {
        var error = unexpectedTokenError(token, message);
        if (extra.errors) {
            recordError(error);
        } else {
            throw error;
        }
    }

    // Expect the next token to match the specified punctuator.
    // If not, an exception will be thrown.

    function expect(value) {
        var token = lex();
        if (token.type !== Token.Punctuator || token.value !== value) {
            throwUnexpectedToken(token);
        }
    }

    /**
     * @name expectCommaSeparator
     * @description Quietly expect a comma when in tolerant mode, otherwise delegates
     * to <code>expect(value)</code>
     * @since 2.0
     */
    function expectCommaSeparator() {
        var token;

        if (extra.errors) {
            token = lookahead;
            if (token.type === Token.Punctuator && token.value === ',') {
                lex();
            } else if (token.type === Token.Punctuator && token.value === ';') {
                lex();
                tolerateUnexpectedToken(token);
            } else {
                tolerateUnexpectedToken(token, Messages.UnexpectedToken);
            }
        } else {
            expect(',');
        }
    }

    // Expect the next token to match the specified keyword.
    // If not, an exception will be thrown.

    function expectKeyword(keyword) {
        var token = lex();
        if (token.type !== Token.Keyword || token.value !== keyword) {
            throwUnexpectedToken(token);
        }
    }

    // Return true if the next token matches the specified punctuator.

    function match(value) {
        return lookahead.type === Token.Punctuator && lookahead.value === value;
    }

    // Return true if the next token matches the specified keyword

    function matchKeyword(keyword) {
        return lookahead.type === Token.Keyword && lookahead.value === keyword;
    }

    // Return true if the next token matches the specified contextual keyword
    // (where an identifier is sometimes a keyword depending on the context)

    function matchContextualKeyword(keyword) {
        return lookahead.type === Token.Identifier && lookahead.value === keyword;
    }

    // Return true if the next token is an assignment operator

    function matchAssign() {
        var op;

        if (lookahead.type !== Token.Punctuator) {
            return false;
        }
        op = lookahead.value;
        return op === '=' ||
            op === '*=' ||
            op === '/=' ||
            op === '%=' ||
            op === '+=' ||
            op === '-=' ||
            op === '<<=' ||
            op === '>>=' ||
            op === '>>>=' ||
            op === '&=' ||
            op === '^=' ||
            op === '|=';
    }

    function consumeSemicolon() {
        // Catch the very common case first: immediately a semicolon (U+003B).
        if (source.charCodeAt(startIndex) === 0x3B || match(';')) {
            lex();
            return;
        }

        if (hasLineTerminator) {
            return;
        }

        // FIXME(ikarienator): this is seemingly an issue in the previous location info convention.
        lastIndex = startIndex;
        lastLineNumber = startLineNumber;
        lastLineStart = startLineStart;

        if (lookahead.type !== Token.EOF && !match('}')) {
            throwUnexpectedToken(lookahead);
        }
    }

    // Cover grammar support.
    //
    // When an assignment expression position starts with an left parenthesis, the determination of the type
    // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)
    // or the first comma. This situation also defers the determination of all the expressions nested in the pair.
    //
    // There are three productions that can be parsed in a parentheses pair that needs to be determined
    // after the outermost pair is closed. They are:
    //
    //   1. AssignmentExpression
    //   2. BindingElements
    //   3. AssignmentTargets
    //
    // In order to avoid exponential backtracking, we use two flags to denote if the production can be
    // binding element or assignment target.
    //
    // The three productions have the relationship:
    //
    //   BindingElements ⊆ AssignmentTargets ⊆ AssignmentExpression
    //
    // with a single exception that CoverInitializedName when used directly in an Expression, generates
    // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the
    // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.
    //
    // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not
    // effect the current flags. This means the production the parser parses is only used as an expression. Therefore
    // the CoverInitializedName check is conducted.
    //
    // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates
    // the flags outside of the parser. This means the production the parser parses is used as a part of a potential
    // pattern. The CoverInitializedName check is deferred.
    function isolateCoverGrammar(parser) {
        var oldIsBindingElement = isBindingElement,
            oldIsAssignmentTarget = isAssignmentTarget,
            oldFirstCoverInitializedNameError = firstCoverInitializedNameError,
            result;
        isBindingElement = true;
        isAssignmentTarget = true;
        firstCoverInitializedNameError = null;
        result = parser();
        if (firstCoverInitializedNameError !== null) {
            throwUnexpectedToken(firstCoverInitializedNameError);
        }
        isBindingElement = oldIsBindingElement;
        isAssignmentTarget = oldIsAssignmentTarget;
        firstCoverInitializedNameError = oldFirstCoverInitializedNameError;
        return result;
    }

    function inheritCoverGrammar(parser) {
        var oldIsBindingElement = isBindingElement,
            oldIsAssignmentTarget = isAssignmentTarget,
            oldFirstCoverInitializedNameError = firstCoverInitializedNameError,
            result;
        isBindingElement = true;
        isAssignmentTarget = true;
        firstCoverInitializedNameError = null;
        result = parser();
        isBindingElement = isBindingElement && oldIsBindingElement;
        isAssignmentTarget = isAssignmentTarget && oldIsAssignmentTarget;
        firstCoverInitializedNameError = oldFirstCoverInitializedNameError || firstCoverInitializedNameError;
        return result;
    }

    // ECMA-262 13.3.3 Destructuring Binding Patterns

    function parseArrayPattern(params, kind) {
        var node = new Node(), elements = [], rest, restNode;
        expect('[');

        while (!match(']')) {
            if (match(',')) {
                lex();
                elements.push(null);
            } else {
                if (match('...')) {
                    restNode = new Node();
                    lex();
                    params.push(lookahead);
                    rest = parseVariableIdentifier(kind);
                    elements.push(restNode.finishRestElement(rest));
                    break;
                } else {
                    elements.push(parsePatternWithDefault(params, kind));
                }
                if (!match(']')) {
                    expect(',');
                }
            }

        }

        expect(']');

        return node.finishArrayPattern(elements);
    }

    function parsePropertyPattern(params, kind) {
        var node = new Node(), key, keyToken, computed = match('['), init;
        if (lookahead.type === Token.Identifier) {
            keyToken = lookahead;
            key = parseVariableIdentifier();
            if (match('=')) {
                params.push(keyToken);
                lex();
                init = parseAssignmentExpression();

                return node.finishProperty(
                    'init', key, false,
                    new WrappingNode(keyToken).finishAssignmentPattern(key, init), false, true);
            } else if (!match(':')) {
                params.push(keyToken);
                return node.finishProperty('init', key, false, key, false, true);
            }
        } else {
            key = parseObjectPropertyKey();
        }
        expect(':');
        init = parsePatternWithDefault(params, kind);
        return node.finishProperty('init', key, computed, init, false, false);
    }

    function parseObjectPattern(params, kind) {
        var node = new Node(), properties = [];

        expect('{');

        while (!match('}')) {
            properties.push(parsePropertyPattern(params, kind));
            if (!match('}')) {
                expect(',');
            }
        }

        lex();

        return node.finishObjectPattern(properties);
    }

    function parsePattern(params, kind) {
        if (match('[')) {
            return parseArrayPattern(params, kind);
        } else if (match('{')) {
            return parseObjectPattern(params, kind);
        } else if (matchKeyword('let')) {
            if (kind === 'const' || kind === 'let') {
                tolerateUnexpectedToken(lookahead, Messages.UnexpectedToken);
            }
        }

        params.push(lookahead);
        return parseVariableIdentifier(kind);
    }

    function parsePatternWithDefault(params, kind) {
        var startToken = lookahead, pattern, previousAllowYield, right;
        pattern = parsePattern(params, kind);
        if (match('=')) {
            lex();
            previousAllowYield = state.allowYield;
            state.allowYield = true;
            right = isolateCoverGrammar(parseAssignmentExpression);
            state.allowYield = previousAllowYield;
            pattern = new WrappingNode(startToken).finishAssignmentPattern(pattern, right);
        }
        return pattern;
    }

    // ECMA-262 12.2.5 Array Initializer

    function parseArrayInitializer() {
        var elements = [], node = new Node(), restSpread;

        expect('[');

        while (!match(']')) {
            if (match(',')) {
                lex();
                elements.push(null);
            } else if (match('...')) {
                restSpread = new Node();
                lex();
                restSpread.finishSpreadElement(inheritCoverGrammar(parseAssignmentExpression));

                if (!match(']')) {
                    isAssignmentTarget = isBindingElement = false;
                    expect(',');
                }
                elements.push(restSpread);
            } else {
                elements.push(inheritCoverGrammar(parseAssignmentExpression));

                if (!match(']')) {
                    expect(',');
                }
            }
        }

        lex();

        return node.finishArrayExpression(elements);
    }

    // ECMA-262 12.2.6 Object Initializer

    function parsePropertyFunction(node, paramInfo, isGenerator) {
        var previousStrict, body;

        isAssignmentTarget = isBindingElement = false;

        previousStrict = strict;
        body = isolateCoverGrammar(parseFunctionSourceElements);

        if (strict && paramInfo.firstRestricted) {
            tolerateUnexpectedToken(paramInfo.firstRestricted, paramInfo.message);
        }
        if (strict && paramInfo.stricted) {
            tolerateUnexpectedToken(paramInfo.stricted, paramInfo.message);
        }

        strict = previousStrict;
        return node.finishFunctionExpression(null, paramInfo.params, paramInfo.defaults, body, isGenerator);
    }

    function parsePropertyMethodFunction() {
        var params, method, node = new Node(),
            previousAllowYield = state.allowYield;

        state.allowYield = false;
        params = parseParams();
        state.allowYield = previousAllowYield;

        state.allowYield = false;
        method = parsePropertyFunction(node, params, false);
        state.allowYield = previousAllowYield;

        return method;
    }

    function parseObjectPropertyKey() {
        var token, node = new Node(), expr;

        token = lex();

        // Note: This function is called only from parseObjectProperty(), where
        // EOF and Punctuator tokens are already filtered out.

        switch (token.type) {
        case Token.StringLiteral:
        case Token.NumericLiteral:
            if (strict && token.octal) {
                tolerateUnexpectedToken(token, Messages.StrictOctalLiteral);
            }
            return node.finishLiteral(token);
        case Token.Identifier:
        case Token.BooleanLiteral:
        case Token.NullLiteral:
        case Token.Keyword:
            return node.finishIdentifier(token.value);
        case Token.Punctuator:
            if (token.value === '[') {
                expr = isolateCoverGrammar(parseAssignmentExpression);
                expect(']');
                return expr;
            }
            break;
        }
        throwUnexpectedToken(token);
    }

    function lookaheadPropertyName() {
        switch (lookahead.type) {
        case Token.Identifier:
        case Token.StringLiteral:
        case Token.BooleanLiteral:
        case Token.NullLiteral:
        case Token.NumericLiteral:
        case Token.Keyword:
            return true;
        case Token.Punctuator:
            return lookahead.value === '[';
        }
        return false;
    }

    // This function is to try to parse a MethodDefinition as defined in 14.3. But in the case of object literals,
    // it might be called at a position where there is in fact a short hand identifier pattern or a data property.
    // This can only be determined after we consumed up to the left parentheses.
    //
    // In order to avoid back tracking, it returns `null` if the position is not a MethodDefinition and the caller
    // is responsible to visit other options.
    function tryParseMethodDefinition(token, key, computed, node) {
        var value, options, methodNode, params,
            previousAllowYield = state.allowYield;

        if (token.type === Token.Identifier) {
            // check for `get` and `set`;

            if (token.value === 'get' && lookaheadPropertyName()) {
                computed = match('[');
                key = parseObjectPropertyKey();
                methodNode = new Node();
                expect('(');
                expect(')');

                state.allowYield = false;
                value = parsePropertyFunction(methodNode, {
                    params: [],
                    defaults: [],
                    stricted: null,
                    firstRestricted: null,
                    message: null
                }, false);
                state.allowYield = previousAllowYield;

                return node.finishProperty('get', key, computed, value, false, false);
            } else if (token.value === 'set' && lookaheadPropertyName()) {
                computed = match('[');
                key = parseObjectPropertyKey();
                methodNode = new Node();
                expect('(');

                options = {
                    params: [],
                    defaultCount: 0,
                    defaults: [],
                    firstRestricted: null,
                    paramSet: {}
                };
                if (match(')')) {
                    tolerateUnexpectedToken(lookahead);
                } else {
                    state.allowYield = false;
                    parseParam(options);
                    state.allowYield = previousAllowYield;
                    if (options.defaultCount === 0) {
                        options.defaults = [];
                    }
                }
                expect(')');

                state.allowYield = false;
                value = parsePropertyFunction(methodNode, options, false);
                state.allowYield = previousAllowYield;

                return node.finishProperty('set', key, computed, value, false, false);
            }
        } else if (token.type === Token.Punctuator && token.value === '*' && lookaheadPropertyName()) {
            computed = match('[');
            key = parseObjectPropertyKey();
            methodNode = new Node();

            state.allowYield = true;
            params = parseParams();
            state.allowYield = previousAllowYield;

            state.allowYield = false;
            value = parsePropertyFunction(methodNode, params, true);
            state.allowYield = previousAllowYield;

            return node.finishProperty('init', key, computed, value, true, false);
        }

        if (key && match('(')) {
            value = parsePropertyMethodFunction();
            return node.finishProperty('init', key, computed, value, true, false);
        }

        // Not a MethodDefinition.
        return null;
    }

    function parseObjectProperty(hasProto) {
        var token = lookahead, node = new Node(), computed, key, maybeMethod, proto, value;

        computed = match('[');
        if (match('*')) {
            lex();
        } else {
            key = parseObjectPropertyKey();
        }
        maybeMethod = tryParseMethodDefinition(token, key, computed, node);
        if (maybeMethod) {
            return maybeMethod;
        }

        if (!key) {
            throwUnexpectedToken(lookahead);
        }

        // Check for duplicated __proto__
        if (!computed) {
            proto = (key.type === Syntax.Identifier && key.name === '__proto__') ||
                (key.type === Syntax.Literal && key.value === '__proto__');
            if (hasProto.value && proto) {
                tolerateError(Messages.DuplicateProtoProperty);
            }
            hasProto.value |= proto;
        }

        if (match(':')) {
            lex();
            value = inheritCoverGrammar(parseAssignmentExpression);
            return node.finishProperty('init', key, computed, value, false, false);
        }

        if (token.type === Token.Identifier) {
            if (match('=')) {
                firstCoverInitializedNameError = lookahead;
                lex();
                value = isolateCoverGrammar(parseAssignmentExpression);
                return node.finishProperty('init', key, computed,
                    new WrappingNode(token).finishAssignmentPattern(key, value), false, true);
            }
            return node.finishProperty('init', key, computed, key, false, true);
        }

        throwUnexpectedToken(lookahead);
    }

    function parseObjectInitializer() {
        var properties = [], hasProto = {value: false}, node = new Node();

        expect('{');

        while (!match('}')) {
            properties.push(parseObjectProperty(hasProto));

            if (!match('}')) {
                expectCommaSeparator();
            }
        }

        expect('}');

        return node.finishObjectExpression(properties);
    }

    function reinterpretExpressionAsPattern(expr) {
        var i;
        switch (expr.type) {
        case Syntax.Identifier:
        case Syntax.MemberExpression:
        case Syntax.RestElement:
        case Syntax.AssignmentPattern:
            break;
        case Syntax.SpreadElement:
            expr.type = Syntax.RestElement;
            reinterpretExpressionAsPattern(expr.argument);
            break;
        case Syntax.ArrayExpression:
            expr.type = Syntax.ArrayPattern;
            for (i = 0; i < expr.elements.length; i++) {
                if (expr.elements[i] !== null) {
                    reinterpretExpressionAsPattern(expr.elements[i]);
                }
            }
            break;
        case Syntax.ObjectExpression:
            expr.type = Syntax.ObjectPattern;
            for (i = 0; i < expr.properties.length; i++) {
                reinterpretExpressionAsPattern(expr.properties[i].value);
            }
            break;
        case Syntax.AssignmentExpression:
            expr.type = Syntax.AssignmentPattern;
            reinterpretExpressionAsPattern(expr.left);
            break;
        default:
            // Allow other node type for tolerant parsing.
            break;
        }
    }

    // ECMA-262 12.2.9 Template Literals

    function parseTemplateElement(option) {
        var node, token;

        if (lookahead.type !== Token.Template || (option.head && !lookahead.head)) {
            throwUnexpectedToken();
        }

        node = new Node();
        token = lex();

        return node.finishTemplateElement({ raw: token.value.raw, cooked: token.value.cooked }, token.tail);
    }

    function parseTemplateLiteral() {
        var quasi, quasis, expressions, node = new Node();

        quasi = parseTemplateElement({ head: true });
        quasis = [quasi];
        expressions = [];

        while (!quasi.tail) {
            expressions.push(parseExpression());
            quasi = parseTemplateElement({ head: false });
            quasis.push(quasi);
        }

        return node.finishTemplateLiteral(quasis, expressions);
    }

    // ECMA-262 12.2.10 The Grouping Operator

    function parseGroupExpression() {
        var expr, expressions, startToken, i, params = [];

        expect('(');

        if (match(')')) {
            lex();
            if (!match('=>')) {
                expect('=>');
            }
            return {
                type: PlaceHolders.ArrowParameterPlaceHolder,
                params: [],
                rawParams: []
            };
        }

        startToken = lookahead;
        if (match('...')) {
            expr = parseRestElement(params);
            expect(')');
            if (!match('=>')) {
                expect('=>');
            }
            return {
                type: PlaceHolders.ArrowParameterPlaceHolder,
                params: [expr]
            };
        }

        isBindingElement = true;
        expr = inheritCoverGrammar(parseAssignmentExpression);

        if (match(',')) {
            isAssignmentTarget = false;
            expressions = [expr];

            while (startIndex < length) {
                if (!match(',')) {
                    break;
                }
                lex();

                if (match('...')) {
                    if (!isBindingElement) {
                        throwUnexpectedToken(lookahead);
                    }
                    expressions.push(parseRestElement(params));
                    expect(')');
                    if (!match('=>')) {
                        expect('=>');
                    }
                    isBindingElement = false;
                    for (i = 0; i < expressions.length; i++) {
                        reinterpretExpressionAsPattern(expressions[i]);
                    }
                    return {
                        type: PlaceHolders.ArrowParameterPlaceHolder,
                        params: expressions
                    };
                }

                expressions.push(inheritCoverGrammar(parseAssignmentExpression));
            }

            expr = new WrappingNode(startToken).finishSequenceExpression(expressions);
        }


        expect(')');

        if (match('=>')) {
            if (expr.type === Syntax.Identifier && expr.name === 'yield') {
                return {
                    type: PlaceHolders.ArrowParameterPlaceHolder,
                    params: [expr]
                };
            }

            if (!isBindingElement) {
                throwUnexpectedToken(lookahead);
            }

            if (expr.type === Syntax.SequenceExpression) {
                for (i = 0; i < expr.expressions.length; i++) {
                    reinterpretExpressionAsPattern(expr.expressions[i]);
                }
            } else {
                reinterpretExpressionAsPattern(expr);
            }

            expr = {
                type: PlaceHolders.ArrowParameterPlaceHolder,
                params: expr.type === Syntax.SequenceExpression ? expr.expressions : [expr]
            };
        }
        isBindingElement = false;
        return expr;
    }


    // ECMA-262 12.2 Primary Expressions

    function parsePrimaryExpression() {
        var type, token, expr, node;

        if (match('(')) {
            isBindingElement = false;
            return inheritCoverGrammar(parseGroupExpression);
        }

        if (match('[')) {
            return inheritCoverGrammar(parseArrayInitializer);
        }

        if (match('{')) {
            return inheritCoverGrammar(parseObjectInitializer);
        }

        type = lookahead.type;
        node = new Node();

        if (type === Token.Identifier) {
            if (state.sourceType === 'module' && lookahead.value === 'await') {
                tolerateUnexpectedToken(lookahead);
            }
            expr = node.finishIdentifier(lex().value);
        } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {
            isAssignmentTarget = isBindingElement = false;
            if (strict && lookahead.octal) {
                tolerateUnexpectedToken(lookahead, Messages.StrictOctalLiteral);
            }
            expr = node.finishLiteral(lex());
        } else if (type === Token.Keyword) {
            if (!strict && state.allowYield && matchKeyword('yield')) {
                return parseNonComputedProperty();
            }
            if (!strict && matchKeyword('let')) {
                return node.finishIdentifier(lex().value);
            }
            isAssignmentTarget = isBindingElement = false;
            if (matchKeyword('function')) {
                return parseFunctionExpression();
            }
            if (matchKeyword('this')) {
                lex();
                return node.finishThisExpression();
            }
            if (matchKeyword('class')) {
                return parseClassExpression();
            }
            throwUnexpectedToken(lex());
        } else if (type === Token.BooleanLiteral) {
            isAssignmentTarget = isBindingElement = false;
            token = lex();
            token.value = (token.value === 'true');
            expr = node.finishLiteral(token);
        } else if (type === Token.NullLiteral) {
            isAssignmentTarget = isBindingElement = false;
            token = lex();
            token.value = null;
            expr = node.finishLiteral(token);
        } else if (match('/') || match('/=')) {
            isAssignmentTarget = isBindingElement = false;
            index = startIndex;

            if (typeof extra.tokens !== 'undefined') {
                token = collectRegex();
            } else {
                token = scanRegExp();
            }
            lex();
            expr = node.finishLiteral(token);
        } else if (type === Token.Template) {
            expr = parseTemplateLiteral();
        } else {
            throwUnexpectedToken(lex());
        }

        return expr;
    }

    // ECMA-262 12.3 Left-Hand-Side Expressions

    function parseArguments() {
        var args = [], expr;

        expect('(');

        if (!match(')')) {
            while (startIndex < length) {
                if (match('...')) {
                    expr = new Node();
                    lex();
                    expr.finishSpreadElement(isolateCoverGrammar(parseAssignmentExpression));
                } else {
                    expr = isolateCoverGrammar(parseAssignmentExpression);
                }
                args.push(expr);
                if (match(')')) {
                    break;
                }
                expectCommaSeparator();
            }
        }

        expect(')');

        return args;
    }

    function parseNonComputedProperty() {
        var token, node = new Node();

        token = lex();

        if (!isIdentifierName(token)) {
            throwUnexpectedToken(token);
        }

        return node.finishIdentifier(token.value);
    }

    function parseNonComputedMember() {
        expect('.');

        return parseNonComputedProperty();
    }

    function parseComputedMember() {
        var expr;

        expect('[');

        expr = isolateCoverGrammar(parseExpression);

        expect(']');

        return expr;
    }

    // ECMA-262 12.3.3 The new Operator

    function parseNewExpression() {
        var callee, args, node = new Node();

        expectKeyword('new');

        if (match('.')) {
            lex();
            if (lookahead.type === Token.Identifier && lookahead.value === 'target') {
                if (state.inFunctionBody) {
                    lex();
                    return node.finishMetaProperty('new', 'target');
                }
            }
            throwUnexpectedToken(lookahead);
        }

        callee = isolateCoverGrammar(parseLeftHandSideExpression);
        args = match('(') ? parseArguments() : [];

        isAssignmentTarget = isBindingElement = false;

        return node.finishNewExpression(callee, args);
    }

    // ECMA-262 12.3.4 Function Calls

    function parseLeftHandSideExpressionAllowCall() {
        var quasi, expr, args, property, startToken, previousAllowIn = state.allowIn;

        startToken = lookahead;
        state.allowIn = true;

        if (matchKeyword('super') && state.inFunctionBody) {
            expr = new Node();
            lex();
            expr = expr.finishSuper();
            if (!match('(') && !match('.') && !match('[')) {
                throwUnexpectedToken(lookahead);
            }
        } else {
            expr = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression);
        }

        for (;;) {
            if (match('.')) {
                isBindingElement = false;
                isAssignmentTarget = true;
                property = parseNonComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);
            } else if (match('(')) {
                isBindingElement = false;
                isAssignmentTarget = false;
                args = parseArguments();
                expr = new WrappingNode(startToken).finishCallExpression(expr, args);
            } else if (match('[')) {
                isBindingElement = false;
                isAssignmentTarget = true;
                property = parseComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);
            } else if (lookahead.type === Token.Template && lookahead.head) {
                quasi = parseTemplateLiteral();
                expr = new WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);
            } else {
                break;
            }
        }
        state.allowIn = previousAllowIn;

        return expr;
    }

    // ECMA-262 12.3 Left-Hand-Side Expressions

    function parseLeftHandSideExpression() {
        var quasi, expr, property, startToken;
        assert(state.allowIn, 'callee of new expression always allow in keyword.');

        startToken = lookahead;

        if (matchKeyword('super') && state.inFunctionBody) {
            expr = new Node();
            lex();
            expr = expr.finishSuper();
            if (!match('[') && !match('.')) {
                throwUnexpectedToken(lookahead);
            }
        } else {
            expr = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression);
        }

        for (;;) {
            if (match('[')) {
                isBindingElement = false;
                isAssignmentTarget = true;
                property = parseComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);
            } else if (match('.')) {
                isBindingElement = false;
                isAssignmentTarget = true;
                property = parseNonComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);
            } else if (lookahead.type === Token.Template && lookahead.head) {
                quasi = parseTemplateLiteral();
                expr = new WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);
            } else {
                break;
            }
        }
        return expr;
    }

    // ECMA-262 12.4 Postfix Expressions

    function parsePostfixExpression() {
        var expr, token, startToken = lookahead;

        expr = inheritCoverGrammar(parseLeftHandSideExpressionAllowCall);

        if (!hasLineTerminator && lookahead.type === Token.Punctuator) {
            if (match('++') || match('--')) {
                // ECMA-262 11.3.1, 11.3.2
                if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                    tolerateError(Messages.StrictLHSPostfix);
                }

                if (!isAssignmentTarget) {
                    tolerateError(Messages.InvalidLHSInAssignment);
                }

                isAssignmentTarget = isBindingElement = false;

                token = lex();
                expr = new WrappingNode(startToken).finishPostfixExpression(token.value, expr);
            }
        }

        return expr;
    }

    // ECMA-262 12.5 Unary Operators

    function parseUnaryExpression() {
        var token, expr, startToken;

        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {
            expr = parsePostfixExpression();
        } else if (match('++') || match('--')) {
            startToken = lookahead;
            token = lex();
            expr = inheritCoverGrammar(parseUnaryExpression);
            // ECMA-262 11.4.4, 11.4.5
            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                tolerateError(Messages.StrictLHSPrefix);
            }

            if (!isAssignmentTarget) {
                tolerateError(Messages.InvalidLHSInAssignment);
            }
            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
            isAssignmentTarget = isBindingElement = false;
        } else if (match('+') || match('-') || match('~') || match('!')) {
            startToken = lookahead;
            token = lex();
            expr = inheritCoverGrammar(parseUnaryExpression);
            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
            isAssignmentTarget = isBindingElement = false;
        } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
            startToken = lookahead;
            token = lex();
            expr = inheritCoverGrammar(parseUnaryExpression);
            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {
                tolerateError(Messages.StrictDelete);
            }
            isAssignmentTarget = isBindingElement = false;
        } else {
            expr = parsePostfixExpression();
        }

        return expr;
    }

    function binaryPrecedence(token, allowIn) {
        var prec = 0;

        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
            return 0;
        }

        switch (token.value) {
        case '||':
            prec = 1;
            break;

        case '&&':
            prec = 2;
            break;

        case '|':
            prec = 3;
            break;

        case '^':
            prec = 4;
            break;

        case '&':
            prec = 5;
            break;

        case '==':
        case '!=':
        case '===':
        case '!==':
            prec = 6;
            break;

        case '<':
        case '>':
        case '<=':
        case '>=':
        case 'instanceof':
            prec = 7;
            break;

        case 'in':
            prec = allowIn ? 7 : 0;
            break;

        case '<<':
        case '>>':
        case '>>>':
            prec = 8;
            break;

        case '+':
        case '-':
            prec = 9;
            break;

        case '*':
        case '/':
        case '%':
            prec = 11;
            break;

        default:
            break;
        }

        return prec;
    }

    // ECMA-262 12.6 Multiplicative Operators
    // ECMA-262 12.7 Additive Operators
    // ECMA-262 12.8 Bitwise Shift Operators
    // ECMA-262 12.9 Relational Operators
    // ECMA-262 12.10 Equality Operators
    // ECMA-262 12.11 Binary Bitwise Operators
    // ECMA-262 12.12 Binary Logical Operators

    function parseBinaryExpression() {
        var marker, markers, expr, token, prec, stack, right, operator, left, i;

        marker = lookahead;
        left = inheritCoverGrammar(parseUnaryExpression);

        token = lookahead;
        prec = binaryPrecedence(token, state.allowIn);
        if (prec === 0) {
            return left;
        }
        isAssignmentTarget = isBindingElement = false;
        token.prec = prec;
        lex();

        markers = [marker, lookahead];
        right = isolateCoverGrammar(parseUnaryExpression);

        stack = [left, token, right];

        while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {

            // Reduce: make a binary expression from the three topmost entries.
            while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {
                right = stack.pop();
                operator = stack.pop().value;
                left = stack.pop();
                markers.pop();
                expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);
                stack.push(expr);
            }

            // Shift.
            token = lex();
            token.prec = prec;
            stack.push(token);
            markers.push(lookahead);
            expr = isolateCoverGrammar(parseUnaryExpression);
            stack.push(expr);
        }

        // Final reduce to clean-up the stack.
        i = stack.length - 1;
        expr = stack[i];
        markers.pop();
        while (i > 1) {
            expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
            i -= 2;
        }

        return expr;
    }


    // ECMA-262 12.13 Conditional Operator

    function parseConditionalExpression() {
        var expr, previousAllowIn, consequent, alternate, startToken;

        startToken = lookahead;

        expr = inheritCoverGrammar(parseBinaryExpression);
        if (match('?')) {
            lex();
            previousAllowIn = state.allowIn;
            state.allowIn = true;
            consequent = isolateCoverGrammar(parseAssignmentExpression);
            state.allowIn = previousAllowIn;
            expect(':');
            alternate = isolateCoverGrammar(parseAssignmentExpression);

            expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);
            isAssignmentTarget = isBindingElement = false;
        }

        return expr;
    }

    // ECMA-262 14.2 Arrow Function Definitions

    function parseConciseBody() {
        if (match('{')) {
            return parseFunctionSourceElements();
        }
        return isolateCoverGrammar(parseAssignmentExpression);
    }

    function checkPatternParam(options, param) {
        var i;
        switch (param.type) {
        case Syntax.Identifier:
            validateParam(options, param, param.name);
            break;
        case Syntax.RestElement:
            checkPatternParam(options, param.argument);
            break;
        case Syntax.AssignmentPattern:
            checkPatternParam(options, param.left);
            break;
        case Syntax.ArrayPattern:
            for (i = 0; i < param.elements.length; i++) {
                if (param.elements[i] !== null) {
                    checkPatternParam(options, param.elements[i]);
                }
            }
            break;
        case Syntax.YieldExpression:
            break;
        default:
            assert(param.type === Syntax.ObjectPattern, 'Invalid type');
            for (i = 0; i < param.properties.length; i++) {
                checkPatternParam(options, param.properties[i].value);
            }
            break;
        }
    }
    function reinterpretAsCoverFormalsList(expr) {
        var i, len, param, params, defaults, defaultCount, options, token;

        defaults = [];
        defaultCount = 0;
        params = [expr];

        switch (expr.type) {
        case Syntax.Identifier:
            break;
        case PlaceHolders.ArrowParameterPlaceHolder:
            params = expr.params;
            break;
        default:
            return null;
        }

        options = {
            paramSet: {}
        };

        for (i = 0, len = params.length; i < len; i += 1) {
            param = params[i];
            switch (param.type) {
            case Syntax.AssignmentPattern:
                params[i] = param.left;
                if (param.right.type === Syntax.YieldExpression) {
                    if (param.right.argument) {
                        throwUnexpectedToken(lookahead);
                    }
                    param.right.type = Syntax.Identifier;
                    param.right.name = 'yield';
                    delete param.right.argument;
                    delete param.right.delegate;
                }
                defaults.push(param.right);
                ++defaultCount;
                checkPatternParam(options, param.left);
                break;
            default:
                checkPatternParam(options, param);
                params[i] = param;
                defaults.push(null);
                break;
            }
        }

        if (strict || !state.allowYield) {
            for (i = 0, len = params.length; i < len; i += 1) {
                param = params[i];
                if (param.type === Syntax.YieldExpression) {
                    throwUnexpectedToken(lookahead);
                }
            }
        }

        if (options.message === Messages.StrictParamDupe) {
            token = strict ? options.stricted : options.firstRestricted;
            throwUnexpectedToken(token, options.message);
        }

        if (defaultCount === 0) {
            defaults = [];
        }

        return {
            params: params,
            defaults: defaults,
            stricted: options.stricted,
            firstRestricted: options.firstRestricted,
            message: options.message
        };
    }

    function parseArrowFunctionExpression(options, node) {
        var previousStrict, previousAllowYield, body;

        if (hasLineTerminator) {
            tolerateUnexpectedToken(lookahead);
        }
        expect('=>');

        previousStrict = strict;
        previousAllowYield = state.allowYield;
        state.allowYield = true;

        body = parseConciseBody();

        if (strict && options.firstRestricted) {
            throwUnexpectedToken(options.firstRestricted, options.message);
        }
        if (strict && options.stricted) {
            tolerateUnexpectedToken(options.stricted, options.message);
        }

        strict = previousStrict;
        state.allowYield = previousAllowYield;

        return node.finishArrowFunctionExpression(options.params, options.defaults, body, body.type !== Syntax.BlockStatement);
    }

    // ECMA-262 14.4 Yield expression

    function parseYieldExpression() {
        var argument, expr, delegate, previousAllowYield;

        argument = null;
        expr = new Node();
        delegate = false;

        expectKeyword('yield');

        if (!hasLineTerminator) {
            previousAllowYield = state.allowYield;
            state.allowYield = false;
            delegate = match('*');
            if (delegate) {
                lex();
                argument = parseAssignmentExpression();
            } else {
                if (!match(';') && !match('}') && !match(')') && lookahead.type !== Token.EOF) {
                    argument = parseAssignmentExpression();
                }
            }
            state.allowYield = previousAllowYield;
        }

        return expr.finishYieldExpression(argument, delegate);
    }

    // ECMA-262 12.14 Assignment Operators

    function parseAssignmentExpression() {
        var token, expr, right, list, startToken;

        startToken = lookahead;
        token = lookahead;

        if (!state.allowYield && matchKeyword('yield')) {
            return parseYieldExpression();
        }

        expr = parseConditionalExpression();

        if (expr.type === PlaceHolders.ArrowParameterPlaceHolder || match('=>')) {
            isAssignmentTarget = isBindingElement = false;
            list = reinterpretAsCoverFormalsList(expr);

            if (list) {
                firstCoverInitializedNameError = null;
                return parseArrowFunctionExpression(list, new WrappingNode(startToken));
            }

            return expr;
        }

        if (matchAssign()) {
            if (!isAssignmentTarget) {
                tolerateError(Messages.InvalidLHSInAssignment);
            }

            // ECMA-262 12.1.1
            if (strict && expr.type === Syntax.Identifier) {
                if (isRestrictedWord(expr.name)) {
                    tolerateUnexpectedToken(token, Messages.StrictLHSAssignment);
                }
                if (isStrictModeReservedWord(expr.name)) {
                    tolerateUnexpectedToken(token, Messages.StrictReservedWord);
                }
            }

            if (!match('=')) {
                isAssignmentTarget = isBindingElement = false;
            } else {
                reinterpretExpressionAsPattern(expr);
            }

            token = lex();
            right = isolateCoverGrammar(parseAssignmentExpression);
            expr = new WrappingNode(startToken).finishAssignmentExpression(token.value, expr, right);
            firstCoverInitializedNameError = null;
        }

        return expr;
    }

    // ECMA-262 12.15 Comma Operator

    function parseExpression() {
        var expr, startToken = lookahead, expressions;

        expr = isolateCoverGrammar(parseAssignmentExpression);

        if (match(',')) {
            expressions = [expr];

            while (startIndex < length) {
                if (!match(',')) {
                    break;
                }
                lex();
                expressions.push(isolateCoverGrammar(parseAssignmentExpression));
            }

            expr = new WrappingNode(startToken).finishSequenceExpression(expressions);
        }

        return expr;
    }

    // ECMA-262 13.2 Block

    function parseStatementListItem() {
        if (lookahead.type === Token.Keyword) {
            switch (lookahead.value) {
            case 'export':
                if (state.sourceType !== 'module') {
                    tolerateUnexpectedToken(lookahead, Messages.IllegalExportDeclaration);
                }
                return parseExportDeclaration();
            case 'import':
                if (state.sourceType !== 'module') {
                    tolerateUnexpectedToken(lookahead, Messages.IllegalImportDeclaration);
                }
                return parseImportDeclaration();
            case 'const':
                return parseLexicalDeclaration({inFor: false});
            case 'function':
                return parseFunctionDeclaration(new Node());
            case 'class':
                return parseClassDeclaration();
            }
        }

        if (matchKeyword('let') && isLexicalDeclaration()) {
            return parseLexicalDeclaration({inFor: false});
        }

        return parseStatement();
    }

    function parseStatementList() {
        var list = [];
        while (startIndex < length) {
            if (match('}')) {
                break;
            }
            list.push(parseStatementListItem());
        }

        return list;
    }

    function parseBlock() {
        var block, node = new Node();

        expect('{');

        block = parseStatementList();

        expect('}');

        return node.finishBlockStatement(block);
    }

    // ECMA-262 13.3.2 Variable Statement

    function parseVariableIdentifier(kind) {
        var token, node = new Node();

        token = lex();

        if (token.type === Token.Keyword && token.value === 'yield') {
            if (strict) {
                tolerateUnexpectedToken(token, Messages.StrictReservedWord);
            } if (!state.allowYield) {
                throwUnexpectedToken(token);
            }
        } else if (token.type !== Token.Identifier) {
            if (strict && token.type === Token.Keyword && isStrictModeReservedWord(token.value)) {
                tolerateUnexpectedToken(token, Messages.StrictReservedWord);
            } else {
                if (strict || token.value !== 'let' || kind !== 'var') {
                    throwUnexpectedToken(token);
                }
            }
        } else if (state.sourceType === 'module' && token.type === Token.Identifier && token.value === 'await') {
            tolerateUnexpectedToken(token);
        }

        return node.finishIdentifier(token.value);
    }

    function parseVariableDeclaration(options) {
        var init = null, id, node = new Node(), params = [];

        id = parsePattern(params, 'var');

        // ECMA-262 12.2.1
        if (strict && isRestrictedWord(id.name)) {
            tolerateError(Messages.StrictVarName);
        }

        if (match('=')) {
            lex();
            init = isolateCoverGrammar(parseAssignmentExpression);
        } else if (id.type !== Syntax.Identifier && !options.inFor) {
            expect('=');
        }

        return node.finishVariableDeclarator(id, init);
    }

    function parseVariableDeclarationList(options) {
        var opt, list;

        opt = { inFor: options.inFor };
        list = [parseVariableDeclaration(opt)];

        while (match(',')) {
            lex();
            list.push(parseVariableDeclaration(opt));
        }

        return list;
    }

    function parseVariableStatement(node) {
        var declarations;

        expectKeyword('var');

        declarations = parseVariableDeclarationList({ inFor: false });

        consumeSemicolon();

        return node.finishVariableDeclaration(declarations);
    }

    // ECMA-262 13.3.1 Let and Const Declarations

    function parseLexicalBinding(kind, options) {
        var init = null, id, node = new Node(), params = [];

        id = parsePattern(params, kind);

        // ECMA-262 12.2.1
        if (strict && id.type === Syntax.Identifier && isRestrictedWord(id.name)) {
            tolerateError(Messages.StrictVarName);
        }

        if (kind === 'const') {
            if (!matchKeyword('in') && !matchContextualKeyword('of')) {
                expect('=');
                init = isolateCoverGrammar(parseAssignmentExpression);
            }
        } else if ((!options.inFor && id.type !== Syntax.Identifier) || match('=')) {
            expect('=');
            init = isolateCoverGrammar(parseAssignmentExpression);
        }

        return node.finishVariableDeclarator(id, init);
    }

    function parseBindingList(kind, options) {
        var list = [parseLexicalBinding(kind, options)];

        while (match(',')) {
            lex();
            list.push(parseLexicalBinding(kind, options));
        }

        return list;
    }


    function tokenizerState() {
        return {
            index: index,
            lineNumber: lineNumber,
            lineStart: lineStart,
            hasLineTerminator: hasLineTerminator,
            lastIndex: lastIndex,
            lastLineNumber: lastLineNumber,
            lastLineStart: lastLineStart,
            startIndex: startIndex,
            startLineNumber: startLineNumber,
            startLineStart: startLineStart,
            lookahead: lookahead,
            tokenCount: extra.tokens ? extra.tokens.length : 0
        };
    }

    function resetTokenizerState(ts) {
        index = ts.index;
        lineNumber = ts.lineNumber;
        lineStart = ts.lineStart;
        hasLineTerminator = ts.hasLineTerminator;
        lastIndex = ts.lastIndex;
        lastLineNumber = ts.lastLineNumber;
        lastLineStart = ts.lastLineStart;
        startIndex = ts.startIndex;
        startLineNumber = ts.startLineNumber;
        startLineStart = ts.startLineStart;
        lookahead = ts.lookahead;
        if (extra.tokens) {
            extra.tokens.splice(ts.tokenCount, extra.tokens.length);
        }
    }

    function isLexicalDeclaration() {
        var lexical, ts;

        ts = tokenizerState();

        lex();
        lexical = (lookahead.type === Token.Identifier) || match('[') || match('{') ||
            matchKeyword('let') || matchKeyword('yield');

        resetTokenizerState(ts);

        return lexical;
    }

    function parseLexicalDeclaration(options) {
        var kind, declarations, node = new Node();

        kind = lex().value;
        assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');

        declarations = parseBindingList(kind, options);

        consumeSemicolon();

        return node.finishLexicalDeclaration(declarations, kind);
    }

    function parseRestElement(params) {
        var param, node = new Node();

        lex();

        if (match('{')) {
            throwError(Messages.ObjectPatternAsRestParameter);
        }

        params.push(lookahead);

        param = parseVariableIdentifier();

        if (match('=')) {
            throwError(Messages.DefaultRestParameter);
        }

        if (!match(')')) {
            throwError(Messages.ParameterAfterRestParameter);
        }

        return node.finishRestElement(param);
    }

    // ECMA-262 13.4 Empty Statement

    function parseEmptyStatement(node) {
        expect(';');
        return node.finishEmptyStatement();
    }

    // ECMA-262 12.4 Expression Statement

    function parseExpressionStatement(node) {
        var expr = parseExpression();
        consumeSemicolon();
        return node.finishExpressionStatement(expr);
    }

    // ECMA-262 13.6 If statement

    function parseIfStatement(node) {
        var test, consequent, alternate;

        expectKeyword('if');

        expect('(');

        test = parseExpression();

        expect(')');

        consequent = parseStatement();

        if (matchKeyword('else')) {
            lex();
            alternate = parseStatement();
        } else {
            alternate = null;
        }

        return node.finishIfStatement(test, consequent, alternate);
    }

    // ECMA-262 13.7 Iteration Statements

    function parseDoWhileStatement(node) {
        var body, test, oldInIteration;

        expectKeyword('do');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        expectKeyword('while');

        expect('(');

        test = parseExpression();

        expect(')');

        if (match(';')) {
            lex();
        }

        return node.finishDoWhileStatement(body, test);
    }

    function parseWhileStatement(node) {
        var test, body, oldInIteration;

        expectKeyword('while');

        expect('(');

        test = parseExpression();

        expect(')');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        return node.finishWhileStatement(test, body);
    }

    function parseForStatement(node) {
        var init, forIn, initSeq, initStartToken, test, update, left, right, kind, declarations,
            body, oldInIteration, previousAllowIn = state.allowIn;

        init = test = update = null;
        forIn = true;

        expectKeyword('for');

        expect('(');

        if (match(';')) {
            lex();
        } else {
            if (matchKeyword('var')) {
                init = new Node();
                lex();

                state.allowIn = false;
                declarations = parseVariableDeclarationList({ inFor: true });
                state.allowIn = previousAllowIn;

                if (declarations.length === 1 && matchKeyword('in')) {
                    init = init.finishVariableDeclaration(declarations);
                    lex();
                    left = init;
                    right = parseExpression();
                    init = null;
                } else if (declarations.length === 1 && declarations[0].init === null && matchContextualKeyword('of')) {
                    init = init.finishVariableDeclaration(declarations);
                    lex();
                    left = init;
                    right = parseAssignmentExpression();
                    init = null;
                    forIn = false;
                } else {
                    init = init.finishVariableDeclaration(declarations);
                    expect(';');
                }
            } else if (matchKeyword('const') || matchKeyword('let')) {
                init = new Node();
                kind = lex().value;

                if (!strict && lookahead.value === 'in') {
                    init = init.finishIdentifier(kind);
                    lex();
                    left = init;
                    right = parseExpression();
                    init = null;
                } else {
                    state.allowIn = false;
                    declarations = parseBindingList(kind, {inFor: true});
                    state.allowIn = previousAllowIn;

                    if (declarations.length === 1 && declarations[0].init === null && matchKeyword('in')) {
                        init = init.finishLexicalDeclaration(declarations, kind);
                        lex();
                        left = init;
                        right = parseExpression();
                        init = null;
                    } else if (declarations.length === 1 && declarations[0].init === null && matchContextualKeyword('of')) {
                        init = init.finishLexicalDeclaration(declarations, kind);
                        lex();
                        left = init;
                        right = parseAssignmentExpression();
                        init = null;
                        forIn = false;
                    } else {
                        consumeSemicolon();
                        init = init.finishLexicalDeclaration(declarations, kind);
                    }
                }
            } else {
                initStartToken = lookahead;
                state.allowIn = false;
                init = inheritCoverGrammar(parseAssignmentExpression);
                state.allowIn = previousAllowIn;

                if (matchKeyword('in')) {
                    if (!isAssignmentTarget) {
                        tolerateError(Messages.InvalidLHSInForIn);
                    }

                    lex();
                    reinterpretExpressionAsPattern(init);
                    left = init;
                    right = parseExpression();
                    init = null;
                } else if (matchContextualKeyword('of')) {
                    if (!isAssignmentTarget) {
                        tolerateError(Messages.InvalidLHSInForLoop);
                    }

                    lex();
                    reinterpretExpressionAsPattern(init);
                    left = init;
                    right = parseAssignmentExpression();
                    init = null;
                    forIn = false;
                } else {
                    if (match(',')) {
                        initSeq = [init];
                        while (match(',')) {
                            lex();
                            initSeq.push(isolateCoverGrammar(parseAssignmentExpression));
                        }
                        init = new WrappingNode(initStartToken).finishSequenceExpression(initSeq);
                    }
                    expect(';');
                }
            }
        }

        if (typeof left === 'undefined') {

            if (!match(';')) {
                test = parseExpression();
            }
            expect(';');

            if (!match(')')) {
                update = parseExpression();
            }
        }

        expect(')');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = isolateCoverGrammar(parseStatement);

        state.inIteration = oldInIteration;

        return (typeof left === 'undefined') ?
                node.finishForStatement(init, test, update, body) :
                forIn ? node.finishForInStatement(left, right, body) :
                    node.finishForOfStatement(left, right, body);
    }

    // ECMA-262 13.8 The continue statement

    function parseContinueStatement(node) {
        var label = null, key;

        expectKeyword('continue');

        // Optimize the most common form: 'continue;'.
        if (source.charCodeAt(startIndex) === 0x3B) {
            lex();

            if (!state.inIteration) {
                throwError(Messages.IllegalContinue);
            }

            return node.finishContinueStatement(null);
        }

        if (hasLineTerminator) {
            if (!state.inIteration) {
                throwError(Messages.IllegalContinue);
            }

            return node.finishContinueStatement(null);
        }

        if (lookahead.type === Token.Identifier) {
            label = parseVariableIdentifier();

            key = '$' + label.name;
            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError(Messages.UnknownLabel, label.name);
            }
        }

        consumeSemicolon();

        if (label === null && !state.inIteration) {
            throwError(Messages.IllegalContinue);
        }

        return node.finishContinueStatement(label);
    }

    // ECMA-262 13.9 The break statement

    function parseBreakStatement(node) {
        var label = null, key;

        expectKeyword('break');

        // Catch the very common case first: immediately a semicolon (U+003B).
        if (source.charCodeAt(lastIndex) === 0x3B) {
            lex();

            if (!(state.inIteration || state.inSwitch)) {
                throwError(Messages.IllegalBreak);
            }

            return node.finishBreakStatement(null);
        }

        if (hasLineTerminator) {
            if (!(state.inIteration || state.inSwitch)) {
                throwError(Messages.IllegalBreak);
            }
        } else if (lookahead.type === Token.Identifier) {
            label = parseVariableIdentifier();

            key = '$' + label.name;
            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError(Messages.UnknownLabel, label.name);
            }
        }

        consumeSemicolon();

        if (label === null && !(state.inIteration || state.inSwitch)) {
            throwError(Messages.IllegalBreak);
        }

        return node.finishBreakStatement(label);
    }

    // ECMA-262 13.10 The return statement

    function parseReturnStatement(node) {
        var argument = null;

        expectKeyword('return');

        if (!state.inFunctionBody) {
            tolerateError(Messages.IllegalReturn);
        }

        // 'return' followed by a space and an identifier is very common.
        if (source.charCodeAt(lastIndex) === 0x20) {
            if (isIdentifierStart(source.charCodeAt(lastIndex + 1))) {
                argument = parseExpression();
                consumeSemicolon();
                return node.finishReturnStatement(argument);
            }
        }

        if (hasLineTerminator) {
            // HACK
            return node.finishReturnStatement(null);
        }

        if (!match(';')) {
            if (!match('}') && lookahead.type !== Token.EOF) {
                argument = parseExpression();
            }
        }

        consumeSemicolon();

        return node.finishReturnStatement(argument);
    }

    // ECMA-262 13.11 The with statement

    function parseWithStatement(node) {
        var object, body;

        if (strict) {
            tolerateError(Messages.StrictModeWith);
        }

        expectKeyword('with');

        expect('(');

        object = parseExpression();

        expect(')');

        body = parseStatement();

        return node.finishWithStatement(object, body);
    }

    // ECMA-262 13.12 The switch statement

    function parseSwitchCase() {
        var test, consequent = [], statement, node = new Node();

        if (matchKeyword('default')) {
            lex();
            test = null;
        } else {
            expectKeyword('case');
            test = parseExpression();
        }
        expect(':');

        while (startIndex < length) {
            if (match('}') || matchKeyword('default') || matchKeyword('case')) {
                break;
            }
            statement = parseStatementListItem();
            consequent.push(statement);
        }

        return node.finishSwitchCase(test, consequent);
    }

    function parseSwitchStatement(node) {
        var discriminant, cases, clause, oldInSwitch, defaultFound;

        expectKeyword('switch');

        expect('(');

        discriminant = parseExpression();

        expect(')');

        expect('{');

        cases = [];

        if (match('}')) {
            lex();
            return node.finishSwitchStatement(discriminant, cases);
        }

        oldInSwitch = state.inSwitch;
        state.inSwitch = true;
        defaultFound = false;

        while (startIndex < length) {
            if (match('}')) {
                break;
            }
            clause = parseSwitchCase();
            if (clause.test === null) {
                if (defaultFound) {
                    throwError(Messages.MultipleDefaultsInSwitch);
                }
                defaultFound = true;
            }
            cases.push(clause);
        }

        state.inSwitch = oldInSwitch;

        expect('}');

        return node.finishSwitchStatement(discriminant, cases);
    }

    // ECMA-262 13.14 The throw statement

    function parseThrowStatement(node) {
        var argument;

        expectKeyword('throw');

        if (hasLineTerminator) {
            throwError(Messages.NewlineAfterThrow);
        }

        argument = parseExpression();

        consumeSemicolon();

        return node.finishThrowStatement(argument);
    }

    // ECMA-262 13.15 The try statement

    function parseCatchClause() {
        var param, params = [], paramMap = {}, key, i, body, node = new Node();

        expectKeyword('catch');

        expect('(');
        if (match(')')) {
            throwUnexpectedToken(lookahead);
        }

        param = parsePattern(params);
        for (i = 0; i < params.length; i++) {
            key = '$' + params[i].value;
            if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
                tolerateError(Messages.DuplicateBinding, params[i].value);
            }
            paramMap[key] = true;
        }

        // ECMA-262 12.14.1
        if (strict && isRestrictedWord(param.name)) {
            tolerateError(Messages.StrictCatchVariable);
        }

        expect(')');
        body = parseBlock();
        return node.finishCatchClause(param, body);
    }

    function parseTryStatement(node) {
        var block, handler = null, finalizer = null;

        expectKeyword('try');

        block = parseBlock();

        if (matchKeyword('catch')) {
            handler = parseCatchClause();
        }

        if (matchKeyword('finally')) {
            lex();
            finalizer = parseBlock();
        }

        if (!handler && !finalizer) {
            throwError(Messages.NoCatchOrFinally);
        }

        return node.finishTryStatement(block, handler, finalizer);
    }

    // ECMA-262 13.16 The debugger statement

    function parseDebuggerStatement(node) {
        expectKeyword('debugger');

        consumeSemicolon();

        return node.finishDebuggerStatement();
    }

    // 13 Statements

    function parseStatement() {
        var type = lookahead.type,
            expr,
            labeledBody,
            key,
            node;

        if (type === Token.EOF) {
            throwUnexpectedToken(lookahead);
        }

        if (type === Token.Punctuator && lookahead.value === '{') {
            return parseBlock();
        }
        isAssignmentTarget = isBindingElement = true;
        node = new Node();

        if (type === Token.Punctuator) {
            switch (lookahead.value) {
            case ';':
                return parseEmptyStatement(node);
            case '(':
                return parseExpressionStatement(node);
            default:
                break;
            }
        } else if (type === Token.Keyword) {
            switch (lookahead.value) {
            case 'break':
                return parseBreakStatement(node);
            case 'continue':
                return parseContinueStatement(node);
            case 'debugger':
                return parseDebuggerStatement(node);
            case 'do':
                return parseDoWhileStatement(node);
            case 'for':
                return parseForStatement(node);
            case 'function':
                return parseFunctionDeclaration(node);
            case 'if':
                return parseIfStatement(node);
            case 'return':
                return parseReturnStatement(node);
            case 'switch':
                return parseSwitchStatement(node);
            case 'throw':
                return parseThrowStatement(node);
            case 'try':
                return parseTryStatement(node);
            case 'var':
                return parseVariableStatement(node);
            case 'while':
                return parseWhileStatement(node);
            case 'with':
                return parseWithStatement(node);
            default:
                break;
            }
        }

        expr = parseExpression();

        // ECMA-262 12.12 Labelled Statements
        if ((expr.type === Syntax.Identifier) && match(':')) {
            lex();

            key = '$' + expr.name;
            if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError(Messages.Redeclaration, 'Label', expr.name);
            }

            state.labelSet[key] = true;
            labeledBody = parseStatement();
            delete state.labelSet[key];
            return node.finishLabeledStatement(expr, labeledBody);
        }

        consumeSemicolon();

        return node.finishExpressionStatement(expr);
    }

    // ECMA-262 14.1 Function Definition

    function parseFunctionSourceElements() {
        var statement, body = [], token, directive, firstRestricted,
            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody,
            node = new Node();

        expect('{');

        while (startIndex < length) {
            if (lookahead.type !== Token.StringLiteral) {
                break;
            }
            token = lookahead;

            statement = parseStatementListItem();
            body.push(statement);
            if (statement.expression.type !== Syntax.Literal) {
                // this is not directive
                break;
            }
            directive = source.slice(token.start + 1, token.end - 1);
            if (directive === 'use strict') {
                strict = true;
                if (firstRestricted) {
                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);
                }
            } else {
                if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                }
            }
        }

        oldLabelSet = state.labelSet;
        oldInIteration = state.inIteration;
        oldInSwitch = state.inSwitch;
        oldInFunctionBody = state.inFunctionBody;

        state.labelSet = {};
        state.inIteration = false;
        state.inSwitch = false;
        state.inFunctionBody = true;

        while (startIndex < length) {
            if (match('}')) {
                break;
            }
            body.push(parseStatementListItem());
        }

        expect('}');

        state.labelSet = oldLabelSet;
        state.inIteration = oldInIteration;
        state.inSwitch = oldInSwitch;
        state.inFunctionBody = oldInFunctionBody;

        return node.finishBlockStatement(body);
    }

    function validateParam(options, param, name) {
        var key = '$' + name;
        if (strict) {
            if (isRestrictedWord(name)) {
                options.stricted = param;
                options.message = Messages.StrictParamName;
            }
            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                options.stricted = param;
                options.message = Messages.StrictParamDupe;
            }
        } else if (!options.firstRestricted) {
            if (isRestrictedWord(name)) {
                options.firstRestricted = param;
                options.message = Messages.StrictParamName;
            } else if (isStrictModeReservedWord(name)) {
                options.firstRestricted = param;
                options.message = Messages.StrictReservedWord;
            } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                options.stricted = param;
                options.message = Messages.StrictParamDupe;
            }
        }
        options.paramSet[key] = true;
    }

    function parseParam(options) {
        var token, param, params = [], i, def;

        token = lookahead;
        if (token.value === '...') {
            param = parseRestElement(params);
            validateParam(options, param.argument, param.argument.name);
            options.params.push(param);
            options.defaults.push(null);
            return false;
        }

        param = parsePatternWithDefault(params);
        for (i = 0; i < params.length; i++) {
            validateParam(options, params[i], params[i].value);
        }

        if (param.type === Syntax.AssignmentPattern) {
            def = param.right;
            param = param.left;
            ++options.defaultCount;
        }

        options.params.push(param);
        options.defaults.push(def);

        return !match(')');
    }

    function parseParams(firstRestricted) {
        var options;

        options = {
            params: [],
            defaultCount: 0,
            defaults: [],
            firstRestricted: firstRestricted
        };

        expect('(');

        if (!match(')')) {
            options.paramSet = {};
            while (startIndex < length) {
                if (!parseParam(options)) {
                    break;
                }
                expect(',');
            }
        }

        expect(')');

        if (options.defaultCount === 0) {
            options.defaults = [];
        }

        return {
            params: options.params,
            defaults: options.defaults,
            stricted: options.stricted,
            firstRestricted: options.firstRestricted,
            message: options.message
        };
    }

    function parseFunctionDeclaration(node, identifierIsOptional) {
        var id = null, params = [], defaults = [], body, token, stricted, tmp, firstRestricted, message, previousStrict,
            isGenerator, previousAllowYield;

        previousAllowYield = state.allowYield;

        expectKeyword('function');

        isGenerator = match('*');
        if (isGenerator) {
            lex();
        }

        if (!identifierIsOptional || !match('(')) {
            token = lookahead;
            id = parseVariableIdentifier();
            if (strict) {
                if (isRestrictedWord(token.value)) {
                    tolerateUnexpectedToken(token, Messages.StrictFunctionName);
                }
            } else {
                if (isRestrictedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictFunctionName;
                } else if (isStrictModeReservedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictReservedWord;
                }
            }
        }

        state.allowYield = !isGenerator;
        tmp = parseParams(firstRestricted);
        params = tmp.params;
        defaults = tmp.defaults;
        stricted = tmp.stricted;
        firstRestricted = tmp.firstRestricted;
        if (tmp.message) {
            message = tmp.message;
        }


        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) {
            throwUnexpectedToken(firstRestricted, message);
        }
        if (strict && stricted) {
            tolerateUnexpectedToken(stricted, message);
        }

        strict = previousStrict;
        state.allowYield = previousAllowYield;

        return node.finishFunctionDeclaration(id, params, defaults, body, isGenerator);
    }

    function parseFunctionExpression() {
        var token, id = null, stricted, firstRestricted, message, tmp,
            params = [], defaults = [], body, previousStrict, node = new Node(),
            isGenerator, previousAllowYield;

        previousAllowYield = state.allowYield;

        expectKeyword('function');

        isGenerator = match('*');
        if (isGenerator) {
            lex();
        }

        state.allowYield = !isGenerator;
        if (!match('(')) {
            token = lookahead;
            id = (!strict && !isGenerator && matchKeyword('yield')) ? parseNonComputedProperty() : parseVariableIdentifier();
            if (strict) {
                if (isRestrictedWord(token.value)) {
                    tolerateUnexpectedToken(token, Messages.StrictFunctionName);
                }
            } else {
                if (isRestrictedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictFunctionName;
                } else if (isStrictModeReservedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictReservedWord;
                }
            }
        }

        tmp = parseParams(firstRestricted);
        params = tmp.params;
        defaults = tmp.defaults;
        stricted = tmp.stricted;
        firstRestricted = tmp.firstRestricted;
        if (tmp.message) {
            message = tmp.message;
        }

        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) {
            throwUnexpectedToken(firstRestricted, message);
        }
        if (strict && stricted) {
            tolerateUnexpectedToken(stricted, message);
        }
        strict = previousStrict;
        state.allowYield = previousAllowYield;

        return node.finishFunctionExpression(id, params, defaults, body, isGenerator);
    }

    // ECMA-262 14.5 Class Definitions

    function parseClassBody() {
        var classBody, token, isStatic, hasConstructor = false, body, method, computed, key;

        classBody = new Node();

        expect('{');
        body = [];
        while (!match('}')) {
            if (match(';')) {
                lex();
            } else {
                method = new Node();
                token = lookahead;
                isStatic = false;
                computed = match('[');
                if (match('*')) {
                    lex();
                } else {
                    key = parseObjectPropertyKey();
                    if (key.name === 'static' && (lookaheadPropertyName() || match('*'))) {
                        token = lookahead;
                        isStatic = true;
                        computed = match('[');
                        if (match('*')) {
                            lex();
                        } else {
                            key = parseObjectPropertyKey();
                        }
                    }
                }
                method = tryParseMethodDefinition(token, key, computed, method);
                if (method) {
                    method['static'] = isStatic; // jscs:ignore requireDotNotation
                    if (method.kind === 'init') {
                        method.kind = 'method';
                    }
                    if (!isStatic) {
                        if (!method.computed && (method.key.name || method.key.value.toString()) === 'constructor') {
                            if (method.kind !== 'method' || !method.method || method.value.generator) {
                                throwUnexpectedToken(token, Messages.ConstructorSpecialMethod);
                            }
                            if (hasConstructor) {
                                throwUnexpectedToken(token, Messages.DuplicateConstructor);
                            } else {
                                hasConstructor = true;
                            }
                            method.kind = 'constructor';
                        }
                    } else {
                        if (!method.computed && (method.key.name || method.key.value.toString()) === 'prototype') {
                            throwUnexpectedToken(token, Messages.StaticPrototype);
                        }
                    }
                    method.type = Syntax.MethodDefinition;
                    delete method.method;
                    delete method.shorthand;
                    body.push(method);
                } else {
                    throwUnexpectedToken(lookahead);
                }
            }
        }
        lex();
        return classBody.finishClassBody(body);
    }

    function parseClassDeclaration(identifierIsOptional) {
        var id = null, superClass = null, classNode = new Node(), classBody, previousStrict = strict;
        strict = true;

        expectKeyword('class');

        if (!identifierIsOptional || lookahead.type === Token.Identifier) {
            id = parseVariableIdentifier();
        }

        if (matchKeyword('extends')) {
            lex();
            superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);
        }
        classBody = parseClassBody();
        strict = previousStrict;

        return classNode.finishClassDeclaration(id, superClass, classBody);
    }

    function parseClassExpression() {
        var id = null, superClass = null, classNode = new Node(), classBody, previousStrict = strict;
        strict = true;

        expectKeyword('class');

        if (lookahead.type === Token.Identifier) {
            id = parseVariableIdentifier();
        }

        if (matchKeyword('extends')) {
            lex();
            superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);
        }
        classBody = parseClassBody();
        strict = previousStrict;

        return classNode.finishClassExpression(id, superClass, classBody);
    }

    // ECMA-262 15.2 Modules

    function parseModuleSpecifier() {
        var node = new Node();

        if (lookahead.type !== Token.StringLiteral) {
            throwError(Messages.InvalidModuleSpecifier);
        }
        return node.finishLiteral(lex());
    }

    // ECMA-262 15.2.3 Exports

    function parseExportSpecifier() {
        var exported, local, node = new Node(), def;
        if (matchKeyword('default')) {
            // export {default} from 'something';
            def = new Node();
            lex();
            local = def.finishIdentifier('default');
        } else {
            local = parseVariableIdentifier();
        }
        if (matchContextualKeyword('as')) {
            lex();
            exported = parseNonComputedProperty();
        }
        return node.finishExportSpecifier(local, exported);
    }

    function parseExportNamedDeclaration(node) {
        var declaration = null,
            isExportFromIdentifier,
            src = null, specifiers = [];

        // non-default export
        if (lookahead.type === Token.Keyword) {
            // covers:
            // export var f = 1;
            switch (lookahead.value) {
                case 'let':
                case 'const':
                    declaration = parseLexicalDeclaration({inFor: false});
                    return node.finishExportNamedDeclaration(declaration, specifiers, null);
                case 'var':
                case 'class':
                case 'function':
                    declaration = parseStatementListItem();
                    return node.finishExportNamedDeclaration(declaration, specifiers, null);
            }
        }

        expect('{');
        while (!match('}')) {
            isExportFromIdentifier = isExportFromIdentifier || matchKeyword('default');
            specifiers.push(parseExportSpecifier());
            if (!match('}')) {
                expect(',');
                if (match('}')) {
                    break;
                }
            }
        }
        expect('}');

        if (matchContextualKeyword('from')) {
            // covering:
            // export {default} from 'foo';
            // export {foo} from 'foo';
            lex();
            src = parseModuleSpecifier();
            consumeSemicolon();
        } else if (isExportFromIdentifier) {
            // covering:
            // export {default}; // missing fromClause
            throwError(lookahead.value ?
                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
        } else {
            // cover
            // export {foo};
            consumeSemicolon();
        }
        return node.finishExportNamedDeclaration(declaration, specifiers, src);
    }

    function parseExportDefaultDeclaration(node) {
        var declaration = null,
            expression = null;

        // covers:
        // export default ...
        expectKeyword('default');

        if (matchKeyword('function')) {
            // covers:
            // export default function foo () {}
            // export default function () {}
            declaration = parseFunctionDeclaration(new Node(), true);
            return node.finishExportDefaultDeclaration(declaration);
        }
        if (matchKeyword('class')) {
            declaration = parseClassDeclaration(true);
            return node.finishExportDefaultDeclaration(declaration);
        }

        if (matchContextualKeyword('from')) {
            throwError(Messages.UnexpectedToken, lookahead.value);
        }

        // covers:
        // export default {};
        // export default [];
        // export default (1 + 2);
        if (match('{')) {
            expression = parseObjectInitializer();
        } else if (match('[')) {
            expression = parseArrayInitializer();
        } else {
            expression = parseAssignmentExpression();
        }
        consumeSemicolon();
        return node.finishExportDefaultDeclaration(expression);
    }

    function parseExportAllDeclaration(node) {
        var src;

        // covers:
        // export * from 'foo';
        expect('*');
        if (!matchContextualKeyword('from')) {
            throwError(lookahead.value ?
                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
        }
        lex();
        src = parseModuleSpecifier();
        consumeSemicolon();

        return node.finishExportAllDeclaration(src);
    }

    function parseExportDeclaration() {
        var node = new Node();
        if (state.inFunctionBody) {
            throwError(Messages.IllegalExportDeclaration);
        }

        expectKeyword('export');

        if (matchKeyword('default')) {
            return parseExportDefaultDeclaration(node);
        }
        if (match('*')) {
            return parseExportAllDeclaration(node);
        }
        return parseExportNamedDeclaration(node);
    }

    // ECMA-262 15.2.2 Imports

    function parseImportSpecifier() {
        // import {<foo as bar>} ...;
        var local, imported, node = new Node();

        imported = parseNonComputedProperty();
        if (matchContextualKeyword('as')) {
            lex();
            local = parseVariableIdentifier();
        }

        return node.finishImportSpecifier(local, imported);
    }

    function parseNamedImports() {
        var specifiers = [];
        // {foo, bar as bas}
        expect('{');
        while (!match('}')) {
            specifiers.push(parseImportSpecifier());
            if (!match('}')) {
                expect(',');
                if (match('}')) {
                    break;
                }
            }
        }
        expect('}');
        return specifiers;
    }

    function parseImportDefaultSpecifier() {
        // import <foo> ...;
        var local, node = new Node();

        local = parseNonComputedProperty();

        return node.finishImportDefaultSpecifier(local);
    }

    function parseImportNamespaceSpecifier() {
        // import <* as foo> ...;
        var local, node = new Node();

        expect('*');
        if (!matchContextualKeyword('as')) {
            throwError(Messages.NoAsAfterImportNamespace);
        }
        lex();
        local = parseNonComputedProperty();

        return node.finishImportNamespaceSpecifier(local);
    }

    function parseImportDeclaration() {
        var specifiers = [], src, node = new Node();

        if (state.inFunctionBody) {
            throwError(Messages.IllegalImportDeclaration);
        }

        expectKeyword('import');

        if (lookahead.type === Token.StringLiteral) {
            // import 'foo';
            src = parseModuleSpecifier();
        } else {

            if (match('{')) {
                // import {bar}
                specifiers = specifiers.concat(parseNamedImports());
            } else if (match('*')) {
                // import * as foo
                specifiers.push(parseImportNamespaceSpecifier());
            } else if (isIdentifierName(lookahead) && !matchKeyword('default')) {
                // import foo
                specifiers.push(parseImportDefaultSpecifier());
                if (match(',')) {
                    lex();
                    if (match('*')) {
                        // import foo, * as foo
                        specifiers.push(parseImportNamespaceSpecifier());
                    } else if (match('{')) {
                        // import foo, {bar}
                        specifiers = specifiers.concat(parseNamedImports());
                    } else {
                        throwUnexpectedToken(lookahead);
                    }
                }
            } else {
                throwUnexpectedToken(lex());
            }

            if (!matchContextualKeyword('from')) {
                throwError(lookahead.value ?
                        Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
            }
            lex();
            src = parseModuleSpecifier();
        }

        consumeSemicolon();
        return node.finishImportDeclaration(specifiers, src);
    }

    // ECMA-262 15.1 Scripts

    function parseScriptBody() {
        var statement, body = [], token, directive, firstRestricted;

        while (startIndex < length) {
            token = lookahead;
            if (token.type !== Token.StringLiteral) {
                break;
            }

            statement = parseStatementListItem();
            body.push(statement);
            if (statement.expression.type !== Syntax.Literal) {
                // this is not directive
                break;
            }
            directive = source.slice(token.start + 1, token.end - 1);
            if (directive === 'use strict') {
                strict = true;
                if (firstRestricted) {
                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);
                }
            } else {
                if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                }
            }
        }

        while (startIndex < length) {
            statement = parseStatementListItem();
            /* istanbul ignore if */
            if (typeof statement === 'undefined') {
                break;
            }
            body.push(statement);
        }
        return body;
    }

    function parseProgram() {
        var body, node;

        peek();
        node = new Node();

        body = parseScriptBody();
        return node.finishProgram(body, state.sourceType);
    }

    function filterTokenLocation() {
        var i, entry, token, tokens = [];

        for (i = 0; i < extra.tokens.length; ++i) {
            entry = extra.tokens[i];
            token = {
                type: entry.type,
                value: entry.value
            };
            if (entry.regex) {
                token.regex = {
                    pattern: entry.regex.pattern,
                    flags: entry.regex.flags
                };
            }
            if (extra.range) {
                token.range = entry.range;
            }
            if (extra.loc) {
                token.loc = entry.loc;
            }
            tokens.push(token);
        }

        extra.tokens = tokens;
    }

    function tokenize(code, options, delegate) {
        var toString,
            tokens;

        toString = String;
        if (typeof code !== 'string' && !(code instanceof String)) {
            code = toString(code);
        }

        source = code;
        index = 0;
        lineNumber = (source.length > 0) ? 1 : 0;
        lineStart = 0;
        startIndex = index;
        startLineNumber = lineNumber;
        startLineStart = lineStart;
        length = source.length;
        lookahead = null;
        state = {
            allowIn: true,
            allowYield: true,
            labelSet: {},
            inFunctionBody: false,
            inIteration: false,
            inSwitch: false,
            lastCommentStart: -1,
            curlyStack: []
        };

        extra = {};

        // Options matching.
        options = options || {};

        // Of course we collect tokens here.
        options.tokens = true;
        extra.tokens = [];
        extra.tokenValues = [];
        extra.tokenize = true;
        extra.delegate = delegate;

        // The following two fields are necessary to compute the Regex tokens.
        extra.openParenToken = -1;
        extra.openCurlyToken = -1;

        extra.range = (typeof options.range === 'boolean') && options.range;
        extra.loc = (typeof options.loc === 'boolean') && options.loc;

        if (typeof options.comment === 'boolean' && options.comment) {
            extra.comments = [];
        }
        if (typeof options.tolerant === 'boolean' && options.tolerant) {
            extra.errors = [];
        }

        try {
            peek();
            if (lookahead.type === Token.EOF) {
                return extra.tokens;
            }

            lex();
            while (lookahead.type !== Token.EOF) {
                try {
                    lex();
                } catch (lexError) {
                    if (extra.errors) {
                        recordError(lexError);
                        // We have to break on the first error
                        // to avoid infinite loops.
                        break;
                    } else {
                        throw lexError;
                    }
                }
            }

            tokens = extra.tokens;
            if (typeof extra.errors !== 'undefined') {
                tokens.errors = extra.errors;
            }
        } catch (e) {
            throw e;
        } finally {
            extra = {};
        }
        return tokens;
    }

    function parse(code, options) {
        var program, toString;

        toString = String;
        if (typeof code !== 'string' && !(code instanceof String)) {
            code = toString(code);
        }

        source = code;
        index = 0;
        lineNumber = (source.length > 0) ? 1 : 0;
        lineStart = 0;
        startIndex = index;
        startLineNumber = lineNumber;
        startLineStart = lineStart;
        length = source.length;
        lookahead = null;
        state = {
            allowIn: true,
            allowYield: true,
            labelSet: {},
            inFunctionBody: false,
            inIteration: false,
            inSwitch: false,
            lastCommentStart: -1,
            curlyStack: [],
            sourceType: 'script'
        };
        strict = false;

        extra = {};
        if (typeof options !== 'undefined') {
            extra.range = (typeof options.range === 'boolean') && options.range;
            extra.loc = (typeof options.loc === 'boolean') && options.loc;
            extra.attachComment = (typeof options.attachComment === 'boolean') && options.attachComment;

            if (extra.loc && options.source !== null && options.source !== undefined) {
                extra.source = toString(options.source);
            }

            if (typeof options.tokens === 'boolean' && options.tokens) {
                extra.tokens = [];
            }
            if (typeof options.comment === 'boolean' && options.comment) {
                extra.comments = [];
            }
            if (typeof options.tolerant === 'boolean' && options.tolerant) {
                extra.errors = [];
            }
            if (extra.attachComment) {
                extra.range = true;
                extra.comments = [];
                extra.bottomRightStack = [];
                extra.trailingComments = [];
                extra.leadingComments = [];
            }
            if (options.sourceType === 'module') {
                // very restrictive condition for now
                state.sourceType = options.sourceType;
                strict = true;
            }
        }

        try {
            program = parseProgram();
            if (typeof extra.comments !== 'undefined') {
                program.comments = extra.comments;
            }
            if (typeof extra.tokens !== 'undefined') {
                filterTokenLocation();
                program.tokens = extra.tokens;
            }
            if (typeof extra.errors !== 'undefined') {
                program.errors = extra.errors;
            }
        } catch (e) {
            throw e;
        } finally {
            extra = {};
        }

        return program;
    }

    // Sync with *.json manifests.
    exports.version = '2.7.3';

    exports.tokenize = tokenize;

    exports.parse = parse;

    // Deep copy.
    /* istanbul ignore next */
    exports.Syntax = (function () {
        var name, types = {};

        if (typeof Object.create === 'function') {
            types = Object.create(null);
        }

        for (name in Syntax) {
            if (Syntax.hasOwnProperty(name)) {
                types[name] = Syntax[name];
            }
        }

        if (typeof Object.freeze === 'function') {
            Object.freeze(types);
        }

        return types;
    }());

}));
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],19:[function(require,module,exports){
/*
  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/*jslint vars:false, bitwise:true*/
/*jshint indent:4*/
/*global exports:true*/
(function clone(exports) {
    'use strict';

    var Syntax,
        VisitorOption,
        VisitorKeys,
        BREAK,
        SKIP,
        REMOVE;

    function deepCopy(obj) {
        var ret = {}, key, val;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                val = obj[key];
                if (typeof val === 'object' && val !== null) {
                    ret[key] = deepCopy(val);
                } else {
                    ret[key] = val;
                }
            }
        }
        return ret;
    }

    // based on LLVM libc++ upper_bound / lower_bound
    // MIT License

    function upperBound(array, func) {
        var diff, len, i, current;

        len = array.length;
        i = 0;

        while (len) {
            diff = len >>> 1;
            current = i + diff;
            if (func(array[current])) {
                len = diff;
            } else {
                i = current + 1;
                len -= diff + 1;
            }
        }
        return i;
    }

    Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        AssignmentPattern: 'AssignmentPattern',
        ArrayExpression: 'ArrayExpression',
        ArrayPattern: 'ArrayPattern',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        AwaitExpression: 'AwaitExpression', // CAUTION: It's deferred to ES7.
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ClassBody: 'ClassBody',
        ClassDeclaration: 'ClassDeclaration',
        ClassExpression: 'ClassExpression',
        ComprehensionBlock: 'ComprehensionBlock',  // CAUTION: It's deferred to ES7.
        ComprehensionExpression: 'ComprehensionExpression',  // CAUTION: It's deferred to ES7.
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DebuggerStatement: 'DebuggerStatement',
        DirectiveStatement: 'DirectiveStatement',
        DoWhileStatement: 'DoWhileStatement',
        EmptyStatement: 'EmptyStatement',
        ExportAllDeclaration: 'ExportAllDeclaration',
        ExportDefaultDeclaration: 'ExportDefaultDeclaration',
        ExportNamedDeclaration: 'ExportNamedDeclaration',
        ExportSpecifier: 'ExportSpecifier',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        ForOfStatement: 'ForOfStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        GeneratorExpression: 'GeneratorExpression',  // CAUTION: It's deferred to ES7.
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        ImportExpression: 'ImportExpression',
        ImportDeclaration: 'ImportDeclaration',
        ImportDefaultSpecifier: 'ImportDefaultSpecifier',
        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
        ImportSpecifier: 'ImportSpecifier',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        MetaProperty: 'MetaProperty',
        MethodDefinition: 'MethodDefinition',
        ModuleSpecifier: 'ModuleSpecifier',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        ObjectPattern: 'ObjectPattern',
        Program: 'Program',
        Property: 'Property',
        RestElement: 'RestElement',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SpreadElement: 'SpreadElement',
        Super: 'Super',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        TaggedTemplateExpression: 'TaggedTemplateExpression',
        TemplateElement: 'TemplateElement',
        TemplateLiteral: 'TemplateLiteral',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement',
        YieldExpression: 'YieldExpression'
    };

    VisitorKeys = {
        AssignmentExpression: ['left', 'right'],
        AssignmentPattern: ['left', 'right'],
        ArrayExpression: ['elements'],
        ArrayPattern: ['elements'],
        ArrowFunctionExpression: ['params', 'body'],
        AwaitExpression: ['argument'], // CAUTION: It's deferred to ES7.
        BlockStatement: ['body'],
        BinaryExpression: ['left', 'right'],
        BreakStatement: ['label'],
        CallExpression: ['callee', 'arguments'],
        CatchClause: ['param', 'body'],
        ClassBody: ['body'],
        ClassDeclaration: ['id', 'superClass', 'body'],
        ClassExpression: ['id', 'superClass', 'body'],
        ComprehensionBlock: ['left', 'right'],  // CAUTION: It's deferred to ES7.
        ComprehensionExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.
        ConditionalExpression: ['test', 'consequent', 'alternate'],
        ContinueStatement: ['label'],
        DebuggerStatement: [],
        DirectiveStatement: [],
        DoWhileStatement: ['body', 'test'],
        EmptyStatement: [],
        ExportAllDeclaration: ['source'],
        ExportDefaultDeclaration: ['declaration'],
        ExportNamedDeclaration: ['declaration', 'specifiers', 'source'],
        ExportSpecifier: ['exported', 'local'],
        ExpressionStatement: ['expression'],
        ForStatement: ['init', 'test', 'update', 'body'],
        ForInStatement: ['left', 'right', 'body'],
        ForOfStatement: ['left', 'right', 'body'],
        FunctionDeclaration: ['id', 'params', 'body'],
        FunctionExpression: ['id', 'params', 'body'],
        GeneratorExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.
        Identifier: [],
        IfStatement: ['test', 'consequent', 'alternate'],
        ImportExpression: ['source'],
        ImportDeclaration: ['specifiers', 'source'],
        ImportDefaultSpecifier: ['local'],
        ImportNamespaceSpecifier: ['local'],
        ImportSpecifier: ['imported', 'local'],
        Literal: [],
        LabeledStatement: ['label', 'body'],
        LogicalExpression: ['left', 'right'],
        MemberExpression: ['object', 'property'],
        MetaProperty: ['meta', 'property'],
        MethodDefinition: ['key', 'value'],
        ModuleSpecifier: [],
        NewExpression: ['callee', 'arguments'],
        ObjectExpression: ['properties'],
        ObjectPattern: ['properties'],
        Program: ['body'],
        Property: ['key', 'value'],
        RestElement: [ 'argument' ],
        ReturnStatement: ['argument'],
        SequenceExpression: ['expressions'],
        SpreadElement: ['argument'],
        Super: [],
        SwitchStatement: ['discriminant', 'cases'],
        SwitchCase: ['test', 'consequent'],
        TaggedTemplateExpression: ['tag', 'quasi'],
        TemplateElement: [],
        TemplateLiteral: ['quasis', 'expressions'],
        ThisExpression: [],
        ThrowStatement: ['argument'],
        TryStatement: ['block', 'handler', 'finalizer'],
        UnaryExpression: ['argument'],
        UpdateExpression: ['argument'],
        VariableDeclaration: ['declarations'],
        VariableDeclarator: ['id', 'init'],
        WhileStatement: ['test', 'body'],
        WithStatement: ['object', 'body'],
        YieldExpression: ['argument']
    };

    // unique id
    BREAK = {};
    SKIP = {};
    REMOVE = {};

    VisitorOption = {
        Break: BREAK,
        Skip: SKIP,
        Remove: REMOVE
    };

    function Reference(parent, key) {
        this.parent = parent;
        this.key = key;
    }

    Reference.prototype.replace = function replace(node) {
        this.parent[this.key] = node;
    };

    Reference.prototype.remove = function remove() {
        if (Array.isArray(this.parent)) {
            this.parent.splice(this.key, 1);
            return true;
        } else {
            this.replace(null);
            return false;
        }
    };

    function Element(node, path, wrap, ref) {
        this.node = node;
        this.path = path;
        this.wrap = wrap;
        this.ref = ref;
    }

    function Controller() { }

    // API:
    // return property path array from root to current node
    Controller.prototype.path = function path() {
        var i, iz, j, jz, result, element;

        function addToPath(result, path) {
            if (Array.isArray(path)) {
                for (j = 0, jz = path.length; j < jz; ++j) {
                    result.push(path[j]);
                }
            } else {
                result.push(path);
            }
        }

        // root node
        if (!this.__current.path) {
            return null;
        }

        // first node is sentinel, second node is root element
        result = [];
        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
            element = this.__leavelist[i];
            addToPath(result, element.path);
        }
        addToPath(result, this.__current.path);
        return result;
    };

    // API:
    // return type of current node
    Controller.prototype.type = function () {
        var node = this.current();
        return node.type || this.__current.wrap;
    };

    // API:
    // return array of parent elements
    Controller.prototype.parents = function parents() {
        var i, iz, result;

        // first node is sentinel
        result = [];
        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
            result.push(this.__leavelist[i].node);
        }

        return result;
    };

    // API:
    // return current node
    Controller.prototype.current = function current() {
        return this.__current.node;
    };

    Controller.prototype.__execute = function __execute(callback, element) {
        var previous, result;

        result = undefined;

        previous  = this.__current;
        this.__current = element;
        this.__state = null;
        if (callback) {
            result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
        }
        this.__current = previous;

        return result;
    };

    // API:
    // notify control skip / break
    Controller.prototype.notify = function notify(flag) {
        this.__state = flag;
    };

    // API:
    // skip child nodes of current node
    Controller.prototype.skip = function () {
        this.notify(SKIP);
    };

    // API:
    // break traversals
    Controller.prototype['break'] = function () {
        this.notify(BREAK);
    };

    // API:
    // remove node
    Controller.prototype.remove = function () {
        this.notify(REMOVE);
    };

    Controller.prototype.__initialize = function(root, visitor) {
        this.visitor = visitor;
        this.root = root;
        this.__worklist = [];
        this.__leavelist = [];
        this.__current = null;
        this.__state = null;
        this.__fallback = null;
        if (visitor.fallback === 'iteration') {
            this.__fallback = Object.keys;
        } else if (typeof visitor.fallback === 'function') {
            this.__fallback = visitor.fallback;
        }

        this.__keys = VisitorKeys;
        if (visitor.keys) {
            this.__keys = Object.assign(Object.create(this.__keys), visitor.keys);
        }
    };

    function isNode(node) {
        if (node == null) {
            return false;
        }
        return typeof node === 'object' && typeof node.type === 'string';
    }

    function isProperty(nodeType, key) {
        return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;
    }

    Controller.prototype.traverse = function traverse(root, visitor) {
        var worklist,
            leavelist,
            element,
            node,
            nodeType,
            ret,
            key,
            current,
            current2,
            candidates,
            candidate,
            sentinel;

        this.__initialize(root, visitor);

        sentinel = {};

        // reference
        worklist = this.__worklist;
        leavelist = this.__leavelist;

        // initialize
        worklist.push(new Element(root, null, null, null));
        leavelist.push(new Element(null, null, null, null));

        while (worklist.length) {
            element = worklist.pop();

            if (element === sentinel) {
                element = leavelist.pop();

                ret = this.__execute(visitor.leave, element);

                if (this.__state === BREAK || ret === BREAK) {
                    return;
                }
                continue;
            }

            if (element.node) {

                ret = this.__execute(visitor.enter, element);

                if (this.__state === BREAK || ret === BREAK) {
                    return;
                }

                worklist.push(sentinel);
                leavelist.push(element);

                if (this.__state === SKIP || ret === SKIP) {
                    continue;
                }

                node = element.node;
                nodeType = node.type || element.wrap;
                candidates = this.__keys[nodeType];
                if (!candidates) {
                    if (this.__fallback) {
                        candidates = this.__fallback(node);
                    } else {
                        throw new Error('Unknown node type ' + nodeType + '.');
                    }
                }

                current = candidates.length;
                while ((current -= 1) >= 0) {
                    key = candidates[current];
                    candidate = node[key];
                    if (!candidate) {
                        continue;
                    }

                    if (Array.isArray(candidate)) {
                        current2 = candidate.length;
                        while ((current2 -= 1) >= 0) {
                            if (!candidate[current2]) {
                                continue;
                            }
                            if (isProperty(nodeType, candidates[current])) {
                                element = new Element(candidate[current2], [key, current2], 'Property', null);
                            } else if (isNode(candidate[current2])) {
                                element = new Element(candidate[current2], [key, current2], null, null);
                            } else {
                                continue;
                            }
                            worklist.push(element);
                        }
                    } else if (isNode(candidate)) {
                        worklist.push(new Element(candidate, key, null, null));
                    }
                }
            }
        }
    };

    Controller.prototype.replace = function replace(root, visitor) {
        var worklist,
            leavelist,
            node,
            nodeType,
            target,
            element,
            current,
            current2,
            candidates,
            candidate,
            sentinel,
            outer,
            key;

        function removeElem(element) {
            var i,
                key,
                nextElem,
                parent;

            if (element.ref.remove()) {
                // When the reference is an element of an array.
                key = element.ref.key;
                parent = element.ref.parent;

                // If removed from array, then decrease following items' keys.
                i = worklist.length;
                while (i--) {
                    nextElem = worklist[i];
                    if (nextElem.ref && nextElem.ref.parent === parent) {
                        if  (nextElem.ref.key < key) {
                            break;
                        }
                        --nextElem.ref.key;
                    }
                }
            }
        }

        this.__initialize(root, visitor);

        sentinel = {};

        // reference
        worklist = this.__worklist;
        leavelist = this.__leavelist;

        // initialize
        outer = {
            root: root
        };
        element = new Element(root, null, null, new Reference(outer, 'root'));
        worklist.push(element);
        leavelist.push(element);

        while (worklist.length) {
            element = worklist.pop();

            if (element === sentinel) {
                element = leavelist.pop();

                target = this.__execute(visitor.leave, element);

                // node may be replaced with null,
                // so distinguish between undefined and null in this place
                if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
                    // replace
                    element.ref.replace(target);
                }

                if (this.__state === REMOVE || target === REMOVE) {
                    removeElem(element);
                }

                if (this.__state === BREAK || target === BREAK) {
                    return outer.root;
                }
                continue;
            }

            target = this.__execute(visitor.enter, element);

            // node may be replaced with null,
            // so distinguish between undefined and null in this place
            if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
                // replace
                element.ref.replace(target);
                element.node = target;
            }

            if (this.__state === REMOVE || target === REMOVE) {
                removeElem(element);
                element.node = null;
            }

            if (this.__state === BREAK || target === BREAK) {
                return outer.root;
            }

            // node may be null
            node = element.node;
            if (!node) {
                continue;
            }

            worklist.push(sentinel);
            leavelist.push(element);

            if (this.__state === SKIP || target === SKIP) {
                continue;
            }

            nodeType = node.type || element.wrap;
            candidates = this.__keys[nodeType];
            if (!candidates) {
                if (this.__fallback) {
                    candidates = this.__fallback(node);
                } else {
                    throw new Error('Unknown node type ' + nodeType + '.');
                }
            }

            current = candidates.length;
            while ((current -= 1) >= 0) {
                key = candidates[current];
                candidate = node[key];
                if (!candidate) {
                    continue;
                }

                if (Array.isArray(candidate)) {
                    current2 = candidate.length;
                    while ((current2 -= 1) >= 0) {
                        if (!candidate[current2]) {
                            continue;
                        }
                        if (isProperty(nodeType, candidates[current])) {
                            element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));
                        } else if (isNode(candidate[current2])) {
                            element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
                        } else {
                            continue;
                        }
                        worklist.push(element);
                    }
                } else if (isNode(candidate)) {
                    worklist.push(new Element(candidate, key, null, new Reference(node, key)));
                }
            }
        }

        return outer.root;
    };

    function traverse(root, visitor) {
        var controller = new Controller();
        return controller.traverse(root, visitor);
    }

    function replace(root, visitor) {
        var controller = new Controller();
        return controller.replace(root, visitor);
    }

    function extendCommentRange(comment, tokens) {
        var target;

        target = upperBound(tokens, function search(token) {
            return token.range[0] > comment.range[0];
        });

        comment.extendedRange = [comment.range[0], comment.range[1]];

        if (target !== tokens.length) {
            comment.extendedRange[1] = tokens[target].range[0];
        }

        target -= 1;
        if (target >= 0) {
            comment.extendedRange[0] = tokens[target].range[1];
        }

        return comment;
    }

    function attachComments(tree, providedComments, tokens) {
        // At first, we should calculate extended comment ranges.
        var comments = [], comment, len, i, cursor;

        if (!tree.range) {
            throw new Error('attachComments needs range information');
        }

        // tokens array is empty, we attach comments to tree as 'leadingComments'
        if (!tokens.length) {
            if (providedComments.length) {
                for (i = 0, len = providedComments.length; i < len; i += 1) {
                    comment = deepCopy(providedComments[i]);
                    comment.extendedRange = [0, tree.range[0]];
                    comments.push(comment);
                }
                tree.leadingComments = comments;
            }
            return tree;
        }

        for (i = 0, len = providedComments.length; i < len; i += 1) {
            comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
        }

        // This is based on John Freeman's implementation.
        cursor = 0;
        traverse(tree, {
            enter: function (node) {
                var comment;

                while (cursor < comments.length) {
                    comment = comments[cursor];
                    if (comment.extendedRange[1] > node.range[0]) {
                        break;
                    }

                    if (comment.extendedRange[1] === node.range[0]) {
                        if (!node.leadingComments) {
                            node.leadingComments = [];
                        }
                        node.leadingComments.push(comment);
                        comments.splice(cursor, 1);
                    } else {
                        cursor += 1;
                    }
                }

                // already out of owned node
                if (cursor === comments.length) {
                    return VisitorOption.Break;
                }

                if (comments[cursor].extendedRange[0] > node.range[1]) {
                    return VisitorOption.Skip;
                }
            }
        });

        cursor = 0;
        traverse(tree, {
            leave: function (node) {
                var comment;

                while (cursor < comments.length) {
                    comment = comments[cursor];
                    if (node.range[1] < comment.extendedRange[0]) {
                        break;
                    }

                    if (node.range[1] === comment.extendedRange[0]) {
                        if (!node.trailingComments) {
                            node.trailingComments = [];
                        }
                        node.trailingComments.push(comment);
                        comments.splice(cursor, 1);
                    } else {
                        cursor += 1;
                    }
                }

                // already out of owned node
                if (cursor === comments.length) {
                    return VisitorOption.Break;
                }

                if (comments[cursor].extendedRange[0] > node.range[1]) {
                    return VisitorOption.Skip;
                }
            }
        });

        return tree;
    }

    exports.version = require('./package.json').version;
    exports.Syntax = Syntax;
    exports.traverse = traverse;
    exports.replace = replace;
    exports.attachComments = attachComments;
    exports.VisitorKeys = VisitorKeys;
    exports.VisitorOption = VisitorOption;
    exports.Controller = Controller;
    exports.cloneEnvironment = function () { return clone({}); };

    return exports;
}(exports));
/* vim: set sw=4 ts=4 et tw=80 : */

},{"./package.json":20}],20:[function(require,module,exports){
module.exports={
  "_args": [
    [
      "estraverse@4.3.0",
      "/mnt/c/Users/dhn03/source/projects/jsflow/jsflow-master"
    ]
  ],
  "_from": "estraverse@4.3.0",
  "_id": "estraverse@4.3.0",
  "_inBundle": false,
  "_integrity": "sha512-39nnKffWz8xN1BU/2c79n9nB9HDzo0niYUqx6xyqUnyoAnQyyWpOTdZEeiCch8BBu515t4wp9ZmgVfVhn9EBpw==",
  "_location": "/estraverse",
  "_phantomChildren": {},
  "_requested": {
    "type": "version",
    "registry": true,
    "raw": "estraverse@4.3.0",
    "name": "estraverse",
    "escapedName": "estraverse",
    "rawSpec": "4.3.0",
    "saveSpec": null,
    "fetchSpec": "4.3.0"
  },
  "_requiredBy": [
    "/",
    "/escodegen",
    "/static-eval/escodegen",
    "/static-module/escodegen"
  ],
  "_resolved": "https://registry.npmjs.org/estraverse/-/estraverse-4.3.0.tgz",
  "_spec": "4.3.0",
  "_where": "/mnt/c/Users/dhn03/source/projects/jsflow/jsflow-master",
  "bugs": {
    "url": "https://github.com/estools/estraverse/issues"
  },
  "description": "ECMAScript JS AST traversal functions",
  "devDependencies": {
    "babel-preset-env": "^1.6.1",
    "babel-register": "^6.3.13",
    "chai": "^2.1.1",
    "espree": "^1.11.0",
    "gulp": "^3.8.10",
    "gulp-bump": "^0.2.2",
    "gulp-filter": "^2.0.0",
    "gulp-git": "^1.0.1",
    "gulp-tag-version": "^1.3.0",
    "jshint": "^2.5.6",
    "mocha": "^2.1.0"
  },
  "engines": {
    "node": ">=4.0"
  },
  "homepage": "https://github.com/estools/estraverse",
  "license": "BSD-2-Clause",
  "main": "estraverse.js",
  "maintainers": [
    {
      "name": "Yusuke Suzuki",
      "email": "utatane.tea@gmail.com",
      "url": "http://github.com/Constellation"
    }
  ],
  "name": "estraverse",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/estools/estraverse.git"
  },
  "scripts": {
    "lint": "jshint estraverse.js",
    "test": "npm run-script lint && npm run-script unit-test",
    "unit-test": "mocha --compilers js:babel-register"
  },
  "version": "4.3.0"
}

},{}],21:[function(require,module,exports){
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    function isExpression(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'ArrayExpression':
            case 'AssignmentExpression':
            case 'BinaryExpression':
            case 'CallExpression':
            case 'ConditionalExpression':
            case 'FunctionExpression':
            case 'Identifier':
            case 'Literal':
            case 'LogicalExpression':
            case 'MemberExpression':
            case 'NewExpression':
            case 'ObjectExpression':
            case 'SequenceExpression':
            case 'ThisExpression':
            case 'UnaryExpression':
            case 'UpdateExpression':
                return true;
        }
        return false;
    }

    function isIterationStatement(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'DoWhileStatement':
            case 'ForInStatement':
            case 'ForStatement':
            case 'WhileStatement':
                return true;
        }
        return false;
    }

    function isStatement(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'BlockStatement':
            case 'BreakStatement':
            case 'ContinueStatement':
            case 'DebuggerStatement':
            case 'DoWhileStatement':
            case 'EmptyStatement':
            case 'ExpressionStatement':
            case 'ForInStatement':
            case 'ForStatement':
            case 'IfStatement':
            case 'LabeledStatement':
            case 'ReturnStatement':
            case 'SwitchStatement':
            case 'ThrowStatement':
            case 'TryStatement':
            case 'VariableDeclaration':
            case 'WhileStatement':
            case 'WithStatement':
                return true;
        }
        return false;
    }

    function isSourceElement(node) {
      return isStatement(node) || node != null && node.type === 'FunctionDeclaration';
    }

    function trailingStatement(node) {
        switch (node.type) {
        case 'IfStatement':
            if (node.alternate != null) {
                return node.alternate;
            }
            return node.consequent;

        case 'LabeledStatement':
        case 'ForStatement':
        case 'ForInStatement':
        case 'WhileStatement':
        case 'WithStatement':
            return node.body;
        }
        return null;
    }

    function isProblematicIfStatement(node) {
        var current;

        if (node.type !== 'IfStatement') {
            return false;
        }
        if (node.alternate == null) {
            return false;
        }
        current = node.consequent;
        do {
            if (current.type === 'IfStatement') {
                if (current.alternate == null)  {
                    return true;
                }
            }
            current = trailingStatement(current);
        } while (current);

        return false;
    }

    module.exports = {
        isExpression: isExpression,
        isStatement: isStatement,
        isIterationStatement: isIterationStatement,
        isSourceElement: isSourceElement,
        isProblematicIfStatement: isProblematicIfStatement,

        trailingStatement: trailingStatement
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],22:[function(require,module,exports){
/*
  Copyright (C) 2013-2014 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch;

    // See `tools/generate-identifier-regex.js`.
    ES5Regex = {
        // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierStart:
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
        // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierPart:
        NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
    };

    ES6Regex = {
        // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierStart:
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
        // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierPart:
        NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
    };

    function isDecimalDigit(ch) {
        return 0x30 <= ch && ch <= 0x39;  // 0..9
    }

    function isHexDigit(ch) {
        return 0x30 <= ch && ch <= 0x39 ||  // 0..9
            0x61 <= ch && ch <= 0x66 ||     // a..f
            0x41 <= ch && ch <= 0x46;       // A..F
    }

    function isOctalDigit(ch) {
        return ch >= 0x30 && ch <= 0x37;  // 0..7
    }

    // 7.2 White Space

    NON_ASCII_WHITESPACES = [
        0x1680,
        0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A,
        0x202F, 0x205F,
        0x3000,
        0xFEFF
    ];

    function isWhiteSpace(ch) {
        return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 ||
            ch >= 0x1680 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0;
    }

    // 7.3 Line Terminators

    function isLineTerminator(ch) {
        return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;
    }

    // 7.6 Identifier Names and Identifiers

    function fromCodePoint(cp) {
        if (cp <= 0xFFFF) { return String.fromCharCode(cp); }
        var cu1 = String.fromCharCode(Math.floor((cp - 0x10000) / 0x400) + 0xD800);
        var cu2 = String.fromCharCode(((cp - 0x10000) % 0x400) + 0xDC00);
        return cu1 + cu2;
    }

    IDENTIFIER_START = new Array(0x80);
    for(ch = 0; ch < 0x80; ++ch) {
        IDENTIFIER_START[ch] =
            ch >= 0x61 && ch <= 0x7A ||  // a..z
            ch >= 0x41 && ch <= 0x5A ||  // A..Z
            ch === 0x24 || ch === 0x5F;  // $ (dollar) and _ (underscore)
    }

    IDENTIFIER_PART = new Array(0x80);
    for(ch = 0; ch < 0x80; ++ch) {
        IDENTIFIER_PART[ch] =
            ch >= 0x61 && ch <= 0x7A ||  // a..z
            ch >= 0x41 && ch <= 0x5A ||  // A..Z
            ch >= 0x30 && ch <= 0x39 ||  // 0..9
            ch === 0x24 || ch === 0x5F;  // $ (dollar) and _ (underscore)
    }

    function isIdentifierStartES5(ch) {
        return ch < 0x80 ? IDENTIFIER_START[ch] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
    }

    function isIdentifierPartES5(ch) {
        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
    }

    function isIdentifierStartES6(ch) {
        return ch < 0x80 ? IDENTIFIER_START[ch] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
    }

    function isIdentifierPartES6(ch) {
        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
    }

    module.exports = {
        isDecimalDigit: isDecimalDigit,
        isHexDigit: isHexDigit,
        isOctalDigit: isOctalDigit,
        isWhiteSpace: isWhiteSpace,
        isLineTerminator: isLineTerminator,
        isIdentifierStartES5: isIdentifierStartES5,
        isIdentifierPartES5: isIdentifierPartES5,
        isIdentifierStartES6: isIdentifierStartES6,
        isIdentifierPartES6: isIdentifierPartES6
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],23:[function(require,module,exports){
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    var code = require('./code');

    function isStrictModeReservedWordES6(id) {
        switch (id) {
        case 'implements':
        case 'interface':
        case 'package':
        case 'private':
        case 'protected':
        case 'public':
        case 'static':
        case 'let':
            return true;
        default:
            return false;
        }
    }

    function isKeywordES5(id, strict) {
        // yield should not be treated as keyword under non-strict mode.
        if (!strict && id === 'yield') {
            return false;
        }
        return isKeywordES6(id, strict);
    }

    function isKeywordES6(id, strict) {
        if (strict && isStrictModeReservedWordES6(id)) {
            return true;
        }

        switch (id.length) {
        case 2:
            return (id === 'if') || (id === 'in') || (id === 'do');
        case 3:
            return (id === 'var') || (id === 'for') || (id === 'new') || (id === 'try');
        case 4:
            return (id === 'this') || (id === 'else') || (id === 'case') ||
                (id === 'void') || (id === 'with') || (id === 'enum');
        case 5:
            return (id === 'while') || (id === 'break') || (id === 'catch') ||
                (id === 'throw') || (id === 'const') || (id === 'yield') ||
                (id === 'class') || (id === 'super');
        case 6:
            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
                (id === 'switch') || (id === 'export') || (id === 'import');
        case 7:
            return (id === 'default') || (id === 'finally') || (id === 'extends');
        case 8:
            return (id === 'function') || (id === 'continue') || (id === 'debugger');
        case 10:
            return (id === 'instanceof');
        default:
            return false;
        }
    }

    function isReservedWordES5(id, strict) {
        return id === 'null' || id === 'true' || id === 'false' || isKeywordES5(id, strict);
    }

    function isReservedWordES6(id, strict) {
        return id === 'null' || id === 'true' || id === 'false' || isKeywordES6(id, strict);
    }

    function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
    }

    function isIdentifierNameES5(id) {
        var i, iz, ch;

        if (id.length === 0) { return false; }

        ch = id.charCodeAt(0);
        if (!code.isIdentifierStartES5(ch)) {
            return false;
        }

        for (i = 1, iz = id.length; i < iz; ++i) {
            ch = id.charCodeAt(i);
            if (!code.isIdentifierPartES5(ch)) {
                return false;
            }
        }
        return true;
    }

    function decodeUtf16(lead, trail) {
        return (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
    }

    function isIdentifierNameES6(id) {
        var i, iz, ch, lowCh, check;

        if (id.length === 0) { return false; }

        check = code.isIdentifierStartES6;
        for (i = 0, iz = id.length; i < iz; ++i) {
            ch = id.charCodeAt(i);
            if (0xD800 <= ch && ch <= 0xDBFF) {
                ++i;
                if (i >= iz) { return false; }
                lowCh = id.charCodeAt(i);
                if (!(0xDC00 <= lowCh && lowCh <= 0xDFFF)) {
                    return false;
                }
                ch = decodeUtf16(ch, lowCh);
            }
            if (!check(ch)) {
                return false;
            }
            check = code.isIdentifierPartES6;
        }
        return true;
    }

    function isIdentifierES5(id, strict) {
        return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
    }

    function isIdentifierES6(id, strict) {
        return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
    }

    module.exports = {
        isKeywordES5: isKeywordES5,
        isKeywordES6: isKeywordES6,
        isReservedWordES5: isReservedWordES5,
        isReservedWordES6: isReservedWordES6,
        isRestrictedWord: isRestrictedWord,
        isIdentifierNameES5: isIdentifierNameES5,
        isIdentifierNameES6: isIdentifierNameES6,
        isIdentifierES5: isIdentifierES5,
        isIdentifierES6: isIdentifierES6
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{"./code":22}],24:[function(require,module,exports){
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


(function () {
    'use strict';

    exports.ast = require('./ast');
    exports.code = require('./code');
    exports.keyword = require('./keyword');
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{"./ast":21,"./code":22,"./keyword":23}],25:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],26:[function(require,module,exports){
/*jshint node:true */
/* globals define */
/*
  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.

*/

'use strict';

/**
The following batches are equivalent:

var beautify_js = require('js-beautify');
var beautify_js = require('js-beautify').js;
var beautify_js = require('js-beautify').js_beautify;

var beautify_css = require('js-beautify').css;
var beautify_css = require('js-beautify').css_beautify;

var beautify_html = require('js-beautify').html;
var beautify_html = require('js-beautify').html_beautify;

All methods returned accept two arguments, the source string and an options object.
**/

function get_beautify(js_beautify, css_beautify, html_beautify) {
  // the default is js
  var beautify = function(src, config) {
    return js_beautify.js_beautify(src, config);
  };

  // short aliases
  beautify.js = js_beautify.js_beautify;
  beautify.css = css_beautify.css_beautify;
  beautify.html = html_beautify.html_beautify;

  // legacy aliases
  beautify.js_beautify = js_beautify.js_beautify;
  beautify.css_beautify = css_beautify.css_beautify;
  beautify.html_beautify = html_beautify.html_beautify;

  return beautify;
}

if (typeof define === "function" && define.amd) {
  // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )
  define([
    "./lib/beautify",
    "./lib/beautify-css",
    "./lib/beautify-html"
  ], function(js_beautify, css_beautify, html_beautify) {
    return get_beautify(js_beautify, css_beautify, html_beautify);
  });
} else {
  (function(mod) {
    var beautifier = require('./src/index');
    beautifier.js_beautify = beautifier.js;
    beautifier.css_beautify = beautifier.css;
    beautifier.html_beautify = beautifier.html;

    mod.exports = get_beautify(beautifier, beautifier, beautifier);

  })(module);
}
},{"./src/index":44}],27:[function(require,module,exports){
/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

'use strict';

function Directives(start_block_pattern, end_block_pattern) {
  start_block_pattern = typeof start_block_pattern === 'string' ? start_block_pattern : start_block_pattern.source;
  end_block_pattern = typeof end_block_pattern === 'string' ? end_block_pattern : end_block_pattern.source;
  this.__directives_block_pattern = new RegExp(start_block_pattern + / beautify( \w+[:]\w+)+ /.source + end_block_pattern, 'g');
  this.__directive_pattern = / (\w+)[:](\w+)/g;

  this.__directives_end_ignore_pattern = new RegExp(start_block_pattern + /\sbeautify\signore:end\s/.source + end_block_pattern, 'g');
}

Directives.prototype.get_directives = function(text) {
  if (!text.match(this.__directives_block_pattern)) {
    return null;
  }

  var directives = {};
  this.__directive_pattern.lastIndex = 0;
  var directive_match = this.__directive_pattern.exec(text);

  while (directive_match) {
    directives[directive_match[1]] = directive_match[2];
    directive_match = this.__directive_pattern.exec(text);
  }

  return directives;
};

Directives.prototype.readIgnored = function(input) {
  return input.readUntilAfter(this.__directives_end_ignore_pattern);
};


module.exports.Directives = Directives;

},{}],28:[function(require,module,exports){
/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

'use strict';

var regexp_has_sticky = RegExp.prototype.hasOwnProperty('sticky');

function InputScanner(input_string) {
  this.__input = input_string || '';
  this.__input_length = this.__input.length;
  this.__position = 0;
}

InputScanner.prototype.restart = function() {
  this.__position = 0;
};

InputScanner.prototype.back = function() {
  if (this.__position > 0) {
    this.__position -= 1;
  }
};

InputScanner.prototype.hasNext = function() {
  return this.__position < this.__input_length;
};

InputScanner.prototype.next = function() {
  var val = null;
  if (this.hasNext()) {
    val = this.__input.charAt(this.__position);
    this.__position += 1;
  }
  return val;
};

InputScanner.prototype.peek = function(index) {
  var val = null;
  index = index || 0;
  index += this.__position;
  if (index >= 0 && index < this.__input_length) {
    val = this.__input.charAt(index);
  }
  return val;
};

// This is a JavaScript only helper function (not in python)
// Javascript doesn't have a match method
// and not all implementation support "sticky" flag.
// If they do not support sticky then both this.match() and this.test() method
// must get the match and check the index of the match.
// If sticky is supported and set, this method will use it.
// Otherwise it will check that global is set, and fall back to the slower method.
InputScanner.prototype.__match = function(pattern, index) {
  pattern.lastIndex = index;
  var pattern_match = pattern.exec(this.__input);

  if (pattern_match && !(regexp_has_sticky && pattern.sticky)) {
    if (pattern_match.index !== index) {
      pattern_match = null;
    }
  }

  return pattern_match;
};

InputScanner.prototype.test = function(pattern, index) {
  index = index || 0;
  index += this.__position;

  if (index >= 0 && index < this.__input_length) {
    return !!this.__match(pattern, index);
  } else {
    return false;
  }
};

InputScanner.prototype.testChar = function(pattern, index) {
  // test one character regex match
  var val = this.peek(index);
  pattern.lastIndex = 0;
  return val !== null && pattern.test(val);
};

InputScanner.prototype.match = function(pattern) {
  var pattern_match = this.__match(pattern, this.__position);
  if (pattern_match) {
    this.__position += pattern_match[0].length;
  } else {
    pattern_match = null;
  }
  return pattern_match;
};

InputScanner.prototype.read = function(starting_pattern, until_pattern, until_after) {
  var val = '';
  var match;
  if (starting_pattern) {
    match = this.match(starting_pattern);
    if (match) {
      val += match[0];
    }
  }
  if (until_pattern && (match || !starting_pattern)) {
    val += this.readUntil(until_pattern, until_after);
  }
  return val;
};

InputScanner.prototype.readUntil = function(pattern, until_after) {
  var val = '';
  var match_index = this.__position;
  pattern.lastIndex = this.__position;
  var pattern_match = pattern.exec(this.__input);
  if (pattern_match) {
    match_index = pattern_match.index;
    if (until_after) {
      match_index += pattern_match[0].length;
    }
  } else {
    match_index = this.__input_length;
  }

  val = this.__input.substring(this.__position, match_index);
  this.__position = match_index;
  return val;
};

InputScanner.prototype.readUntilAfter = function(pattern) {
  return this.readUntil(pattern, true);
};

InputScanner.prototype.get_regexp = function(pattern, match_from) {
  var result = null;
  var flags = 'g';
  if (match_from && regexp_has_sticky) {
    flags = 'y';
  }
  // strings are converted to regexp
  if (typeof pattern === "string" && pattern !== '') {
    // result = new RegExp(pattern.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), flags);
    result = new RegExp(pattern, flags);
  } else if (pattern) {
    result = new RegExp(pattern.source, flags);
  }
  return result;
};

InputScanner.prototype.get_literal_regexp = function(literal_string) {
  return RegExp(literal_string.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'));
};

/* css beautifier legacy helpers */
InputScanner.prototype.peekUntilAfter = function(pattern) {
  var start = this.__position;
  var val = this.readUntilAfter(pattern);
  this.__position = start;
  return val;
};

InputScanner.prototype.lookBack = function(testVal) {
  var start = this.__position - 1;
  return start >= testVal.length && this.__input.substring(start - testVal.length, start)
    .toLowerCase() === testVal;
};

module.exports.InputScanner = InputScanner;

},{}],29:[function(require,module,exports){
/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

'use strict';

function Options(options, merge_child_field) {
  this.raw_options = _mergeOpts(options, merge_child_field);

  // Support passing the source text back with no change
  this.disabled = this._get_boolean('disabled');

  this.eol = this._get_characters('eol', 'auto');
  this.end_with_newline = this._get_boolean('end_with_newline');
  this.indent_size = this._get_number('indent_size', 4);
  this.indent_char = this._get_characters('indent_char', ' ');
  this.indent_level = this._get_number('indent_level');

  this.preserve_newlines = this._get_boolean('preserve_newlines', true);
  this.max_preserve_newlines = this._get_number('max_preserve_newlines', 32786);
  if (!this.preserve_newlines) {
    this.max_preserve_newlines = 0;
  }

  this.indent_with_tabs = this._get_boolean('indent_with_tabs', this.indent_char === '\t');
  if (this.indent_with_tabs) {
    this.indent_char = '\t';

    // indent_size behavior changed after 1.8.6
    // It used to be that indent_size would be
    // set to 1 for indent_with_tabs. That is no longer needed and
    // actually doesn't make sense - why not use spaces? Further,
    // that might produce unexpected behavior - tabs being used
    // for single-column alignment. So, when indent_with_tabs is true
    // and indent_size is 1, reset indent_size to 4.
    if (this.indent_size === 1) {
      this.indent_size = 4;
    }
  }

  // Backwards compat with 1.3.x
  this.wrap_line_length = this._get_number('wrap_line_length', this._get_number('max_char'));

  this.indent_empty_lines = this._get_boolean('indent_empty_lines');

  // valid templating languages ['django', 'erb', 'handlebars', 'php']
  // For now, 'auto' = all off for javascript, all on for html (and inline javascript).
  // other values ignored
  this.templating = this._get_selection_list('templating', ['auto', 'none', 'django', 'erb', 'handlebars', 'php'], ['auto']);
}

Options.prototype._get_array = function(name, default_value) {
  var option_value = this.raw_options[name];
  var result = default_value || [];
  if (typeof option_value === 'object') {
    if (option_value !== null && typeof option_value.concat === 'function') {
      result = option_value.concat();
    }
  } else if (typeof option_value === 'string') {
    result = option_value.split(/[^a-zA-Z0-9_\/\-]+/);
  }
  return result;
};

Options.prototype._get_boolean = function(name, default_value) {
  var option_value = this.raw_options[name];
  var result = option_value === undefined ? !!default_value : !!option_value;
  return result;
};

Options.prototype._get_characters = function(name, default_value) {
  var option_value = this.raw_options[name];
  var result = default_value || '';
  if (typeof option_value === 'string') {
    result = option_value.replace(/\\r/, '\r').replace(/\\n/, '\n').replace(/\\t/, '\t');
  }
  return result;
};

Options.prototype._get_number = function(name, default_value) {
  var option_value = this.raw_options[name];
  default_value = parseInt(default_value, 10);
  if (isNaN(default_value)) {
    default_value = 0;
  }
  var result = parseInt(option_value, 10);
  if (isNaN(result)) {
    result = default_value;
  }
  return result;
};

Options.prototype._get_selection = function(name, selection_list, default_value) {
  var result = this._get_selection_list(name, selection_list, default_value);
  if (result.length !== 1) {
    throw new Error(
      "Invalid Option Value: The option '" + name + "' can only be one of the following values:\n" +
      selection_list + "\nYou passed in: '" + this.raw_options[name] + "'");
  }

  return result[0];
};


Options.prototype._get_selection_list = function(name, selection_list, default_value) {
  if (!selection_list || selection_list.length === 0) {
    throw new Error("Selection list cannot be empty.");
  }

  default_value = default_value || [selection_list[0]];
  if (!this._is_valid_selection(default_value, selection_list)) {
    throw new Error("Invalid Default Value!");
  }

  var result = this._get_array(name, default_value);
  if (!this._is_valid_selection(result, selection_list)) {
    throw new Error(
      "Invalid Option Value: The option '" + name + "' can contain only the following values:\n" +
      selection_list + "\nYou passed in: '" + this.raw_options[name] + "'");
  }

  return result;
};

Options.prototype._is_valid_selection = function(result, selection_list) {
  return result.length && selection_list.length &&
    !result.some(function(item) { return selection_list.indexOf(item) === -1; });
};


// merges child options up with the parent options object
// Example: obj = {a: 1, b: {a: 2}}
//          mergeOpts(obj, 'b')
//
//          Returns: {a: 2}
function _mergeOpts(allOptions, childFieldName) {
  var finalOpts = {};
  allOptions = _normalizeOpts(allOptions);
  var name;

  for (name in allOptions) {
    if (name !== childFieldName) {
      finalOpts[name] = allOptions[name];
    }
  }

  //merge in the per type settings for the childFieldName
  if (childFieldName && allOptions[childFieldName]) {
    for (name in allOptions[childFieldName]) {
      finalOpts[name] = allOptions[childFieldName][name];
    }
  }
  return finalOpts;
}

function _normalizeOpts(options) {
  var convertedOpts = {};
  var key;

  for (key in options) {
    var newKey = key.replace(/-/g, "_");
    convertedOpts[newKey] = options[key];
  }
  return convertedOpts;
}

module.exports.Options = Options;
module.exports.normalizeOpts = _normalizeOpts;
module.exports.mergeOpts = _mergeOpts;

},{}],30:[function(require,module,exports){
/*jshint node:true */
/*
  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

'use strict';

function OutputLine(parent) {
  this.__parent = parent;
  this.__character_count = 0;
  // use indent_count as a marker for this.__lines that have preserved indentation
  this.__indent_count = -1;
  this.__alignment_count = 0;
  this.__wrap_point_index = 0;
  this.__wrap_point_character_count = 0;
  this.__wrap_point_indent_count = -1;
  this.__wrap_point_alignment_count = 0;

  this.__items = [];
}

OutputLine.prototype.clone_empty = function() {
  var line = new OutputLine(this.__parent);
  line.set_indent(this.__indent_count, this.__alignment_count);
  return line;
};

OutputLine.prototype.item = function(index) {
  if (index < 0) {
    return this.__items[this.__items.length + index];
  } else {
    return this.__items[index];
  }
};

OutputLine.prototype.has_match = function(pattern) {
  for (var lastCheckedOutput = this.__items.length - 1; lastCheckedOutput >= 0; lastCheckedOutput--) {
    if (this.__items[lastCheckedOutput].match(pattern)) {
      return true;
    }
  }
  return false;
};

OutputLine.prototype.set_indent = function(indent, alignment) {
  if (this.is_empty()) {
    this.__indent_count = indent || 0;
    this.__alignment_count = alignment || 0;
    this.__character_count = this.__parent.get_indent_size(this.__indent_count, this.__alignment_count);
  }
};

OutputLine.prototype._set_wrap_point = function() {
  if (this.__parent.wrap_line_length) {
    this.__wrap_point_index = this.__items.length;
    this.__wrap_point_character_count = this.__character_count;
    this.__wrap_point_indent_count = this.__parent.next_line.__indent_count;
    this.__wrap_point_alignment_count = this.__parent.next_line.__alignment_count;
  }
};

OutputLine.prototype._should_wrap = function() {
  return this.__wrap_point_index &&
    this.__character_count > this.__parent.wrap_line_length &&
    this.__wrap_point_character_count > this.__parent.next_line.__character_count;
};

OutputLine.prototype._allow_wrap = function() {
  if (this._should_wrap()) {
    this.__parent.add_new_line();
    var next = this.__parent.current_line;
    next.set_indent(this.__wrap_point_indent_count, this.__wrap_point_alignment_count);
    next.__items = this.__items.slice(this.__wrap_point_index);
    this.__items = this.__items.slice(0, this.__wrap_point_index);

    next.__character_count += this.__character_count - this.__wrap_point_character_count;
    this.__character_count = this.__wrap_point_character_count;

    if (next.__items[0] === " ") {
      next.__items.splice(0, 1);
      next.__character_count -= 1;
    }
    return true;
  }
  return false;
};

OutputLine.prototype.is_empty = function() {
  return this.__items.length === 0;
};

OutputLine.prototype.last = function() {
  if (!this.is_empty()) {
    return this.__items[this.__items.length - 1];
  } else {
    return null;
  }
};

OutputLine.prototype.push = function(item) {
  this.__items.push(item);
  var last_newline_index = item.lastIndexOf('\n');
  if (last_newline_index !== -1) {
    this.__character_count = item.length - last_newline_index;
  } else {
    this.__character_count += item.length;
  }
};

OutputLine.prototype.pop = function() {
  var item = null;
  if (!this.is_empty()) {
    item = this.__items.pop();
    this.__character_count -= item.length;
  }
  return item;
};


OutputLine.prototype._remove_indent = function() {
  if (this.__indent_count > 0) {
    this.__indent_count -= 1;
    this.__character_count -= this.__parent.indent_size;
  }
};

OutputLine.prototype._remove_wrap_indent = function() {
  if (this.__wrap_point_indent_count > 0) {
    this.__wrap_point_indent_count -= 1;
  }
};
OutputLine.prototype.trim = function() {
  while (this.last() === ' ') {
    this.__items.pop();
    this.__character_count -= 1;
  }
};

OutputLine.prototype.toString = function() {
  var result = '';
  if (this.is_empty()) {
    if (this.__parent.indent_empty_lines) {
      result = this.__parent.get_indent_string(this.__indent_count);
    }
  } else {
    result = this.__parent.get_indent_string(this.__indent_count, this.__alignment_count);
    result += this.__items.join('');
  }
  return result;
};

function IndentStringCache(options, baseIndentString) {
  this.__cache = [''];
  this.__indent_size = options.indent_size;
  this.__indent_string = options.indent_char;
  if (!options.indent_with_tabs) {
    this.__indent_string = new Array(options.indent_size + 1).join(options.indent_char);
  }

  // Set to null to continue support for auto detection of base indent
  baseIndentString = baseIndentString || '';
  if (options.indent_level > 0) {
    baseIndentString = new Array(options.indent_level + 1).join(this.__indent_string);
  }

  this.__base_string = baseIndentString;
  this.__base_string_length = baseIndentString.length;
}

IndentStringCache.prototype.get_indent_size = function(indent, column) {
  var result = this.__base_string_length;
  column = column || 0;
  if (indent < 0) {
    result = 0;
  }
  result += indent * this.__indent_size;
  result += column;
  return result;
};

IndentStringCache.prototype.get_indent_string = function(indent_level, column) {
  var result = this.__base_string;
  column = column || 0;
  if (indent_level < 0) {
    indent_level = 0;
    result = '';
  }
  column += indent_level * this.__indent_size;
  this.__ensure_cache(column);
  result += this.__cache[column];
  return result;
};

IndentStringCache.prototype.__ensure_cache = function(column) {
  while (column >= this.__cache.length) {
    this.__add_column();
  }
};

IndentStringCache.prototype.__add_column = function() {
  var column = this.__cache.length;
  var indent = 0;
  var result = '';
  if (this.__indent_size && column >= this.__indent_size) {
    indent = Math.floor(column / this.__indent_size);
    column -= indent * this.__indent_size;
    result = new Array(indent + 1).join(this.__indent_string);
  }
  if (column) {
    result += new Array(column + 1).join(' ');
  }

  this.__cache.push(result);
};

function Output(options, baseIndentString) {
  this.__indent_cache = new IndentStringCache(options, baseIndentString);
  this.raw = false;
  this._end_with_newline = options.end_with_newline;
  this.indent_size = options.indent_size;
  this.wrap_line_length = options.wrap_line_length;
  this.indent_empty_lines = options.indent_empty_lines;
  this.__lines = [];
  this.previous_line = null;
  this.current_line = null;
  this.next_line = new OutputLine(this);
  this.space_before_token = false;
  this.non_breaking_space = false;
  this.previous_token_wrapped = false;
  // initialize
  this.__add_outputline();
}

Output.prototype.__add_outputline = function() {
  this.previous_line = this.current_line;
  this.current_line = this.next_line.clone_empty();
  this.__lines.push(this.current_line);
};

Output.prototype.get_line_number = function() {
  return this.__lines.length;
};

Output.prototype.get_indent_string = function(indent, column) {
  return this.__indent_cache.get_indent_string(indent, column);
};

Output.prototype.get_indent_size = function(indent, column) {
  return this.__indent_cache.get_indent_size(indent, column);
};

Output.prototype.is_empty = function() {
  return !this.previous_line && this.current_line.is_empty();
};

Output.prototype.add_new_line = function(force_newline) {
  // never newline at the start of file
  // otherwise, newline only if we didn't just add one or we're forced
  if (this.is_empty() ||
    (!force_newline && this.just_added_newline())) {
    return false;
  }

  // if raw output is enabled, don't print additional newlines,
  // but still return True as though you had
  if (!this.raw) {
    this.__add_outputline();
  }
  return true;
};

Output.prototype.get_code = function(eol) {
  this.trim(true);

  // handle some edge cases where the last tokens
  // has text that ends with newline(s)
  var last_item = this.current_line.pop();
  if (last_item) {
    if (last_item[last_item.length - 1] === '\n') {
      last_item = last_item.replace(/\n+$/g, '');
    }
    this.current_line.push(last_item);
  }

  if (this._end_with_newline) {
    this.__add_outputline();
  }

  var sweet_code = this.__lines.join('\n');

  if (eol !== '\n') {
    sweet_code = sweet_code.replace(/[\n]/g, eol);
  }
  return sweet_code;
};

Output.prototype.set_wrap_point = function() {
  this.current_line._set_wrap_point();
};

Output.prototype.set_indent = function(indent, alignment) {
  indent = indent || 0;
  alignment = alignment || 0;

  // Next line stores alignment values
  this.next_line.set_indent(indent, alignment);

  // Never indent your first output indent at the start of the file
  if (this.__lines.length > 1) {
    this.current_line.set_indent(indent, alignment);
    return true;
  }

  this.current_line.set_indent();
  return false;
};

Output.prototype.add_raw_token = function(token) {
  for (var x = 0; x < token.newlines; x++) {
    this.__add_outputline();
  }
  this.current_line.set_indent(-1);
  this.current_line.push(token.whitespace_before);
  this.current_line.push(token.text);
  this.space_before_token = false;
  this.non_breaking_space = false;
  this.previous_token_wrapped = false;
};

Output.prototype.add_token = function(printable_token) {
  this.__add_space_before_token();
  this.current_line.push(printable_token);
  this.space_before_token = false;
  this.non_breaking_space = false;
  this.previous_token_wrapped = this.current_line._allow_wrap();
};

Output.prototype.__add_space_before_token = function() {
  if (this.space_before_token && !this.just_added_newline()) {
    if (!this.non_breaking_space) {
      this.set_wrap_point();
    }
    this.current_line.push(' ');
  }
};

Output.prototype.remove_indent = function(index) {
  var output_length = this.__lines.length;
  while (index < output_length) {
    this.__lines[index]._remove_indent();
    index++;
  }
  this.current_line._remove_wrap_indent();
};

Output.prototype.trim = function(eat_newlines) {
  eat_newlines = (eat_newlines === undefined) ? false : eat_newlines;

  this.current_line.trim();

  while (eat_newlines && this.__lines.length > 1 &&
    this.current_line.is_empty()) {
    this.__lines.pop();
    this.current_line = this.__lines[this.__lines.length - 1];
    this.current_line.trim();
  }

  this.previous_line = this.__lines.length > 1 ?
    this.__lines[this.__lines.length - 2] : null;
};

Output.prototype.just_added_newline = function() {
  return this.current_line.is_empty();
};

Output.prototype.just_added_blankline = function() {
  return this.is_empty() ||
    (this.current_line.is_empty() && this.previous_line.is_empty());
};

Output.prototype.ensure_empty_line_above = function(starts_with, ends_with) {
  var index = this.__lines.length - 2;
  while (index >= 0) {
    var potentialEmptyLine = this.__lines[index];
    if (potentialEmptyLine.is_empty()) {
      break;
    } else if (potentialEmptyLine.item(0).indexOf(starts_with) !== 0 &&
      potentialEmptyLine.item(-1) !== ends_with) {
      this.__lines.splice(index + 1, 0, new OutputLine(this));
      this.previous_line = this.__lines[this.__lines.length - 2];
      break;
    }
    index--;
  }
};

module.exports.Output = Output;

},{}],31:[function(require,module,exports){
/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

'use strict';

function Pattern(input_scanner, parent) {
  this._input = input_scanner;
  this._starting_pattern = null;
  this._match_pattern = null;
  this._until_pattern = null;
  this._until_after = false;

  if (parent) {
    this._starting_pattern = this._input.get_regexp(parent._starting_pattern, true);
    this._match_pattern = this._input.get_regexp(parent._match_pattern, true);
    this._until_pattern = this._input.get_regexp(parent._until_pattern);
    this._until_after = parent._until_after;
  }
}

Pattern.prototype.read = function() {
  var result = this._input.read(this._starting_pattern);
  if (!this._starting_pattern || result) {
    result += this._input.read(this._match_pattern, this._until_pattern, this._until_after);
  }
  return result;
};

Pattern.prototype.read_match = function() {
  return this._input.match(this._match_pattern);
};

Pattern.prototype.until_after = function(pattern) {
  var result = this._create();
  result._until_after = true;
  result._until_pattern = this._input.get_regexp(pattern);
  result._update();
  return result;
};

Pattern.prototype.until = function(pattern) {
  var result = this._create();
  result._until_after = false;
  result._until_pattern = this._input.get_regexp(pattern);
  result._update();
  return result;
};

Pattern.prototype.starting_with = function(pattern) {
  var result = this._create();
  result._starting_pattern = this._input.get_regexp(pattern, true);
  result._update();
  return result;
};

Pattern.prototype.matching = function(pattern) {
  var result = this._create();
  result._match_pattern = this._input.get_regexp(pattern, true);
  result._update();
  return result;
};

Pattern.prototype._create = function() {
  return new Pattern(this._input, this);
};

Pattern.prototype._update = function() {};

module.exports.Pattern = Pattern;

},{}],32:[function(require,module,exports){
/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

'use strict';

var Pattern = require('./pattern').Pattern;


var template_names = {
  django: false,
  erb: false,
  handlebars: false,
  php: false
};

// This lets templates appear anywhere we would do a readUntil
// The cost is higher but it is pay to play.
function TemplatablePattern(input_scanner, parent) {
  Pattern.call(this, input_scanner, parent);
  this.__template_pattern = null;
  this._disabled = Object.assign({}, template_names);
  this._excluded = Object.assign({}, template_names);

  if (parent) {
    this.__template_pattern = this._input.get_regexp(parent.__template_pattern);
    this._excluded = Object.assign(this._excluded, parent._excluded);
    this._disabled = Object.assign(this._disabled, parent._disabled);
  }
  var pattern = new Pattern(input_scanner);
  this.__patterns = {
    handlebars_comment: pattern.starting_with(/{{!--/).until_after(/--}}/),
    handlebars_unescaped: pattern.starting_with(/{{{/).until_after(/}}}/),
    handlebars: pattern.starting_with(/{{/).until_after(/}}/),
    php: pattern.starting_with(/<\?(?:[=]|php)/).until_after(/\?>/),
    erb: pattern.starting_with(/<%[^%]/).until_after(/[^%]%>/),
    // django coflicts with handlebars a bit.
    django: pattern.starting_with(/{%/).until_after(/%}/),
    django_value: pattern.starting_with(/{{/).until_after(/}}/),
    django_comment: pattern.starting_with(/{#/).until_after(/#}/)
  };
}
TemplatablePattern.prototype = new Pattern();

TemplatablePattern.prototype._create = function() {
  return new TemplatablePattern(this._input, this);
};

TemplatablePattern.prototype._update = function() {
  this.__set_templated_pattern();
};

TemplatablePattern.prototype.disable = function(language) {
  var result = this._create();
  result._disabled[language] = true;
  result._update();
  return result;
};

TemplatablePattern.prototype.read_options = function(options) {
  var result = this._create();
  for (var language in template_names) {
    result._disabled[language] = options.templating.indexOf(language) === -1;
  }
  result._update();
  return result;
};

TemplatablePattern.prototype.exclude = function(language) {
  var result = this._create();
  result._excluded[language] = true;
  result._update();
  return result;
};

TemplatablePattern.prototype.read = function() {
  var result = '';
  if (this._match_pattern) {
    result = this._input.read(this._starting_pattern);
  } else {
    result = this._input.read(this._starting_pattern, this.__template_pattern);
  }
  var next = this._read_template();
  while (next) {
    if (this._match_pattern) {
      next += this._input.read(this._match_pattern);
    } else {
      next += this._input.readUntil(this.__template_pattern);
    }
    result += next;
    next = this._read_template();
  }

  if (this._until_after) {
    result += this._input.readUntilAfter(this._until_pattern);
  }
  return result;
};

TemplatablePattern.prototype.__set_templated_pattern = function() {
  var items = [];

  if (!this._disabled.php) {
    items.push(this.__patterns.php._starting_pattern.source);
  }
  if (!this._disabled.handlebars) {
    items.push(this.__patterns.handlebars._starting_pattern.source);
  }
  if (!this._disabled.erb) {
    items.push(this.__patterns.erb._starting_pattern.source);
  }
  if (!this._disabled.django) {
    items.push(this.__patterns.django._starting_pattern.source);
    items.push(this.__patterns.django_value._starting_pattern.source);
    items.push(this.__patterns.django_comment._starting_pattern.source);
  }

  if (this._until_pattern) {
    items.push(this._until_pattern.source);
  }
  this.__template_pattern = this._input.get_regexp('(?:' + items.join('|') + ')');
};

TemplatablePattern.prototype._read_template = function() {
  var resulting_string = '';
  var c = this._input.peek();
  if (c === '<') {
    var peek1 = this._input.peek(1);
    //if we're in a comment, do something special
    // We treat all comments as literals, even more than preformatted tags
    // we just look for the appropriate close tag
    if (!this._disabled.php && !this._excluded.php && peek1 === '?') {
      resulting_string = resulting_string ||
        this.__patterns.php.read();
    }
    if (!this._disabled.erb && !this._excluded.erb && peek1 === '%') {
      resulting_string = resulting_string ||
        this.__patterns.erb.read();
    }
  } else if (c === '{') {
    if (!this._disabled.handlebars && !this._excluded.handlebars) {
      resulting_string = resulting_string ||
        this.__patterns.handlebars_comment.read();
      resulting_string = resulting_string ||
        this.__patterns.handlebars_unescaped.read();
      resulting_string = resulting_string ||
        this.__patterns.handlebars.read();
    }
    if (!this._disabled.django) {
      // django coflicts with handlebars a bit.
      if (!this._excluded.django && !this._excluded.handlebars) {
        resulting_string = resulting_string ||
          this.__patterns.django_value.read();
      }
      if (!this._excluded.django) {
        resulting_string = resulting_string ||
          this.__patterns.django_comment.read();
        resulting_string = resulting_string ||
          this.__patterns.django.read();
      }
    }
  }
  return resulting_string;
};


module.exports.TemplatablePattern = TemplatablePattern;

},{"./pattern":31}],33:[function(require,module,exports){
/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

'use strict';

function Token(type, text, newlines, whitespace_before) {
  this.type = type;
  this.text = text;

  // comments_before are
  // comments that have a new line before them
  // and may or may not have a newline after
  // this is a set of comments before
  this.comments_before = null; /* inline comment*/


  // this.comments_after =  new TokenStream(); // no new line before and newline after
  this.newlines = newlines || 0;
  this.whitespace_before = whitespace_before || '';
  this.parent = null;
  this.next = null;
  this.previous = null;
  this.opened = null;
  this.closed = null;
  this.directives = null;
}


module.exports.Token = Token;

},{}],34:[function(require,module,exports){
/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

'use strict';

var InputScanner = require('../core/inputscanner').InputScanner;
var Token = require('../core/token').Token;
var TokenStream = require('../core/tokenstream').TokenStream;
var WhitespacePattern = require('./whitespacepattern').WhitespacePattern;

var TOKEN = {
  START: 'TK_START',
  RAW: 'TK_RAW',
  EOF: 'TK_EOF'
};

var Tokenizer = function(input_string, options) {
  this._input = new InputScanner(input_string);
  this._options = options || {};
  this.__tokens = null;

  this._patterns = {};
  this._patterns.whitespace = new WhitespacePattern(this._input);
};

Tokenizer.prototype.tokenize = function() {
  this._input.restart();
  this.__tokens = new TokenStream();

  this._reset();

  var current;
  var previous = new Token(TOKEN.START, '');
  var open_token = null;
  var open_stack = [];
  var comments = new TokenStream();

  while (previous.type !== TOKEN.EOF) {
    current = this._get_next_token(previous, open_token);
    while (this._is_comment(current)) {
      comments.add(current);
      current = this._get_next_token(previous, open_token);
    }

    if (!comments.isEmpty()) {
      current.comments_before = comments;
      comments = new TokenStream();
    }

    current.parent = open_token;

    if (this._is_opening(current)) {
      open_stack.push(open_token);
      open_token = current;
    } else if (open_token && this._is_closing(current, open_token)) {
      current.opened = open_token;
      open_token.closed = current;
      open_token = open_stack.pop();
      current.parent = open_token;
    }

    current.previous = previous;
    previous.next = current;

    this.__tokens.add(current);
    previous = current;
  }

  return this.__tokens;
};


Tokenizer.prototype._is_first_token = function() {
  return this.__tokens.isEmpty();
};

Tokenizer.prototype._reset = function() {};

Tokenizer.prototype._get_next_token = function(previous_token, open_token) { // jshint unused:false
  this._readWhitespace();
  var resulting_string = this._input.read(/.+/g);
  if (resulting_string) {
    return this._create_token(TOKEN.RAW, resulting_string);
  } else {
    return this._create_token(TOKEN.EOF, '');
  }
};

Tokenizer.prototype._is_comment = function(current_token) { // jshint unused:false
  return false;
};

Tokenizer.prototype._is_opening = function(current_token) { // jshint unused:false
  return false;
};

Tokenizer.prototype._is_closing = function(current_token, open_token) { // jshint unused:false
  return false;
};

Tokenizer.prototype._create_token = function(type, text) {
  var token = new Token(type, text,
    this._patterns.whitespace.newline_count,
    this._patterns.whitespace.whitespace_before_token);
  return token;
};

Tokenizer.prototype._readWhitespace = function() {
  return this._patterns.whitespace.read();
};



module.exports.Tokenizer = Tokenizer;
module.exports.TOKEN = TOKEN;

},{"../core/inputscanner":28,"../core/token":33,"../core/tokenstream":35,"./whitespacepattern":36}],35:[function(require,module,exports){
/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

'use strict';

function TokenStream(parent_token) {
  // private
  this.__tokens = [];
  this.__tokens_length = this.__tokens.length;
  this.__position = 0;
  this.__parent_token = parent_token;
}

TokenStream.prototype.restart = function() {
  this.__position = 0;
};

TokenStream.prototype.isEmpty = function() {
  return this.__tokens_length === 0;
};

TokenStream.prototype.hasNext = function() {
  return this.__position < this.__tokens_length;
};

TokenStream.prototype.next = function() {
  var val = null;
  if (this.hasNext()) {
    val = this.__tokens[this.__position];
    this.__position += 1;
  }
  return val;
};

TokenStream.prototype.peek = function(index) {
  var val = null;
  index = index || 0;
  index += this.__position;
  if (index >= 0 && index < this.__tokens_length) {
    val = this.__tokens[index];
  }
  return val;
};

TokenStream.prototype.add = function(token) {
  if (this.__parent_token) {
    token.parent = this.__parent_token;
  }
  this.__tokens.push(token);
  this.__tokens_length += 1;
};

module.exports.TokenStream = TokenStream;

},{}],36:[function(require,module,exports){
/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

'use strict';

var Pattern = require('../core/pattern').Pattern;

function WhitespacePattern(input_scanner, parent) {
  Pattern.call(this, input_scanner, parent);
  if (parent) {
    this._line_regexp = this._input.get_regexp(parent._line_regexp);
  } else {
    this.__set_whitespace_patterns('', '');
  }

  this.newline_count = 0;
  this.whitespace_before_token = '';
}
WhitespacePattern.prototype = new Pattern();

WhitespacePattern.prototype.__set_whitespace_patterns = function(whitespace_chars, newline_chars) {
  whitespace_chars += '\\t ';
  newline_chars += '\\n\\r';

  this._match_pattern = this._input.get_regexp(
    '[' + whitespace_chars + newline_chars + ']+', true);
  this._newline_regexp = this._input.get_regexp(
    '\\r\\n|[' + newline_chars + ']');
};

WhitespacePattern.prototype.read = function() {
  this.newline_count = 0;
  this.whitespace_before_token = '';

  var resulting_string = this._input.read(this._match_pattern);
  if (resulting_string === ' ') {
    this.whitespace_before_token = ' ';
  } else if (resulting_string) {
    var matches = this.__split(this._newline_regexp, resulting_string);
    this.newline_count = matches.length - 1;
    this.whitespace_before_token = matches[this.newline_count];
  }

  return resulting_string;
};

WhitespacePattern.prototype.matching = function(whitespace_chars, newline_chars) {
  var result = this._create();
  result.__set_whitespace_patterns(whitespace_chars, newline_chars);
  result._update();
  return result;
};

WhitespacePattern.prototype._create = function() {
  return new WhitespacePattern(this._input, this);
};

WhitespacePattern.prototype.__split = function(regexp, input_string) {
  regexp.lastIndex = 0;
  var start_index = 0;
  var result = [];
  var next_match = regexp.exec(input_string);
  while (next_match) {
    result.push(input_string.substring(start_index, next_match.index));
    start_index = next_match.index + next_match[0].length;
    next_match = regexp.exec(input_string);
  }

  if (start_index < input_string.length) {
    result.push(input_string.substring(start_index, input_string.length));
  } else {
    result.push('');
  }

  return result;
};



module.exports.WhitespacePattern = WhitespacePattern;

},{"../core/pattern":31}],37:[function(require,module,exports){
/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

'use strict';

var Options = require('./options').Options;
var Output = require('../core/output').Output;
var InputScanner = require('../core/inputscanner').InputScanner;
var Directives = require('../core/directives').Directives;

var directives_core = new Directives(/\/\*/, /\*\//);

var lineBreak = /\r\n|[\r\n]/;
var allLineBreaks = /\r\n|[\r\n]/g;

// tokenizer
var whitespaceChar = /\s/;
var whitespacePattern = /(?:\s|\n)+/g;
var block_comment_pattern = /\/\*(?:[\s\S]*?)((?:\*\/)|$)/g;
var comment_pattern = /\/\/(?:[^\n\r\u2028\u2029]*)/g;

function Beautifier(source_text, options) {
  this._source_text = source_text || '';
  // Allow the setting of language/file-type specific options
  // with inheritance of overall settings
  this._options = new Options(options);
  this._ch = null;
  this._input = null;

  // https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule
  this.NESTED_AT_RULE = {
    "@page": true,
    "@font-face": true,
    "@keyframes": true,
    // also in CONDITIONAL_GROUP_RULE below
    "@media": true,
    "@supports": true,
    "@document": true
  };
  this.CONDITIONAL_GROUP_RULE = {
    "@media": true,
    "@supports": true,
    "@document": true
  };

}

Beautifier.prototype.eatString = function(endChars) {
  var result = '';
  this._ch = this._input.next();
  while (this._ch) {
    result += this._ch;
    if (this._ch === "\\") {
      result += this._input.next();
    } else if (endChars.indexOf(this._ch) !== -1 || this._ch === "\n") {
      break;
    }
    this._ch = this._input.next();
  }
  return result;
};

// Skips any white space in the source text from the current position.
// When allowAtLeastOneNewLine is true, will output new lines for each
// newline character found; if the user has preserve_newlines off, only
// the first newline will be output
Beautifier.prototype.eatWhitespace = function(allowAtLeastOneNewLine) {
  var result = whitespaceChar.test(this._input.peek());
  var isFirstNewLine = true;

  while (whitespaceChar.test(this._input.peek())) {
    this._ch = this._input.next();
    if (allowAtLeastOneNewLine && this._ch === '\n') {
      if (this._options.preserve_newlines || isFirstNewLine) {
        isFirstNewLine = false;
        this._output.add_new_line(true);
      }
    }
  }
  return result;
};

// Nested pseudo-class if we are insideRule
// and the next special character found opens
// a new block
Beautifier.prototype.foundNestedPseudoClass = function() {
  var openParen = 0;
  var i = 1;
  var ch = this._input.peek(i);
  while (ch) {
    if (ch === "{") {
      return true;
    } else if (ch === '(') {
      // pseudoclasses can contain ()
      openParen += 1;
    } else if (ch === ')') {
      if (openParen === 0) {
        return false;
      }
      openParen -= 1;
    } else if (ch === ";" || ch === "}") {
      return false;
    }
    i++;
    ch = this._input.peek(i);
  }
  return false;
};

Beautifier.prototype.print_string = function(output_string) {
  this._output.set_indent(this._indentLevel);
  this._output.non_breaking_space = true;
  this._output.add_token(output_string);
};

Beautifier.prototype.preserveSingleSpace = function(isAfterSpace) {
  if (isAfterSpace) {
    this._output.space_before_token = true;
  }
};

Beautifier.prototype.indent = function() {
  this._indentLevel++;
};

Beautifier.prototype.outdent = function() {
  if (this._indentLevel > 0) {
    this._indentLevel--;
  }
};

/*_____________________--------------------_____________________*/

Beautifier.prototype.beautify = function() {
  if (this._options.disabled) {
    return this._source_text;
  }

  var source_text = this._source_text;
  var eol = this._options.eol;
  if (eol === 'auto') {
    eol = '\n';
    if (source_text && lineBreak.test(source_text || '')) {
      eol = source_text.match(lineBreak)[0];
    }
  }


  // HACK: newline parsing inconsistent. This brute force normalizes the this._input.
  source_text = source_text.replace(allLineBreaks, '\n');

  // reset
  var baseIndentString = source_text.match(/^[\t ]*/)[0];

  this._output = new Output(this._options, baseIndentString);
  this._input = new InputScanner(source_text);
  this._indentLevel = 0;
  this._nestedLevel = 0;

  this._ch = null;
  var parenLevel = 0;

  var insideRule = false;
  // This is the value side of a property value pair (blue in the following ex)
  // label { content: blue }
  var insidePropertyValue = false;
  var enteringConditionalGroup = false;
  var insideAtExtend = false;
  var insideAtImport = false;
  var topCharacter = this._ch;
  var whitespace;
  var isAfterSpace;
  var previous_ch;

  while (true) {
    whitespace = this._input.read(whitespacePattern);
    isAfterSpace = whitespace !== '';
    previous_ch = topCharacter;
    this._ch = this._input.next();
    if (this._ch === '\\' && this._input.hasNext()) {
      this._ch += this._input.next();
    }
    topCharacter = this._ch;

    if (!this._ch) {
      break;
    } else if (this._ch === '/' && this._input.peek() === '*') {
      // /* css comment */
      // Always start block comments on a new line.
      // This handles scenarios where a block comment immediately
      // follows a property definition on the same line or where
      // minified code is being beautified.
      this._output.add_new_line();
      this._input.back();

      var comment = this._input.read(block_comment_pattern);

      // Handle ignore directive
      var directives = directives_core.get_directives(comment);
      if (directives && directives.ignore === 'start') {
        comment += directives_core.readIgnored(this._input);
      }

      this.print_string(comment);

      // Ensures any new lines following the comment are preserved
      this.eatWhitespace(true);

      // Block comments are followed by a new line so they don't
      // share a line with other properties
      this._output.add_new_line();
    } else if (this._ch === '/' && this._input.peek() === '/') {
      // // single line comment
      // Preserves the space before a comment
      // on the same line as a rule
      this._output.space_before_token = true;
      this._input.back();
      this.print_string(this._input.read(comment_pattern));

      // Ensures any new lines following the comment are preserved
      this.eatWhitespace(true);
    } else if (this._ch === '@') {
      this.preserveSingleSpace(isAfterSpace);

      // deal with less propery mixins @{...}
      if (this._input.peek() === '{') {
        this.print_string(this._ch + this.eatString('}'));
      } else {
        this.print_string(this._ch);

        // strip trailing space, if present, for hash property checks
        var variableOrRule = this._input.peekUntilAfter(/[: ,;{}()[\]\/='"]/g);

        if (variableOrRule.match(/[ :]$/)) {
          // we have a variable or pseudo-class, add it and insert one space before continuing
          variableOrRule = this.eatString(": ").replace(/\s$/, '');
          this.print_string(variableOrRule);
          this._output.space_before_token = true;
        }

        variableOrRule = variableOrRule.replace(/\s$/, '');

        if (variableOrRule === 'extend') {
          insideAtExtend = true;
        } else if (variableOrRule === 'import') {
          insideAtImport = true;
        }

        // might be a nesting at-rule
        if (variableOrRule in this.NESTED_AT_RULE) {
          this._nestedLevel += 1;
          if (variableOrRule in this.CONDITIONAL_GROUP_RULE) {
            enteringConditionalGroup = true;
          }
          // might be less variable
        } else if (!insideRule && parenLevel === 0 && variableOrRule.indexOf(':') !== -1) {
          insidePropertyValue = true;
          this.indent();
        }
      }
    } else if (this._ch === '#' && this._input.peek() === '{') {
      this.preserveSingleSpace(isAfterSpace);
      this.print_string(this._ch + this.eatString('}'));
    } else if (this._ch === '{') {
      if (insidePropertyValue) {
        insidePropertyValue = false;
        this.outdent();
      }
      this.indent();
      this._output.space_before_token = true;
      this.print_string(this._ch);

      // when entering conditional groups, only rulesets are allowed
      if (enteringConditionalGroup) {
        enteringConditionalGroup = false;
        insideRule = (this._indentLevel > this._nestedLevel);
      } else {
        // otherwise, declarations are also allowed
        insideRule = (this._indentLevel >= this._nestedLevel);
      }
      if (this._options.newline_between_rules && insideRule) {
        if (this._output.previous_line && this._output.previous_line.item(-1) !== '{') {
          this._output.ensure_empty_line_above('/', ',');
        }
      }
      this.eatWhitespace(true);
      this._output.add_new_line();
    } else if (this._ch === '}') {
      this.outdent();
      this._output.add_new_line();
      if (previous_ch === '{') {
        this._output.trim(true);
      }
      insideAtImport = false;
      insideAtExtend = false;
      if (insidePropertyValue) {
        this.outdent();
        insidePropertyValue = false;
      }
      this.print_string(this._ch);
      insideRule = false;
      if (this._nestedLevel) {
        this._nestedLevel--;
      }

      this.eatWhitespace(true);
      this._output.add_new_line();

      if (this._options.newline_between_rules && !this._output.just_added_blankline()) {
        if (this._input.peek() !== '}') {
          this._output.add_new_line(true);
        }
      }
    } else if (this._ch === ":") {
      if ((insideRule || enteringConditionalGroup) && !(this._input.lookBack("&") || this.foundNestedPseudoClass()) && !this._input.lookBack("(") && !insideAtExtend && parenLevel === 0) {
        // 'property: value' delimiter
        // which could be in a conditional group query
        this.print_string(':');
        if (!insidePropertyValue) {
          insidePropertyValue = true;
          this._output.space_before_token = true;
          this.eatWhitespace(true);
          this.indent();
        }
      } else {
        // sass/less parent reference don't use a space
        // sass nested pseudo-class don't use a space

        // preserve space before pseudoclasses/pseudoelements, as it means "in any child"
        if (this._input.lookBack(" ")) {
          this._output.space_before_token = true;
        }
        if (this._input.peek() === ":") {
          // pseudo-element
          this._ch = this._input.next();
          this.print_string("::");
        } else {
          // pseudo-class
          this.print_string(':');
        }
      }
    } else if (this._ch === '"' || this._ch === '\'') {
      this.preserveSingleSpace(isAfterSpace);
      this.print_string(this._ch + this.eatString(this._ch));
      this.eatWhitespace(true);
    } else if (this._ch === ';') {
      if (parenLevel === 0) {
        if (insidePropertyValue) {
          this.outdent();
          insidePropertyValue = false;
        }
        insideAtExtend = false;
        insideAtImport = false;
        this.print_string(this._ch);
        this.eatWhitespace(true);

        // This maintains single line comments on the same
        // line. Block comments are also affected, but
        // a new line is always output before one inside
        // that section
        if (this._input.peek() !== '/') {
          this._output.add_new_line();
        }
      } else {
        this.print_string(this._ch);
        this.eatWhitespace(true);
        this._output.space_before_token = true;
      }
    } else if (this._ch === '(') { // may be a url
      if (this._input.lookBack("url")) {
        this.print_string(this._ch);
        this.eatWhitespace();
        parenLevel++;
        this.indent();
        this._ch = this._input.next();
        if (this._ch === ')' || this._ch === '"' || this._ch === '\'') {
          this._input.back();
        } else if (this._ch) {
          this.print_string(this._ch + this.eatString(')'));
          if (parenLevel) {
            parenLevel--;
            this.outdent();
          }
        }
      } else {
        this.preserveSingleSpace(isAfterSpace);
        this.print_string(this._ch);
        this.eatWhitespace();
        parenLevel++;
        this.indent();
      }
    } else if (this._ch === ')') {
      if (parenLevel) {
        parenLevel--;
        this.outdent();
      }
      this.print_string(this._ch);
    } else if (this._ch === ',') {
      this.print_string(this._ch);
      this.eatWhitespace(true);
      if (this._options.selector_separator_newline && !insidePropertyValue && parenLevel === 0 && !insideAtImport) {
        this._output.add_new_line();
      } else {
        this._output.space_before_token = true;
      }
    } else if ((this._ch === '>' || this._ch === '+' || this._ch === '~') && !insidePropertyValue && parenLevel === 0) {
      //handle combinator spacing
      if (this._options.space_around_combinator) {
        this._output.space_before_token = true;
        this.print_string(this._ch);
        this._output.space_before_token = true;
      } else {
        this.print_string(this._ch);
        this.eatWhitespace();
        // squash extra whitespace
        if (this._ch && whitespaceChar.test(this._ch)) {
          this._ch = '';
        }
      }
    } else if (this._ch === ']') {
      this.print_string(this._ch);
    } else if (this._ch === '[') {
      this.preserveSingleSpace(isAfterSpace);
      this.print_string(this._ch);
    } else if (this._ch === '=') { // no whitespace before or after
      this.eatWhitespace();
      this.print_string('=');
      if (whitespaceChar.test(this._ch)) {
        this._ch = '';
      }
    } else if (this._ch === '!' && !this._input.lookBack("\\")) { // !important
      this.print_string(' ');
      this.print_string(this._ch);
    } else {
      this.preserveSingleSpace(isAfterSpace);
      this.print_string(this._ch);
    }
  }

  var sweetCode = this._output.get_code(eol);

  return sweetCode;
};

module.exports.Beautifier = Beautifier;

},{"../core/directives":27,"../core/inputscanner":28,"../core/output":30,"./options":39}],38:[function(require,module,exports){
/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

'use strict';

var Beautifier = require('./beautifier').Beautifier,
  Options = require('./options').Options;

function css_beautify(source_text, options) {
  var beautifier = new Beautifier(source_text, options);
  return beautifier.beautify();
}

module.exports = css_beautify;
module.exports.defaultOptions = function() {
  return new Options();
};

},{"./beautifier":37,"./options":39}],39:[function(require,module,exports){
/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

'use strict';

var BaseOptions = require('../core/options').Options;

function Options(options) {
  BaseOptions.call(this, options, 'css');

  this.selector_separator_newline = this._get_boolean('selector_separator_newline', true);
  this.newline_between_rules = this._get_boolean('newline_between_rules', true);
  var space_around_selector_separator = this._get_boolean('space_around_selector_separator');
  this.space_around_combinator = this._get_boolean('space_around_combinator') || space_around_selector_separator;

}
Options.prototype = new BaseOptions();



module.exports.Options = Options;

},{"../core/options":29}],40:[function(require,module,exports){
/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

'use strict';

var Options = require('../html/options').Options;
var Output = require('../core/output').Output;
var Tokenizer = require('../html/tokenizer').Tokenizer;
var TOKEN = require('../html/tokenizer').TOKEN;

var lineBreak = /\r\n|[\r\n]/;
var allLineBreaks = /\r\n|[\r\n]/g;

var Printer = function(options, base_indent_string) { //handles input/output and some other printing functions

  this.indent_level = 0;
  this.alignment_size = 0;
  this.max_preserve_newlines = options.max_preserve_newlines;
  this.preserve_newlines = options.preserve_newlines;

  this._output = new Output(options, base_indent_string);

};

Printer.prototype.current_line_has_match = function(pattern) {
  return this._output.current_line.has_match(pattern);
};

Printer.prototype.set_space_before_token = function(value, non_breaking) {
  this._output.space_before_token = value;
  this._output.non_breaking_space = non_breaking;
};

Printer.prototype.set_wrap_point = function() {
  this._output.set_indent(this.indent_level, this.alignment_size);
  this._output.set_wrap_point();
};


Printer.prototype.add_raw_token = function(token) {
  this._output.add_raw_token(token);
};

Printer.prototype.print_preserved_newlines = function(raw_token) {
  var newlines = 0;
  if (raw_token.type !== TOKEN.TEXT && raw_token.previous.type !== TOKEN.TEXT) {
    newlines = raw_token.newlines ? 1 : 0;
  }

  if (this.preserve_newlines) {
    newlines = raw_token.newlines < this.max_preserve_newlines + 1 ? raw_token.newlines : this.max_preserve_newlines + 1;
  }
  for (var n = 0; n < newlines; n++) {
    this.print_newline(n > 0);
  }

  return newlines !== 0;
};

Printer.prototype.traverse_whitespace = function(raw_token) {
  if (raw_token.whitespace_before || raw_token.newlines) {
    if (!this.print_preserved_newlines(raw_token)) {
      this._output.space_before_token = true;
    }
    return true;
  }
  return false;
};

Printer.prototype.previous_token_wrapped = function() {
  return this._output.previous_token_wrapped;
};

Printer.prototype.print_newline = function(force) {
  this._output.add_new_line(force);
};

Printer.prototype.print_token = function(token) {
  if (token.text) {
    this._output.set_indent(this.indent_level, this.alignment_size);
    this._output.add_token(token.text);
  }
};

Printer.prototype.indent = function() {
  this.indent_level++;
};

Printer.prototype.get_full_indent = function(level) {
  level = this.indent_level + (level || 0);
  if (level < 1) {
    return '';
  }

  return this._output.get_indent_string(level);
};

var get_type_attribute = function(start_token) {
  var result = null;
  var raw_token = start_token.next;

  // Search attributes for a type attribute
  while (raw_token.type !== TOKEN.EOF && start_token.closed !== raw_token) {
    if (raw_token.type === TOKEN.ATTRIBUTE && raw_token.text === 'type') {
      if (raw_token.next && raw_token.next.type === TOKEN.EQUALS &&
        raw_token.next.next && raw_token.next.next.type === TOKEN.VALUE) {
        result = raw_token.next.next.text;
      }
      break;
    }
    raw_token = raw_token.next;
  }

  return result;
};

var get_custom_beautifier_name = function(tag_check, raw_token) {
  var typeAttribute = null;
  var result = null;

  if (!raw_token.closed) {
    return null;
  }

  if (tag_check === 'script') {
    typeAttribute = 'text/javascript';
  } else if (tag_check === 'style') {
    typeAttribute = 'text/css';
  }

  typeAttribute = get_type_attribute(raw_token) || typeAttribute;

  // For script and style tags that have a type attribute, only enable custom beautifiers for matching values
  // For those without a type attribute use default;
  if (typeAttribute.search('text/css') > -1) {
    result = 'css';
  } else if (typeAttribute.search(/(text|application|dojo)\/(x-)?(javascript|ecmascript|jscript|livescript|(ld\+)?json|method|aspect)/) > -1) {
    result = 'javascript';
  } else if (typeAttribute.search(/(text|application|dojo)\/(x-)?(html)/) > -1) {
    result = 'html';
  } else if (typeAttribute.search(/test\/null/) > -1) {
    // Test only mime-type for testing the beautifier when null is passed as beautifing function
    result = 'null';
  }

  return result;
};

function in_array(what, arr) {
  return arr.indexOf(what) !== -1;
}

function TagFrame(parent, parser_token, indent_level) {
  this.parent = parent || null;
  this.tag = parser_token ? parser_token.tag_name : '';
  this.indent_level = indent_level || 0;
  this.parser_token = parser_token || null;
}

function TagStack(printer) {
  this._printer = printer;
  this._current_frame = null;
}

TagStack.prototype.get_parser_token = function() {
  return this._current_frame ? this._current_frame.parser_token : null;
};

TagStack.prototype.record_tag = function(parser_token) { //function to record a tag and its parent in this.tags Object
  var new_frame = new TagFrame(this._current_frame, parser_token, this._printer.indent_level);
  this._current_frame = new_frame;
};

TagStack.prototype._try_pop_frame = function(frame) { //function to retrieve the opening tag to the corresponding closer
  var parser_token = null;

  if (frame) {
    parser_token = frame.parser_token;
    this._printer.indent_level = frame.indent_level;
    this._current_frame = frame.parent;
  }

  return parser_token;
};

TagStack.prototype._get_frame = function(tag_list, stop_list) { //function to retrieve the opening tag to the corresponding closer
  var frame = this._current_frame;

  while (frame) { //till we reach '' (the initial value);
    if (tag_list.indexOf(frame.tag) !== -1) { //if this is it use it
      break;
    } else if (stop_list && stop_list.indexOf(frame.tag) !== -1) {
      frame = null;
      break;
    }
    frame = frame.parent;
  }

  return frame;
};

TagStack.prototype.try_pop = function(tag, stop_list) { //function to retrieve the opening tag to the corresponding closer
  var frame = this._get_frame([tag], stop_list);
  return this._try_pop_frame(frame);
};

TagStack.prototype.indent_to_tag = function(tag_list) {
  var frame = this._get_frame(tag_list);
  if (frame) {
    this._printer.indent_level = frame.indent_level;
  }
};

function Beautifier(source_text, options, js_beautify, css_beautify) {
  //Wrapper function to invoke all the necessary constructors and deal with the output.
  this._source_text = source_text || '';
  options = options || {};
  this._js_beautify = js_beautify;
  this._css_beautify = css_beautify;
  this._tag_stack = null;

  // Allow the setting of language/file-type specific options
  // with inheritance of overall settings
  var optionHtml = new Options(options, 'html');

  this._options = optionHtml;

  this._is_wrap_attributes_force = this._options.wrap_attributes.substr(0, 'force'.length) === 'force';
  this._is_wrap_attributes_force_expand_multiline = (this._options.wrap_attributes === 'force-expand-multiline');
  this._is_wrap_attributes_force_aligned = (this._options.wrap_attributes === 'force-aligned');
  this._is_wrap_attributes_aligned_multiple = (this._options.wrap_attributes === 'aligned-multiple');
  this._is_wrap_attributes_preserve = this._options.wrap_attributes.substr(0, 'preserve'.length) === 'preserve';
  this._is_wrap_attributes_preserve_aligned = (this._options.wrap_attributes === 'preserve-aligned');
}

Beautifier.prototype.beautify = function() {

  // if disabled, return the input unchanged.
  if (this._options.disabled) {
    return this._source_text;
  }

  var source_text = this._source_text;
  var eol = this._options.eol;
  if (this._options.eol === 'auto') {
    eol = '\n';
    if (source_text && lineBreak.test(source_text)) {
      eol = source_text.match(lineBreak)[0];
    }
  }

  // HACK: newline parsing inconsistent. This brute force normalizes the input.
  source_text = source_text.replace(allLineBreaks, '\n');

  var baseIndentString = source_text.match(/^[\t ]*/)[0];

  var last_token = {
    text: '',
    type: ''
  };

  var last_tag_token = new TagOpenParserToken();

  var printer = new Printer(this._options, baseIndentString);
  var tokens = new Tokenizer(source_text, this._options).tokenize();

  this._tag_stack = new TagStack(printer);

  var parser_token = null;
  var raw_token = tokens.next();
  while (raw_token.type !== TOKEN.EOF) {

    if (raw_token.type === TOKEN.TAG_OPEN || raw_token.type === TOKEN.COMMENT) {
      parser_token = this._handle_tag_open(printer, raw_token, last_tag_token, last_token);
      last_tag_token = parser_token;
    } else if ((raw_token.type === TOKEN.ATTRIBUTE || raw_token.type === TOKEN.EQUALS || raw_token.type === TOKEN.VALUE) ||
      (raw_token.type === TOKEN.TEXT && !last_tag_token.tag_complete)) {
      parser_token = this._handle_inside_tag(printer, raw_token, last_tag_token, tokens);
    } else if (raw_token.type === TOKEN.TAG_CLOSE) {
      parser_token = this._handle_tag_close(printer, raw_token, last_tag_token);
    } else if (raw_token.type === TOKEN.TEXT) {
      parser_token = this._handle_text(printer, raw_token, last_tag_token);
    } else {
      // This should never happen, but if it does. Print the raw token
      printer.add_raw_token(raw_token);
    }

    last_token = parser_token;

    raw_token = tokens.next();
  }
  var sweet_code = printer._output.get_code(eol);

  return sweet_code;
};

Beautifier.prototype._handle_tag_close = function(printer, raw_token, last_tag_token) {
  var parser_token = {
    text: raw_token.text,
    type: raw_token.type
  };
  printer.alignment_size = 0;
  last_tag_token.tag_complete = true;

  printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== '', true);
  if (last_tag_token.is_unformatted) {
    printer.add_raw_token(raw_token);
  } else {
    if (last_tag_token.tag_start_char === '<') {
      printer.set_space_before_token(raw_token.text[0] === '/', true); // space before />, no space before >
      if (this._is_wrap_attributes_force_expand_multiline && last_tag_token.has_wrapped_attrs) {
        printer.print_newline(false);
      }
    }
    printer.print_token(raw_token);

  }

  if (last_tag_token.indent_content &&
    !(last_tag_token.is_unformatted || last_tag_token.is_content_unformatted)) {
    printer.indent();

    // only indent once per opened tag
    last_tag_token.indent_content = false;
  }

  if (!last_tag_token.is_inline_element &&
    !(last_tag_token.is_unformatted || last_tag_token.is_content_unformatted)) {
    printer.set_wrap_point();
  }

  return parser_token;
};

Beautifier.prototype._handle_inside_tag = function(printer, raw_token, last_tag_token, tokens) {
  var wrapped = last_tag_token.has_wrapped_attrs;
  var parser_token = {
    text: raw_token.text,
    type: raw_token.type
  };

  printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== '', true);
  if (last_tag_token.is_unformatted) {
    printer.add_raw_token(raw_token);
  } else if (last_tag_token.tag_start_char === '{' && raw_token.type === TOKEN.TEXT) {
    // For the insides of handlebars allow newlines or a single space between open and contents
    if (printer.print_preserved_newlines(raw_token)) {
      raw_token.newlines = 0;
      printer.add_raw_token(raw_token);
    } else {
      printer.print_token(raw_token);
    }
  } else {
    if (raw_token.type === TOKEN.ATTRIBUTE) {
      printer.set_space_before_token(true);
      last_tag_token.attr_count += 1;
    } else if (raw_token.type === TOKEN.EQUALS) { //no space before =
      printer.set_space_before_token(false);
    } else if (raw_token.type === TOKEN.VALUE && raw_token.previous.type === TOKEN.EQUALS) { //no space before value
      printer.set_space_before_token(false);
    }

    if (raw_token.type === TOKEN.ATTRIBUTE && last_tag_token.tag_start_char === '<') {
      if (this._is_wrap_attributes_preserve || this._is_wrap_attributes_preserve_aligned) {
        printer.traverse_whitespace(raw_token);
        wrapped = wrapped || raw_token.newlines !== 0;
      }


      if (this._is_wrap_attributes_force) {
        var force_attr_wrap = last_tag_token.attr_count > 1;
        if (this._is_wrap_attributes_force_expand_multiline && last_tag_token.attr_count === 1) {
          var is_only_attribute = true;
          var peek_index = 0;
          var peek_token;
          do {
            peek_token = tokens.peek(peek_index);
            if (peek_token.type === TOKEN.ATTRIBUTE) {
              is_only_attribute = false;
              break;
            }
            peek_index += 1;
          } while (peek_index < 4 && peek_token.type !== TOKEN.EOF && peek_token.type !== TOKEN.TAG_CLOSE);

          force_attr_wrap = !is_only_attribute;
        }

        if (force_attr_wrap) {
          printer.print_newline(false);
          wrapped = true;
        }
      }
    }
    printer.print_token(raw_token);
    wrapped = wrapped || printer.previous_token_wrapped();
    last_tag_token.has_wrapped_attrs = wrapped;
  }
  return parser_token;
};

Beautifier.prototype._handle_text = function(printer, raw_token, last_tag_token) {
  var parser_token = {
    text: raw_token.text,
    type: 'TK_CONTENT'
  };
  if (last_tag_token.custom_beautifier_name) { //check if we need to format javascript
    this._print_custom_beatifier_text(printer, raw_token, last_tag_token);
  } else if (last_tag_token.is_unformatted || last_tag_token.is_content_unformatted) {
    printer.add_raw_token(raw_token);
  } else {
    printer.traverse_whitespace(raw_token);
    printer.print_token(raw_token);
  }
  return parser_token;
};

Beautifier.prototype._print_custom_beatifier_text = function(printer, raw_token, last_tag_token) {
  var local = this;
  if (raw_token.text !== '') {

    var text = raw_token.text,
      _beautifier,
      script_indent_level = 1,
      pre = '',
      post = '';
    if (last_tag_token.custom_beautifier_name === 'javascript' && typeof this._js_beautify === 'function') {
      _beautifier = this._js_beautify;
    } else if (last_tag_token.custom_beautifier_name === 'css' && typeof this._css_beautify === 'function') {
      _beautifier = this._css_beautify;
    } else if (last_tag_token.custom_beautifier_name === 'html') {
      _beautifier = function(html_source, options) {
        var beautifier = new Beautifier(html_source, options, local._js_beautify, local._css_beautify);
        return beautifier.beautify();
      };
    }

    if (this._options.indent_scripts === "keep") {
      script_indent_level = 0;
    } else if (this._options.indent_scripts === "separate") {
      script_indent_level = -printer.indent_level;
    }

    var indentation = printer.get_full_indent(script_indent_level);

    // if there is at least one empty line at the end of this text, strip it
    // we'll be adding one back after the text but before the containing tag.
    text = text.replace(/\n[ \t]*$/, '');

    // Handle the case where content is wrapped in a comment or cdata.
    if (last_tag_token.custom_beautifier_name !== 'html' &&
      text[0] === '<' && text.match(/^(<!--|<!\[CDATA\[)/)) {
      var matched = /^(<!--[^\n]*|<!\[CDATA\[)(\n?)([ \t\n]*)([\s\S]*)(-->|]]>)$/.exec(text);

      // if we start to wrap but don't finish, print raw
      if (!matched) {
        printer.add_raw_token(raw_token);
        return;
      }

      pre = indentation + matched[1] + '\n';
      text = matched[4];
      if (matched[5]) {
        post = indentation + matched[5];
      }

      // if there is at least one empty line at the end of this text, strip it
      // we'll be adding one back after the text but before the containing tag.
      text = text.replace(/\n[ \t]*$/, '');

      if (matched[2] || matched[3].indexOf('\n') !== -1) {
        // if the first line of the non-comment text has spaces
        // use that as the basis for indenting in null case.
        matched = matched[3].match(/[ \t]+$/);
        if (matched) {
          raw_token.whitespace_before = matched[0];
        }
      }
    }

    if (text) {
      if (_beautifier) {

        // call the Beautifier if avaliable
        var Child_options = function() {
          this.eol = '\n';
        };
        Child_options.prototype = this._options.raw_options;
        var child_options = new Child_options();
        text = _beautifier(indentation + text, child_options);
      } else {
        // simply indent the string otherwise
        var white = raw_token.whitespace_before;
        if (white) {
          text = text.replace(new RegExp('\n(' + white + ')?', 'g'), '\n');
        }

        text = indentation + text.replace(/\n/g, '\n' + indentation);
      }
    }

    if (pre) {
      if (!text) {
        text = pre + post;
      } else {
        text = pre + text + '\n' + post;
      }
    }

    printer.print_newline(false);
    if (text) {
      raw_token.text = text;
      raw_token.whitespace_before = '';
      raw_token.newlines = 0;
      printer.add_raw_token(raw_token);
      printer.print_newline(true);
    }
  }
};

Beautifier.prototype._handle_tag_open = function(printer, raw_token, last_tag_token, last_token) {
  var parser_token = this._get_tag_open_token(raw_token);

  if ((last_tag_token.is_unformatted || last_tag_token.is_content_unformatted) &&
    raw_token.type === TOKEN.TAG_OPEN && raw_token.text.indexOf('</') === 0) {
    // End element tags for unformatted or content_unformatted elements
    // are printed raw to keep any newlines inside them exactly the same.
    printer.add_raw_token(raw_token);
  } else {
    printer.traverse_whitespace(raw_token);
    this._set_tag_position(printer, raw_token, parser_token, last_tag_token, last_token);
    if (!parser_token.is_inline_element) {
      printer.set_wrap_point();
    }
    printer.print_token(raw_token);
  }

  //indent attributes an auto, forced, aligned or forced-align line-wrap
  if (this._is_wrap_attributes_force_aligned || this._is_wrap_attributes_aligned_multiple || this._is_wrap_attributes_preserve_aligned) {
    parser_token.alignment_size = raw_token.text.length + 1;
  }

  if (!parser_token.tag_complete && !parser_token.is_unformatted) {
    printer.alignment_size = parser_token.alignment_size;
  }

  return parser_token;
};

var TagOpenParserToken = function(parent, raw_token) {
  this.parent = parent || null;
  this.text = '';
  this.type = 'TK_TAG_OPEN';
  this.tag_name = '';
  this.is_inline_element = false;
  this.is_unformatted = false;
  this.is_content_unformatted = false;
  this.is_empty_element = false;
  this.is_start_tag = false;
  this.is_end_tag = false;
  this.indent_content = false;
  this.multiline_content = false;
  this.custom_beautifier_name = null;
  this.start_tag_token = null;
  this.attr_count = 0;
  this.has_wrapped_attrs = false;
  this.alignment_size = 0;
  this.tag_complete = false;
  this.tag_start_char = '';
  this.tag_check = '';

  if (!raw_token) {
    this.tag_complete = true;
  } else {
    var tag_check_match;

    this.tag_start_char = raw_token.text[0];
    this.text = raw_token.text;

    if (this.tag_start_char === '<') {
      tag_check_match = raw_token.text.match(/^<([^\s>]*)/);
      this.tag_check = tag_check_match ? tag_check_match[1] : '';
    } else {
      tag_check_match = raw_token.text.match(/^{{[#\^]?([^\s}]+)/);
      this.tag_check = tag_check_match ? tag_check_match[1] : '';
    }
    this.tag_check = this.tag_check.toLowerCase();

    if (raw_token.type === TOKEN.COMMENT) {
      this.tag_complete = true;
    }

    this.is_start_tag = this.tag_check.charAt(0) !== '/';
    this.tag_name = !this.is_start_tag ? this.tag_check.substr(1) : this.tag_check;
    this.is_end_tag = !this.is_start_tag ||
      (raw_token.closed && raw_token.closed.text === '/>');

    // handlebars tags that don't start with # or ^ are single_tags, and so also start and end.
    this.is_end_tag = this.is_end_tag ||
      (this.tag_start_char === '{' && (this.text.length < 3 || (/[^#\^]/.test(this.text.charAt(2)))));
  }
};

Beautifier.prototype._get_tag_open_token = function(raw_token) { //function to get a full tag and parse its type
  var parser_token = new TagOpenParserToken(this._tag_stack.get_parser_token(), raw_token);

  parser_token.alignment_size = this._options.wrap_attributes_indent_size;

  parser_token.is_end_tag = parser_token.is_end_tag ||
    in_array(parser_token.tag_check, this._options.void_elements);

  parser_token.is_empty_element = parser_token.tag_complete ||
    (parser_token.is_start_tag && parser_token.is_end_tag);

  parser_token.is_unformatted = !parser_token.tag_complete && in_array(parser_token.tag_check, this._options.unformatted);
  parser_token.is_content_unformatted = !parser_token.is_empty_element && in_array(parser_token.tag_check, this._options.content_unformatted);
  parser_token.is_inline_element = in_array(parser_token.tag_name, this._options.inline) || parser_token.tag_start_char === '{';

  return parser_token;
};

Beautifier.prototype._set_tag_position = function(printer, raw_token, parser_token, last_tag_token, last_token) {

  if (!parser_token.is_empty_element) {
    if (parser_token.is_end_tag) { //this tag is a double tag so check for tag-ending
      parser_token.start_tag_token = this._tag_stack.try_pop(parser_token.tag_name); //remove it and all ancestors
    } else { // it's a start-tag
      // check if this tag is starting an element that has optional end element
      // and do an ending needed
      if (this._do_optional_end_element(parser_token)) {
        if (!parser_token.is_inline_element) {
          if (parser_token.parent) {
            parser_token.parent.multiline_content = true;
          }
          printer.print_newline(false);
        }

      }

      this._tag_stack.record_tag(parser_token); //push it on the tag stack

      if ((parser_token.tag_name === 'script' || parser_token.tag_name === 'style') &&
        !(parser_token.is_unformatted || parser_token.is_content_unformatted)) {
        parser_token.custom_beautifier_name = get_custom_beautifier_name(parser_token.tag_check, raw_token);
      }
    }
  }

  if (in_array(parser_token.tag_check, this._options.extra_liners)) { //check if this double needs an extra line
    printer.print_newline(false);
    if (!printer._output.just_added_blankline()) {
      printer.print_newline(true);
    }
  }

  if (parser_token.is_empty_element) { //if this tag name is a single tag type (either in the list or has a closing /)

    // if you hit an else case, reset the indent level if you are inside an:
    // 'if', 'unless', or 'each' block.
    if (parser_token.tag_start_char === '{' && parser_token.tag_check === 'else') {
      this._tag_stack.indent_to_tag(['if', 'unless', 'each']);
      parser_token.indent_content = true;
      // Don't add a newline if opening {{#if}} tag is on the current line
      var foundIfOnCurrentLine = printer.current_line_has_match(/{{#if/);
      if (!foundIfOnCurrentLine) {
        printer.print_newline(false);
      }
    }

    // Don't add a newline before elements that should remain where they are.
    if (parser_token.tag_name === '!--' && last_token.type === TOKEN.TAG_CLOSE &&
      last_tag_token.is_end_tag && parser_token.text.indexOf('\n') === -1) {
      //Do nothing. Leave comments on same line.
    } else if (!parser_token.is_inline_element && !parser_token.is_unformatted) {
      printer.print_newline(false);
    }
  } else if (parser_token.is_unformatted || parser_token.is_content_unformatted) {
    if (!parser_token.is_inline_element && !parser_token.is_unformatted) {
      printer.print_newline(false);
    }
  } else if (parser_token.is_end_tag) { //this tag is a double tag so check for tag-ending
    if ((parser_token.start_tag_token && parser_token.start_tag_token.multiline_content) ||
      !(parser_token.is_inline_element ||
        (last_tag_token.is_inline_element) ||
        (last_token.type === TOKEN.TAG_CLOSE &&
          parser_token.start_tag_token === last_tag_token) ||
        (last_token.type === 'TK_CONTENT')
      )) {
      printer.print_newline(false);
    }
  } else { // it's a start-tag
    parser_token.indent_content = !parser_token.custom_beautifier_name;

    if (parser_token.tag_start_char === '<') {
      if (parser_token.tag_name === 'html') {
        parser_token.indent_content = this._options.indent_inner_html;
      } else if (parser_token.tag_name === 'head') {
        parser_token.indent_content = this._options.indent_head_inner_html;
      } else if (parser_token.tag_name === 'body') {
        parser_token.indent_content = this._options.indent_body_inner_html;
      }
    }

    if (!parser_token.is_inline_element && last_token.type !== 'TK_CONTENT') {
      if (parser_token.parent) {
        parser_token.parent.multiline_content = true;
      }
      printer.print_newline(false);
    }
  }
};

//To be used for <p> tag special case:
//var p_closers = ['address', 'article', 'aside', 'blockquote', 'details', 'div', 'dl', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hr', 'main', 'nav', 'ol', 'p', 'pre', 'section', 'table', 'ul'];

Beautifier.prototype._do_optional_end_element = function(parser_token) {
  var result = null;
  // NOTE: cases of "if there is no more content in the parent element"
  // are handled automatically by the beautifier.
  // It assumes parent or ancestor close tag closes all children.
  // https://www.w3.org/TR/html5/syntax.html#optional-tags
  if (parser_token.is_empty_element || !parser_token.is_start_tag || !parser_token.parent) {
    return;

  } else if (parser_token.tag_name === 'body') {
    // A head element’s end tag may be omitted if the head element is not immediately followed by a space character or a comment.
    result = result || this._tag_stack.try_pop('head');

    //} else if (parser_token.tag_name === 'body') {
    // DONE: A body element’s end tag may be omitted if the body element is not immediately followed by a comment.

  } else if (parser_token.tag_name === 'li') {
    // An li element’s end tag may be omitted if the li element is immediately followed by another li element or if there is no more content in the parent element.
    result = result || this._tag_stack.try_pop('li', ['ol', 'ul']);

  } else if (parser_token.tag_name === 'dd' || parser_token.tag_name === 'dt') {
    // A dd element’s end tag may be omitted if the dd element is immediately followed by another dd element or a dt element, or if there is no more content in the parent element.
    // A dt element’s end tag may be omitted if the dt element is immediately followed by another dt element or a dd element.
    result = result || this._tag_stack.try_pop('dt', ['dl']);
    result = result || this._tag_stack.try_pop('dd', ['dl']);

    //} else if (p_closers.indexOf(parser_token.tag_name) !== -1) {
    //TODO: THIS IS A BUG FARM. We are not putting this into 1.8.0 as it is likely to blow up.
    //A p element’s end tag may be omitted if the p element is immediately followed by an address, article, aside, blockquote, details, div, dl, fieldset, figcaption, figure, footer, form, h1, h2, h3, h4, h5, h6, header, hr, main, nav, ol, p, pre, section, table, or ul element, or if there is no more content in the parent element and the parent element is an HTML element that is not an a, audio, del, ins, map, noscript, or video element, or an autonomous custom element.
    //result = result || this._tag_stack.try_pop('p', ['body']);

  } else if (parser_token.tag_name === 'rp' || parser_token.tag_name === 'rt') {
    // An rt element’s end tag may be omitted if the rt element is immediately followed by an rt or rp element, or if there is no more content in the parent element.
    // An rp element’s end tag may be omitted if the rp element is immediately followed by an rt or rp element, or if there is no more content in the parent element.
    result = result || this._tag_stack.try_pop('rt', ['ruby', 'rtc']);
    result = result || this._tag_stack.try_pop('rp', ['ruby', 'rtc']);

  } else if (parser_token.tag_name === 'optgroup') {
    // An optgroup element’s end tag may be omitted if the optgroup element is immediately followed by another optgroup element, or if there is no more content in the parent element.
    // An option element’s end tag may be omitted if the option element is immediately followed by another option element, or if it is immediately followed by an optgroup element, or if there is no more content in the parent element.
    result = result || this._tag_stack.try_pop('optgroup', ['select']);
    //result = result || this._tag_stack.try_pop('option', ['select']);

  } else if (parser_token.tag_name === 'option') {
    // An option element’s end tag may be omitted if the option element is immediately followed by another option element, or if it is immediately followed by an optgroup element, or if there is no more content in the parent element.
    result = result || this._tag_stack.try_pop('option', ['select', 'datalist', 'optgroup']);

  } else if (parser_token.tag_name === 'colgroup') {
    // DONE: A colgroup element’s end tag may be omitted if the colgroup element is not immediately followed by a space character or a comment.
    // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.
    result = result || this._tag_stack.try_pop('caption', ['table']);

  } else if (parser_token.tag_name === 'thead') {
    // A colgroup element's end tag may be ommitted if a thead, tfoot, tbody, or tr element is started.
    // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.
    result = result || this._tag_stack.try_pop('caption', ['table']);
    result = result || this._tag_stack.try_pop('colgroup', ['table']);

    //} else if (parser_token.tag_name === 'caption') {
    // DONE: A caption element’s end tag may be omitted if the caption element is not immediately followed by a space character or a comment.

  } else if (parser_token.tag_name === 'tbody' || parser_token.tag_name === 'tfoot') {
    // A thead element’s end tag may be omitted if the thead element is immediately followed by a tbody or tfoot element.
    // A tbody element’s end tag may be omitted if the tbody element is immediately followed by a tbody or tfoot element, or if there is no more content in the parent element.
    // A colgroup element's end tag may be ommitted if a thead, tfoot, tbody, or tr element is started.
    // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.
    result = result || this._tag_stack.try_pop('caption', ['table']);
    result = result || this._tag_stack.try_pop('colgroup', ['table']);
    result = result || this._tag_stack.try_pop('thead', ['table']);
    result = result || this._tag_stack.try_pop('tbody', ['table']);

    //} else if (parser_token.tag_name === 'tfoot') {
    // DONE: A tfoot element’s end tag may be omitted if there is no more content in the parent element.

  } else if (parser_token.tag_name === 'tr') {
    // A tr element’s end tag may be omitted if the tr element is immediately followed by another tr element, or if there is no more content in the parent element.
    // A colgroup element's end tag may be ommitted if a thead, tfoot, tbody, or tr element is started.
    // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.
    result = result || this._tag_stack.try_pop('caption', ['table']);
    result = result || this._tag_stack.try_pop('colgroup', ['table']);
    result = result || this._tag_stack.try_pop('tr', ['table', 'thead', 'tbody', 'tfoot']);

  } else if (parser_token.tag_name === 'th' || parser_token.tag_name === 'td') {
    // A td element’s end tag may be omitted if the td element is immediately followed by a td or th element, or if there is no more content in the parent element.
    // A th element’s end tag may be omitted if the th element is immediately followed by a td or th element, or if there is no more content in the parent element.
    result = result || this._tag_stack.try_pop('td', ['table', 'thead', 'tbody', 'tfoot', 'tr']);
    result = result || this._tag_stack.try_pop('th', ['table', 'thead', 'tbody', 'tfoot', 'tr']);
  }

  // Start element omission not handled currently
  // A head element’s start tag may be omitted if the element is empty, or if the first thing inside the head element is an element.
  // A tbody element’s start tag may be omitted if the first thing inside the tbody element is a tr element, and if the element is not immediately preceded by a tbody, thead, or tfoot element whose end tag has been omitted. (It can’t be omitted if the element is empty.)
  // A colgroup element’s start tag may be omitted if the first thing inside the colgroup element is a col element, and if the element is not immediately preceded by another colgroup element whose end tag has been omitted. (It can’t be omitted if the element is empty.)

  // Fix up the parent of the parser token
  parser_token.parent = this._tag_stack.get_parser_token();

  return result;
};

module.exports.Beautifier = Beautifier;

},{"../core/output":30,"../html/options":42,"../html/tokenizer":43}],41:[function(require,module,exports){
/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

'use strict';

var Beautifier = require('./beautifier').Beautifier,
  Options = require('./options').Options;

function style_html(html_source, options, js_beautify, css_beautify) {
  var beautifier = new Beautifier(html_source, options, js_beautify, css_beautify);
  return beautifier.beautify();
}

module.exports = style_html;
module.exports.defaultOptions = function() {
  return new Options();
};

},{"./beautifier":40,"./options":42}],42:[function(require,module,exports){
/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

'use strict';

var BaseOptions = require('../core/options').Options;

function Options(options) {
  BaseOptions.call(this, options, 'html');
  if (this.templating.length === 1 && this.templating[0] === 'auto') {
    this.templating = ['django', 'erb', 'handlebars', 'php'];
  }

  this.indent_inner_html = this._get_boolean('indent_inner_html');
  this.indent_body_inner_html = this._get_boolean('indent_body_inner_html', true);
  this.indent_head_inner_html = this._get_boolean('indent_head_inner_html', true);

  this.indent_handlebars = this._get_boolean('indent_handlebars', true);
  this.wrap_attributes = this._get_selection('wrap_attributes',
    ['auto', 'force', 'force-aligned', 'force-expand-multiline', 'aligned-multiple', 'preserve', 'preserve-aligned']);
  this.wrap_attributes_indent_size = this._get_number('wrap_attributes_indent_size', this.indent_size);
  this.extra_liners = this._get_array('extra_liners', ['head', 'body', '/html']);

  // Block vs inline elements
  // https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements
  // https://developer.mozilla.org/en-US/docs/Web/HTML/Inline_elements
  // https://www.w3.org/TR/html5/dom.html#phrasing-content
  this.inline = this._get_array('inline', [
    'a', 'abbr', 'area', 'audio', 'b', 'bdi', 'bdo', 'br', 'button', 'canvas', 'cite',
    'code', 'data', 'datalist', 'del', 'dfn', 'em', 'embed', 'i', 'iframe', 'img',
    'input', 'ins', 'kbd', 'keygen', 'label', 'map', 'mark', 'math', 'meter', 'noscript',
    'object', 'output', 'progress', 'q', 'ruby', 's', 'samp', /* 'script', */ 'select', 'small',
    'span', 'strong', 'sub', 'sup', 'svg', 'template', 'textarea', 'time', 'u', 'var',
    'video', 'wbr', 'text',
    // obsolete inline tags
    'acronym', 'big', 'strike', 'tt'
  ]);
  this.void_elements = this._get_array('void_elements', [
    // HTLM void elements - aka self-closing tags - aka singletons
    // https://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements
    'area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'keygen',
    'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr',
    // NOTE: Optional tags are too complex for a simple list
    // they are hard coded in _do_optional_end_element

    // Doctype and xml elements
    '!doctype', '?xml',

    // obsolete tags
    // basefont: https://www.computerhope.com/jargon/h/html-basefont-tag.htm
    // isndex: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/isindex
    'basefont', 'isindex'
  ]);
  this.unformatted = this._get_array('unformatted', []);
  this.content_unformatted = this._get_array('content_unformatted', [
    'pre', 'textarea'
  ]);
  this.unformatted_content_delimiter = this._get_characters('unformatted_content_delimiter');
  this.indent_scripts = this._get_selection('indent_scripts', ['normal', 'keep', 'separate']);

}
Options.prototype = new BaseOptions();



module.exports.Options = Options;

},{"../core/options":29}],43:[function(require,module,exports){
/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

'use strict';

var BaseTokenizer = require('../core/tokenizer').Tokenizer;
var BASETOKEN = require('../core/tokenizer').TOKEN;
var Directives = require('../core/directives').Directives;
var TemplatablePattern = require('../core/templatablepattern').TemplatablePattern;
var Pattern = require('../core/pattern').Pattern;

var TOKEN = {
  TAG_OPEN: 'TK_TAG_OPEN',
  TAG_CLOSE: 'TK_TAG_CLOSE',
  ATTRIBUTE: 'TK_ATTRIBUTE',
  EQUALS: 'TK_EQUALS',
  VALUE: 'TK_VALUE',
  COMMENT: 'TK_COMMENT',
  TEXT: 'TK_TEXT',
  UNKNOWN: 'TK_UNKNOWN',
  START: BASETOKEN.START,
  RAW: BASETOKEN.RAW,
  EOF: BASETOKEN.EOF
};

var directives_core = new Directives(/<\!--/, /-->/);

var Tokenizer = function(input_string, options) {
  BaseTokenizer.call(this, input_string, options);
  this._current_tag_name = '';

  // Words end at whitespace or when a tag starts
  // if we are indenting handlebars, they are considered tags
  var templatable_reader = new TemplatablePattern(this._input).read_options(this._options);
  var pattern_reader = new Pattern(this._input);

  this.__patterns = {
    word: templatable_reader.until(/[\n\r\t <]/),
    single_quote: templatable_reader.until_after(/'/),
    double_quote: templatable_reader.until_after(/"/),
    attribute: templatable_reader.until(/[\n\r\t =>]|\/>/),
    element_name: templatable_reader.until(/[\n\r\t >\/]/),

    handlebars_comment: pattern_reader.starting_with(/{{!--/).until_after(/--}}/),
    handlebars: pattern_reader.starting_with(/{{/).until_after(/}}/),
    handlebars_open: pattern_reader.until(/[\n\r\t }]/),
    handlebars_raw_close: pattern_reader.until(/}}/),
    comment: pattern_reader.starting_with(/<!--/).until_after(/-->/),
    cdata: pattern_reader.starting_with(/<!\[CDATA\[/).until_after(/]]>/),
    // https://en.wikipedia.org/wiki/Conditional_comment
    conditional_comment: pattern_reader.starting_with(/<!\[/).until_after(/]>/),
    processing: pattern_reader.starting_with(/<\?/).until_after(/\?>/)
  };

  if (this._options.indent_handlebars) {
    this.__patterns.word = this.__patterns.word.exclude('handlebars');
  }

  this._unformatted_content_delimiter = null;

  if (this._options.unformatted_content_delimiter) {
    var literal_regexp = this._input.get_literal_regexp(this._options.unformatted_content_delimiter);
    this.__patterns.unformatted_content_delimiter =
      pattern_reader.matching(literal_regexp)
      .until_after(literal_regexp);
  }
};
Tokenizer.prototype = new BaseTokenizer();

Tokenizer.prototype._is_comment = function(current_token) { // jshint unused:false
  return false; //current_token.type === TOKEN.COMMENT || current_token.type === TOKEN.UNKNOWN;
};

Tokenizer.prototype._is_opening = function(current_token) {
  return current_token.type === TOKEN.TAG_OPEN;
};

Tokenizer.prototype._is_closing = function(current_token, open_token) {
  return current_token.type === TOKEN.TAG_CLOSE &&
    (open_token && (
      ((current_token.text === '>' || current_token.text === '/>') && open_token.text[0] === '<') ||
      (current_token.text === '}}' && open_token.text[0] === '{' && open_token.text[1] === '{')));
};

Tokenizer.prototype._reset = function() {
  this._current_tag_name = '';
};

Tokenizer.prototype._get_next_token = function(previous_token, open_token) { // jshint unused:false
  var token = null;
  this._readWhitespace();
  var c = this._input.peek();

  if (c === null) {
    return this._create_token(TOKEN.EOF, '');
  }

  token = token || this._read_open_handlebars(c, open_token);
  token = token || this._read_attribute(c, previous_token, open_token);
  token = token || this._read_raw_content(c, previous_token, open_token);
  token = token || this._read_close(c, open_token);
  token = token || this._read_content_word(c);
  token = token || this._read_comment_or_cdata(c);
  token = token || this._read_processing(c);
  token = token || this._read_open(c, open_token);
  token = token || this._create_token(TOKEN.UNKNOWN, this._input.next());

  return token;
};

Tokenizer.prototype._read_comment_or_cdata = function(c) { // jshint unused:false
  var token = null;
  var resulting_string = null;
  var directives = null;

  if (c === '<') {
    var peek1 = this._input.peek(1);
    // We treat all comments as literals, even more than preformatted tags
    // we only look for the appropriate closing marker
    if (peek1 === '!') {
      resulting_string = this.__patterns.comment.read();

      // only process directive on html comments
      if (resulting_string) {
        directives = directives_core.get_directives(resulting_string);
        if (directives && directives.ignore === 'start') {
          resulting_string += directives_core.readIgnored(this._input);
        }
      } else {
        resulting_string = this.__patterns.cdata.read();
      }
    }

    if (resulting_string) {
      token = this._create_token(TOKEN.COMMENT, resulting_string);
      token.directives = directives;
    }
  }

  return token;
};

Tokenizer.prototype._read_processing = function(c) { // jshint unused:false
  var token = null;
  var resulting_string = null;
  var directives = null;

  if (c === '<') {
    var peek1 = this._input.peek(1);
    if (peek1 === '!' || peek1 === '?') {
      resulting_string = this.__patterns.conditional_comment.read();
      resulting_string = resulting_string || this.__patterns.processing.read();
    }

    if (resulting_string) {
      token = this._create_token(TOKEN.COMMENT, resulting_string);
      token.directives = directives;
    }
  }

  return token;
};

Tokenizer.prototype._read_open = function(c, open_token) {
  var resulting_string = null;
  var token = null;
  if (!open_token) {
    if (c === '<') {

      resulting_string = this._input.next();
      if (this._input.peek() === '/') {
        resulting_string += this._input.next();
      }
      resulting_string += this.__patterns.element_name.read();
      token = this._create_token(TOKEN.TAG_OPEN, resulting_string);
    }
  }
  return token;
};

Tokenizer.prototype._read_open_handlebars = function(c, open_token) {
  var resulting_string = null;
  var token = null;
  if (!open_token) {
    if (this._options.indent_handlebars && c === '{' && this._input.peek(1) === '{') {
      if (this._input.peek(2) === '!') {
        resulting_string = this.__patterns.handlebars_comment.read();
        resulting_string = resulting_string || this.__patterns.handlebars.read();
        token = this._create_token(TOKEN.COMMENT, resulting_string);
      } else {
        resulting_string = this.__patterns.handlebars_open.read();
        token = this._create_token(TOKEN.TAG_OPEN, resulting_string);
      }
    }
  }
  return token;
};


Tokenizer.prototype._read_close = function(c, open_token) {
  var resulting_string = null;
  var token = null;
  if (open_token) {
    if (open_token.text[0] === '<' && (c === '>' || (c === '/' && this._input.peek(1) === '>'))) {
      resulting_string = this._input.next();
      if (c === '/') { //  for close tag "/>"
        resulting_string += this._input.next();
      }
      token = this._create_token(TOKEN.TAG_CLOSE, resulting_string);
    } else if (open_token.text[0] === '{' && c === '}' && this._input.peek(1) === '}') {
      this._input.next();
      this._input.next();
      token = this._create_token(TOKEN.TAG_CLOSE, '}}');
    }
  }

  return token;
};

Tokenizer.prototype._read_attribute = function(c, previous_token, open_token) {
  var token = null;
  var resulting_string = '';
  if (open_token && open_token.text[0] === '<') {

    if (c === '=') {
      token = this._create_token(TOKEN.EQUALS, this._input.next());
    } else if (c === '"' || c === "'") {
      var content = this._input.next();
      if (c === '"') {
        content += this.__patterns.double_quote.read();
      } else {
        content += this.__patterns.single_quote.read();
      }
      token = this._create_token(TOKEN.VALUE, content);
    } else {
      resulting_string = this.__patterns.attribute.read();

      if (resulting_string) {
        if (previous_token.type === TOKEN.EQUALS) {
          token = this._create_token(TOKEN.VALUE, resulting_string);
        } else {
          token = this._create_token(TOKEN.ATTRIBUTE, resulting_string);
        }
      }
    }
  }
  return token;
};

Tokenizer.prototype._is_content_unformatted = function(tag_name) {
  // void_elements have no content and so cannot have unformatted content
  // script and style tags should always be read as unformatted content
  // finally content_unformatted and unformatted element contents are unformatted
  return this._options.void_elements.indexOf(tag_name) === -1 &&
    (this._options.content_unformatted.indexOf(tag_name) !== -1 ||
      this._options.unformatted.indexOf(tag_name) !== -1);
};


Tokenizer.prototype._read_raw_content = function(c, previous_token, open_token) { // jshint unused:false
  var resulting_string = '';
  if (open_token && open_token.text[0] === '{') {
    resulting_string = this.__patterns.handlebars_raw_close.read();
  } else if (previous_token.type === TOKEN.TAG_CLOSE && (previous_token.opened.text[0] === '<')) {
    var tag_name = previous_token.opened.text.substr(1).toLowerCase();
    if (tag_name === 'script' || tag_name === 'style') {
      // Script and style tags are allowed to have comments wrapping their content
      // or just have regular content.
      var token = this._read_comment_or_cdata(c);
      if (token) {
        token.type = TOKEN.TEXT;
        return token;
      }
      resulting_string = this._input.readUntil(new RegExp('</' + tag_name + '[\\n\\r\\t ]*?>', 'ig'));
    } else if (this._is_content_unformatted(tag_name)) {
      resulting_string = this._input.readUntil(new RegExp('</' + tag_name + '[\\n\\r\\t ]*?>', 'ig'));
    }
  }

  if (resulting_string) {
    return this._create_token(TOKEN.TEXT, resulting_string);
  }

  return null;
};

Tokenizer.prototype._read_content_word = function(c) {
  var resulting_string = '';
  if (this._options.unformatted_content_delimiter) {
    if (c === this._options.unformatted_content_delimiter[0]) {
      resulting_string = this.__patterns.unformatted_content_delimiter.read();
    }
  }

  if (!resulting_string) {
    resulting_string = this.__patterns.word.read();
  }
  if (resulting_string) {
    return this._create_token(TOKEN.TEXT, resulting_string);
  }
};

module.exports.Tokenizer = Tokenizer;
module.exports.TOKEN = TOKEN;

},{"../core/directives":27,"../core/pattern":31,"../core/templatablepattern":32,"../core/tokenizer":34}],44:[function(require,module,exports){
/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

'use strict';

var js_beautify = require('./javascript/index');
var css_beautify = require('./css/index');
var html_beautify = require('./html/index');

function style_html(html_source, options, js, css) {
  js = js || js_beautify;
  css = css || css_beautify;
  return html_beautify(html_source, options, js, css);
}
style_html.defaultOptions = html_beautify.defaultOptions;

module.exports.js = js_beautify;
module.exports.css = css_beautify;
module.exports.html = style_html;

},{"./css/index":38,"./html/index":41,"./javascript/index":47}],45:[function(require,module,exports){
/* jshint node: true, curly: false */
// Parts of this section of code is taken from acorn.
//
// Acorn was written by Marijn Haverbeke and released under an MIT
// license. The Unicode regexps (for identifiers and whitespace) were
// taken from [Esprima](http://esprima.org) by Ariya Hidayat.
//
// Git repositories for Acorn are available at
//
//     http://marijnhaverbeke.nl/git/acorn
//     https://github.com/marijnh/acorn.git

// ## Character categories


'use strict';

// acorn used char codes to squeeze the last bit of performance out
// Beautifier is okay without that, so we're using regex
// permit # (23), $ (36), and @ (64). @ is used in ES7 decorators.
// 65 through 91 are uppercase letters.
// permit _ (95).
// 97 through 123 are lowercase letters.
var baseASCIIidentifierStartChars = "\\x23\\x24\\x40\\x41-\\x5a\\x5f\\x61-\\x7a";

// inside an identifier @ is not allowed but 0-9 are.
var baseASCIIidentifierChars = "\\x24\\x30-\\x39\\x41-\\x5a\\x5f\\x61-\\x7a";

// Big ugly regular expressions that match characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 128.
var nonASCIIidentifierStartChars = "\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc";
var nonASCIIidentifierChars = "\\u0300-\\u036f\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u0620-\\u0649\\u0672-\\u06d3\\u06e7-\\u06e8\\u06fb-\\u06fc\\u0730-\\u074a\\u0800-\\u0814\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0840-\\u0857\\u08e4-\\u08fe\\u0900-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962-\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09d7\\u09df-\\u09e0\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5f-\\u0b60\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2-\\u0ce3\\u0ce6-\\u0cef\\u0d02\\u0d03\\u0d46-\\u0d48\\u0d57\\u0d62-\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e34-\\u0e3a\\u0e40-\\u0e45\\u0e50-\\u0e59\\u0eb4-\\u0eb9\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f41-\\u0f47\\u0f71-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1029\\u1040-\\u1049\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u170e-\\u1710\\u1720-\\u1730\\u1740-\\u1750\\u1772\\u1773\\u1780-\\u17b2\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1920-\\u192b\\u1930-\\u193b\\u1951-\\u196d\\u19b0-\\u19c0\\u19c8-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a15\\u1a20-\\u1a53\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1b46-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c00-\\u1c22\\u1c40-\\u1c49\\u1c5b-\\u1c7d\\u1cd0-\\u1cd2\\u1d00-\\u1dbe\\u1e01-\\u1f15\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2d81-\\u2d96\\u2de0-\\u2dff\\u3021-\\u3028\\u3099\\u309a\\ua640-\\ua66d\\ua674-\\ua67d\\ua69f\\ua6f0-\\ua6f1\\ua7f8-\\ua800\\ua806\\ua80b\\ua823-\\ua827\\ua880-\\ua881\\ua8b4-\\ua8c4\\ua8d0-\\ua8d9\\ua8f3-\\ua8f7\\ua900-\\ua909\\ua926-\\ua92d\\ua930-\\ua945\\ua980-\\ua983\\ua9b3-\\ua9c0\\uaa00-\\uaa27\\uaa40-\\uaa41\\uaa4c-\\uaa4d\\uaa50-\\uaa59\\uaa7b\\uaae0-\\uaae9\\uaaf2-\\uaaf3\\uabc0-\\uabe1\\uabec\\uabed\\uabf0-\\uabf9\\ufb20-\\ufb28\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f";
//var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
//var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

var identifierStart = "(?:\\\\u[0-9a-fA-F]{4}|[" + baseASCIIidentifierStartChars + nonASCIIidentifierStartChars + "])";
var identifierChars = "(?:\\\\u[0-9a-fA-F]{4}|[" + baseASCIIidentifierChars + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "])*";

exports.identifier = new RegExp(identifierStart + identifierChars, 'g');
exports.identifierStart = new RegExp(identifierStart);
exports.identifierMatch = new RegExp("(?:\\\\u[0-9a-fA-F]{4}|[" + baseASCIIidentifierChars + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "])+");

var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/; // jshint ignore:line

// Whether a single character denotes a newline.

exports.newline = /[\n\r\u2028\u2029]/;

// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.

// in javascript, these two differ
// in python they are the same, different methods are called on them
exports.lineBreak = new RegExp('\r\n|' + exports.newline.source);
exports.allLineBreaks = new RegExp(exports.lineBreak.source, 'g');

},{}],46:[function(require,module,exports){
/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

'use strict';

var Output = require('../core/output').Output;
var Token = require('../core/token').Token;
var acorn = require('./acorn');
var Options = require('./options').Options;
var Tokenizer = require('./tokenizer').Tokenizer;
var line_starters = require('./tokenizer').line_starters;
var positionable_operators = require('./tokenizer').positionable_operators;
var TOKEN = require('./tokenizer').TOKEN;


function in_array(what, arr) {
  return arr.indexOf(what) !== -1;
}

function ltrim(s) {
  return s.replace(/^\s+/g, '');
}

function generateMapFromStrings(list) {
  var result = {};
  for (var x = 0; x < list.length; x++) {
    // make the mapped names underscored instead of dash
    result[list[x].replace(/-/g, '_')] = list[x];
  }
  return result;
}

function reserved_word(token, word) {
  return token && token.type === TOKEN.RESERVED && token.text === word;
}

function reserved_array(token, words) {
  return token && token.type === TOKEN.RESERVED && in_array(token.text, words);
}
// Unsure of what they mean, but they work. Worth cleaning up in future.
var special_words = ['case', 'return', 'do', 'if', 'throw', 'else', 'await', 'break', 'continue', 'async'];

var validPositionValues = ['before-newline', 'after-newline', 'preserve-newline'];

// Generate map from array
var OPERATOR_POSITION = generateMapFromStrings(validPositionValues);

var OPERATOR_POSITION_BEFORE_OR_PRESERVE = [OPERATOR_POSITION.before_newline, OPERATOR_POSITION.preserve_newline];

var MODE = {
  BlockStatement: 'BlockStatement', // 'BLOCK'
  Statement: 'Statement', // 'STATEMENT'
  ObjectLiteral: 'ObjectLiteral', // 'OBJECT',
  ArrayLiteral: 'ArrayLiteral', //'[EXPRESSION]',
  ForInitializer: 'ForInitializer', //'(FOR-EXPRESSION)',
  Conditional: 'Conditional', //'(COND-EXPRESSION)',
  Expression: 'Expression' //'(EXPRESSION)'
};

function remove_redundant_indentation(output, frame) {
  // This implementation is effective but has some issues:
  //     - can cause line wrap to happen too soon due to indent removal
  //           after wrap points are calculated
  // These issues are minor compared to ugly indentation.

  if (frame.multiline_frame ||
    frame.mode === MODE.ForInitializer ||
    frame.mode === MODE.Conditional) {
    return;
  }

  // remove one indent from each line inside this section
  output.remove_indent(frame.start_line_index);
}

// we could use just string.split, but
// IE doesn't like returning empty strings
function split_linebreaks(s) {
  //return s.split(/\x0d\x0a|\x0a/);

  s = s.replace(acorn.allLineBreaks, '\n');
  var out = [],
    idx = s.indexOf("\n");
  while (idx !== -1) {
    out.push(s.substring(0, idx));
    s = s.substring(idx + 1);
    idx = s.indexOf("\n");
  }
  if (s.length) {
    out.push(s);
  }
  return out;
}

function is_array(mode) {
  return mode === MODE.ArrayLiteral;
}

function is_expression(mode) {
  return in_array(mode, [MODE.Expression, MODE.ForInitializer, MODE.Conditional]);
}

function all_lines_start_with(lines, c) {
  for (var i = 0; i < lines.length; i++) {
    var line = lines[i].trim();
    if (line.charAt(0) !== c) {
      return false;
    }
  }
  return true;
}

function each_line_matches_indent(lines, indent) {
  var i = 0,
    len = lines.length,
    line;
  for (; i < len; i++) {
    line = lines[i];
    // allow empty lines to pass through
    if (line && line.indexOf(indent) !== 0) {
      return false;
    }
  }
  return true;
}


function Beautifier(source_text, options) {
  options = options || {};
  this._source_text = source_text || '';

  this._output = null;
  this._tokens = null;
  this._last_last_text = null;
  this._flags = null;
  this._previous_flags = null;

  this._flag_store = null;
  this._options = new Options(options);
}

Beautifier.prototype.create_flags = function(flags_base, mode) {
  var next_indent_level = 0;
  if (flags_base) {
    next_indent_level = flags_base.indentation_level;
    if (!this._output.just_added_newline() &&
      flags_base.line_indent_level > next_indent_level) {
      next_indent_level = flags_base.line_indent_level;
    }
  }

  var next_flags = {
    mode: mode,
    parent: flags_base,
    last_token: flags_base ? flags_base.last_token : new Token(TOKEN.START_BLOCK, ''), // last token text
    last_word: flags_base ? flags_base.last_word : '', // last TOKEN.WORD passed
    declaration_statement: false,
    declaration_assignment: false,
    multiline_frame: false,
    inline_frame: false,
    if_block: false,
    else_block: false,
    do_block: false,
    do_while: false,
    import_block: false,
    in_case_statement: false, // switch(..){ INSIDE HERE }
    in_case: false, // we're on the exact line with "case 0:"
    case_body: false, // the indented case-action block
    indentation_level: next_indent_level,
    alignment: 0,
    line_indent_level: flags_base ? flags_base.line_indent_level : next_indent_level,
    start_line_index: this._output.get_line_number(),
    ternary_depth: 0
  };
  return next_flags;
};

Beautifier.prototype._reset = function(source_text) {
  var baseIndentString = source_text.match(/^[\t ]*/)[0];

  this._last_last_text = ''; // pre-last token text
  this._output = new Output(this._options, baseIndentString);

  // If testing the ignore directive, start with output disable set to true
  this._output.raw = this._options.test_output_raw;


  // Stack of parsing/formatting states, including MODE.
  // We tokenize, parse, and output in an almost purely a forward-only stream of token input
  // and formatted output.  This makes the beautifier less accurate than full parsers
  // but also far more tolerant of syntax errors.
  //
  // For example, the default mode is MODE.BlockStatement. If we see a '{' we push a new frame of type
  // MODE.BlockStatement on the the stack, even though it could be object literal.  If we later
  // encounter a ":", we'll switch to to MODE.ObjectLiteral.  If we then see a ";",
  // most full parsers would die, but the beautifier gracefully falls back to
  // MODE.BlockStatement and continues on.
  this._flag_store = [];
  this.set_mode(MODE.BlockStatement);
  var tokenizer = new Tokenizer(source_text, this._options);
  this._tokens = tokenizer.tokenize();
  return source_text;
};

Beautifier.prototype.beautify = function() {
  // if disabled, return the input unchanged.
  if (this._options.disabled) {
    return this._source_text;
  }

  var sweet_code;
  var source_text = this._reset(this._source_text);

  var eol = this._options.eol;
  if (this._options.eol === 'auto') {
    eol = '\n';
    if (source_text && acorn.lineBreak.test(source_text || '')) {
      eol = source_text.match(acorn.lineBreak)[0];
    }
  }

  var current_token = this._tokens.next();
  while (current_token) {
    this.handle_token(current_token);

    this._last_last_text = this._flags.last_token.text;
    this._flags.last_token = current_token;

    current_token = this._tokens.next();
  }

  sweet_code = this._output.get_code(eol);

  return sweet_code;
};

Beautifier.prototype.handle_token = function(current_token, preserve_statement_flags) {
  if (current_token.type === TOKEN.START_EXPR) {
    this.handle_start_expr(current_token);
  } else if (current_token.type === TOKEN.END_EXPR) {
    this.handle_end_expr(current_token);
  } else if (current_token.type === TOKEN.START_BLOCK) {
    this.handle_start_block(current_token);
  } else if (current_token.type === TOKEN.END_BLOCK) {
    this.handle_end_block(current_token);
  } else if (current_token.type === TOKEN.WORD) {
    this.handle_word(current_token);
  } else if (current_token.type === TOKEN.RESERVED) {
    this.handle_word(current_token);
  } else if (current_token.type === TOKEN.SEMICOLON) {
    this.handle_semicolon(current_token);
  } else if (current_token.type === TOKEN.STRING) {
    this.handle_string(current_token);
  } else if (current_token.type === TOKEN.EQUALS) {
    this.handle_equals(current_token);
  } else if (current_token.type === TOKEN.OPERATOR) {
    this.handle_operator(current_token);
  } else if (current_token.type === TOKEN.COMMA) {
    this.handle_comma(current_token);
  } else if (current_token.type === TOKEN.BLOCK_COMMENT) {
    this.handle_block_comment(current_token, preserve_statement_flags);
  } else if (current_token.type === TOKEN.COMMENT) {
    this.handle_comment(current_token, preserve_statement_flags);
  } else if (current_token.type === TOKEN.DOT) {
    this.handle_dot(current_token);
  } else if (current_token.type === TOKEN.EOF) {
    this.handle_eof(current_token);
  } else if (current_token.type === TOKEN.UNKNOWN) {
    this.handle_unknown(current_token, preserve_statement_flags);
  } else {
    this.handle_unknown(current_token, preserve_statement_flags);
  }
};

Beautifier.prototype.handle_whitespace_and_comments = function(current_token, preserve_statement_flags) {
  var newlines = current_token.newlines;
  var keep_whitespace = this._options.keep_array_indentation && is_array(this._flags.mode);

  if (current_token.comments_before) {
    var comment_token = current_token.comments_before.next();
    while (comment_token) {
      // The cleanest handling of inline comments is to treat them as though they aren't there.
      // Just continue formatting and the behavior should be logical.
      // Also ignore unknown tokens.  Again, this should result in better behavior.
      this.handle_whitespace_and_comments(comment_token, preserve_statement_flags);
      this.handle_token(comment_token, preserve_statement_flags);
      comment_token = current_token.comments_before.next();
    }
  }

  if (keep_whitespace) {
    for (var i = 0; i < newlines; i += 1) {
      this.print_newline(i > 0, preserve_statement_flags);
    }
  } else {
    if (this._options.max_preserve_newlines && newlines > this._options.max_preserve_newlines) {
      newlines = this._options.max_preserve_newlines;
    }

    if (this._options.preserve_newlines) {
      if (newlines > 1) {
        this.print_newline(false, preserve_statement_flags);
        for (var j = 1; j < newlines; j += 1) {
          this.print_newline(true, preserve_statement_flags);
        }
      }
    }
  }

};

var newline_restricted_tokens = ['async', 'break', 'continue', 'return', 'throw', 'yield'];

Beautifier.prototype.allow_wrap_or_preserved_newline = function(current_token, force_linewrap) {
  force_linewrap = (force_linewrap === undefined) ? false : force_linewrap;

  // Never wrap the first token on a line
  if (this._output.just_added_newline()) {
    return;
  }

  var shouldPreserveOrForce = (this._options.preserve_newlines && current_token.newlines) || force_linewrap;
  var operatorLogicApplies = in_array(this._flags.last_token.text, positionable_operators) ||
    in_array(current_token.text, positionable_operators);

  if (operatorLogicApplies) {
    var shouldPrintOperatorNewline = (
        in_array(this._flags.last_token.text, positionable_operators) &&
        in_array(this._options.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE)
      ) ||
      in_array(current_token.text, positionable_operators);
    shouldPreserveOrForce = shouldPreserveOrForce && shouldPrintOperatorNewline;
  }

  if (shouldPreserveOrForce) {
    this.print_newline(false, true);
  } else if (this._options.wrap_line_length) {
    if (reserved_array(this._flags.last_token, newline_restricted_tokens)) {
      // These tokens should never have a newline inserted
      // between them and the following expression.
      return;
    }
    this._output.set_wrap_point();
  }
};

Beautifier.prototype.print_newline = function(force_newline, preserve_statement_flags) {
  if (!preserve_statement_flags) {
    if (this._flags.last_token.text !== ';' && this._flags.last_token.text !== ',' && this._flags.last_token.text !== '=' && (this._flags.last_token.type !== TOKEN.OPERATOR || this._flags.last_token.text === '--' || this._flags.last_token.text === '++')) {
      var next_token = this._tokens.peek();
      while (this._flags.mode === MODE.Statement &&
        !(this._flags.if_block && reserved_word(next_token, 'else')) &&
        !this._flags.do_block) {
        this.restore_mode();
      }
    }
  }

  if (this._output.add_new_line(force_newline)) {
    this._flags.multiline_frame = true;
  }
};

Beautifier.prototype.print_token_line_indentation = function(current_token) {
  if (this._output.just_added_newline()) {
    if (this._options.keep_array_indentation &&
      current_token.newlines &&
      (current_token.text === '[' || is_array(this._flags.mode))) {
      this._output.current_line.set_indent(-1);
      this._output.current_line.push(current_token.whitespace_before);
      this._output.space_before_token = false;
    } else if (this._output.set_indent(this._flags.indentation_level, this._flags.alignment)) {
      this._flags.line_indent_level = this._flags.indentation_level;
    }
  }
};

Beautifier.prototype.print_token = function(current_token) {
  if (this._output.raw) {
    this._output.add_raw_token(current_token);
    return;
  }

  if (this._options.comma_first && current_token.previous && current_token.previous.type === TOKEN.COMMA &&
    this._output.just_added_newline()) {
    if (this._output.previous_line.last() === ',') {
      var popped = this._output.previous_line.pop();
      // if the comma was already at the start of the line,
      // pull back onto that line and reprint the indentation
      if (this._output.previous_line.is_empty()) {
        this._output.previous_line.push(popped);
        this._output.trim(true);
        this._output.current_line.pop();
        this._output.trim();
      }

      // add the comma in front of the next token
      this.print_token_line_indentation(current_token);
      this._output.add_token(',');
      this._output.space_before_token = true;
    }
  }

  this.print_token_line_indentation(current_token);
  this._output.non_breaking_space = true;
  this._output.add_token(current_token.text);
  if (this._output.previous_token_wrapped) {
    this._flags.multiline_frame = true;
  }
};

Beautifier.prototype.indent = function() {
  this._flags.indentation_level += 1;
  this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
};

Beautifier.prototype.deindent = function() {
  if (this._flags.indentation_level > 0 &&
    ((!this._flags.parent) || this._flags.indentation_level > this._flags.parent.indentation_level)) {
    this._flags.indentation_level -= 1;
    this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
  }
};

Beautifier.prototype.set_mode = function(mode) {
  if (this._flags) {
    this._flag_store.push(this._flags);
    this._previous_flags = this._flags;
  } else {
    this._previous_flags = this.create_flags(null, mode);
  }

  this._flags = this.create_flags(this._previous_flags, mode);
  this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
};


Beautifier.prototype.restore_mode = function() {
  if (this._flag_store.length > 0) {
    this._previous_flags = this._flags;
    this._flags = this._flag_store.pop();
    if (this._previous_flags.mode === MODE.Statement) {
      remove_redundant_indentation(this._output, this._previous_flags);
    }
    this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
  }
};

Beautifier.prototype.start_of_object_property = function() {
  return this._flags.parent.mode === MODE.ObjectLiteral && this._flags.mode === MODE.Statement && (
    (this._flags.last_token.text === ':' && this._flags.ternary_depth === 0) || (reserved_array(this._flags.last_token, ['get', 'set'])));
};

Beautifier.prototype.start_of_statement = function(current_token) {
  var start = false;
  start = start || reserved_array(this._flags.last_token, ['var', 'let', 'const']) && current_token.type === TOKEN.WORD;
  start = start || reserved_word(this._flags.last_token, 'do');
  start = start || (!(this._flags.parent.mode === MODE.ObjectLiteral && this._flags.mode === MODE.Statement)) && reserved_array(this._flags.last_token, newline_restricted_tokens) && !current_token.newlines;
  start = start || reserved_word(this._flags.last_token, 'else') &&
    !(reserved_word(current_token, 'if') && !current_token.comments_before);
  start = start || (this._flags.last_token.type === TOKEN.END_EXPR && (this._previous_flags.mode === MODE.ForInitializer || this._previous_flags.mode === MODE.Conditional));
  start = start || (this._flags.last_token.type === TOKEN.WORD && this._flags.mode === MODE.BlockStatement &&
    !this._flags.in_case &&
    !(current_token.text === '--' || current_token.text === '++') &&
    this._last_last_text !== 'function' &&
    current_token.type !== TOKEN.WORD && current_token.type !== TOKEN.RESERVED);
  start = start || (this._flags.mode === MODE.ObjectLiteral && (
    (this._flags.last_token.text === ':' && this._flags.ternary_depth === 0) || reserved_array(this._flags.last_token, ['get', 'set'])));

  if (start) {
    this.set_mode(MODE.Statement);
    this.indent();

    this.handle_whitespace_and_comments(current_token, true);

    // Issue #276:
    // If starting a new statement with [if, for, while, do], push to a new line.
    // if (a) if (b) if(c) d(); else e(); else f();
    if (!this.start_of_object_property()) {
      this.allow_wrap_or_preserved_newline(current_token,
        reserved_array(current_token, ['do', 'for', 'if', 'while']));
    }
    return true;
  }
  return false;
};

Beautifier.prototype.handle_start_expr = function(current_token) {
  // The conditional starts the statement if appropriate.
  if (!this.start_of_statement(current_token)) {
    this.handle_whitespace_and_comments(current_token);
  }

  var next_mode = MODE.Expression;
  if (current_token.text === '[') {

    if (this._flags.last_token.type === TOKEN.WORD || this._flags.last_token.text === ')') {
      // this is array index specifier, break immediately
      // a[x], fn()[x]
      if (reserved_array(this._flags.last_token, line_starters)) {
        this._output.space_before_token = true;
      }
      this.print_token(current_token);
      this.set_mode(next_mode);
      this.indent();
      if (this._options.space_in_paren) {
        this._output.space_before_token = true;
      }
      return;
    }

    next_mode = MODE.ArrayLiteral;
    if (is_array(this._flags.mode)) {
      if (this._flags.last_token.text === '[' ||
        (this._flags.last_token.text === ',' && (this._last_last_text === ']' || this._last_last_text === '}'))) {
        // ], [ goes to new line
        // }, [ goes to new line
        if (!this._options.keep_array_indentation) {
          this.print_newline();
        }
      }
    }

    if (!in_array(this._flags.last_token.type, [TOKEN.START_EXPR, TOKEN.END_EXPR, TOKEN.WORD, TOKEN.OPERATOR])) {
      this._output.space_before_token = true;
    }
  } else {
    if (this._flags.last_token.type === TOKEN.RESERVED) {
      if (this._flags.last_token.text === 'for') {
        this._output.space_before_token = this._options.space_before_conditional;
        next_mode = MODE.ForInitializer;
      } else if (in_array(this._flags.last_token.text, ['if', 'while'])) {
        this._output.space_before_token = this._options.space_before_conditional;
        next_mode = MODE.Conditional;
      } else if (in_array(this._flags.last_word, ['await', 'async'])) {
        // Should be a space between await and an IIFE, or async and an arrow function
        this._output.space_before_token = true;
      } else if (this._flags.last_token.text === 'import' && current_token.whitespace_before === '') {
        this._output.space_before_token = false;
      } else if (in_array(this._flags.last_token.text, line_starters) || this._flags.last_token.text === 'catch') {
        this._output.space_before_token = true;
      }
    } else if (this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {
      // Support of this kind of newline preservation.
      // a = (b &&
      //     (c || d));
      if (!this.start_of_object_property()) {
        this.allow_wrap_or_preserved_newline(current_token);
      }
    } else if (this._flags.last_token.type === TOKEN.WORD) {
      this._output.space_before_token = false;

      // function name() vs function name ()
      // function* name() vs function* name ()
      // async name() vs async name ()
      // In ES6, you can also define the method properties of an object
      // var obj = {a: function() {}}
      // It can be abbreviated
      // var obj = {a() {}}
      // var obj = { a() {}} vs var obj = { a () {}}
      // var obj = { * a() {}} vs var obj = { * a () {}}
      var peek_back_two = this._tokens.peek(-3);
      if (this._options.space_after_named_function && peek_back_two) {
        // peek starts at next character so -1 is current token
        var peek_back_three = this._tokens.peek(-4);
        if (reserved_array(peek_back_two, ['async', 'function']) ||
          (peek_back_two.text === '*' && reserved_array(peek_back_three, ['async', 'function']))) {
          this._output.space_before_token = true;
        } else if (this._flags.mode === MODE.ObjectLiteral) {
          if ((peek_back_two.text === '{' || peek_back_two.text === ',') ||
            (peek_back_two.text === '*' && (peek_back_three.text === '{' || peek_back_three.text === ','))) {
            this._output.space_before_token = true;
          }
        }
      }
    } else {
      // Support preserving wrapped arrow function expressions
      // a.b('c',
      //     () => d.e
      // )
      this.allow_wrap_or_preserved_newline(current_token);
    }

    // function() vs function ()
    // yield*() vs yield* ()
    // function*() vs function* ()
    if ((this._flags.last_token.type === TOKEN.RESERVED && (this._flags.last_word === 'function' || this._flags.last_word === 'typeof')) ||
      (this._flags.last_token.text === '*' &&
        (in_array(this._last_last_text, ['function', 'yield']) ||
          (this._flags.mode === MODE.ObjectLiteral && in_array(this._last_last_text, ['{', ',']))))) {
      this._output.space_before_token = this._options.space_after_anon_function;
    }
  }

  if (this._flags.last_token.text === ';' || this._flags.last_token.type === TOKEN.START_BLOCK) {
    this.print_newline();
  } else if (this._flags.last_token.type === TOKEN.END_EXPR || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.END_BLOCK || this._flags.last_token.text === '.' || this._flags.last_token.type === TOKEN.COMMA) {
    // do nothing on (( and )( and ][ and ]( and .(
    // TODO: Consider whether forcing this is required.  Review failing tests when removed.
    this.allow_wrap_or_preserved_newline(current_token, current_token.newlines);
  }

  this.print_token(current_token);
  this.set_mode(next_mode);
  if (this._options.space_in_paren) {
    this._output.space_before_token = true;
  }

  // In all cases, if we newline while inside an expression it should be indented.
  this.indent();
};

Beautifier.prototype.handle_end_expr = function(current_token) {
  // statements inside expressions are not valid syntax, but...
  // statements must all be closed when their container closes
  while (this._flags.mode === MODE.Statement) {
    this.restore_mode();
  }

  this.handle_whitespace_and_comments(current_token);

  if (this._flags.multiline_frame) {
    this.allow_wrap_or_preserved_newline(current_token,
      current_token.text === ']' && is_array(this._flags.mode) && !this._options.keep_array_indentation);
  }

  if (this._options.space_in_paren) {
    if (this._flags.last_token.type === TOKEN.START_EXPR && !this._options.space_in_empty_paren) {
      // () [] no inner space in empty parens like these, ever, ref #320
      this._output.trim();
      this._output.space_before_token = false;
    } else {
      this._output.space_before_token = true;
    }
  }
  this.deindent();
  this.print_token(current_token);
  this.restore_mode();

  remove_redundant_indentation(this._output, this._previous_flags);

  // do {} while () // no statement required after
  if (this._flags.do_while && this._previous_flags.mode === MODE.Conditional) {
    this._previous_flags.mode = MODE.Expression;
    this._flags.do_block = false;
    this._flags.do_while = false;

  }
};

Beautifier.prototype.handle_start_block = function(current_token) {
  this.handle_whitespace_and_comments(current_token);

  // Check if this is should be treated as a ObjectLiteral
  var next_token = this._tokens.peek();
  var second_token = this._tokens.peek(1);
  if (this._flags.last_word === 'switch' && this._flags.last_token.type === TOKEN.END_EXPR) {
    this.set_mode(MODE.BlockStatement);
    this._flags.in_case_statement = true;
  } else if (this._flags.case_body) {
    this.set_mode(MODE.BlockStatement);
  } else if (second_token && (
      (in_array(second_token.text, [':', ',']) && in_array(next_token.type, [TOKEN.STRING, TOKEN.WORD, TOKEN.RESERVED])) ||
      (in_array(next_token.text, ['get', 'set', '...']) && in_array(second_token.type, [TOKEN.WORD, TOKEN.RESERVED]))
    )) {
    // We don't support TypeScript,but we didn't break it for a very long time.
    // We'll try to keep not breaking it.
    if (!in_array(this._last_last_text, ['class', 'interface'])) {
      this.set_mode(MODE.ObjectLiteral);
    } else {
      this.set_mode(MODE.BlockStatement);
    }
  } else if (this._flags.last_token.type === TOKEN.OPERATOR && this._flags.last_token.text === '=>') {
    // arrow function: (param1, paramN) => { statements }
    this.set_mode(MODE.BlockStatement);
  } else if (in_array(this._flags.last_token.type, [TOKEN.EQUALS, TOKEN.START_EXPR, TOKEN.COMMA, TOKEN.OPERATOR]) ||
    reserved_array(this._flags.last_token, ['return', 'throw', 'import', 'default'])
  ) {
    // Detecting shorthand function syntax is difficult by scanning forward,
    //     so check the surrounding context.
    // If the block is being returned, imported, export default, passed as arg,
    //     assigned with = or assigned in a nested object, treat as an ObjectLiteral.
    this.set_mode(MODE.ObjectLiteral);
  } else {
    this.set_mode(MODE.BlockStatement);
  }

  var empty_braces = !next_token.comments_before && next_token.text === '}';
  var empty_anonymous_function = empty_braces && this._flags.last_word === 'function' &&
    this._flags.last_token.type === TOKEN.END_EXPR;

  if (this._options.brace_preserve_inline) // check for inline, set inline_frame if so
  {
    // search forward for a newline wanted inside this block
    var index = 0;
    var check_token = null;
    this._flags.inline_frame = true;
    do {
      index += 1;
      check_token = this._tokens.peek(index - 1);
      if (check_token.newlines) {
        this._flags.inline_frame = false;
        break;
      }
    } while (check_token.type !== TOKEN.EOF &&
      !(check_token.type === TOKEN.END_BLOCK && check_token.opened === current_token));
  }

  if ((this._options.brace_style === "expand" ||
      (this._options.brace_style === "none" && current_token.newlines)) &&
    !this._flags.inline_frame) {
    if (this._flags.last_token.type !== TOKEN.OPERATOR &&
      (empty_anonymous_function ||
        this._flags.last_token.type === TOKEN.EQUALS ||
        (reserved_array(this._flags.last_token, special_words) && this._flags.last_token.text !== 'else'))) {
      this._output.space_before_token = true;
    } else {
      this.print_newline(false, true);
    }
  } else { // collapse || inline_frame
    if (is_array(this._previous_flags.mode) && (this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.COMMA)) {
      if (this._flags.last_token.type === TOKEN.COMMA || this._options.space_in_paren) {
        this._output.space_before_token = true;
      }

      if (this._flags.last_token.type === TOKEN.COMMA || (this._flags.last_token.type === TOKEN.START_EXPR && this._flags.inline_frame)) {
        this.allow_wrap_or_preserved_newline(current_token);
        this._previous_flags.multiline_frame = this._previous_flags.multiline_frame || this._flags.multiline_frame;
        this._flags.multiline_frame = false;
      }
    }
    if (this._flags.last_token.type !== TOKEN.OPERATOR && this._flags.last_token.type !== TOKEN.START_EXPR) {
      if (this._flags.last_token.type === TOKEN.START_BLOCK && !this._flags.inline_frame) {
        this.print_newline();
      } else {
        this._output.space_before_token = true;
      }
    }
  }
  this.print_token(current_token);
  this.indent();

  // Except for specific cases, open braces are followed by a new line.
  if (!empty_braces && !(this._options.brace_preserve_inline && this._flags.inline_frame)) {
    this.print_newline();
  }
};

Beautifier.prototype.handle_end_block = function(current_token) {
  // statements must all be closed when their container closes
  this.handle_whitespace_and_comments(current_token);

  while (this._flags.mode === MODE.Statement) {
    this.restore_mode();
  }

  var empty_braces = this._flags.last_token.type === TOKEN.START_BLOCK;

  if (this._flags.inline_frame && !empty_braces) { // try inline_frame (only set if this._options.braces-preserve-inline) first
    this._output.space_before_token = true;
  } else if (this._options.brace_style === "expand") {
    if (!empty_braces) {
      this.print_newline();
    }
  } else {
    // skip {}
    if (!empty_braces) {
      if (is_array(this._flags.mode) && this._options.keep_array_indentation) {
        // we REALLY need a newline here, but newliner would skip that
        this._options.keep_array_indentation = false;
        this.print_newline();
        this._options.keep_array_indentation = true;

      } else {
        this.print_newline();
      }
    }
  }
  this.restore_mode();
  this.print_token(current_token);
};

Beautifier.prototype.handle_word = function(current_token) {
  if (current_token.type === TOKEN.RESERVED) {
    if (in_array(current_token.text, ['set', 'get']) && this._flags.mode !== MODE.ObjectLiteral) {
      current_token.type = TOKEN.WORD;
    } else if (current_token.text === 'import' && this._tokens.peek().text === '(') {
      current_token.type = TOKEN.WORD;
    } else if (in_array(current_token.text, ['as', 'from']) && !this._flags.import_block) {
      current_token.type = TOKEN.WORD;
    } else if (this._flags.mode === MODE.ObjectLiteral) {
      var next_token = this._tokens.peek();
      if (next_token.text === ':') {
        current_token.type = TOKEN.WORD;
      }
    }
  }

  if (this.start_of_statement(current_token)) {
    // The conditional starts the statement if appropriate.
    if (reserved_array(this._flags.last_token, ['var', 'let', 'const']) && current_token.type === TOKEN.WORD) {
      this._flags.declaration_statement = true;
    }
  } else if (current_token.newlines && !is_expression(this._flags.mode) &&
    (this._flags.last_token.type !== TOKEN.OPERATOR || (this._flags.last_token.text === '--' || this._flags.last_token.text === '++')) &&
    this._flags.last_token.type !== TOKEN.EQUALS &&
    (this._options.preserve_newlines || !reserved_array(this._flags.last_token, ['var', 'let', 'const', 'set', 'get']))) {
    this.handle_whitespace_and_comments(current_token);
    this.print_newline();
  } else {
    this.handle_whitespace_and_comments(current_token);
  }

  if (this._flags.do_block && !this._flags.do_while) {
    if (reserved_word(current_token, 'while')) {
      // do {} ## while ()
      this._output.space_before_token = true;
      this.print_token(current_token);
      this._output.space_before_token = true;
      this._flags.do_while = true;
      return;
    } else {
      // do {} should always have while as the next word.
      // if we don't see the expected while, recover
      this.print_newline();
      this._flags.do_block = false;
    }
  }

  // if may be followed by else, or not
  // Bare/inline ifs are tricky
  // Need to unwind the modes correctly: if (a) if (b) c(); else d(); else e();
  if (this._flags.if_block) {
    if (!this._flags.else_block && reserved_word(current_token, 'else')) {
      this._flags.else_block = true;
    } else {
      while (this._flags.mode === MODE.Statement) {
        this.restore_mode();
      }
      this._flags.if_block = false;
      this._flags.else_block = false;
    }
  }

  if (this._flags.in_case_statement && reserved_array(current_token, ['case', 'default'])) {
    this.print_newline();
    if (this._flags.last_token.type !== TOKEN.END_BLOCK && (this._flags.case_body || this._options.jslint_happy)) {
      // switch cases following one another
      this.deindent();
    }
    this._flags.case_body = false;

    this.print_token(current_token);
    this._flags.in_case = true;
    return;
  }

  if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {
    if (!this.start_of_object_property()) {
      this.allow_wrap_or_preserved_newline(current_token);
    }
  }

  if (reserved_word(current_token, 'function')) {
    if (in_array(this._flags.last_token.text, ['}', ';']) ||
      (this._output.just_added_newline() && !(in_array(this._flags.last_token.text, ['(', '[', '{', ':', '=', ',']) || this._flags.last_token.type === TOKEN.OPERATOR))) {
      // make sure there is a nice clean space of at least one blank line
      // before a new function definition
      if (!this._output.just_added_blankline() && !current_token.comments_before) {
        this.print_newline();
        this.print_newline(true);
      }
    }
    if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD) {
      if (reserved_array(this._flags.last_token, ['get', 'set', 'new', 'export']) ||
        reserved_array(this._flags.last_token, newline_restricted_tokens)) {
        this._output.space_before_token = true;
      } else if (reserved_word(this._flags.last_token, 'default') && this._last_last_text === 'export') {
        this._output.space_before_token = true;
      } else if (this._flags.last_token.text === 'declare') {
        // accomodates Typescript declare function formatting
        this._output.space_before_token = true;
      } else {
        this.print_newline();
      }
    } else if (this._flags.last_token.type === TOKEN.OPERATOR || this._flags.last_token.text === '=') {
      // foo = function
      this._output.space_before_token = true;
    } else if (!this._flags.multiline_frame && (is_expression(this._flags.mode) || is_array(this._flags.mode))) {
      // (function
    } else {
      this.print_newline();
    }

    this.print_token(current_token);
    this._flags.last_word = current_token.text;
    return;
  }

  var prefix = 'NONE';

  if (this._flags.last_token.type === TOKEN.END_BLOCK) {

    if (this._previous_flags.inline_frame) {
      prefix = 'SPACE';
    } else if (!reserved_array(current_token, ['else', 'catch', 'finally', 'from'])) {
      prefix = 'NEWLINE';
    } else {
      if (this._options.brace_style === "expand" ||
        this._options.brace_style === "end-expand" ||
        (this._options.brace_style === "none" && current_token.newlines)) {
        prefix = 'NEWLINE';
      } else {
        prefix = 'SPACE';
        this._output.space_before_token = true;
      }
    }
  } else if (this._flags.last_token.type === TOKEN.SEMICOLON && this._flags.mode === MODE.BlockStatement) {
    // TODO: Should this be for STATEMENT as well?
    prefix = 'NEWLINE';
  } else if (this._flags.last_token.type === TOKEN.SEMICOLON && is_expression(this._flags.mode)) {
    prefix = 'SPACE';
  } else if (this._flags.last_token.type === TOKEN.STRING) {
    prefix = 'NEWLINE';
  } else if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD ||
    (this._flags.last_token.text === '*' &&
      (in_array(this._last_last_text, ['function', 'yield']) ||
        (this._flags.mode === MODE.ObjectLiteral && in_array(this._last_last_text, ['{', ',']))))) {
    prefix = 'SPACE';
  } else if (this._flags.last_token.type === TOKEN.START_BLOCK) {
    if (this._flags.inline_frame) {
      prefix = 'SPACE';
    } else {
      prefix = 'NEWLINE';
    }
  } else if (this._flags.last_token.type === TOKEN.END_EXPR) {
    this._output.space_before_token = true;
    prefix = 'NEWLINE';
  }

  if (reserved_array(current_token, line_starters) && this._flags.last_token.text !== ')') {
    if (this._flags.inline_frame || this._flags.last_token.text === 'else' || this._flags.last_token.text === 'export') {
      prefix = 'SPACE';
    } else {
      prefix = 'NEWLINE';
    }

  }

  if (reserved_array(current_token, ['else', 'catch', 'finally'])) {
    if ((!(this._flags.last_token.type === TOKEN.END_BLOCK && this._previous_flags.mode === MODE.BlockStatement) ||
        this._options.brace_style === "expand" ||
        this._options.brace_style === "end-expand" ||
        (this._options.brace_style === "none" && current_token.newlines)) &&
      !this._flags.inline_frame) {
      this.print_newline();
    } else {
      this._output.trim(true);
      var line = this._output.current_line;
      // If we trimmed and there's something other than a close block before us
      // put a newline back in.  Handles '} // comment' scenario.
      if (line.last() !== '}') {
        this.print_newline();
      }
      this._output.space_before_token = true;
    }
  } else if (prefix === 'NEWLINE') {
    if (reserved_array(this._flags.last_token, special_words)) {
      // no newline between 'return nnn'
      this._output.space_before_token = true;
    } else if (this._flags.last_token.text === 'declare' && reserved_array(current_token, ['var', 'let', 'const'])) {
      // accomodates Typescript declare formatting
      this._output.space_before_token = true;
    } else if (this._flags.last_token.type !== TOKEN.END_EXPR) {
      if ((this._flags.last_token.type !== TOKEN.START_EXPR || !reserved_array(current_token, ['var', 'let', 'const'])) && this._flags.last_token.text !== ':') {
        // no need to force newline on 'var': for (var x = 0...)
        if (reserved_word(current_token, 'if') && reserved_word(current_token.previous, 'else')) {
          // no newline for } else if {
          this._output.space_before_token = true;
        } else {
          this.print_newline();
        }
      }
    } else if (reserved_array(current_token, line_starters) && this._flags.last_token.text !== ')') {
      this.print_newline();
    }
  } else if (this._flags.multiline_frame && is_array(this._flags.mode) && this._flags.last_token.text === ',' && this._last_last_text === '}') {
    this.print_newline(); // }, in lists get a newline treatment
  } else if (prefix === 'SPACE') {
    this._output.space_before_token = true;
  }
  if (current_token.previous && (current_token.previous.type === TOKEN.WORD || current_token.previous.type === TOKEN.RESERVED)) {
    this._output.space_before_token = true;
  }
  this.print_token(current_token);
  this._flags.last_word = current_token.text;

  if (current_token.type === TOKEN.RESERVED) {
    if (current_token.text === 'do') {
      this._flags.do_block = true;
    } else if (current_token.text === 'if') {
      this._flags.if_block = true;
    } else if (current_token.text === 'import') {
      this._flags.import_block = true;
    } else if (this._flags.import_block && reserved_word(current_token, 'from')) {
      this._flags.import_block = false;
    }
  }
};

Beautifier.prototype.handle_semicolon = function(current_token) {
  if (this.start_of_statement(current_token)) {
    // The conditional starts the statement if appropriate.
    // Semicolon can be the start (and end) of a statement
    this._output.space_before_token = false;
  } else {
    this.handle_whitespace_and_comments(current_token);
  }

  var next_token = this._tokens.peek();
  while (this._flags.mode === MODE.Statement &&
    !(this._flags.if_block && reserved_word(next_token, 'else')) &&
    !this._flags.do_block) {
    this.restore_mode();
  }

  // hacky but effective for the moment
  if (this._flags.import_block) {
    this._flags.import_block = false;
  }
  this.print_token(current_token);
};

Beautifier.prototype.handle_string = function(current_token) {
  if (this.start_of_statement(current_token)) {
    // The conditional starts the statement if appropriate.
    // One difference - strings want at least a space before
    this._output.space_before_token = true;
  } else {
    this.handle_whitespace_and_comments(current_token);
    if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD || this._flags.inline_frame) {
      this._output.space_before_token = true;
    } else if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {
      if (!this.start_of_object_property()) {
        this.allow_wrap_or_preserved_newline(current_token);
      }
    } else {
      this.print_newline();
    }
  }
  this.print_token(current_token);
};

Beautifier.prototype.handle_equals = function(current_token) {
  if (this.start_of_statement(current_token)) {
    // The conditional starts the statement if appropriate.
  } else {
    this.handle_whitespace_and_comments(current_token);
  }

  if (this._flags.declaration_statement) {
    // just got an '=' in a var-line, different formatting/line-breaking, etc will now be done
    this._flags.declaration_assignment = true;
  }
  this._output.space_before_token = true;
  this.print_token(current_token);
  this._output.space_before_token = true;
};

Beautifier.prototype.handle_comma = function(current_token) {
  this.handle_whitespace_and_comments(current_token, true);

  this.print_token(current_token);
  this._output.space_before_token = true;
  if (this._flags.declaration_statement) {
    if (is_expression(this._flags.parent.mode)) {
      // do not break on comma, for(var a = 1, b = 2)
      this._flags.declaration_assignment = false;
    }

    if (this._flags.declaration_assignment) {
      this._flags.declaration_assignment = false;
      this.print_newline(false, true);
    } else if (this._options.comma_first) {
      // for comma-first, we want to allow a newline before the comma
      // to turn into a newline after the comma, which we will fixup later
      this.allow_wrap_or_preserved_newline(current_token);
    }
  } else if (this._flags.mode === MODE.ObjectLiteral ||
    (this._flags.mode === MODE.Statement && this._flags.parent.mode === MODE.ObjectLiteral)) {
    if (this._flags.mode === MODE.Statement) {
      this.restore_mode();
    }

    if (!this._flags.inline_frame) {
      this.print_newline();
    }
  } else if (this._options.comma_first) {
    // EXPR or DO_BLOCK
    // for comma-first, we want to allow a newline before the comma
    // to turn into a newline after the comma, which we will fixup later
    this.allow_wrap_or_preserved_newline(current_token);
  }
};

Beautifier.prototype.handle_operator = function(current_token) {
  var isGeneratorAsterisk = current_token.text === '*' &&
    (reserved_array(this._flags.last_token, ['function', 'yield']) ||
      (in_array(this._flags.last_token.type, [TOKEN.START_BLOCK, TOKEN.COMMA, TOKEN.END_BLOCK, TOKEN.SEMICOLON]))
    );
  var isUnary = in_array(current_token.text, ['-', '+']) && (
    in_array(this._flags.last_token.type, [TOKEN.START_BLOCK, TOKEN.START_EXPR, TOKEN.EQUALS, TOKEN.OPERATOR]) ||
    in_array(this._flags.last_token.text, line_starters) ||
    this._flags.last_token.text === ','
  );

  if (this.start_of_statement(current_token)) {
    // The conditional starts the statement if appropriate.
  } else {
    var preserve_statement_flags = !isGeneratorAsterisk;
    this.handle_whitespace_and_comments(current_token, preserve_statement_flags);
  }

  if (reserved_array(this._flags.last_token, special_words)) {
    // "return" had a special handling in TK_WORD. Now we need to return the favor
    this._output.space_before_token = true;
    this.print_token(current_token);
    return;
  }

  // hack for actionscript's import .*;
  if (current_token.text === '*' && this._flags.last_token.type === TOKEN.DOT) {
    this.print_token(current_token);
    return;
  }

  if (current_token.text === '::') {
    // no spaces around exotic namespacing syntax operator
    this.print_token(current_token);
    return;
  }

  // Allow line wrapping between operators when operator_position is
  //   set to before or preserve
  if (this._flags.last_token.type === TOKEN.OPERATOR && in_array(this._options.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE)) {
    this.allow_wrap_or_preserved_newline(current_token);
  }

  if (current_token.text === ':' && this._flags.in_case) {
    this.print_token(current_token);

    this._flags.in_case = false;
    this._flags.case_body = true;
    if (this._tokens.peek().type !== TOKEN.START_BLOCK) {
      this.indent();
      this.print_newline();
    } else {
      this._output.space_before_token = true;
    }
    return;
  }

  var space_before = true;
  var space_after = true;
  var in_ternary = false;
  if (current_token.text === ':') {
    if (this._flags.ternary_depth === 0) {
      // Colon is invalid javascript outside of ternary and object, but do our best to guess what was meant.
      space_before = false;
    } else {
      this._flags.ternary_depth -= 1;
      in_ternary = true;
    }
  } else if (current_token.text === '?') {
    this._flags.ternary_depth += 1;
  }

  // let's handle the operator_position option prior to any conflicting logic
  if (!isUnary && !isGeneratorAsterisk && this._options.preserve_newlines && in_array(current_token.text, positionable_operators)) {
    var isColon = current_token.text === ':';
    var isTernaryColon = (isColon && in_ternary);
    var isOtherColon = (isColon && !in_ternary);

    switch (this._options.operator_position) {
      case OPERATOR_POSITION.before_newline:
        // if the current token is : and it's not a ternary statement then we set space_before to false
        this._output.space_before_token = !isOtherColon;

        this.print_token(current_token);

        if (!isColon || isTernaryColon) {
          this.allow_wrap_or_preserved_newline(current_token);
        }

        this._output.space_before_token = true;
        return;

      case OPERATOR_POSITION.after_newline:
        // if the current token is anything but colon, or (via deduction) it's a colon and in a ternary statement,
        //   then print a newline.

        this._output.space_before_token = true;

        if (!isColon || isTernaryColon) {
          if (this._tokens.peek().newlines) {
            this.print_newline(false, true);
          } else {
            this.allow_wrap_or_preserved_newline(current_token);
          }
        } else {
          this._output.space_before_token = false;
        }

        this.print_token(current_token);

        this._output.space_before_token = true;
        return;

      case OPERATOR_POSITION.preserve_newline:
        if (!isOtherColon) {
          this.allow_wrap_or_preserved_newline(current_token);
        }

        // if we just added a newline, or the current token is : and it's not a ternary statement,
        //   then we set space_before to false
        space_before = !(this._output.just_added_newline() || isOtherColon);

        this._output.space_before_token = space_before;
        this.print_token(current_token);
        this._output.space_before_token = true;
        return;
    }
  }

  if (isGeneratorAsterisk) {
    this.allow_wrap_or_preserved_newline(current_token);
    space_before = false;
    var next_token = this._tokens.peek();
    space_after = next_token && in_array(next_token.type, [TOKEN.WORD, TOKEN.RESERVED]);
  } else if (current_token.text === '...') {
    this.allow_wrap_or_preserved_newline(current_token);
    space_before = this._flags.last_token.type === TOKEN.START_BLOCK;
    space_after = false;
  } else if (in_array(current_token.text, ['--', '++', '!', '~']) || isUnary) {
    // unary operators (and binary +/- pretending to be unary) special cases
    if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR) {
      this.allow_wrap_or_preserved_newline(current_token);
    }

    space_before = false;
    space_after = false;

    // http://www.ecma-international.org/ecma-262/5.1/#sec-7.9.1
    // if there is a newline between -- or ++ and anything else we should preserve it.
    if (current_token.newlines && (current_token.text === '--' || current_token.text === '++')) {
      this.print_newline(false, true);
    }

    if (this._flags.last_token.text === ';' && is_expression(this._flags.mode)) {
      // for (;; ++i)
      //        ^^^
      space_before = true;
    }

    if (this._flags.last_token.type === TOKEN.RESERVED) {
      space_before = true;
    } else if (this._flags.last_token.type === TOKEN.END_EXPR) {
      space_before = !(this._flags.last_token.text === ']' && (current_token.text === '--' || current_token.text === '++'));
    } else if (this._flags.last_token.type === TOKEN.OPERATOR) {
      // a++ + ++b;
      // a - -b
      space_before = in_array(current_token.text, ['--', '-', '++', '+']) && in_array(this._flags.last_token.text, ['--', '-', '++', '+']);
      // + and - are not unary when preceeded by -- or ++ operator
      // a-- + b
      // a * +b
      // a - -b
      if (in_array(current_token.text, ['+', '-']) && in_array(this._flags.last_token.text, ['--', '++'])) {
        space_after = true;
      }
    }


    if (((this._flags.mode === MODE.BlockStatement && !this._flags.inline_frame) || this._flags.mode === MODE.Statement) &&
      (this._flags.last_token.text === '{' || this._flags.last_token.text === ';')) {
      // { foo; --i }
      // foo(); --bar;
      this.print_newline();
    }
  }

  this._output.space_before_token = this._output.space_before_token || space_before;
  this.print_token(current_token);
  this._output.space_before_token = space_after;
};

Beautifier.prototype.handle_block_comment = function(current_token, preserve_statement_flags) {
  if (this._output.raw) {
    this._output.add_raw_token(current_token);
    if (current_token.directives && current_token.directives.preserve === 'end') {
      // If we're testing the raw output behavior, do not allow a directive to turn it off.
      this._output.raw = this._options.test_output_raw;
    }
    return;
  }

  if (current_token.directives) {
    this.print_newline(false, preserve_statement_flags);
    this.print_token(current_token);
    if (current_token.directives.preserve === 'start') {
      this._output.raw = true;
    }
    this.print_newline(false, true);
    return;
  }

  // inline block
  if (!acorn.newline.test(current_token.text) && !current_token.newlines) {
    this._output.space_before_token = true;
    this.print_token(current_token);
    this._output.space_before_token = true;
    return;
  } else {
    this.print_block_commment(current_token, preserve_statement_flags);
  }
};

Beautifier.prototype.print_block_commment = function(current_token, preserve_statement_flags) {
  var lines = split_linebreaks(current_token.text);
  var j; // iterator for this case
  var javadoc = false;
  var starless = false;
  var lastIndent = current_token.whitespace_before;
  var lastIndentLength = lastIndent.length;

  // block comment starts with a new line
  this.print_newline(false, preserve_statement_flags);

  // first line always indented
  this.print_token_line_indentation(current_token);
  this._output.add_token(lines[0]);
  this.print_newline(false, preserve_statement_flags);


  if (lines.length > 1) {
    lines = lines.slice(1);
    javadoc = all_lines_start_with(lines, '*');
    starless = each_line_matches_indent(lines, lastIndent);

    if (javadoc) {
      this._flags.alignment = 1;
    }

    for (j = 0; j < lines.length; j++) {
      if (javadoc) {
        // javadoc: reformat and re-indent
        this.print_token_line_indentation(current_token);
        this._output.add_token(ltrim(lines[j]));
      } else if (starless && lines[j]) {
        // starless: re-indent non-empty content, avoiding trim
        this.print_token_line_indentation(current_token);
        this._output.add_token(lines[j].substring(lastIndentLength));
      } else {
        // normal comments output raw
        this._output.current_line.set_indent(-1);
        this._output.add_token(lines[j]);
      }

      // for comments on their own line or  more than one line, make sure there's a new line after
      this.print_newline(false, preserve_statement_flags);
    }

    this._flags.alignment = 0;
  }
};


Beautifier.prototype.handle_comment = function(current_token, preserve_statement_flags) {
  if (current_token.newlines) {
    this.print_newline(false, preserve_statement_flags);
  } else {
    this._output.trim(true);
  }

  this._output.space_before_token = true;
  this.print_token(current_token);
  this.print_newline(false, preserve_statement_flags);
};

Beautifier.prototype.handle_dot = function(current_token) {
  if (this.start_of_statement(current_token)) {
    // The conditional starts the statement if appropriate.
  } else {
    this.handle_whitespace_and_comments(current_token, true);
  }

  if (reserved_array(this._flags.last_token, special_words)) {
    this._output.space_before_token = false;
  } else {
    // allow preserved newlines before dots in general
    // force newlines on dots after close paren when break_chained - for bar().baz()
    this.allow_wrap_or_preserved_newline(current_token,
      this._flags.last_token.text === ')' && this._options.break_chained_methods);
  }

  // Only unindent chained method dot if this dot starts a new line.
  // Otherwise the automatic extra indentation removal will handle the over indent
  if (this._options.unindent_chained_methods && this._output.just_added_newline()) {
    this.deindent();
  }

  this.print_token(current_token);
};

Beautifier.prototype.handle_unknown = function(current_token, preserve_statement_flags) {
  this.print_token(current_token);

  if (current_token.text[current_token.text.length - 1] === '\n') {
    this.print_newline(false, preserve_statement_flags);
  }
};

Beautifier.prototype.handle_eof = function(current_token) {
  // Unwind any open statements
  while (this._flags.mode === MODE.Statement) {
    this.restore_mode();
  }
  this.handle_whitespace_and_comments(current_token);
};

module.exports.Beautifier = Beautifier;

},{"../core/output":30,"../core/token":33,"./acorn":45,"./options":48,"./tokenizer":49}],47:[function(require,module,exports){
/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

'use strict';

var Beautifier = require('./beautifier').Beautifier,
  Options = require('./options').Options;

function js_beautify(js_source_text, options) {
  var beautifier = new Beautifier(js_source_text, options);
  return beautifier.beautify();
}

module.exports = js_beautify;
module.exports.defaultOptions = function() {
  return new Options();
};

},{"./beautifier":46,"./options":48}],48:[function(require,module,exports){
/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

'use strict';

var BaseOptions = require('../core/options').Options;

var validPositionValues = ['before-newline', 'after-newline', 'preserve-newline'];

function Options(options) {
  BaseOptions.call(this, options, 'js');

  // compatibility, re
  var raw_brace_style = this.raw_options.brace_style || null;
  if (raw_brace_style === "expand-strict") { //graceful handling of deprecated option
    this.raw_options.brace_style = "expand";
  } else if (raw_brace_style === "collapse-preserve-inline") { //graceful handling of deprecated option
    this.raw_options.brace_style = "collapse,preserve-inline";
  } else if (this.raw_options.braces_on_own_line !== undefined) { //graceful handling of deprecated option
    this.raw_options.brace_style = this.raw_options.braces_on_own_line ? "expand" : "collapse";
    // } else if (!raw_brace_style) { //Nothing exists to set it
    //   raw_brace_style = "collapse";
  }

  //preserve-inline in delimited string will trigger brace_preserve_inline, everything
  //else is considered a brace_style and the last one only will have an effect

  var brace_style_split = this._get_selection_list('brace_style', ['collapse', 'expand', 'end-expand', 'none', 'preserve-inline']);

  this.brace_preserve_inline = false; //Defaults in case one or other was not specified in meta-option
  this.brace_style = "collapse";

  for (var bs = 0; bs < brace_style_split.length; bs++) {
    if (brace_style_split[bs] === "preserve-inline") {
      this.brace_preserve_inline = true;
    } else {
      this.brace_style = brace_style_split[bs];
    }
  }

  this.unindent_chained_methods = this._get_boolean('unindent_chained_methods');
  this.break_chained_methods = this._get_boolean('break_chained_methods');
  this.space_in_paren = this._get_boolean('space_in_paren');
  this.space_in_empty_paren = this._get_boolean('space_in_empty_paren');
  this.jslint_happy = this._get_boolean('jslint_happy');
  this.space_after_anon_function = this._get_boolean('space_after_anon_function');
  this.space_after_named_function = this._get_boolean('space_after_named_function');
  this.keep_array_indentation = this._get_boolean('keep_array_indentation');
  this.space_before_conditional = this._get_boolean('space_before_conditional', true);
  this.unescape_strings = this._get_boolean('unescape_strings');
  this.e4x = this._get_boolean('e4x');
  this.comma_first = this._get_boolean('comma_first');
  this.operator_position = this._get_selection('operator_position', validPositionValues);

  // For testing of beautify preserve:start directive
  this.test_output_raw = this._get_boolean('test_output_raw');

  // force this._options.space_after_anon_function to true if this._options.jslint_happy
  if (this.jslint_happy) {
    this.space_after_anon_function = true;
  }

}
Options.prototype = new BaseOptions();



module.exports.Options = Options;

},{"../core/options":29}],49:[function(require,module,exports){
/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

'use strict';

var InputScanner = require('../core/inputscanner').InputScanner;
var BaseTokenizer = require('../core/tokenizer').Tokenizer;
var BASETOKEN = require('../core/tokenizer').TOKEN;
var Directives = require('../core/directives').Directives;
var acorn = require('./acorn');
var Pattern = require('../core/pattern').Pattern;
var TemplatablePattern = require('../core/templatablepattern').TemplatablePattern;


function in_array(what, arr) {
  return arr.indexOf(what) !== -1;
}


var TOKEN = {
  START_EXPR: 'TK_START_EXPR',
  END_EXPR: 'TK_END_EXPR',
  START_BLOCK: 'TK_START_BLOCK',
  END_BLOCK: 'TK_END_BLOCK',
  WORD: 'TK_WORD',
  RESERVED: 'TK_RESERVED',
  SEMICOLON: 'TK_SEMICOLON',
  STRING: 'TK_STRING',
  EQUALS: 'TK_EQUALS',
  OPERATOR: 'TK_OPERATOR',
  COMMA: 'TK_COMMA',
  BLOCK_COMMENT: 'TK_BLOCK_COMMENT',
  COMMENT: 'TK_COMMENT',
  DOT: 'TK_DOT',
  UNKNOWN: 'TK_UNKNOWN',
  START: BASETOKEN.START,
  RAW: BASETOKEN.RAW,
  EOF: BASETOKEN.EOF
};


var directives_core = new Directives(/\/\*/, /\*\//);

var number_pattern = /0[xX][0123456789abcdefABCDEF]*|0[oO][01234567]*|0[bB][01]*|\d+n|(?:\.\d+|\d+\.?\d*)(?:[eE][+-]?\d+)?/;

var digit = /[0-9]/;

// Dot "." must be distinguished from "..." and decimal
var dot_pattern = /[^\d\.]/;

var positionable_operators = (
  ">>> === !== " +
  "<< && >= ** != == <= >> || " +
  "< / - + > : & % ? ^ | *").split(' ');

// IMPORTANT: this must be sorted longest to shortest or tokenizing many not work.
// Also, you must update possitionable operators separately from punct
var punct =
  ">>>= " +
  "... >>= <<= === >>> !== **= " +
  "=> ^= :: /= << <= == && -= >= >> != -- += ** || ++ %= &= *= |= " +
  "= ! ? > < : / ^ - + * & % ~ |";

punct = punct.replace(/[-[\]{}()*+?.,\\^$|#]/g, "\\$&");
punct = punct.replace(/ /g, '|');

var punct_pattern = new RegExp(punct);

// words which should always start on new line.
var line_starters = 'continue,try,throw,return,var,let,const,if,switch,case,default,for,while,break,function,import,export'.split(',');
var reserved_words = line_starters.concat(['do', 'in', 'of', 'else', 'get', 'set', 'new', 'catch', 'finally', 'typeof', 'yield', 'async', 'await', 'from', 'as']);
var reserved_word_pattern = new RegExp('^(?:' + reserved_words.join('|') + ')$');

// var template_pattern = /(?:(?:<\?php|<\?=)[\s\S]*?\?>)|(?:<%[\s\S]*?%>)/g;

var in_html_comment;

var Tokenizer = function(input_string, options) {
  BaseTokenizer.call(this, input_string, options);

  this._patterns.whitespace = this._patterns.whitespace.matching(
    /\u00A0\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff/.source,
    /\u2028\u2029/.source);

  var pattern_reader = new Pattern(this._input);
  var templatable = new TemplatablePattern(this._input)
    .read_options(this._options);

  this.__patterns = {
    template: templatable,
    identifier: templatable.starting_with(acorn.identifier).matching(acorn.identifierMatch),
    number: pattern_reader.matching(number_pattern),
    punct: pattern_reader.matching(punct_pattern),
    // comment ends just before nearest linefeed or end of file
    comment: pattern_reader.starting_with(/\/\//).until(/[\n\r\u2028\u2029]/),
    //  /* ... */ comment ends with nearest */ or end of file
    block_comment: pattern_reader.starting_with(/\/\*/).until_after(/\*\//),
    html_comment_start: pattern_reader.matching(/<!--/),
    html_comment_end: pattern_reader.matching(/-->/),
    include: pattern_reader.starting_with(/#include/).until_after(acorn.lineBreak),
    shebang: pattern_reader.starting_with(/#!/).until_after(acorn.lineBreak),
    xml: pattern_reader.matching(/[\s\S]*?<(\/?)([-a-zA-Z:0-9_.]+|{[\s\S]+?}|!\[CDATA\[[\s\S]*?\]\])(\s+{[\s\S]+?}|\s+[-a-zA-Z:0-9_.]+|\s+[-a-zA-Z:0-9_.]+\s*=\s*('[^']*'|"[^"]*"|{[\s\S]+?}))*\s*(\/?)\s*>/),
    single_quote: templatable.until(/['\\\n\r\u2028\u2029]/),
    double_quote: templatable.until(/["\\\n\r\u2028\u2029]/),
    template_text: templatable.until(/[`\\$]/),
    template_expression: templatable.until(/[`}\\]/)
  };

};
Tokenizer.prototype = new BaseTokenizer();

Tokenizer.prototype._is_comment = function(current_token) {
  return current_token.type === TOKEN.COMMENT || current_token.type === TOKEN.BLOCK_COMMENT || current_token.type === TOKEN.UNKNOWN;
};

Tokenizer.prototype._is_opening = function(current_token) {
  return current_token.type === TOKEN.START_BLOCK || current_token.type === TOKEN.START_EXPR;
};

Tokenizer.prototype._is_closing = function(current_token, open_token) {
  return (current_token.type === TOKEN.END_BLOCK || current_token.type === TOKEN.END_EXPR) &&
    (open_token && (
      (current_token.text === ']' && open_token.text === '[') ||
      (current_token.text === ')' && open_token.text === '(') ||
      (current_token.text === '}' && open_token.text === '{')));
};

Tokenizer.prototype._reset = function() {
  in_html_comment = false;
};

Tokenizer.prototype._get_next_token = function(previous_token, open_token) { // jshint unused:false
  var token = null;
  this._readWhitespace();
  var c = this._input.peek();

  if (c === null) {
    return this._create_token(TOKEN.EOF, '');
  }

  token = token || this._read_non_javascript(c);
  token = token || this._read_string(c);
  token = token || this._read_word(previous_token);
  token = token || this._read_singles(c);
  token = token || this._read_comment(c);
  token = token || this._read_regexp(c, previous_token);
  token = token || this._read_xml(c, previous_token);
  token = token || this._read_punctuation();
  token = token || this._create_token(TOKEN.UNKNOWN, this._input.next());

  return token;
};

Tokenizer.prototype._read_word = function(previous_token) {
  var resulting_string;
  resulting_string = this.__patterns.identifier.read();
  if (resulting_string !== '') {
    resulting_string = resulting_string.replace(acorn.allLineBreaks, '\n');
    if (!(previous_token.type === TOKEN.DOT ||
        (previous_token.type === TOKEN.RESERVED && (previous_token.text === 'set' || previous_token.text === 'get'))) &&
      reserved_word_pattern.test(resulting_string)) {
      if (resulting_string === 'in' || resulting_string === 'of') { // hack for 'in' and 'of' operators
        return this._create_token(TOKEN.OPERATOR, resulting_string);
      }
      return this._create_token(TOKEN.RESERVED, resulting_string);
    }
    return this._create_token(TOKEN.WORD, resulting_string);
  }

  resulting_string = this.__patterns.number.read();
  if (resulting_string !== '') {
    return this._create_token(TOKEN.WORD, resulting_string);
  }
};

Tokenizer.prototype._read_singles = function(c) {
  var token = null;
  if (c === '(' || c === '[') {
    token = this._create_token(TOKEN.START_EXPR, c);
  } else if (c === ')' || c === ']') {
    token = this._create_token(TOKEN.END_EXPR, c);
  } else if (c === '{') {
    token = this._create_token(TOKEN.START_BLOCK, c);
  } else if (c === '}') {
    token = this._create_token(TOKEN.END_BLOCK, c);
  } else if (c === ';') {
    token = this._create_token(TOKEN.SEMICOLON, c);
  } else if (c === '.' && dot_pattern.test(this._input.peek(1))) {
    token = this._create_token(TOKEN.DOT, c);
  } else if (c === ',') {
    token = this._create_token(TOKEN.COMMA, c);
  }

  if (token) {
    this._input.next();
  }
  return token;
};

Tokenizer.prototype._read_punctuation = function() {
  var resulting_string = this.__patterns.punct.read();

  if (resulting_string !== '') {
    if (resulting_string === '=') {
      return this._create_token(TOKEN.EQUALS, resulting_string);
    } else {
      return this._create_token(TOKEN.OPERATOR, resulting_string);
    }
  }
};

Tokenizer.prototype._read_non_javascript = function(c) {
  var resulting_string = '';

  if (c === '#') {
    if (this._is_first_token()) {
      resulting_string = this.__patterns.shebang.read();

      if (resulting_string) {
        return this._create_token(TOKEN.UNKNOWN, resulting_string.trim() + '\n');
      }
    }

    // handles extendscript #includes
    resulting_string = this.__patterns.include.read();

    if (resulting_string) {
      return this._create_token(TOKEN.UNKNOWN, resulting_string.trim() + '\n');
    }

    c = this._input.next();

    // Spidermonkey-specific sharp variables for circular references. Considered obsolete.
    var sharp = '#';
    if (this._input.hasNext() && this._input.testChar(digit)) {
      do {
        c = this._input.next();
        sharp += c;
      } while (this._input.hasNext() && c !== '#' && c !== '=');
      if (c === '#') {
        //
      } else if (this._input.peek() === '[' && this._input.peek(1) === ']') {
        sharp += '[]';
        this._input.next();
        this._input.next();
      } else if (this._input.peek() === '{' && this._input.peek(1) === '}') {
        sharp += '{}';
        this._input.next();
        this._input.next();
      }
      return this._create_token(TOKEN.WORD, sharp);
    }

    this._input.back();

  } else if (c === '<' && this._is_first_token()) {
    resulting_string = this.__patterns.html_comment_start.read();
    if (resulting_string) {
      while (this._input.hasNext() && !this._input.testChar(acorn.newline)) {
        resulting_string += this._input.next();
      }
      in_html_comment = true;
      return this._create_token(TOKEN.COMMENT, resulting_string);
    }
  } else if (in_html_comment && c === '-') {
    resulting_string = this.__patterns.html_comment_end.read();
    if (resulting_string) {
      in_html_comment = false;
      return this._create_token(TOKEN.COMMENT, resulting_string);
    }
  }

  return null;
};

Tokenizer.prototype._read_comment = function(c) {
  var token = null;
  if (c === '/') {
    var comment = '';
    if (this._input.peek(1) === '*') {
      // peek for comment /* ... */
      comment = this.__patterns.block_comment.read();
      var directives = directives_core.get_directives(comment);
      if (directives && directives.ignore === 'start') {
        comment += directives_core.readIgnored(this._input);
      }
      comment = comment.replace(acorn.allLineBreaks, '\n');
      token = this._create_token(TOKEN.BLOCK_COMMENT, comment);
      token.directives = directives;
    } else if (this._input.peek(1) === '/') {
      // peek for comment // ...
      comment = this.__patterns.comment.read();
      token = this._create_token(TOKEN.COMMENT, comment);
    }
  }
  return token;
};

Tokenizer.prototype._read_string = function(c) {
  if (c === '`' || c === "'" || c === '"') {
    var resulting_string = this._input.next();
    this.has_char_escapes = false;

    if (c === '`') {
      resulting_string += this._read_string_recursive('`', true, '${');
    } else {
      resulting_string += this._read_string_recursive(c);
    }

    if (this.has_char_escapes && this._options.unescape_strings) {
      resulting_string = unescape_string(resulting_string);
    }

    if (this._input.peek() === c) {
      resulting_string += this._input.next();
    }

    resulting_string = resulting_string.replace(acorn.allLineBreaks, '\n');

    return this._create_token(TOKEN.STRING, resulting_string);
  }

  return null;
};

Tokenizer.prototype._allow_regexp_or_xml = function(previous_token) {
  // regex and xml can only appear in specific locations during parsing
  return (previous_token.type === TOKEN.RESERVED && in_array(previous_token.text, ['return', 'case', 'throw', 'else', 'do', 'typeof', 'yield'])) ||
    (previous_token.type === TOKEN.END_EXPR && previous_token.text === ')' &&
      previous_token.opened.previous.type === TOKEN.RESERVED && in_array(previous_token.opened.previous.text, ['if', 'while', 'for'])) ||
    (in_array(previous_token.type, [TOKEN.COMMENT, TOKEN.START_EXPR, TOKEN.START_BLOCK, TOKEN.START,
      TOKEN.END_BLOCK, TOKEN.OPERATOR, TOKEN.EQUALS, TOKEN.EOF, TOKEN.SEMICOLON, TOKEN.COMMA
    ]));
};

Tokenizer.prototype._read_regexp = function(c, previous_token) {

  if (c === '/' && this._allow_regexp_or_xml(previous_token)) {
    // handle regexp
    //
    var resulting_string = this._input.next();
    var esc = false;

    var in_char_class = false;
    while (this._input.hasNext() &&
      ((esc || in_char_class || this._input.peek() !== c) &&
        !this._input.testChar(acorn.newline))) {
      resulting_string += this._input.peek();
      if (!esc) {
        esc = this._input.peek() === '\\';
        if (this._input.peek() === '[') {
          in_char_class = true;
        } else if (this._input.peek() === ']') {
          in_char_class = false;
        }
      } else {
        esc = false;
      }
      this._input.next();
    }

    if (this._input.peek() === c) {
      resulting_string += this._input.next();

      // regexps may have modifiers /regexp/MOD , so fetch those, too
      // Only [gim] are valid, but if the user puts in garbage, do what we can to take it.
      resulting_string += this._input.read(acorn.identifier);
    }
    return this._create_token(TOKEN.STRING, resulting_string);
  }
  return null;
};

Tokenizer.prototype._read_xml = function(c, previous_token) {

  if (this._options.e4x && c === "<" && this._allow_regexp_or_xml(previous_token)) {
    var xmlStr = '';
    var match = this.__patterns.xml.read_match();
    // handle e4x xml literals
    //
    if (match) {
      // Trim root tag to attempt to
      var rootTag = match[2].replace(/^{\s+/, '{').replace(/\s+}$/, '}');
      var isCurlyRoot = rootTag.indexOf('{') === 0;
      var depth = 0;
      while (match) {
        var isEndTag = !!match[1];
        var tagName = match[2];
        var isSingletonTag = (!!match[match.length - 1]) || (tagName.slice(0, 8) === "![CDATA[");
        if (!isSingletonTag &&
          (tagName === rootTag || (isCurlyRoot && tagName.replace(/^{\s+/, '{').replace(/\s+}$/, '}')))) {
          if (isEndTag) {
            --depth;
          } else {
            ++depth;
          }
        }
        xmlStr += match[0];
        if (depth <= 0) {
          break;
        }
        match = this.__patterns.xml.read_match();
      }
      // if we didn't close correctly, keep unformatted.
      if (!match) {
        xmlStr += this._input.match(/[\s\S]*/g)[0];
      }
      xmlStr = xmlStr.replace(acorn.allLineBreaks, '\n');
      return this._create_token(TOKEN.STRING, xmlStr);
    }
  }

  return null;
};

function unescape_string(s) {
  // You think that a regex would work for this
  // return s.replace(/\\x([0-9a-f]{2})/gi, function(match, val) {
  //         return String.fromCharCode(parseInt(val, 16));
  //     })
  // However, dealing with '\xff', '\\xff', '\\\xff' makes this more fun.
  var out = '',
    escaped = 0;

  var input_scan = new InputScanner(s);
  var matched = null;

  while (input_scan.hasNext()) {
    // Keep any whitespace, non-slash characters
    // also keep slash pairs.
    matched = input_scan.match(/([\s]|[^\\]|\\\\)+/g);

    if (matched) {
      out += matched[0];
    }

    if (input_scan.peek() === '\\') {
      input_scan.next();
      if (input_scan.peek() === 'x') {
        matched = input_scan.match(/x([0-9A-Fa-f]{2})/g);
      } else if (input_scan.peek() === 'u') {
        matched = input_scan.match(/u([0-9A-Fa-f]{4})/g);
      } else {
        out += '\\';
        if (input_scan.hasNext()) {
          out += input_scan.next();
        }
        continue;
      }

      // If there's some error decoding, return the original string
      if (!matched) {
        return s;
      }

      escaped = parseInt(matched[1], 16);

      if (escaped > 0x7e && escaped <= 0xff && matched[0].indexOf('x') === 0) {
        // we bail out on \x7f..\xff,
        // leaving whole string escaped,
        // as it's probably completely binary
        return s;
      } else if (escaped >= 0x00 && escaped < 0x20) {
        // leave 0x00...0x1f escaped
        out += '\\' + matched[0];
        continue;
      } else if (escaped === 0x22 || escaped === 0x27 || escaped === 0x5c) {
        // single-quote, apostrophe, backslash - escape these
        out += '\\' + String.fromCharCode(escaped);
      } else {
        out += String.fromCharCode(escaped);
      }
    }
  }

  return out;
}

// handle string
//
Tokenizer.prototype._read_string_recursive = function(delimiter, allow_unescaped_newlines, start_sub) {
  var current_char;
  var pattern;
  if (delimiter === '\'') {
    pattern = this.__patterns.single_quote;
  } else if (delimiter === '"') {
    pattern = this.__patterns.double_quote;
  } else if (delimiter === '`') {
    pattern = this.__patterns.template_text;
  } else if (delimiter === '}') {
    pattern = this.__patterns.template_expression;
  }

  var resulting_string = pattern.read();
  var next = '';
  while (this._input.hasNext()) {
    next = this._input.next();
    if (next === delimiter ||
      (!allow_unescaped_newlines && acorn.newline.test(next))) {
      this._input.back();
      break;
    } else if (next === '\\' && this._input.hasNext()) {
      current_char = this._input.peek();

      if (current_char === 'x' || current_char === 'u') {
        this.has_char_escapes = true;
      } else if (current_char === '\r' && this._input.peek(1) === '\n') {
        this._input.next();
      }
      next += this._input.next();
    } else if (start_sub) {
      if (start_sub === '${' && next === '$' && this._input.peek() === '{') {
        next += this._input.next();
      }

      if (start_sub === next) {
        if (delimiter === '`') {
          next += this._read_string_recursive('}', allow_unescaped_newlines, '`');
        } else {
          next += this._read_string_recursive('`', allow_unescaped_newlines, '${');
        }
        if (this._input.hasNext()) {
          next += this._input.next();
        }
      }
    }
    next += pattern.read();
    resulting_string += next;
  }

  return resulting_string;
};

module.exports.Tokenizer = Tokenizer;
module.exports.TOKEN = TOKEN;
module.exports.positionable_operators = positionable_operators.slice();
module.exports.line_starters = line_starters.slice();

},{"../core/directives":27,"../core/inputscanner":28,"../core/pattern":31,"../core/templatablepattern":32,"../core/tokenizer":34,"./acorn":45}],50:[function(require,module,exports){
(function (process){
// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":51}],51:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],52:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"./util":61,"dup":6}],53:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"./base64":54,"dup":7}],54:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],55:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"dup":9}],56:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"./util":61,"dup":10}],57:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],58:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./array-set":52,"./base64-vlq":53,"./binary-search":55,"./quick-sort":57,"./util":61,"dup":12}],59:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"./array-set":52,"./base64-vlq":53,"./mapping-list":56,"./util":61,"dup":13}],60:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./source-map-generator":59,"./util":61,"dup":14}],61:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"dup":15}],62:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./lib/source-map-consumer":58,"./lib/source-map-generator":59,"./lib/source-node":60,"dup":16}],63:[function(require,module,exports){
(function (process){
var SourceMapConsumer = require('source-map').SourceMapConsumer;
var path = require('path');

var fs;
try {
  fs = require('fs');
  if (!fs.existsSync || !fs.readFileSync) {
    // fs doesn't have all methods we need
    fs = null;
  }
} catch (err) {
  /* nop */
}

var bufferFrom = require('buffer-from');

// Only install once if called multiple times
var errorFormatterInstalled = false;
var uncaughtShimInstalled = false;

// If true, the caches are reset before a stack trace formatting operation
var emptyCacheBetweenOperations = false;

// Supports {browser, node, auto}
var environment = "auto";

// Maps a file path to a string containing the file contents
var fileContentsCache = {};

// Maps a file path to a source map for that file
var sourceMapCache = {};

// Regex for detecting source maps
var reSourceMap = /^data:application\/json[^,]+base64,/;

// Priority list of retrieve handlers
var retrieveFileHandlers = [];
var retrieveMapHandlers = [];

function isInBrowser() {
  if (environment === "browser")
    return true;
  if (environment === "node")
    return false;
  return ((typeof window !== 'undefined') && (typeof XMLHttpRequest === 'function') && !(window.require && window.module && window.process && window.process.type === "renderer"));
}

function hasGlobalProcessEventEmitter() {
  return ((typeof process === 'object') && (process !== null) && (typeof process.on === 'function'));
}

function handlerExec(list) {
  return function(arg) {
    for (var i = 0; i < list.length; i++) {
      var ret = list[i](arg);
      if (ret) {
        return ret;
      }
    }
    return null;
  };
}

var retrieveFile = handlerExec(retrieveFileHandlers);

retrieveFileHandlers.push(function(path) {
  // Trim the path to make sure there is no extra whitespace.
  path = path.trim();
  if (/^file:/.test(path)) {
    // existsSync/readFileSync can't handle file protocol, but once stripped, it works
    path = path.replace(/file:\/\/\/(\w:)?/, function(protocol, drive) {
      return drive ?
        '' : // file:///C:/dir/file -> C:/dir/file
        '/'; // file:///root-dir/file -> /root-dir/file
    });
  }
  if (path in fileContentsCache) {
    return fileContentsCache[path];
  }

  var contents = '';
  try {
    if (!fs) {
      // Use SJAX if we are in the browser
      var xhr = new XMLHttpRequest();
      xhr.open('GET', path, /** async */ false);
      xhr.send(null);
      if (xhr.readyState === 4 && xhr.status === 200) {
        contents = xhr.responseText;
      }
    } else if (fs.existsSync(path)) {
      // Otherwise, use the filesystem
      contents = fs.readFileSync(path, 'utf8');
    }
  } catch (er) {
    /* ignore any errors */
  }

  return fileContentsCache[path] = contents;
});

// Support URLs relative to a directory, but be careful about a protocol prefix
// in case we are in the browser (i.e. directories may start with "http://" or "file:///")
function supportRelativeURL(file, url) {
  if (!file) return url;
  var dir = path.dirname(file);
  var match = /^\w+:\/\/[^\/]*/.exec(dir);
  var protocol = match ? match[0] : '';
  var startPath = dir.slice(protocol.length);
  if (protocol && /^\/\w\:/.test(startPath)) {
    // handle file:///C:/ paths
    protocol += '/';
    return protocol + path.resolve(dir.slice(protocol.length), url).replace(/\\/g, '/');
  }
  return protocol + path.resolve(dir.slice(protocol.length), url);
}

function retrieveSourceMapURL(source) {
  var fileData;

  if (isInBrowser()) {
     try {
       var xhr = new XMLHttpRequest();
       xhr.open('GET', source, false);
       xhr.send(null);
       fileData = xhr.readyState === 4 ? xhr.responseText : null;

       // Support providing a sourceMappingURL via the SourceMap header
       var sourceMapHeader = xhr.getResponseHeader("SourceMap") ||
                             xhr.getResponseHeader("X-SourceMap");
       if (sourceMapHeader) {
         return sourceMapHeader;
       }
     } catch (e) {
     }
  }

  // Get the URL of the source map
  fileData = retrieveFile(source);
  var re = /(?:\/\/[@#][\s]*sourceMappingURL=([^\s'"]+)[\s]*$)|(?:\/\*[@#][\s]*sourceMappingURL=([^\s*'"]+)[\s]*(?:\*\/)[\s]*$)/mg;
  // Keep executing the search to find the *last* sourceMappingURL to avoid
  // picking up sourceMappingURLs from comments, strings, etc.
  var lastMatch, match;
  while (match = re.exec(fileData)) lastMatch = match;
  if (!lastMatch) return null;
  return lastMatch[1];
};

// Can be overridden by the retrieveSourceMap option to install. Takes a
// generated source filename; returns a {map, optional url} object, or null if
// there is no source map.  The map field may be either a string or the parsed
// JSON object (ie, it must be a valid argument to the SourceMapConsumer
// constructor).
var retrieveSourceMap = handlerExec(retrieveMapHandlers);
retrieveMapHandlers.push(function(source) {
  var sourceMappingURL = retrieveSourceMapURL(source);
  if (!sourceMappingURL) return null;

  // Read the contents of the source map
  var sourceMapData;
  if (reSourceMap.test(sourceMappingURL)) {
    // Support source map URL as a data url
    var rawData = sourceMappingURL.slice(sourceMappingURL.indexOf(',') + 1);
    sourceMapData = bufferFrom(rawData, "base64").toString();
    sourceMappingURL = source;
  } else {
    // Support source map URLs relative to the source URL
    sourceMappingURL = supportRelativeURL(source, sourceMappingURL);
    sourceMapData = retrieveFile(sourceMappingURL);
  }

  if (!sourceMapData) {
    return null;
  }

  return {
    url: sourceMappingURL,
    map: sourceMapData
  };
});

function mapSourcePosition(position) {
  var sourceMap = sourceMapCache[position.source];
  if (!sourceMap) {
    // Call the (overrideable) retrieveSourceMap function to get the source map.
    var urlAndMap = retrieveSourceMap(position.source);
    if (urlAndMap) {
      sourceMap = sourceMapCache[position.source] = {
        url: urlAndMap.url,
        map: new SourceMapConsumer(urlAndMap.map)
      };

      // Load all sources stored inline with the source map into the file cache
      // to pretend like they are already loaded. They may not exist on disk.
      if (sourceMap.map.sourcesContent) {
        sourceMap.map.sources.forEach(function(source, i) {
          var contents = sourceMap.map.sourcesContent[i];
          if (contents) {
            var url = supportRelativeURL(sourceMap.url, source);
            fileContentsCache[url] = contents;
          }
        });
      }
    } else {
      sourceMap = sourceMapCache[position.source] = {
        url: null,
        map: null
      };
    }
  }

  // Resolve the source URL relative to the URL of the source map
  if (sourceMap && sourceMap.map && typeof sourceMap.map.originalPositionFor === 'function') {
    var originalPosition = sourceMap.map.originalPositionFor(position);

    // Only return the original position if a matching line was found. If no
    // matching line is found then we return position instead, which will cause
    // the stack trace to print the path and line for the compiled file. It is
    // better to give a precise location in the compiled file than a vague
    // location in the original file.
    if (originalPosition.source !== null) {
      originalPosition.source = supportRelativeURL(
        sourceMap.url, originalPosition.source);
      return originalPosition;
    }
  }

  return position;
}

// Parses code generated by FormatEvalOrigin(), a function inside V8:
// https://code.google.com/p/v8/source/browse/trunk/src/messages.js
function mapEvalOrigin(origin) {
  // Most eval() calls are in this format
  var match = /^eval at ([^(]+) \((.+):(\d+):(\d+)\)$/.exec(origin);
  if (match) {
    var position = mapSourcePosition({
      source: match[2],
      line: +match[3],
      column: match[4] - 1
    });
    return 'eval at ' + match[1] + ' (' + position.source + ':' +
      position.line + ':' + (position.column + 1) + ')';
  }

  // Parse nested eval() calls using recursion
  match = /^eval at ([^(]+) \((.+)\)$/.exec(origin);
  if (match) {
    return 'eval at ' + match[1] + ' (' + mapEvalOrigin(match[2]) + ')';
  }

  // Make sure we still return useful information if we didn't find anything
  return origin;
}

// This is copied almost verbatim from the V8 source code at
// https://code.google.com/p/v8/source/browse/trunk/src/messages.js. The
// implementation of wrapCallSite() used to just forward to the actual source
// code of CallSite.prototype.toString but unfortunately a new release of V8
// did something to the prototype chain and broke the shim. The only fix I
// could find was copy/paste.
function CallSiteToString() {
  var fileName;
  var fileLocation = "";
  if (this.isNative()) {
    fileLocation = "native";
  } else {
    fileName = this.getScriptNameOrSourceURL();
    if (!fileName && this.isEval()) {
      fileLocation = this.getEvalOrigin();
      fileLocation += ", ";  // Expecting source position to follow.
    }

    if (fileName) {
      fileLocation += fileName;
    } else {
      // Source code does not originate from a file and is not native, but we
      // can still get the source position inside the source string, e.g. in
      // an eval string.
      fileLocation += "<anonymous>";
    }
    var lineNumber = this.getLineNumber();
    if (lineNumber != null) {
      fileLocation += ":" + lineNumber;
      var columnNumber = this.getColumnNumber();
      if (columnNumber) {
        fileLocation += ":" + columnNumber;
      }
    }
  }

  var line = "";
  var functionName = this.getFunctionName();
  var addSuffix = true;
  var isConstructor = this.isConstructor();
  var isMethodCall = !(this.isToplevel() || isConstructor);
  if (isMethodCall) {
    var typeName = this.getTypeName();
    // Fixes shim to be backward compatable with Node v0 to v4
    if (typeName === "[object Object]") {
      typeName = "null";
    }
    var methodName = this.getMethodName();
    if (functionName) {
      if (typeName && functionName.indexOf(typeName) != 0) {
        line += typeName + ".";
      }
      line += functionName;
      if (methodName && functionName.indexOf("." + methodName) != functionName.length - methodName.length - 1) {
        line += " [as " + methodName + "]";
      }
    } else {
      line += typeName + "." + (methodName || "<anonymous>");
    }
  } else if (isConstructor) {
    line += "new " + (functionName || "<anonymous>");
  } else if (functionName) {
    line += functionName;
  } else {
    line += fileLocation;
    addSuffix = false;
  }
  if (addSuffix) {
    line += " (" + fileLocation + ")";
  }
  return line;
}

function cloneCallSite(frame) {
  var object = {};
  Object.getOwnPropertyNames(Object.getPrototypeOf(frame)).forEach(function(name) {
    object[name] = /^(?:is|get)/.test(name) ? function() { return frame[name].call(frame); } : frame[name];
  });
  object.toString = CallSiteToString;
  return object;
}

function wrapCallSite(frame, state) {
  // provides interface backward compatibility
  if (state === undefined) {
    state = { nextPosition: null, curPosition: null }
  }
  if(frame.isNative()) {
    state.curPosition = null;
    return frame;
  }

  // Most call sites will return the source file from getFileName(), but code
  // passed to eval() ending in "//# sourceURL=..." will return the source file
  // from getScriptNameOrSourceURL() instead
  var source = frame.getFileName() || frame.getScriptNameOrSourceURL();
  if (source) {
    var line = frame.getLineNumber();
    var column = frame.getColumnNumber() - 1;

    // Fix position in Node where some (internal) code is prepended.
    // See https://github.com/evanw/node-source-map-support/issues/36
    // Header removed in node at ^10.16 || >=11.11.0
    // v11 is not an LTS candidate, we can just test the one version with it.
    // Test node versions for: 10.16-19, 10.20+, 12-19, 20-99, 100+, or 11.11
    var noHeader = /^v(10\.1[6-9]|10\.[2-9][0-9]|10\.[0-9]{3,}|1[2-9]\d*|[2-9]\d|\d{3,}|11\.11)/;
    var headerLength = noHeader.test(process.version) ? 0 : 62;
    if (line === 1 && column > headerLength && !isInBrowser() && !frame.isEval()) {
      column -= headerLength;
    }

    var position = mapSourcePosition({
      source: source,
      line: line,
      column: column
    });
    state.curPosition = position;
    frame = cloneCallSite(frame);
    var originalFunctionName = frame.getFunctionName;
    frame.getFunctionName = function() {
      if (state.nextPosition == null) {
        return originalFunctionName();
      }
      return state.nextPosition.name || originalFunctionName();
    };
    frame.getFileName = function() { return position.source; };
    frame.getLineNumber = function() { return position.line; };
    frame.getColumnNumber = function() { return position.column + 1; };
    frame.getScriptNameOrSourceURL = function() { return position.source; };
    return frame;
  }

  // Code called using eval() needs special handling
  var origin = frame.isEval() && frame.getEvalOrigin();
  if (origin) {
    origin = mapEvalOrigin(origin);
    frame = cloneCallSite(frame);
    frame.getEvalOrigin = function() { return origin; };
    return frame;
  }

  // If we get here then we were unable to change the source position
  return frame;
}

// This function is part of the V8 stack trace API, for more info see:
// https://v8.dev/docs/stack-trace-api
function prepareStackTrace(error, stack) {
  if (emptyCacheBetweenOperations) {
    fileContentsCache = {};
    sourceMapCache = {};
  }

  var name = error.name || 'Error';
  var message = error.message || '';
  var errorString = name + ": " + message;

  var state = { nextPosition: null, curPosition: null };
  var processedStack = [];
  for (var i = stack.length - 1; i >= 0; i--) {
    processedStack.push('\n    at ' + wrapCallSite(stack[i], state));
    state.nextPosition = state.curPosition;
  }
  state.curPosition = state.nextPosition = null;
  return errorString + processedStack.reverse().join('');
}

// Generate position and snippet of original source with pointer
function getErrorSource(error) {
  var match = /\n    at [^(]+ \((.*):(\d+):(\d+)\)/.exec(error.stack);
  if (match) {
    var source = match[1];
    var line = +match[2];
    var column = +match[3];

    // Support the inline sourceContents inside the source map
    var contents = fileContentsCache[source];

    // Support files on disk
    if (!contents && fs && fs.existsSync(source)) {
      try {
        contents = fs.readFileSync(source, 'utf8');
      } catch (er) {
        contents = '';
      }
    }

    // Format the line from the original source code like node does
    if (contents) {
      var code = contents.split(/(?:\r\n|\r|\n)/)[line - 1];
      if (code) {
        return source + ':' + line + '\n' + code + '\n' +
          new Array(column).join(' ') + '^';
      }
    }
  }
  return null;
}

function printErrorAndExit (error) {
  var source = getErrorSource(error);

  // Ensure error is printed synchronously and not truncated
  if (process.stderr._handle && process.stderr._handle.setBlocking) {
    process.stderr._handle.setBlocking(true);
  }

  if (source) {
    console.error();
    console.error(source);
  }

  console.error(error.stack);
  process.exit(1);
}

function shimEmitUncaughtException () {
  var origEmit = process.emit;

  process.emit = function (type) {
    if (type === 'uncaughtException') {
      var hasStack = (arguments[1] && arguments[1].stack);
      var hasListeners = (this.listeners(type).length > 0);

      if (hasStack && !hasListeners) {
        return printErrorAndExit(arguments[1]);
      }
    }

    return origEmit.apply(this, arguments);
  };
}

var originalRetrieveFileHandlers = retrieveFileHandlers.slice(0);
var originalRetrieveMapHandlers = retrieveMapHandlers.slice(0);

exports.wrapCallSite = wrapCallSite;
exports.getErrorSource = getErrorSource;
exports.mapSourcePosition = mapSourcePosition;
exports.retrieveSourceMap = retrieveSourceMap;

exports.install = function(options) {
  options = options || {};

  if (options.environment) {
    environment = options.environment;
    if (["node", "browser", "auto"].indexOf(environment) === -1) {
      throw new Error("environment " + environment + " was unknown. Available options are {auto, browser, node}")
    }
  }

  // Allow sources to be found by methods other than reading the files
  // directly from disk.
  if (options.retrieveFile) {
    if (options.overrideRetrieveFile) {
      retrieveFileHandlers.length = 0;
    }

    retrieveFileHandlers.unshift(options.retrieveFile);
  }

  // Allow source maps to be found by methods other than reading the files
  // directly from disk.
  if (options.retrieveSourceMap) {
    if (options.overrideRetrieveSourceMap) {
      retrieveMapHandlers.length = 0;
    }

    retrieveMapHandlers.unshift(options.retrieveSourceMap);
  }

  // Support runtime transpilers that include inline source maps
  if (options.hookRequire && !isInBrowser()) {
    var Module;
    try {
      Module = require('module');
    } catch (err) {
      // NOP: Loading in catch block to convert webpack error to warning.
    }
    var $compile = Module.prototype._compile;

    if (!$compile.__sourceMapSupport) {
      Module.prototype._compile = function(content, filename) {
        fileContentsCache[filename] = content;
        sourceMapCache[filename] = undefined;
        return $compile.call(this, content, filename);
      };

      Module.prototype._compile.__sourceMapSupport = true;
    }
  }

  // Configure options
  if (!emptyCacheBetweenOperations) {
    emptyCacheBetweenOperations = 'emptyCacheBetweenOperations' in options ?
      options.emptyCacheBetweenOperations : false;
  }

  // Install the error reformatter
  if (!errorFormatterInstalled) {
    errorFormatterInstalled = true;
    Error.prepareStackTrace = prepareStackTrace;
  }

  if (!uncaughtShimInstalled) {
    var installHandler = 'handleUncaughtExceptions' in options ?
      options.handleUncaughtExceptions : true;

    // Provide the option to not install the uncaught exception handler. This is
    // to support other uncaught exception handlers (in test frameworks, for
    // example). If this handler is not installed and there are no other uncaught
    // exception handlers, uncaught exceptions will be caught by node's built-in
    // exception handler and the process will still be terminated. However, the
    // generated JavaScript code will be shown above the stack trace instead of
    // the original source code.
    if (installHandler && hasGlobalProcessEventEmitter()) {
      uncaughtShimInstalled = true;
      shimEmitUncaughtException();
    }
  }
};

exports.resetRetrieveHandlers = function() {
  retrieveFileHandlers.length = 0;
  retrieveMapHandlers.length = 0;

  retrieveFileHandlers = originalRetrieveFileHandlers.slice(0);
  retrieveMapHandlers = originalRetrieveMapHandlers.slice(0);

  retrieveSourceMap = handlerExec(retrieveMapHandlers);
  retrieveFile = handlerExec(retrieveFileHandlers);
}

}).call(this,require('_process'))

},{"_process":51,"buffer-from":3,"fs":2,"module":2,"path":50,"source-map":62}],64:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
var Label_1 = require("./Label");
var Value_1 = require("./Value");
exports.index = new Value_1.Value('index', Label_1.bot);
exports.input = new Value_1.Value('input', Label_1.bot);
exports.value = new Value_1.Value('value', Label_1.bot);
exports.writable = new Value_1.Value('writable', Label_1.bot);
exports.enumerable = new Value_1.Value('enumerable', Label_1.bot);
exports.configurable = new Value_1.Value('configurable', Label_1.bot);
exports.get = new Value_1.Value('get', Label_1.bot);
exports.set = new Value_1.Value('set', Label_1.bot);
exports.print = new Value_1.Value('print', Label_1.bot);
exports.console = new Value_1.Value('console', Label_1.bot);
exports.alert = new Value_1.Value('alert', Label_1.bot);
exports.prototype = new Value_1.Value('prototype', Label_1.bot);
exports.constructor = new Value_1.Value('constructor', Label_1.bot);
exports.length = new Value_1.Value('length', Label_1.bot);
//@ts-ignore TYPES
exports.arguments = new Value_1.Value('arguments', Label_1.bot);
exports.upg = new Value_1.Value('upg', Label_1.bot);
exports.upgv = new Value_1.Value('upgv', Label_1.bot);
exports.upgf = new Value_1.Value('upgf', Label_1.bot);
exports.upgs = new Value_1.Value('upgs', Label_1.bot);
exports.getPrototypeOf = new Value_1.Value('getPrototypeOf', Label_1.bot);
exports.getOwnPropertyDescriptor = new Value_1.Value('getOwnPropertyDescriptor', Label_1.bot);
exports.getOwnPropertyNames = new Value_1.Value('getOwnPropertyNames', Label_1.bot);
exports.create = new Value_1.Value('create', Label_1.bot);
//@ts-ignore TYPES
exports.require = new Value_1.Value('require', Label_1.bot);
exports.defineProperty = new Value_1.Value('defineProperty', Label_1.bot);
exports.defineProperties = new Value_1.Value('defineProperties', Label_1.bot);
exports.seal = new Value_1.Value('seal', Label_1.bot);
exports.freeze = new Value_1.Value('freeze', Label_1.bot);
exports.preventExtensions = new Value_1.Value('preventExtensions', Label_1.bot);
exports.isSealed = new Value_1.Value('isSealed', Label_1.bot);
exports.isFrozen = new Value_1.Value('isFrozen', Label_1.bot);
exports.isExtensible = new Value_1.Value('isExtensible', Label_1.bot);
exports.keys = new Value_1.Value('keys', Label_1.bot);
exports.toString = new Value_1.Value('toString', Label_1.bot);
exports.toLocaleString = new Value_1.Value('toLocaleString', Label_1.bot);
exports.valueOf = new Value_1.Value('valueOf', Label_1.bot);
exports.hasOwnProperty = new Value_1.Value('hasOwnProperty', Label_1.bot);
exports.isPrototypeOf = new Value_1.Value('isPrototypeOf', Label_1.bot);
exports.propertyIsEnumerable = new Value_1.Value('propertyIsEnumerable', Label_1.bot);
exports.apply = new Value_1.Value('apply', Label_1.bot);
exports.call = new Value_1.Value('call', Label_1.bot);
exports.caller = new Value_1.Value('caller', Label_1.bot);
exports.bind = new Value_1.Value('bind', Label_1.bot);
exports.NaN = new Value_1.Value('NaN', Label_1.bot);
exports.Infinity = new Value_1.Value('Infinity', Label_1.bot);
exports.undefined = new Value_1.Value('undefined', Label_1.bot);
//@ts-ignore TYPES
exports.eval = new Value_1.Value('eval', Label_1.bot);
exports.parseInt = new Value_1.Value('parseInt', Label_1.bot);
exports.parseFloat = new Value_1.Value('parseFloat', Label_1.bot);
exports.isNaN = new Value_1.Value('isNaN', Label_1.bot);
exports.isFinite = new Value_1.Value('isFinite', Label_1.bot);
exports.decodeURI = new Value_1.Value('decodeURI', Label_1.bot);
exports.decodeURIComponent = new Value_1.Value('decodeURIComponent', Label_1.bot);
exports.encodeURI = new Value_1.Value('encodeURI', Label_1.bot);
exports.encodeURIComponent = new Value_1.Value('encodeURIComponent', Label_1.bot);
exports.Object = new Value_1.Value('Object', Label_1.bot);
exports.Function = new Value_1.Value('Function', Label_1.bot);
exports.Array = new Value_1.Value('Array', Label_1.bot);
exports.String = new Value_1.Value('String', Label_1.bot);
exports.Boolean = new Value_1.Value('Boolean', Label_1.bot);
exports.Number = new Value_1.Value('Number', Label_1.bot);
exports.Date = new Value_1.Value('Date', Label_1.bot);
exports.RegExp = new Value_1.Value('RegExp', Label_1.bot);
exports.Error = new Value_1.Value('Error', Label_1.bot);
exports.EvalError = new Value_1.Value('EvalError', Label_1.bot);
exports.RangeError = new Value_1.Value('RangeError', Label_1.bot);
exports.ReferenceError = new Value_1.Value('ReferenceError', Label_1.bot);
exports.SyntaxError = new Value_1.Value('SyntaxError', Label_1.bot);
exports.TypeError = new Value_1.Value('TypeError', Label_1.bot);
exports.URIError = new Value_1.Value('URIError', Label_1.bot);
exports.Math = new Value_1.Value('Math', Label_1.bot);
exports.JSON = new Value_1.Value('JSON', Label_1.bot);
exports.parse = new Value_1.Value('parse', Label_1.bot);
exports.stringify = new Value_1.Value('stringify', Label_1.bot);
exports.name = new Value_1.Value('name', Label_1.bot);
exports.message = new Value_1.Value('message', Label_1.bot);
exports.isArray = new Value_1.Value('isArray', Label_1.bot);
exports.concat = new Value_1.Value('concat', Label_1.bot);
exports.join = new Value_1.Value('join', Label_1.bot);
exports.pop = new Value_1.Value('pop', Label_1.bot);
exports.push = new Value_1.Value('push', Label_1.bot);
exports.reverse = new Value_1.Value('reverse', Label_1.bot);
exports.shift = new Value_1.Value('shift', Label_1.bot);
exports.slice = new Value_1.Value('slice', Label_1.bot);
exports.sort = new Value_1.Value('sort', Label_1.bot);
exports.splice = new Value_1.Value('splice', Label_1.bot);
exports.unshift = new Value_1.Value('unshift', Label_1.bot);
exports.indexOf = new Value_1.Value('indexOf', Label_1.bot);
exports.lastIndexOf = new Value_1.Value('lastIndexOf', Label_1.bot);
exports.every = new Value_1.Value('every', Label_1.bot);
exports.some = new Value_1.Value('some', Label_1.bot);
exports.forEach = new Value_1.Value('forEach', Label_1.bot);
exports.map = new Value_1.Value('map', Label_1.bot);
exports.filter = new Value_1.Value('filter', Label_1.bot);
exports.reduce = new Value_1.Value('reduce', Label_1.bot);
exports.reduceRight = new Value_1.Value('reduceRight', Label_1.bot);
exports.fromCharCode = new Value_1.Value('fromCharCode', Label_1.bot);
exports.charAt = new Value_1.Value('charAt', Label_1.bot);
exports.charCodeAt = new Value_1.Value('charCodeAt', Label_1.bot);
exports.localeCompare = new Value_1.Value('localeCompare', Label_1.bot);
exports.match = new Value_1.Value('match', Label_1.bot);
exports.replace = new Value_1.Value('replace', Label_1.bot);
exports.search = new Value_1.Value('search', Label_1.bot);
exports.split = new Value_1.Value('split', Label_1.bot);
exports.substring = new Value_1.Value('substring', Label_1.bot);
exports.substr = new Value_1.Value('substr', Label_1.bot);
exports.toLowerCase = new Value_1.Value('toLowerCase', Label_1.bot);
exports.toLocaleLowerCase = new Value_1.Value('toLocaleLowerCase', Label_1.bot);
exports.toUpperCase = new Value_1.Value('toUpperCase', Label_1.bot);
exports.toLocaleUpperCase = new Value_1.Value('toLocaleUpperCase', Label_1.bot);
exports.trim = new Value_1.Value('trim', Label_1.bot);
exports.MAX_VALUE = new Value_1.Value('MAX_VALUE', Label_1.bot);
exports.MIN_VALUE = new Value_1.Value('MIN_VALUE', Label_1.bot);
exports.NEGATIVE_INFINITY = new Value_1.Value('NEGATIVE_INFINITY', Label_1.bot);
exports.POSITIVE_INFINITY = new Value_1.Value('POSITIVE_INFINITY', Label_1.bot);
exports.toFixed = new Value_1.Value('toFixed', Label_1.bot);
exports.toExponential = new Value_1.Value('toExponential', Label_1.bot);
exports.toPrecision = new Value_1.Value('toPrecision', Label_1.bot);
exports.E = new Value_1.Value('E', Label_1.bot);
exports.LN10 = new Value_1.Value('LN10', Label_1.bot);
exports.LN2 = new Value_1.Value('LN2', Label_1.bot);
exports.LOG2E = new Value_1.Value('LOG2E', Label_1.bot);
exports.LOG10E = new Value_1.Value('LOG10E', Label_1.bot);
exports.PI = new Value_1.Value('PI', Label_1.bot);
exports.SQRT1_2 = new Value_1.Value('SQRT1_2', Label_1.bot);
exports.SQRT2 = new Value_1.Value('SQRT2', Label_1.bot);
exports.abs = new Value_1.Value('abs', Label_1.bot);
exports.acos = new Value_1.Value('acos', Label_1.bot);
exports.asin = new Value_1.Value('asin', Label_1.bot);
exports.atan = new Value_1.Value('atan', Label_1.bot);
exports.atan2 = new Value_1.Value('atan2', Label_1.bot);
exports.ceil = new Value_1.Value('ceil', Label_1.bot);
exports.cos = new Value_1.Value('cos', Label_1.bot);
exports.exp = new Value_1.Value('exp', Label_1.bot);
exports.floor = new Value_1.Value('floor', Label_1.bot);
exports.log = new Value_1.Value('log', Label_1.bot);
exports.max = new Value_1.Value('max', Label_1.bot);
exports.min = new Value_1.Value('min', Label_1.bot);
exports.pow = new Value_1.Value('pow', Label_1.bot);
exports.random = new Value_1.Value('random', Label_1.bot);
exports.round = new Value_1.Value('round', Label_1.bot);
exports.sin = new Value_1.Value('sin', Label_1.bot);
exports.sqrt = new Value_1.Value('sqrt', Label_1.bot);
exports.tan = new Value_1.Value('tan', Label_1.bot);
exports.toDateString = new Value_1.Value('toDateString', Label_1.bot);
exports.toTimeString = new Value_1.Value('toTimeString', Label_1.bot);
exports.toLocaleDateString = new Value_1.Value('toLocaleDateString', Label_1.bot);
exports.toLocaleTimeString = new Value_1.Value('toLocaleTimeString', Label_1.bot);
exports.getTime = new Value_1.Value('getTime', Label_1.bot);
exports.getFullYear = new Value_1.Value('getFullYear', Label_1.bot);
exports.getUTCFullYear = new Value_1.Value('getUTCFullYear', Label_1.bot);
exports.getMonth = new Value_1.Value('getMonth', Label_1.bot);
exports.getUTCMonth = new Value_1.Value('getUTCMonth', Label_1.bot);
exports.getDate = new Value_1.Value('getDate', Label_1.bot);
exports.getUTCDate = new Value_1.Value('getUTCDate', Label_1.bot);
exports.getDay = new Value_1.Value('getDay', Label_1.bot);
exports.getUTCDay = new Value_1.Value('getUTCDay', Label_1.bot);
exports.getHours = new Value_1.Value('getHours', Label_1.bot);
exports.getUTCHours = new Value_1.Value('getUTCHours', Label_1.bot);
exports.getMinutes = new Value_1.Value('getMinutes', Label_1.bot);
exports.getUTCMinutes = new Value_1.Value('getUTCMinutes', Label_1.bot);
exports.getSeconds = new Value_1.Value('getSeconds', Label_1.bot);
exports.getUTCSeconds = new Value_1.Value('getUTCSeconds', Label_1.bot);
exports.getMilliseconds = new Value_1.Value('getMilliseconds', Label_1.bot);
exports.getUTCMilliseconds = new Value_1.Value('getUTCMilliseconds', Label_1.bot);
exports.getTimezoneOffset = new Value_1.Value('getTimezoneOffset', Label_1.bot);
exports.setTime = new Value_1.Value('setTime', Label_1.bot);
exports.setMilliseconds = new Value_1.Value('setMilliseconds', Label_1.bot);
exports.setUTCMilliseconds = new Value_1.Value('setUTCMilliseconds', Label_1.bot);
exports.setSeconds = new Value_1.Value('setSeconds', Label_1.bot);
exports.setUTCSeconds = new Value_1.Value('setUTCSeconds', Label_1.bot);
exports.setMinutes = new Value_1.Value('setMinutes', Label_1.bot);
exports.setUTCMinutes = new Value_1.Value('setUTCMinutes', Label_1.bot);
exports.setHours = new Value_1.Value('setHours', Label_1.bot);
exports.setUTCHours = new Value_1.Value('setUTCHours', Label_1.bot);
exports.setDate = new Value_1.Value('setDate', Label_1.bot);
exports.setUTCDate = new Value_1.Value('setUTCDate', Label_1.bot);
exports.setMonth = new Value_1.Value('setMonth', Label_1.bot);
exports.setUTCMonth = new Value_1.Value('setUTCMonth', Label_1.bot);
exports.setFullYear = new Value_1.Value('setFullYear', Label_1.bot);
exports.setUTCFullYear = new Value_1.Value('setUTCFullYear', Label_1.bot);
exports.toUTCString = new Value_1.Value('toUTCString', Label_1.bot);
exports.toISOString = new Value_1.Value('toISOString', Label_1.bot);
exports.toJSON = new Value_1.Value('toJSON', Label_1.bot);
exports.UTC = new Value_1.Value('UTC', Label_1.bot);
exports.now = new Value_1.Value('now', Label_1.bot);
exports.exec = new Value_1.Value('exec', Label_1.bot);
exports.test = new Value_1.Value('test', Label_1.bot);
exports.source = new Value_1.Value('source', Label_1.bot);
exports.global = new Value_1.Value('global', Label_1.bot);
exports.ignoreCase = new Value_1.Value('ignoreCase', Label_1.bot);
exports.multiline = new Value_1.Value('multiline', Label_1.bot);
exports.lastIndex = new Value_1.Value('lastIndex', Label_1.bot);
exports.getYear = new Value_1.Value('getYear', Label_1.bot);
exports.setYear = new Value_1.Value('setYear', Label_1.bot);
exports.toGMTString = new Value_1.Value('toGMTString', Label_1.bot);
exports.escape = new Value_1.Value('escape', Label_1.bot);
exports.unescape = new Value_1.Value('unescape', Label_1.bot);
exports.of = new Value_1.Value('of', Label_1.bot);

},{"./Label":123,"./Value":184}],65:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
var Value_1 = require("../Value");
var constants = require("../Constants");
var BuiltinFunctionObject_1 = require("../Objects/BuiltinFunctionObject");
var Label_1 = require("../Label");
var Define_1 = require("../Define");
var EcmaObject_1 = require("../Objects/EcmaObject");
var ArrayObject_1 = require("../Objects/ArrayObject");
var HasInstance_1 = require("../HasInstance");
var IsConstructor_1 = require("../Utility/IsConstructor");
var ToString_1 = require("../Conversion/ToString");
// ------------------------------------------------------------
// 15.4.3 
var ArrayConstructor = /** @class */ (function (_super) {
    __extends(ArrayConstructor, _super);
    function ArrayConstructor(host) {
        var _this = _super.call(this) || this;
        _this.Class = 'Function';
        _this.Extensible = true;
        _this.host = host;
        return _this;
    }
    ArrayConstructor.prototype.Setup = function () {
        this.Prototype = new Value_1.Value(monitor.instances.FunctionPrototype, Label_1.bot);
        Define_1.DefineFFF(this, constants.length, 1);
        Define_1.DefineFFF(this, constants.prototype, monitor.instances.ArrayPrototype);
        Define_1.DefineTFT(this, constants.isArray, new BuiltinFunctionObject_1.BuiltinFunctionObject(isArray, 1, Array.isArray));
        // ES6, 22.1.2.3
        Define_1.DefineTFT(this, constants.of, new BuiltinFunctionObject_1.BuiltinFunctionObject(of, 1, Array.of));
    };
    ArrayConstructor.prototype.HasInstance = function (V) {
        return HasInstance_1.HasInstance.call(this, V);
    };
    ArrayConstructor.prototype.Call = function (thisArg, args) {
        return this.Construct(args);
    };
    // ------------------------------------------------------------
    ArrayConstructor.prototype.Construct = function (args) {
        var array;
        var len = args.length;
        if (len === 0 || len >= 2) {
            array = ArrayObject_1.ArrayObject.fromValueArray(args, Label_1.bot);
        }
        else {
            var arg = args[0];
            if (typeof arg.value === 'number') {
                array = new ArrayObject_1.ArrayObject();
                array.properties.length = arg.value;
                array.labels.length = {
                    value: arg.label,
                    existence: Label_1.bot
                };
            }
            else {
                array = ArrayObject_1.ArrayObject.fromValueArray(args, Label_1.bot);
            }
        }
        return new Value_1.Value(array, Label_1.bot);
    };
    return ArrayConstructor;
}(EcmaObject_1.EcmaObject));
exports.ArrayConstructor = ArrayConstructor;
// ------------------------------------------------------------
// isArray, 15.4.3.1
function isArray(thisArg, args) {
    var arg = args[0] || new Value_1.Value(undefined, Label_1.bot);
    if (arg.value === null || typeof arg.value !== 'object') {
        return new Value_1.Value(false, arg.label);
    }
    return new Value_1.Value(arg.value.Class === 'Array', arg.label);
}
;
// ------------------------------------------------------------
// ES6: of, 22.1.2.3
function of(thisArg, args) {
    var e_1, _a;
    var len = args.length;
    var lbl = new Label_1.Label();
    try {
        for (var args_1 = __values(args), args_1_1 = args_1.next(); !args_1_1.done; args_1_1 = args_1.next()) {
            var arg = args_1_1.value;
            lbl = Label_1.lub(lbl, arg.label);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (args_1_1 && !args_1_1.done && (_a = args_1.return)) _a.call(args_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var A;
    if (IsConstructor_1.IsConstructor(thisArg)) {
        // @ts-ignore
        A = thisArg.value.Construct([new Value_1.Value(len, lbl)]);
    }
    else {
        A = new ArrayObject_1.ArrayObject();
        A.properties.length = len;
        A.labels.length = {
            value: lbl,
            existence: Label_1.bot
        };
    }
    var k = 0;
    while (k < len) {
        var kValue = args[k];
        var Pk = ToString_1.ToString(new Value_1.Value(k, kValue.label));
        // 7.3.4 in ES6 will make this..
        var desc = {
            value: kValue.value,
            label: kValue.label,
            writable: true,
            enumerable: true,
            configurable: true
        };
        A.DefineOwnProperty(Pk, desc);
        k++;
    }
    return A;
}
;

},{"../Constants":64,"../Conversion/ToString":87,"../Define":91,"../HasInstance":120,"../Label":123,"../Objects/ArrayObject":132,"../Objects/BuiltinFunctionObject":134,"../Objects/EcmaObject":137,"../Utility/IsConstructor":183,"../Value":184}],66:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Value_1 = require("../Value");
var constants = require("../Constants");
var HasInstance_1 = require("../HasInstance");
var Define_1 = require("../Define");
var EcmaObject_1 = require("../Objects/EcmaObject");
var Label_1 = require("../Label");
var BooleanObject_1 = require("../Objects/BooleanObject");
var ToBoolean_1 = require("../Conversion/ToBoolean");
// ------------------------------------------------------------
// 15.6.2 
var BooleanConstructor = /** @class */ (function (_super) {
    __extends(BooleanConstructor, _super);
    function BooleanConstructor(host) {
        var _this = _super.call(this) || this;
        _this.Class = 'Function';
        _this.Extensible = true;
        _this.host = host;
        return _this;
    }
    BooleanConstructor.prototype.Setup = function () {
        this.Prototype = new Value_1.Value(monitor.instances.FunctionPrototype, Label_1.bot);
        Define_1.DefineFFF(this, constants.length, 1); //REMOVE ?
        Define_1.DefineFFF(this, constants.prototype, monitor.instances.BooleanPrototype);
    };
    BooleanConstructor.prototype.HasInstance = function (V) {
        return HasInstance_1.HasInstance.call(this, V);
    };
    // 15.6.1.1
    BooleanConstructor.prototype.Call = function (thisArg, args) {
        var arg0 = args[0] ? args[0] : new Value_1.Value(undefined, Label_1.bot);
        return ToBoolean_1.ToBoolean(arg0);
    };
    // 15.6.2.1
    BooleanConstructor.prototype.Construct = function (args) {
        var arg0 = args[0] ? args[0] : new Value_1.Value(undefined, Label_1.bot);
        var b = ToBoolean_1.ToBoolean(arg0);
        var obj = new BooleanObject_1.BooleanObject(b.value, b.label);
        return new Value_1.Value(obj, Label_1.bot);
    };
    return BooleanConstructor;
}(EcmaObject_1.EcmaObject));
exports.BooleanConstructor = BooleanConstructor;

},{"../Constants":64,"../Conversion/ToBoolean":81,"../Define":91,"../HasInstance":120,"../Label":123,"../Objects/BooleanObject":133,"../Objects/EcmaObject":137,"../Value":184}],67:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Value_1 = require("../Value");
var constants = require("../Constants");
var BuiltinFunctionObject_1 = require("../Objects/BuiltinFunctionObject");
var HasInstance_1 = require("../HasInstance");
var ToPrimitive_1 = require("../Conversion/ToPrimitive");
var ToNumber_1 = require("../Conversion/ToNumber");
var ToString_1 = require("../Conversion/ToString");
var Define_1 = require("../Define");
var EcmaObject_1 = require("../Objects/EcmaObject");
var Label_1 = require("../Label");
var DateObject_1 = require("../Objects/DateObject");
// ------------------------------------------------------------
// The Date Constructor, 15.9.3
var DateConstructor = /** @class */ (function (_super) {
    __extends(DateConstructor, _super);
    function DateConstructor(host) {
        var _this = _super.call(this) || this;
        _this.Class = 'Function';
        _this.Extensible = true;
        _this.host = host;
        return _this;
    }
    DateConstructor.prototype.Setup = function () {
        this.Prototype = new Value_1.Value(monitor.instances.FunctionPrototype, Label_1.bot);
        Define_1.DefineFFF(this, constants.length, 7);
        Define_1.DefineFFF(this, constants.prototype, monitor.instances.DatePrototype);
        Define_1.DefineTFT(this, constants.parse, new BuiltinFunctionObject_1.BuiltinFunctionObject(parse, 0, Date.parse));
        Define_1.DefineTFT(this, constants.UTC, new BuiltinFunctionObject_1.BuiltinFunctionObject(UTC, 0, Date.UTC));
        Define_1.DefineTFT(this, constants.now, new BuiltinFunctionObject_1.BuiltinFunctionObject(now, 0, Date.now));
    };
    DateConstructor.prototype.HasInstance = function (V) {
        return HasInstance_1.HasInstance.call(this, V);
    };
    //----------------------------------------------------
    // 15.9.1.1
    DateConstructor.prototype.Call = function (thisArg, args) {
        var str = this.host();
        return new Value_1.Value(str, Label_1.bot);
    };
    //----------------------------------------------------
    // 15.9.3.1
    DateConstructor.prototype.Construct = function (args) {
        var _args = [];
        var label = new Label_1.Label();
        var obj;
        switch (args.length) {
            case 0:
                obj = new DateObject_1.DateObject(new this.host(), new Label_1.Label('Date'));
                break;
            case 1:
                var v = ToPrimitive_1.ToPrimitive(args[0]);
                if (typeof v.value !== 'string') {
                    v = ToNumber_1.ToNumber(v);
                }
                obj = new DateObject_1.DateObject(new this.host(v.value), v.label);
                break;
            default:
                var len = args.length;
                var i = 0;
                for (; i < len; i++) {
                    var val = ToNumber_1.ToNumber(args[i]);
                    _args[i] = val.value;
                    Label_1.lub(val.label);
                }
                if (len == 2) {
                    _args[2] = 1;
                }
                for (; i < 7; i++) {
                    _args[i] = 0;
                }
                var date = new this.host(_args[0], _args[1], _args[2], _args[3], _args[4], _args[5], _args[6]);
                obj = new DateObject_1.DateObject(date, label);
        }
        return new Value_1.Value(obj, Label_1.bot);
    };
    ;
    return DateConstructor;
}(EcmaObject_1.EcmaObject));
exports.DateConstructor = DateConstructor;
// ------------------------------------------------------------
// parse, 15.9.4.2
function parse(thisArg, args) {
    var arg = args[0] || new Value_1.Value(undefined, Label_1.bot);
    var string = ToString_1.ToString(arg);
    var number = monitor.instances.DateConstructor.host.parse(string.value);
    return new Value_1.Value(number, string.label);
}
// ------------------------------------------------------------
// UTC, 15.9.4.3
function UTC(thisArg, args) {
    var _args = [];
    var label = new Label_1.Label();
    for (var i = 0, len = args.length; i < len; i++) {
        var val = ToNumber_1.ToNumber(args[i]);
        _args[i] = val.value;
        Label_1.lub(val.label);
    }
    var number = monitor.instances.DateConstructor.host.UTC.apply(null, _args);
    return new Value_1.Value(number, label);
}
// ------------------------------------------------------------
// now, 15.9.4.4
function now(thisArg, args) {
    var number = monitor.instances.DateConstructor.host.now();
    return new Value_1.Value(number, Label_1.bot /*top*/);
}

},{"../Constants":64,"../Conversion/ToNumber":84,"../Conversion/ToPrimitive":86,"../Conversion/ToString":87,"../Define":91,"../HasInstance":120,"../Label":123,"../Objects/BuiltinFunctionObject":134,"../Objects/DateObject":136,"../Objects/EcmaObject":137,"../Value":184}],68:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Value_1 = require("../Value");
var constants = require("../Constants");
var HasInstance_1 = require("../HasInstance");
var EcmaObject_1 = require("../Objects/EcmaObject");
var Define_1 = require("../Define");
var Label_1 = require("../Label");
var ErrorObject_1 = require("../Objects/ErrorObject");
// ------------------------------------------------------------
// 15.11 - The Error Constructor
var ErrorConstructor = /** @class */ (function (_super) {
    __extends(ErrorConstructor, _super);
    function ErrorConstructor(host) {
        var _this = _super.call(this) || this;
        _this.Class = 'Function';
        _this.host = host;
        _this.Extensible = true;
        _this.name = 'Error';
        return _this;
    }
    ErrorConstructor.prototype.Setup = function () {
        this.SetupBase(monitor.instances.ErrorPrototype);
    };
    ErrorConstructor.prototype.SetupBase = function (prototype) {
        this.Prototype = new Value_1.Value(monitor.instances.FunctionPrototype, Label_1.bot);
        Define_1.DefineFFF(this, constants.length, 1);
        Define_1.DefineFFF(this, constants.prototype, prototype);
    };
    ErrorConstructor.prototype.HasInstance = function (V) {
        return HasInstance_1.HasInstance.call(this, V);
    };
    // 15.11.2
    ErrorConstructor.prototype.Call = function (thisArg, args) {
        return this.Construct(args);
    };
    // 15.11.2.1
    ErrorConstructor.prototype.Construct = function (args) {
        var arg0 = args[0] ? args[0] : new Value_1.Value(undefined, Label_1.bot);
        var o = new ErrorObject_1.ErrorObject(arg0);
        return new Value_1.Value(o, Label_1.bot);
    };
    return ErrorConstructor;
}(EcmaObject_1.EcmaObject));
exports.ErrorConstructor = ErrorConstructor;

},{"../Constants":64,"../Define":91,"../HasInstance":120,"../Label":123,"../Objects/EcmaObject":137,"../Objects/ErrorObject":138,"../Value":184}],69:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ErrorConstructor_1 = require("./ErrorConstructor");
var Label_1 = require("../Label");
var Value_1 = require("../Value");
var EvalErrorObject_1 = require("../Objects/EvalErrorObject");
var EvalErrorConstructor = /** @class */ (function (_super) {
    __extends(EvalErrorConstructor, _super);
    function EvalErrorConstructor(host) {
        return _super.call(this, host) || this;
    }
    EvalErrorConstructor.prototype.Setup = function () {
        this.SetupBase(monitor.instances.EvalErrorPrototype);
    };
    EvalErrorConstructor.prototype.Construct = function (args) {
        var message = args[0] || new Value_1.Value(undefined, Label_1.bot);
        var o = new EvalErrorObject_1.EvalErrorObject(message);
        return new Value_1.Value(o, Label_1.bot);
    };
    return EvalErrorConstructor;
}(ErrorConstructor_1.ErrorConstructor));
exports.EvalErrorConstructor = EvalErrorConstructor;

},{"../Label":123,"../Objects/EvalErrorObject":139,"../Value":184,"./ErrorConstructor":68}],70:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Label_1 = require("../Label");
var Value_1 = require("../Value");
var Define_1 = require("../Define");
var EcmaObject_1 = require("../Objects/EcmaObject");
var constants = require("../Constants");
var FunctionObject_1 = require("../Objects/FunctionObject");
var HasInstance_1 = require("../HasInstance");
var esprima = require("esprima");
var ToString_1 = require("../Conversion/ToString");
// ------------------------------------------------------------
// Function Constructor, 15.3.2 (15.3.1, 15.3.1.1)
var FunctionConstructor = /** @class */ (function (_super) {
    __extends(FunctionConstructor, _super);
    function FunctionConstructor(host) {
        var _this = _super.call(this) || this;
        // Properties, 15.3.3.
        _this.Class = 'Function';
        _this.host = host;
        _this.Extensible = true;
        return _this;
    }
    FunctionConstructor.prototype.Setup = function () {
        // 15.3.3.1 
        Define_1.DefineFFF(this, constants.prototype, monitor.instances.FunctionPrototype);
        this.Prototype = new Value_1.Value(monitor.instances.FunctionPrototype, Label_1.bot);
        // 15.3.3.2 
        Define_1.DefineFFF(this, constants.length, 1);
    };
    // ---
    FunctionConstructor.prototype.HasInstance = function (V) {
        return HasInstance_1.HasInstance.call(this, V);
    };
    // 15.3.1
    FunctionConstructor.prototype.Call = function (thisArg, args) {
        return this.Construct(args);
    };
    // 15.3.2
    FunctionConstructor.prototype.Construct = function (args) {
        var argCount = args.length;
        var P = '';
        var body;
        var label = Label_1.bot;
        if (argCount === 0) {
            body = new Value_1.Value('', Label_1.bot);
        }
        else if (argCount === 1) {
            body = args[0];
        }
        else {
            var firstArg = ToString_1.ToString(args[0]);
            label = Label_1.lub(label, firstArg.label);
            P = firstArg.value;
            for (var i = 1; i < argCount - 1; i++) {
                var nextArg = ToString_1.ToString(args[i]);
                label = Label_1.lub(label, firstArg.label);
                P += ', ' + nextArg.value;
            }
            body = args[argCount - 1];
        }
        var strbody = ToString_1.ToString(body);
        label = Label_1.lub(label, strbody.label);
        // transform may use a parser, which means we cannot transform the body
        // in isolation (e.g., it may contain return), and we cannot assume that the
        // transformation returns a function
        var transformed = monitor.transform("function __jsflow_transformed() {\n        arguments.callee = __jsflow_callee;\n        arguments.caller = __jsflow_caller;\n        " + strbody.value + "\n      }");
        P = "(function ( " + P + " ) {\n        let __jsflow_callee = arguments.callee;\n        let __jsflow_caller = arguments.caller;\n        " + transformed + ";\n        return __jsflow_transformed.apply(this, arguments);\n      })";
        var prog;
        try {
            prog = esprima.parse(P, { loc: true });
        }
        catch (e) {
            monitor.Throw("SyntaxError", e.message, label);
        }
        // parsing returns a program --- we are interested in function declaration
        var func = prog.body[0].expression;
        var F = new FunctionObject_1.FunctionObject(func.params, func.body, new Value_1.Value(monitor.GlobalEnvironment, Label_1.bot));
        // For pretty printing
        F.Source = func;
        return new Value_1.Value(F, label);
    };
    return FunctionConstructor;
}(EcmaObject_1.EcmaObject));
exports.FunctionConstructor = FunctionConstructor;

},{"../Constants":64,"../Conversion/ToString":87,"../Define":91,"../HasInstance":120,"../Label":123,"../Objects/EcmaObject":137,"../Objects/FunctionObject":140,"../Value":184,"esprima":18}],71:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Label_1 = require("../Label");
var Value_1 = require("../Value");
var Define_1 = require("../Define");
var EcmaObject_1 = require("../Objects/EcmaObject");
var constants = require("../Constants");
var HasInstance_1 = require("../HasInstance");
var NumberObject_1 = require("../Objects/NumberObject");
var ToNumber_1 = require("../Conversion/ToNumber");
// ------------------------------------------------------------
// The Number Constructor, 15.7.2
var NumberConstructor = /** @class */ (function (_super) {
    __extends(NumberConstructor, _super);
    function NumberConstructor(host) {
        var _this = _super.call(this) || this;
        _this.Class = 'Function';
        // not mandated by standard
        _this.Extensible = true;
        _this.host = host;
        return _this;
    }
    NumberConstructor.prototype.Setup = function () {
        this.Prototype = new Value_1.Value(monitor.instances.FunctionPrototype, Label_1.bot);
        Define_1.DefineFFF(this, constants.prototype, monitor.instances.NumberPrototype);
        Define_1.DefineFFF(this, constants.length, 1);
        Define_1.DefineFFF(this, constants.MAX_VALUE, this.host.MAX_VALUE);
        Define_1.DefineFFF(this, constants.MIN_VALUE, this.host.MIN_VALUE);
        Define_1.DefineFFF(this, constants.NaN, this.host.NaN);
        Define_1.DefineFFF(this, constants.NEGATIVE_INFINITY, this.host.NEGATIVE_INFINITY);
        Define_1.DefineFFF(this, constants.POSITIVE_INFINITY, this.host.POSITIVE_INFINITY);
    };
    NumberConstructor.prototype.HasInstance = function (V) {
        return HasInstance_1.HasInstance.call(this, V);
    };
    // 15.7.1.1
    NumberConstructor.prototype.Call = function (thisArg, args) {
        if (!args[0]) {
            return new Value_1.Value(0, Label_1.bot);
        }
        return ToNumber_1.ToNumber(args[0]);
    };
    // 15.7.2.1
    NumberConstructor.prototype.Construct = function (args) {
        var arg0 = args[0] ? ToNumber_1.ToNumber(args[0]) : new Value_1.Value(0, Label_1.bot);
        var res = new NumberObject_1.NumberObject(arg0.value, arg0.label);
        return new Value_1.Value(res, Label_1.bot);
    };
    return NumberConstructor;
}(EcmaObject_1.EcmaObject));
exports.NumberConstructor = NumberConstructor;

},{"../Constants":64,"../Conversion/ToNumber":84,"../Define":91,"../HasInstance":120,"../Label":123,"../Objects/EcmaObject":137,"../Objects/NumberObject":145,"../Value":184}],72:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Label_1 = require("../Label");
var Value_1 = require("../Value");
var Define_1 = require("../Define");
var EcmaObject_1 = require("../Objects/EcmaObject");
var constants = require("../Constants");
var BuiltinFunctionObject_1 = require("../Objects/BuiltinFunctionObject");
var ObjectObject_1 = require("../Objects/ObjectObject");
var ArrayObject_1 = require("../Objects/ArrayObject");
var ToBoolean_1 = require("../Conversion/ToBoolean");
var HasInstance_1 = require("../HasInstance");
var ToString_1 = require("../Conversion/ToString");
var ToObject_1 = require("../Conversion/ToObject");
var PropertyDescriptor_1 = require("../PropertyDescriptor");
var Interfaces_1 = require("../Interfaces");
// ------------------------------------------------------------
// Object Constructor, 15.2.3
var ObjectConstructor = /** @class */ (function (_super) {
    __extends(ObjectConstructor, _super);
    function ObjectConstructor(host) {
        var _this = _super.call(this) || this;
        _this.Class = 'Function';
        _this.host = host;
        return _this;
    }
    ObjectConstructor.prototype.Setup = function () {
        Define_1.DefineFFF(this, constants.length, 1);
        // 15.2.3
        this.Prototype = new Value_1.Value(monitor.instances.FunctionPrototype, Label_1.bot);
        // 15.2.3.1
        Define_1.DefineFFF(this, constants.prototype, monitor.instances.ObjectPrototype);
        Define_1.DefineTFT(this, constants.getPrototypeOf, new BuiltinFunctionObject_1.BuiltinFunctionObject(getPrototypeOf, 1, Object.getPrototypeOf));
        Define_1.DefineTFT(this, constants.getOwnPropertyDescriptor, new BuiltinFunctionObject_1.BuiltinFunctionObject(getOwnPropertyDescriptor, 2, Object.getOwnPropertyDescriptor));
        Define_1.DefineTFT(this, constants.getOwnPropertyNames, new BuiltinFunctionObject_1.BuiltinFunctionObject(getOwnPropertyNames, 1, Object.getOwnPropertyNames));
        Define_1.DefineTFT(this, constants.create, new BuiltinFunctionObject_1.BuiltinFunctionObject(create, 2, Object.create));
        Define_1.DefineTFT(this, constants.defineProperty, new BuiltinFunctionObject_1.BuiltinFunctionObject(defineProperty, 3, Object.defineProperty));
        Define_1.DefineTFT(this, constants.defineProperties, new BuiltinFunctionObject_1.BuiltinFunctionObject(defineProperties, 2, Object.defineProperties));
        Define_1.DefineTFT(this, constants.seal, new BuiltinFunctionObject_1.BuiltinFunctionObject(seal, 1, Object.seal));
        Define_1.DefineTFT(this, constants.freeze, new BuiltinFunctionObject_1.BuiltinFunctionObject(freeze, 1, Object.freeze));
        Define_1.DefineTFT(this, constants.preventExtensions, new BuiltinFunctionObject_1.BuiltinFunctionObject(preventExtensions, 1, Object.preventExtensions));
        Define_1.DefineTFT(this, constants.isSealed, new BuiltinFunctionObject_1.BuiltinFunctionObject(isSealed, 1, Object.isSealed));
        Define_1.DefineTFT(this, constants.isFrozen, new BuiltinFunctionObject_1.BuiltinFunctionObject(isFrozen, 1, Object.isFrozen));
        Define_1.DefineTFT(this, constants.isExtensible, new BuiltinFunctionObject_1.BuiltinFunctionObject(isExtensible, 1, Object.isExtensible));
        Define_1.DefineTFT(this, constants.keys, new BuiltinFunctionObject_1.BuiltinFunctionObject(keys, 1, Object.keys));
    };
    ObjectConstructor.prototype.HasInstance = function (V) {
        return HasInstance_1.HasInstance.call(this, V);
    };
    // ------------------------------------------------------------
    // 15.2.1.1
    ObjectConstructor.prototype.Call = function (thisArg, args) {
        var arg0 = args[0] || new Value_1.Value(undefined, Label_1.bot);
        var res;
        monitor.context.pushPC(arg0.label);
        if (arg0.value === undefined || arg0.value === null) {
            res = this.Construct(args);
            res.raise(arg0.label);
            monitor.context.popPC();
            return res;
        }
        res = ToObject_1.ToObject(arg0);
        monitor.context.popPC();
        return res;
    };
    // ------------------------------------------------------------
    // 15.2.2.1
    ObjectConstructor.prototype.Construct = function (args) {
        var arg0 = args[0] || new Value_1.Value(undefined, Label_1.bot);
        monitor.context.pushPC(arg0.label);
        var res;
        if (arg0.value === undefined || arg0.value === null) {
            var o = new ObjectObject_1.ObjectObject();
            res = new Value_1.Value(o, arg0.label);
            monitor.context.popPC();
            return res;
        }
        if (typeof arg0.value === 'object') {
            res = new Value_1.Value(arg0.value, arg0.label);
            monitor.context.popPC();
            return res;
        }
        res = ToObject_1.ToObject(arg0);
        monitor.context.popPC();
        return res;
    };
    return ObjectConstructor;
}(EcmaObject_1.EcmaObject));
exports.ObjectConstructor = ObjectConstructor;
// ------------------------------------------------------------
function AssertObject(arg, callee) {
    monitor.context.pushPC(arg.label);
    monitor.Throw("TypeError", callee + ' called on non-object (' + String(arg.value) + ')', arg.label);
}
// ------------------------------------------------------------
// 15.2.3.2
function getPrototypeOf(thisArg, args) {
    var O = args[0] || new Value_1.Value(undefined, Label_1.bot);
    if (!Interfaces_1.IsIEcmaObject(O)) {
        AssertObject(O, 'Object.getPrototypeOf');
        throw 'TypeScript';
    }
    var proto = O.value.Prototype;
    return new Value_1.Value(proto.value, Label_1.lub(proto.label, O.label));
}
// ------------------------------------------------------------
// 15.2.3.3
var getOwnPropertyDescriptor = function (thisArg, args) {
    var O = args[0] || new Value_1.Value(undefined, Label_1.bot);
    var P = args[1] || new Value_1.Value(undefined, Label_1.bot);
    if (!Interfaces_1.IsIEcmaObject(O)) {
        AssertObject(O, 'Object.getOwnPropertyDescriptor');
        throw 'TypeScript';
    }
    var name = ToString_1.ToString(P);
    var desc = O.GetOwnProperty(name);
    if (desc.value === undefined) {
        return new Value_1.Value(undefined, desc.label);
    }
    var obj = new ObjectObject_1.ObjectObject();
    if (PropertyDescriptor_1.IsDataDescriptor(desc.value)) {
        obj.DefineOwnProperty(constants.value, {
            value: desc.value.value,
            writable: true, enumerable: true, configurable: true,
            label: desc.value.label
        }, false);
        obj.DefineOwnProperty(constants.writable, {
            value: desc.value.writable,
            writable: true, enumerable: true, configurable: true,
            label: desc.value.label
        }, false);
    }
    else {
        //@ts-ignore DESC HELL
        var get = desc.value.get ? desc.value.get.actualFunction : desc.value.get;
        obj.DefineOwnProperty(constants.get, {
            value: get,
            writable: true, enumerable: true, configurable: true,
            label: desc.value.label
        }, false);
        //@ts-ignore DESC HELL
        var set = desc.value.set ? desc.value.set.actualFunction : desc.value.set;
        obj.DefineOwnProperty(constants.set, {
            value: set,
            writable: true, enumerable: true, configurable: true,
            label: desc.value.label
        }, false);
    }
    obj.DefineOwnProperty(constants.enumerable, {
        value: desc.value.enumerable,
        writable: true, enumerable: true, configurable: true,
        label: desc.value.label
    }, false);
    obj.DefineOwnProperty(constants.configurable, {
        value: desc.value.configurable,
        writable: true, enumerable: true, configurable: true,
        label: desc.value.label
    }, false);
    return new Value_1.Value(obj, desc.label);
};
// ------------------------------------------------------------
// 15.2.3.4
function getOwnPropertyNames(thisArg, args) {
    var O = args[0] || new Value_1.Value(undefined, Label_1.bot);
    if (!Interfaces_1.IsIEcmaObject(O)) {
        AssertObject(O, 'Object.getOwnPropertyNames');
        throw 'TypeScript';
    }
    var propertyNames = O.value.getOwnPropertyNames(O.label);
    var array = ArrayObject_1.ArrayObject.fromPropertyArray(propertyNames, O.value.struct);
    return new Value_1.Value(array, Label_1.bot);
}
// ------------------------------------------------------------
// 15.2.3.5
function create(thisArg, args) {
    var O = args[0] || new Value_1.Value(undefined, Label_1.bot);
    var Properties = args[1] || new Value_1.Value(undefined, Label_1.bot);
    if (O.value !== null && !Interfaces_1.IsIEcmaObject(O)) {
        AssertObject(O, 'Object.create');
        throw 'TypeScript';
    }
    var obj = new ObjectObject_1.ObjectObject();
    obj.Prototype = O;
    var objValue = new Value_1.Value(obj, Label_1.bot);
    if (Properties.value !== undefined) {
        defineProperties(thisArg, [objValue, Properties]);
    }
    return objValue;
}
// ------------------------------------------------------------
function ToPropertyDescriptor(Obj) {
    if (!Interfaces_1.IsIEcmaObject(Obj)) {
        AssertObject(Obj, 'Object.ToPropertyDescriptor');
        throw 'TypeScript';
    }
    var c = monitor.context;
    var lbl = new Label_1.Label();
    var desc = { label: Label_1.bot };
    var b;
    var x;
    var propertyName;
    // enumerable
    propertyName = constants.enumerable;
    b = Obj.HasProperty(propertyName);
    lbl = Label_1.lub(lbl, b.label);
    if (b.value) {
        c.pushPC(b.label);
        x = ToBoolean_1.ToBoolean(Obj.Get(propertyName));
        c.popPC();
        lbl = Label_1.lub(lbl, x.label);
        desc[propertyName.value] = x.value;
    }
    // configurable
    propertyName = constants.configurable;
    b = Obj.HasProperty(propertyName);
    lbl = Label_1.lub(lbl, b.label);
    if (b.value) {
        c.pushPC(b.label);
        x = ToBoolean_1.ToBoolean(Obj.Get(propertyName));
        c.popPC();
        lbl = Label_1.lub(lbl, x.label);
        desc[propertyName.value] = x.value;
    }
    // value
    propertyName = constants.value;
    b = Obj.HasProperty(propertyName);
    lbl = Label_1.lub(lbl, b.label);
    if (b.value) {
        c.pushPC(b.label);
        x = Obj.Get(propertyName);
        c.popPC();
        lbl = Label_1.lub(lbl, x.label);
        desc[propertyName.value] = x.value;
    }
    // writable
    propertyName = constants.writable;
    b = Obj.HasProperty(propertyName);
    lbl = Label_1.lub(lbl, b.label);
    if (b.value) {
        c.pushPC(b.label);
        x = ToBoolean_1.ToBoolean(Obj.Get(propertyName));
        c.popPC();
        lbl = Label_1.lub(lbl, x.label);
        desc[propertyName.value] = x.value;
    }
    // get
    propertyName = constants.get;
    b = Obj.HasProperty(propertyName);
    lbl = Label_1.lub(lbl, b.label);
    if (b.value) {
        c.pushPC(b.label);
        x = Obj.Get(propertyName);
        c.popPC();
        lbl = Label_1.lub(lbl, x.label);
        desc[propertyName.value] = x.value;
    }
    // set
    propertyName = constants.set;
    b = Obj.HasProperty(propertyName);
    lbl = Label_1.lub(lbl, b.label);
    if (b.value) {
        c.pushPC(b.label);
        x = Obj.Get(propertyName);
        c.popPC();
        lbl = Label_1.lub(lbl, x.label);
        desc[propertyName.value] = x.value;
    }
    desc.label = lbl;
    return desc;
}
// ------------------------------------------------------------
// 15.2.3.6
function defineProperty(thisArg, args) {
    var O = args[0] || new Value_1.Value(undefined, Label_1.bot);
    var P = args[1] || new Value_1.Value(undefined, Label_1.bot);
    var Attributes = args[2] || new Value_1.Value(undefined, Label_1.bot);
    if (!Interfaces_1.IsIEcmaObject(O)) {
        AssertObject(O, 'Object.defineProperty');
        throw 'TypeScript';
    }
    var name = ToString_1.ToString(P);
    var desc = ToPropertyDescriptor(Attributes);
    O.DefineOwnProperty(name, desc, true);
    return O;
}
// ------------------------------------------------------------
// 15.2.3.7
function defineProperties(thisArg, args) {
    var O = args[0] || new Value_1.Value(undefined, Label_1.bot);
    var Properties = args[1] || new Value_1.Value(undefined, Label_1.bot);
    if (!Interfaces_1.IsIEcmaObject(O)) {
        AssertObject(O, 'Object.defineProperties');
        throw 'TypeScript';
    }
    var props = ToObject_1.ToObject(Properties);
    var names = props.value.getOwnEnumerablePropertyNames(props.label);
    var descriptors = [];
    for (var i = 0, len = names.length; i < len; i++) {
        var P = names[i];
        var descObject = props.Get(P);
        //@ts-ignore DEC HELL
        var desc = ToPropertyDescriptor(descObject);
        descriptors.push({ name: P, descriptor: desc });
    }
    for (var i = 0, len = descriptors.length; i < len; i++) {
        var P = descriptors[i].name;
        var desc = descriptors[i].descriptor;
        O.DefineOwnProperty(P, desc, true);
    }
    return O;
}
// ------------------------------------------------------------
// 15.2.3.8
function seal(thisArg, args) {
    var O = args[0] || new Value_1.Value(undefined, Label_1.bot);
    if (!Interfaces_1.IsIEcmaObject(O)) {
        AssertObject(O, 'Object.defineProperties');
        throw 'TypeScript';
    }
    var context = Label_1.lub(monitor.context.effectivePC, O.label);
    monitor.assert(Label_1.le(context, O.value.struct), 'Object.seal: context label ' + context + ' not below structural label ' + O.value.struct + ' of object');
    var labels = O.value.labels;
    for (var x in labels) {
        if (Object.hasOwnProperty.call(labels, x)) {
            monitor.assert(Label_1.le(context, labels[x].value), 'Object.seal: context label ' + context + ' not below label ' + labels[x].value + ' of ' + x);
        }
    }
    Object.seal(O.value.properties);
    O.value.Extensible = false;
    return O;
}
// ------------------------------------------------------------
// 15.2.3.9
function freeze(thisArg, args) {
    var O = args[0] || new Value_1.Value(undefined, Label_1.bot);
    if (!Interfaces_1.IsIEcmaObject(O)) {
        AssertObject(O, 'Object.freeze');
        throw 'TypeScript';
    }
    var context = Label_1.lub(monitor.context.effectivePC, O.label);
    monitor.assert(Label_1.le(context, O.value.struct), 'Object.freeze: context label ' + context + ' not below structural label ' + O.value.struct + ' of object');
    var labels = O.value.labels;
    var properties = O.value.properties;
    for (var x in properties) {
        if (Object.hasOwnProperty.call(properties, x)) {
            var desc = Object.getOwnPropertyDescriptor(properties, x);
            if (desc.enumerable) {
                monitor.assert(Label_1.le(context, labels[x].value), 'Object.freeze: context label ' + context + ' not below label ' + labels[x].value + ' of ' + x);
            }
        }
    }
    Object.freeze(O.value.properties);
    O.value.Extensible = false;
    return O;
}
// ------------------------------------------------------------
// 15.2.3.10
function preventExtensions(thisArg, args) {
    var O = args[0] || new Value_1.Value(undefined, Label_1.bot);
    if (!Interfaces_1.IsIEcmaObject(O)) {
        AssertObject(O, 'Object.preventExtensions');
        throw 'TypeScript';
    }
    var context = Label_1.lub(monitor.context.effectivePC, O.label);
    monitor.assert(Label_1.le(context, O.value.struct), 'Object.preventExtensions: context label ' + context + ' not below structural label ' + O.value.struct + ' of object');
    Object.preventExtensions(O.value.properties);
    O.value.Extensible = false;
    return O;
}
// ------------------------------------------------------------
// 15.2.3.11
function isSealed(thisArg, args) {
    var O = args[0] || new Value_1.Value(undefined, Label_1.bot);
    if (!Interfaces_1.IsIEcmaObject(O)) {
        AssertObject(O, 'Object.isSealed');
        throw 'TypeScript';
    }
    var result = Object.isSealed(O.value.properties);
    return new Value_1.Value(result, Label_1.lub(O.label, O.value.struct));
}
// ------------------------------------------------------------
// 15.2.3.12
function isFrozen(thisArg, args) {
    var O = args[0] || new Value_1.Value(undefined, Label_1.bot);
    if (!Interfaces_1.IsIEcmaObject(O)) {
        AssertObject(O, 'Object.isFrozen');
        throw 'TypeScript';
    }
    var result = Object.isFrozen(O.value.properties);
    return new Value_1.Value(result, Label_1.lub(O.label, O.value.struct));
}
// ------------------------------------------------------------
// 15.2.3.13
function isExtensible(thisArg, args) {
    var O = args[0] || new Value_1.Value(undefined, Label_1.bot);
    if (!Interfaces_1.IsIEcmaObject(O)) {
        AssertObject(O, 'Object.isExtensible');
        throw 'TypeScript';
    }
    var result = Object.isExtensible(O.value.properties);
    return new Value_1.Value(result, Label_1.lub(O.label, O.value.struct));
}
// ------------------------------------------------------------
// 15.2.3.14
function keys(thisArg, args) {
    var O = args[0] || new Value_1.Value(undefined, Label_1.bot);
    if (!Interfaces_1.IsIEcmaObject(O)) {
        AssertObject(O, 'Object.isExtensible');
        throw 'TypeScript';
    }
    var enumerable = O.value.getOwnEnumerablePropertyNames(O.label);
    var array = ArrayObject_1.ArrayObject.fromPropertyArray(enumerable, O.value.struct);
    return new Value_1.Value(array, Label_1.bot);
}

},{"../Constants":64,"../Conversion/ToBoolean":81,"../Conversion/ToObject":85,"../Conversion/ToString":87,"../Define":91,"../HasInstance":120,"../Interfaces":122,"../Label":123,"../Objects/ArrayObject":132,"../Objects/BuiltinFunctionObject":134,"../Objects/EcmaObject":137,"../Objects/ObjectObject":146,"../PropertyDescriptor":156,"../Value":184}],73:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ErrorConstructor_1 = require("./ErrorConstructor");
var Label_1 = require("../Label");
var Value_1 = require("../Value");
var RangeErrorObject_1 = require("../Objects/RangeErrorObject");
var RangeErrorConstructor = /** @class */ (function (_super) {
    __extends(RangeErrorConstructor, _super);
    function RangeErrorConstructor(host) {
        return _super.call(this, host) || this;
    }
    RangeErrorConstructor.prototype.Setup = function () {
        this.SetupBase(monitor.instances.RangeErrorPrototype);
    };
    RangeErrorConstructor.prototype.Construct = function (args) {
        var message = args[0] || new Value_1.Value(undefined, Label_1.bot);
        var o = new RangeErrorObject_1.RangeErrorObject(message);
        return new Value_1.Value(o, Label_1.bot);
    };
    return RangeErrorConstructor;
}(ErrorConstructor_1.ErrorConstructor));
exports.RangeErrorConstructor = RangeErrorConstructor;

},{"../Label":123,"../Objects/RangeErrorObject":147,"../Value":184,"./ErrorConstructor":68}],74:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ErrorConstructor_1 = require("./ErrorConstructor");
var Label_1 = require("../Label");
var Value_1 = require("../Value");
var ReferenceErrorObject_1 = require("../Objects/ReferenceErrorObject");
var ReferenceErrorConstructor = /** @class */ (function (_super) {
    __extends(ReferenceErrorConstructor, _super);
    function ReferenceErrorConstructor(host) {
        return _super.call(this, host) || this;
    }
    ReferenceErrorConstructor.prototype.Setup = function () {
        this.SetupBase(monitor.instances.ReferenceErrorPrototype);
    };
    ReferenceErrorConstructor.prototype.Construct = function (args) {
        var message = args[0] || new Value_1.Value(undefined, Label_1.bot);
        var o = new ReferenceErrorObject_1.ReferenceErrorObject(message);
        return new Value_1.Value(o, Label_1.bot);
    };
    return ReferenceErrorConstructor;
}(ErrorConstructor_1.ErrorConstructor));
exports.ReferenceErrorConstructor = ReferenceErrorConstructor;

},{"../Label":123,"../Objects/ReferenceErrorObject":148,"../Value":184,"./ErrorConstructor":68}],75:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Value_1 = require("../Value");
var constants = require("../Constants");
var HasInstance_1 = require("../HasInstance");
var ToString_1 = require("../Conversion/ToString");
var Label_1 = require("../Label");
var RegExpObject_1 = require("../Objects/RegExpObject");
var Define_1 = require("../Define");
var EcmaObject_1 = require("../Objects/EcmaObject");
// ------------------------------------------------------------
// The RegExp Constructor, 15.10.5
var RegExpConstructor = /** @class */ (function (_super) {
    __extends(RegExpConstructor, _super);
    function RegExpConstructor(host) {
        var _this = _super.call(this) || this;
        _this.Class = 'Function';
        // not mandated by standard
        _this.Extensible = true;
        _this.host = host;
        return _this;
    }
    RegExpConstructor.prototype.Setup = function () {
        this.Prototype = new Value_1.Value(monitor.instances.FunctionPrototype, Label_1.bot);
        Define_1.DefineFFF(this, constants.length, 2);
        Define_1.DefineFFF(this, constants.prototype, monitor.instances.RegExpPrototype);
    };
    RegExpConstructor.prototype.HasInstance = function (V) {
        return HasInstance_1.HasInstance.call(this, V);
    };
    // 15.10.3.1
    RegExpConstructor.prototype.Call = function (thisArg, args) {
        var pattern = args[0] || new Value_1.Value(undefined, Label_1.bot);
        var flags = args[1] || new Value_1.Value(undefined, Label_1.bot);
        if (RegExpObject_1.IsRegExpObject(pattern) && flags.value === undefined) {
            return pattern;
        }
        return this.Construct(args);
    };
    // 15.10.4.1
    RegExpConstructor.prototype.Construct = function (args) {
        var c = monitor.context;
        var pattern = args[0] || new Value_1.Value(undefined, Label_1.bot);
        var flags = args[1] || new Value_1.Value(undefined, Label_1.bot);
        var P = "";
        var F = "";
        var l = Label_1.lub(pattern.label, flags.label);
        c.pushPC(l);
        if (RegExpObject_1.IsRegExpObject(pattern)) {
            if (flags.value === undefined) {
                var rx = pattern.value.PrimitiveValue;
                P = rx.source;
                F = (rx.global ? 'g' : '') + (rx.ignoreCase ? 'i' : '') + (rx.multiline ? 'm' : '');
            }
            else {
                monitor.Throw("TypeError", '', Label_1.bot);
            }
        }
        else {
            var _P = pattern.value === undefined ? new Value_1.Value("", l) : ToString_1.ToString(pattern);
            var _F = flags.value === undefined ? new Value_1.Value("", l) : ToString_1.ToString(flags);
            l = Label_1.lub(l, _P.label, _F.label);
            P = _P.value;
            F = _F.value;
        }
        var res;
        try {
            res = new RegExpObject_1.RegExpObject(new RegExp(P, F), l);
        }
        catch (e) {
            monitor.tryRethrow(e, true);
            monitor.fatal("RegExp.Construct, unable to lift " + e + " of type " + typeof e + " for RegExp(" + P + ", " + F + ")");
        }
        c.popPC();
        return new Value_1.Value(res, Label_1.bot);
    };
    return RegExpConstructor;
}(EcmaObject_1.EcmaObject));
exports.RegExpConstructor = RegExpConstructor;

},{"../Constants":64,"../Conversion/ToString":87,"../Define":91,"../HasInstance":120,"../Label":123,"../Objects/EcmaObject":137,"../Objects/RegExpObject":149,"../Value":184}],76:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Value_1 = require("../Value");
var constants = require("../Constants");
var BuiltinFunctionObject_1 = require("../Objects/BuiltinFunctionObject");
var HasInstance_1 = require("../HasInstance");
var ToUInt16_1 = require("../Conversion/ToUInt16");
var ToString_1 = require("../Conversion/ToString");
var Define_1 = require("../Define");
var EcmaObject_1 = require("../Objects/EcmaObject");
var Label_1 = require("../Label");
var StringObject_1 = require("../Objects/StringObject");
// ------------------------------------------------------------
// The String Constructor, 15.5.2
var StringConstructor = /** @class */ (function (_super) {
    __extends(StringConstructor, _super);
    function StringConstructor(host) {
        var _this = _super.call(this) || this;
        _this.Class = 'Function';
        // not mandated by standard
        _this.Extensible = true;
        _this.host = host;
        return _this;
    }
    StringConstructor.prototype.Setup = function () {
        this.Prototype = new Value_1.Value(monitor.instances.FunctionPrototype, Label_1.bot);
        Define_1.DefineFFF(this, constants.length, 1);
        Define_1.DefineFFF(this, constants.prototype, monitor.instances.StringPrototype);
        Define_1.DefineTFT(this, constants.fromCharCode, new BuiltinFunctionObject_1.BuiltinFunctionObject(fromCharCode, 1, this.host.fromCharCode));
    };
    StringConstructor.prototype.HasInstance = function (V) {
        return HasInstance_1.HasInstance.call(this, V);
    };
    // 15.5.1.1 -----------------------------------------------------------------
    StringConstructor.prototype.Call = function (thisArg, args) {
        if (!args[0]) {
            return new Value_1.Value('', Label_1.bot);
        }
        var str = ToString_1.ToString(args[0]);
        return str;
    };
    // 15.5.2.1 ----------------------------------------------------------------- 
    StringConstructor.prototype.Construct = function (args) {
        var value = args[0];
        var str;
        if (value) {
            var x = ToString_1.ToString(value);
            str = new StringObject_1.StringObject(x.value, x.label);
        }
        else {
            str = new StringObject_1.StringObject('');
        }
        return new Value_1.Value(str, Label_1.bot);
    };
    return StringConstructor;
}(EcmaObject_1.EcmaObject));
exports.StringConstructor = StringConstructor;
// --------------------------------------------------------------------------
// fromCharCode, 15.5.3.2 
function fromCharCode(thisArg, args) {
    var lbl = new Label_1.Label();
    var _args = [];
    for (var i = 0, len = args.length; i < len; i++) {
        var arg = ToUInt16_1.ToUInt16(args[i]);
        lbl = Label_1.lub(lbl, arg.label);
        _args[i] = arg.value;
    }
    var _String = monitor.instances.StringConstructor.host;
    var v = _String.fromCharCode.apply(_String, _args);
    return new Value_1.Value(v, lbl);
}

},{"../Constants":64,"../Conversion/ToString":87,"../Conversion/ToUInt16":88,"../Define":91,"../HasInstance":120,"../Label":123,"../Objects/BuiltinFunctionObject":134,"../Objects/EcmaObject":137,"../Objects/StringObject":150,"../Value":184}],77:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ErrorConstructor_1 = require("./ErrorConstructor");
var Label_1 = require("../Label");
var Value_1 = require("../Value");
var SyntaxErrorObject_1 = require("../Objects/SyntaxErrorObject");
var SyntaxErrorConstructor = /** @class */ (function (_super) {
    __extends(SyntaxErrorConstructor, _super);
    function SyntaxErrorConstructor(host) {
        return _super.call(this, host) || this;
    }
    SyntaxErrorConstructor.prototype.Setup = function () {
        this.SetupBase(monitor.instances.SyntaxErrorPrototype);
    };
    SyntaxErrorConstructor.prototype.Construct = function (args) {
        var message = args[0] || new Value_1.Value(undefined, Label_1.bot);
        var o = new SyntaxErrorObject_1.SyntaxErrorObject(message);
        return new Value_1.Value(o, Label_1.bot);
    };
    return SyntaxErrorConstructor;
}(ErrorConstructor_1.ErrorConstructor));
exports.SyntaxErrorConstructor = SyntaxErrorConstructor;

},{"../Label":123,"../Objects/SyntaxErrorObject":151,"../Value":184,"./ErrorConstructor":68}],78:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ErrorConstructor_1 = require("./ErrorConstructor");
var Label_1 = require("../Label");
var Value_1 = require("../Value");
var TypeErrorObject_1 = require("../Objects/TypeErrorObject");
var TypeErrorConstructor = /** @class */ (function (_super) {
    __extends(TypeErrorConstructor, _super);
    function TypeErrorConstructor(host) {
        return _super.call(this, host) || this;
    }
    TypeErrorConstructor.prototype.Setup = function () {
        this.SetupBase(monitor.instances.TypeErrorPrototype);
    };
    TypeErrorConstructor.prototype.Construct = function (args) {
        var message = args[0] || new Value_1.Value(undefined, Label_1.bot);
        var o = new TypeErrorObject_1.TypeErrorObject(message);
        return new Value_1.Value(o, Label_1.bot);
    };
    return TypeErrorConstructor;
}(ErrorConstructor_1.ErrorConstructor));
exports.TypeErrorConstructor = TypeErrorConstructor;

},{"../Label":123,"../Objects/TypeErrorObject":152,"../Value":184,"./ErrorConstructor":68}],79:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ErrorConstructor_1 = require("./ErrorConstructor");
var Label_1 = require("../Label");
var Value_1 = require("../Value");
var URIErrorObject_1 = require("../Objects/URIErrorObject");
var URIErrorConstructor = /** @class */ (function (_super) {
    __extends(URIErrorConstructor, _super);
    function URIErrorConstructor(host) {
        return _super.call(this, host) || this;
    }
    URIErrorConstructor.prototype.Setup = function () {
        this.SetupBase(monitor.instances.URIErrorPrototype);
    };
    URIErrorConstructor.prototype.Construct = function (args) {
        var message = args[0] || new Value_1.Value(undefined, Label_1.bot);
        var o = new URIErrorObject_1.URIErrorObject(message);
        return new Value_1.Value(o, Label_1.bot);
    };
    return URIErrorConstructor;
}(ErrorConstructor_1.ErrorConstructor));
exports.URIErrorConstructor = URIErrorConstructor;

},{"../Label":123,"../Objects/URIErrorObject":153,"../Value":184,"./ErrorConstructor":68}],80:[function(require,module,exports){
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
var Label_1 = require("./Label");
var Stack_1 = require("./Stack");
var PP_1 = require("./PP");
var Result_1 = require("./Result");
// --- -----------------------------------------------------------------------
var Bucket = /** @class */ (function () {
    function Bucket(element, prev, next) {
        this.element = element;
        this.next = next || null;
        this.prev = prev || null;
    }
    return Bucket;
}());
function isGuardedFunction(el) {
    return el.runfor !== undefined;
}
exports.isGuardedFunction = isGuardedFunction;
function isClosure(el) {
    return el.func !== undefined;
}
exports.isClosure = isClosure;
var WorkList = /** @class */ (function () {
    function WorkList() {
        this.length = 0;
        this.head = null;
        this.thenloc = null;
    }
    // ---
    WorkList.prototype.toString = function () {
        var pos = this.head;
        var str = 'worklist:';
        var cnt = 1;
        while (pos) {
            var element = pos.element;
            var line;
            if (typeof element === 'function') {
                line = cnt + ': ' + String(element);
            }
            else if ('func' in element && 'data' in element) {
                line = cnt + ': ' + String(element.func);
            }
            else {
                //@ts-ignore TYPES
                line = cnt + ': ' + element.type + ' ' + PP_1.pretty(element);
            }
            var ix = line.indexOf('\n');
            if (ix > 0) {
                line = line.slice(0, ix);
            }
            str = str + '\n' + line;
            pos = pos.next;
            cnt++;
        }
        return str;
    };
    // ---
    WorkList.prototype.push = function (element) {
        this.head = new Bucket(element, null, this.head);
        if (this.head.next !== null) {
            this.head.next.prev = this.head;
        }
        this.length++;
    };
    // ---
    WorkList.prototype.prepend = function (elements) {
        for (var i = elements.length - 1; i >= 0; i--) {
            this.push(elements[i]);
        }
    };
    // ---
    WorkList.prototype.peek = function () {
        if (this.head === null) {
            return monitor.fatal("WorkList.peek() empty work list");
        }
        return this.head.element;
    };
    // ---
    WorkList.prototype.pop = function () {
        if (this.head === null) {
            return monitor.fatal("WorkList.pop() empty work list");
        }
        var element = this.head.element;
        this.head = this.head.next;
        this.length--;
        return element;
    };
    // ---
    WorkList.prototype.empty = function () {
        return (this.head === null);
    };
    // ---
    WorkList.prototype.top = function () {
        return new WorkListPtr(this, null);
    };
    // ---
    WorkList.prototype.first = function (element) {
        if (element) {
            this.push(element);
            this.thenloc = this.head;
        }
        else {
            // if no element given, reset thenloc to force next called 'then'
            // to be a 'first'
            this.thenloc = null;
        }
    };
    // ---
    WorkList.prototype.then = function (element) {
        if (!this.thenloc) {
            this.first(element);
        }
        else {
            var before = this.thenloc;
            var after = this.thenloc.next;
            var bucket = new Bucket(element, before, after);
            before.next = bucket;
            this.thenloc = before.next;
            if (after) {
                after.prev = before.next;
            }
            this.length++;
        }
    };
    return WorkList;
}());
exports.WorkList = WorkList;
// -------------------------------------------------------------
var WorkListPtr = /** @class */ (function () {
    function WorkListPtr(worklist, pos) {
        this.worklist = worklist;
        this.pos = pos;
    }
    WorkListPtr.prototype.then = function (element, data) {
        if (!element) {
            throw Error();
        }
        var thing = element;
        if (typeof element === 'function' && data) {
            thing = { func: element, data: data };
        }
        if (this.pos) {
            var before = this.pos;
            var after = this.pos.next;
            var bucket = new Bucket(thing, before, after);
            before.next = bucket;
            this.pos = before.next;
            if (after) {
                after.prev = before.next;
            }
            this.worklist.length++;
        }
        else {
            this.worklist.push(thing);
            this.pos = this.worklist.head;
        }
        return this;
    };
    return WorkListPtr;
}());
exports.WorkListPtr = WorkListPtr;
// -------------------------------------------------------------
// The Execution Context
var Context = /** @class */ (function () {
    function Context(thisValue, variableEnv, lexicalEnv) {
        this.labels = new /** @class */ (function () {
            function class_1(outer) {
                this.excLbl = Label_1.bot;
                this.retLbl = Label_1.bot;
                this.labelmap = {};
                this.outer = outer;
            }
            Object.defineProperty(class_1.prototype, "exc", {
                get: function () {
                    if (monitor.options.get('monitor.taintMode')) {
                        return Label_1.bot;
                    }
                    return this.excLbl;
                },
                set: function (l) {
                    this.excLbl = l;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(class_1.prototype, "ret", {
                get: function () {
                    if (monitor.options.get('monitor.taintMode')) {
                        return Label_1.bot;
                    }
                    return this.retLbl;
                },
                set: function (l) {
                    this.retLbl = l;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(class_1.prototype, "pc", {
                get: function () {
                    if (monitor.options.get('monitor.taintMode')) {
                        return Label_1.bot;
                    }
                    return this.outer.pcStack.peek();
                },
                set: function (l) {
                    this.outer.pcStack.pop();
                    this.outer.pcStack.push(l);
                },
                enumerable: true,
                configurable: true
            });
            return class_1;
        }())(this);
        this.thisValue = thisValue;
        this.variableEnv = variableEnv;
        this.lexicalEnv = lexicalEnv;
        this.pcStack = new Stack_1.Stack();
        this.pcStack.push(Label_1.bot);
        this.workList = new WorkList();
        this.result = new Result_1.Result();
        this.valueStack = new Stack_1.Stack();
        this.codeStack = new Stack_1.Stack();
    }
    Object.defineProperty(Context.prototype, "effectivePC", {
        // ---
        get: function () {
            if (monitor.options.get('monitor.taintMode')) {
                return Label_1.bot;
            }
            return Label_1.lub(this.labels.pc, this.labels.exc, this.labels.ret);
        },
        enumerable: true,
        configurable: true
    });
    // ---
    Context.prototype.clone = function (thisValue, variableEnv, lexicalEnv) {
        var tV = thisValue || this.thisValue;
        var lE = lexicalEnv || this.lexicalEnv;
        var vE = variableEnv || this.variableEnv;
        var newCtx = new Context(tV, vE, lE);
        newCtx.labels.pc = this.effectivePC;
        newCtx.labels.exc = this.labels.exc;
        newCtx.labels.ret = this.labels.ret;
        return newCtx;
    };
    // ---
    Context.prototype.pushPC = function (l) {
        this.pcStack.push(Label_1.lub(l, this.labels.pc));
    };
    // ---
    Context.prototype.raisePC = function (l) {
        this.labels.pc = Label_1.lub(this.labels.pc, l);
    };
    // ---
    Context.prototype.popPC = function () {
        return this.pcStack.pop();
    };
    return Context;
}());
exports.Context = Context;

},{"./Label":123,"./PP":155,"./Result":174,"./Stack":175}],81:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
var Value_1 = require("../Value");
// -------------------------------------------------------------
// ToBoolean, 9.2
function ToBoolean(x) {
    return new Value_1.Value(Boolean(x.value), x.label);
}
exports.ToBoolean = ToBoolean;

},{"../Value":184}],82:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
var ToNumber_1 = require("./ToNumber");
// -------------------------------------------------------------
// ToInt32, 9.5
function ToInt32(x) {
    return ToNumber_1.ToNumber(x);
}
exports.ToInt32 = ToInt32;

},{"./ToNumber":84}],83:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
var Value_1 = require("../Value");
var ToNumber_1 = require("./ToNumber");
// -------------------------------------------------------------
// ToInteger, 9.4
//        Using ToNumber to capture the ToPrimitive
//        and rely on the internal conversion at the point of use
//        should suffice.
function ToInteger(x) {
    var number = ToNumber_1.ToNumber(x);
    if (isNaN(number.value)) {
        return new Value_1.Value(0, number.label);
    }
    else if (number.value === 0 ||
        number.value === Number.POSITIVE_INFINITY ||
        number.value === Number.NEGATIVE_INFINITY) {
        return number;
    }
    else {
        return new Value_1.Value(sign(number.value) * Math.floor(Math.abs(number.value)), number.label);
    }
}
exports.ToInteger = ToInteger;
function sign(n) {
    if (n > 0) {
        return 1;
    }
    else if (n < 0) {
        return -1;
    }
    return 0;
}

},{"../Value":184,"./ToNumber":84}],84:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
var Value_1 = require("../Value");
var ToPrimitive_1 = require("./ToPrimitive");
// -------------------------------------------------------------
// ToNumber, 9.3
function ToNumber(x) {
    if (typeof x.value !== 'object') {
        return new Value_1.Value(Number(x.value), x.label);
    }
    monitor.context.pushPC(x.label);
    var primValue = ToPrimitive_1.ToPrimitive(x, 'number');
    monitor.context.popPC();
    return new Value_1.Value(Number(primValue.value), primValue.label);
}
exports.ToNumber = ToNumber;

},{"../Value":184,"./ToPrimitive":86}],85:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
var Value_1 = require("../Value");
var Label_1 = require("../Label");
var BooleanObject_1 = require("../Objects/BooleanObject");
var NumberObject_1 = require("../Objects/NumberObject");
var StringObject_1 = require("../Objects/StringObject");
// -------------------------------------------------------------
// ToObject, 9.9
function ToObject(x) {
    // null or undefined, hence ==
    var value = x.value;
    if (value === null || value === undefined) {
        monitor.context.pushPC(x.label);
        monitor.Throw("TypeError", 'cannot convert ' + String(x.value) + ' to object', Label_1.bot);
    }
    monitor.context.pushPC(x.label);
    var res = undefined;
    switch (typeof x.value) {
        case 'boolean':
            res = new Value_1.Value(new BooleanObject_1.BooleanObject(x.value, x.label), x.label);
            break;
        case 'number':
            res = new Value_1.Value(new NumberObject_1.NumberObject(x.value, x.label), x.label);
            break;
        case 'string':
            //@ts-ignore
            res = new Value_1.Value(new StringObject_1.StringObject(x.value, x.label), x.label);
            break;
    }
    monitor.context.popPC();
    if (res !== undefined) {
        return res;
    }
    else {
        //@ts-ignore
        return new Value_1.Value(x.value, x.label);
    }
}
exports.ToObject = ToObject;

},{"../Label":123,"../Objects/BooleanObject":133,"../Objects/NumberObject":145,"../Objects/StringObject":150,"../Value":184}],86:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
// -------------------------------------------------------------
// ToPrimitive, 9.1  
function ToPrimitive(x, PreferredType) {
    if (x.value === null || typeof x.value !== 'object') {
        // @ts-ignore
        return x;
    }
    // will run int the context of x due to value lifting
    var res = x.DefaultValue(PreferredType);
    return res;
}
exports.ToPrimitive = ToPrimitive;

},{}],87:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
var Value_1 = require("../Value");
var ToPrimitive_1 = require("./ToPrimitive");
// -------------------------------------------------------------
// ToString, 9.8
function ToString(x) {
    if (typeof x.value !== 'object')
        return new Value_1.Value(String(x.value), x.label);
    monitor.context.pushPC(x.label);
    var primValue = ToPrimitive_1.ToPrimitive(x, 'string');
    monitor.context.popPC();
    return new Value_1.Value(String(primValue.value), primValue.label);
}
exports.ToString = ToString;

},{"../Value":184,"./ToPrimitive":86}],88:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
var Value_1 = require("../Value");
var ToNumber_1 = require("./ToNumber");
// -------------------------------------------------------------
// ToUInt16, 9.7
function ToUInt16(x) {
    var number = ToNumber_1.ToNumber(x);
    if (isNaN(number.value) ||
        number.value === 0 ||
        number.value === Number.POSITIVE_INFINITY ||
        number.value === Number.NEGATIVE_INFINITY) {
        return new Value_1.Value(0, number.label);
    }
    var posInt = sign(number.value) * Math.floor(Math.abs(number.value));
    var int16bit = posInt % Math.pow(2, 16);
    return new Value_1.Value(int16bit, number.label);
}
exports.ToUInt16 = ToUInt16;
function sign(n) {
    if (n > 0) {
        return 1;
    }
    else if (n < 0) {
        return -1;
    }
    return 0;
}
;

},{"../Value":184,"./ToNumber":84}],89:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
var ToNumber_1 = require("./ToNumber");
// -------------------------------------------------------------
// ToUInt32, 9.6
function ToUInt32(x) {
    return ToNumber_1.ToNumber(x);
}
exports.ToUInt32 = ToUInt32;

},{"./ToNumber":84}],90:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Label_1 = require("./Label");
var Value_1 = require("./Value");
var EcmaObject_1 = require("./Objects/EcmaObject");
var LexicalEnvironment_1 = require("./LexicalEnvironment");
// ------------------------------------------------------------
// 10.2.2.2
function NewDeclarativeEnvironment(e) {
    var envRec = new DeclarativeEnvironmentRecord();
    var env = new LexicalEnvironment_1.LexicalEnvironment(envRec, e);
    return env;
}
exports.NewDeclarativeEnvironment = NewDeclarativeEnvironment;
// ------------------------------------------------------------
// Declarative Environment Record, 10.2.1.1
var DeclarativeEnvironmentRecord = /** @class */ (function (_super) {
    __extends(DeclarativeEnvironmentRecord, _super);
    function DeclarativeEnvironmentRecord() {
        return _super.call(this) || this;
    }
    // HasBinding, 10.2.1.1.1
    DeclarativeEnvironmentRecord.prototype.HasBinding = function (s) {
        return this.HasProperty(s);
    };
    // CreateMutableBinding, 10.2.1.1.2
    DeclarativeEnvironmentRecord.prototype.CreateMutableBinding = function (p, d) {
        var desc = {
            value: undefined,
            label: monitor.context.effectivePC,
            writable: true,
            enumerable: true,
            configurable: d
        };
        this.DefineOwnProperty(p, desc, true);
    };
    // GetBindingValue 10.2.1.1.4
    DeclarativeEnvironmentRecord.prototype.GetBindingValue = function (p, s) {
        return this.Get(p);
    };
    // SetMutableBinding, 10.2.1.1.3
    DeclarativeEnvironmentRecord.prototype.SetMutableBinding = function (p, v, s) {
        this.Put(p, v, s === true);
    };
    // DeleteBinding, 10.2.1.1.5
    DeclarativeEnvironmentRecord.prototype.DeleteBinding = function (p) {
        return this.Delete(p);
    };
    // ImplicitThisValie. 10.2.1.1.6
    DeclarativeEnvironmentRecord.prototype.ImplicitThisValue = function () {
        return new Value_1.Value(undefined, Label_1.bot);
    };
    // CreateImmutableBinding, 10.2.1.1.7
    DeclarativeEnvironmentRecord.prototype.CreateImmutableBinding = function (p) {
        var desc = {
            value: undefined,
            label: Label_1.bot,
            writable: false,
            enumerable: true,
            configurable: true
        };
        this.DefineOwnProperty(p, desc, false);
    };
    // InitializeImmutableBinding, 10.2.1.1.8
    DeclarativeEnvironmentRecord.prototype.InitializeImmutableBinding = function (p, v) {
        var desc = this.GetOwnProperty(p).value;
        if (desc === undefined) {
            monitor.fatal("InitializeImmutableBinding: no bindinging for {p.value}");
        }
        else {
            desc.value = v.value;
            desc.label = v.label;
            // @ts-ignore desc should be a data descriptor created by CreateImmutableBinding
            this.DefineOwnProperty(p, desc, false);
        }
    };
    return DeclarativeEnvironmentRecord;
}(EcmaObject_1.EcmaObject));
exports.DeclarativeEnvironmentRecord = DeclarativeEnvironmentRecord;

},{"./Label":123,"./LexicalEnvironment":124,"./Objects/EcmaObject":137,"./Value":184}],91:[function(require,module,exports){
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
var Label_1 = require("./Label");
// TODO: label of name not used; only Value to be compatible with constants - reasonable?
function Define(_this, name, v, opts) {
    opts = opts || {};
    var pd = {
        value: v,
        writable: opts.writable === true,
        enumerable: opts.enumerable === true,
        configurable: opts.configurable === true
    };
    Object.defineProperty(_this.properties, name.value, pd);
    _this.labels[name.value] = { value: opts.label || Label_1.bot, existence: opts.existence || Label_1.bot };
}
exports.Define = Define;
// ---
function DefineFFT(_this, name, v, opts) {
    opts = opts || {};
    Object.defineProperty(_this.properties, name.value, {
        value: v,
        configurable: true
    });
    _this.labels[name.value] = { value: opts.label || Label_1.bot, existence: opts.existence || Label_1.bot };
}
exports.DefineFFT = DefineFFT;
// ---
function DefineFFF(_this, name, v, opts) {
    opts = opts || {};
    Object.defineProperty(_this.properties, name.value, { value: v });
    _this.labels[name.value] = { value: opts.label || Label_1.bot, existence: opts.existence || Label_1.bot };
}
exports.DefineFFF = DefineFFF;
// ---
function DefineTFF(_this, name, v, opts) {
    opts = opts || {};
    Object.defineProperty(_this.properties, name.value, {
        value: v,
        writable: true
    });
    _this.labels[name.value] = { value: opts.label || Label_1.bot, existence: opts.existence || Label_1.bot };
}
exports.DefineTFF = DefineTFF;
// ---
function DefineTFT(_this, name, v, opts) {
    opts = opts || {};
    Object.defineProperty(_this.properties, name.value, {
        value: v,
        writable: true,
        configurable: true
    });
    _this.labels[name.value] = { value: opts.label || Label_1.bot, existence: opts.existence || Label_1.bot };
}
exports.DefineTFT = DefineTFT;
// ------------------------------------------------------------

},{"./Label":123}],92:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
var Value_1 = require("../Value");
var Label_1 = require("../Label");
var ToNumber_1 = require("../Conversion/ToNumber");
var ToPrimitive_1 = require("../Conversion/ToPrimitive");
var ToUInt32_1 = require("../Conversion/ToUInt32");
var ToInt32_1 = require("../Conversion/ToInt32");
var ToString_1 = require("../Conversion/ToString");
var GetValue_1 = require("../GetValue");
var ToBoolean_1 = require("../Conversion/ToBoolean");
// -------------------------------------------------------------
// Equality Operators, 11.9
function binaryEqs(op, wl, vs) {
    // @ts-ignore
    var rval = vs.pop();
    // @ts-ignore
    var lval = vs.pop();
    var res;
    while (true) {
        var lt = typeof lval.value;
        var rt = typeof rval.value;
        lt = lval.value === undefined ? 'undefined' : lt;
        rt = rval.value === undefined ? 'undefined' : rt;
        lt = lval.value === null ? 'null' : lt;
        rt = rval.value === null ? 'null' : rt;
        // must use strict in order not to trigger conversion
        //   but then null and undefined must be handled separately
        if (lt === rt) {
            res = new Value_1.Value(lval.value === rval.value, Label_1.lub(lval.label, rval.label));
            break;
        }
        if ((lval.value === null && rval.value === undefined) ||
            (lval.value === undefined && rval.value === null)) {
            res = new Value_1.Value(true, Label_1.lub(lval.label, rval.label));
            break;
        }
        if (lt === 'number' && rt === 'string') {
            rval = ToNumber_1.ToNumber(rval);
            continue;
        }
        if (lt === 'string' && rt === 'number') {
            lval = ToNumber_1.ToNumber(lval);
            continue;
        }
        if (lt === 'boolean') {
            lval = ToNumber_1.ToNumber(lval);
            continue;
        }
        if (rt === 'boolean') {
            rval = ToNumber_1.ToNumber(rval);
            continue;
        }
        if ((lt === 'string' || lt === 'number') &&
            rt === 'object') {
            rval = ToPrimitive_1.ToPrimitive(rval);
            continue;
        }
        if (lt === 'object' &&
            (rt === 'string' || rt === 'number')) {
            lval = ToPrimitive_1.ToPrimitive(lval);
            continue;
        }
        res = new Value_1.Value(false, Label_1.lub(lval.label, rval.label));
        break;
    }
    if (op === '!=') {
        res.value = !res.value;
    }
    vs.push(res);
}
// -------------------------------------------------------------
// Strict Equality Operators, 11.9.4, 11.9.5
function binaryStrictEqs(op, wl, vs) {
    // @ts-ignore
    var rval = vs.pop();
    // @ts-ignore
    var lval = vs.pop();
    var res = new Value_1.Value(lval.value === rval.value, Label_1.lub(lval.label, rval.label));
    if (op === '!==') {
        res.value = !res.value;
    }
    vs.push(res);
}
exports.binaryStrictEqs = binaryStrictEqs;
// -------------------------------------------------------------
// Relational Operators, 11.8
//  The evaluation order is important, 11.8.5
function binaryOrds(op, wl, vs) {
    // @ts-ignore
    var rval = vs.pop();
    // @ts-ignore
    var lval = vs.pop();
    var lprim, rprim;
    if (op.charAt(0) === '<' || op.charAt(0) === '>') {
        lprim = ToPrimitive_1.ToPrimitive(lval, 'number');
        rprim = ToPrimitive_1.ToPrimitive(rval, 'number');
    }
    else {
        lprim = ToPrimitive_1.ToPrimitive(lval);
        rprim = ToPrimitive_1.ToPrimitive(rval);
    }
    var res;
    if (typeof lprim.value !== 'string' &&
        typeof rprim.value !== 'string') {
        var lnum = ToNumber_1.ToNumber(lprim);
        var rnum = ToNumber_1.ToNumber(rprim);
        var val = eval('lnum.value ' + op + ' rnum.value');
        res = new Value_1.Value(val, Label_1.lub(lnum.label, rnum.label));
    }
    else {
        var val = eval('lprim.value ' + op + ' rprim.value');
        res = new Value_1.Value(val, Label_1.lub(lprim.label, rprim.label));
    }
    vs.push(res);
}
// -------------------------------------------------------------
// Bitwise Shift Operators, 11.7
function binaryShifts(op, wl, vs) {
    // @ts-ignore
    var rval = vs.pop();
    // @ts-ignore
    var lval = vs.pop();
    var lnum = (op === '>>>') ? ToUInt32_1.ToUInt32(lval) : ToInt32_1.ToInt32(lval);
    var rnum = ToUInt32_1.ToUInt32(rval);
    var val = eval('lnum.value ' + op + ' rnum.value');
    vs.push(new Value_1.Value(val, Label_1.lub(lnum.label, rnum.label)));
}
// -------------------------------------------------------------
// Binary Bitwise Operators, 11.10
function binaryBitwiseOps(op, wl, vs) {
    // @ts-ignore
    var rval = vs.pop();
    // @ts-ignore
    var lval = vs.pop();
    var lnum = ToInt32_1.ToInt32(lval);
    var rnum = ToInt32_1.ToInt32(rval);
    var val = eval('lnum.value ' + op + ' rnum.value');
    vs.push(new Value_1.Value(val, Label_1.lub(lnum.label, rnum.label)));
}
// -------------------------------------------------------------
// Plus, 11.6
function binaryPlus(wl, vs) {
    // @ts-ignore
    var rval = vs.pop();
    // @ts-ignore
    var lval = vs.pop();
    var lprim = ToPrimitive_1.ToPrimitive(lval);
    var rprim = ToPrimitive_1.ToPrimitive(rval);
    var res;
    if ((typeof lprim.value) === 'string' ||
        (typeof rprim.value) === 'string') {
        var lstr = ToString_1.ToString(lprim);
        var rstr = ToString_1.ToString(rprim);
        res = new Value_1.Value(lstr.value + rstr.value, Label_1.lub(lprim.label, rprim.label));
    }
    else {
        var lnum = ToNumber_1.ToNumber(lprim);
        var rnum = ToNumber_1.ToNumber(rprim);
        res = new Value_1.Value(lnum.value + rnum.value, Label_1.lub(lnum.label, rnum.label));
    }
    vs.push(res);
}
// -------------------------------------------------------------
// Multiplicative operators, 11.5, and minus, 11.6
function binaryArithmeticOps(op, wl, vs) {
    // @ts-ignore
    var rval = vs.pop();
    // @ts-ignore
    var lval = vs.pop();
    var leftNum = ToNumber_1.ToNumber(lval);
    var rightNum = ToNumber_1.ToNumber(rval);
    var val = eval('leftNum.value ' + op + ' rightNum.value');
    vs.push(new Value_1.Value(val, Label_1.lub(leftNum.label, rightNum.label)));
}
// -------------------------------------------------------------
// The in operator, 11.8.7
function binaryIn(wl, vs) {
    // @ts-ignore
    var rval = vs.pop();
    // @ts-ignore
    var lval = vs.pop();
    if (typeof rval.value !== 'object') {
        if (false) { // SILENT ERROR
            vs.push(new Value_1.Value(false, Label_1.lub(lval.label, rval.label)));
            return;
        }
        monitor.Throw("TypeError", "invalid 'in' parameter", rval.label);
    }
    vs.push(rval.HasProperty(ToString_1.ToString(lval)));
}
// -------------------------------------------------------------
// The instanceof operator, 11.8.6
function binaryInstanceof(wl, vs) {
    // @ts-ignore
    var rval = vs.pop();
    // @ts-ignore
    var lval = vs.pop();
    if (rval.value === null || typeof rval.value !== 'object') {
        if (false) { // SILENT ERROR
            vs.push(new Value_1.Value(false, Label_1.lub(lval.label, rval.label)));
        }
        monitor.Throw("TypeError", "invalid 'instanceof' parameter", rval.label);
        throw 'TypeScript';
    }
    if (!('HasInstance' in rval.value)) {
        if (false) { // SILENT ERROR
            vs.push(new Value_1.Value(false, Label_1.lub(lval.label, rval.label)));
        }
        monitor.Throw("TypeError", "invalid 'instanceof' parameter", rval.label);
    }
    vs.push(rval.HasInstance(lval));
}
// -------------------------------------------------------------
exports.binarytbl = {
    '==': binaryEqs.bind(null, '=='),
    '!=': binaryEqs.bind(null, '!='),
    '===': binaryStrictEqs.bind(null, '==='),
    '!==': binaryStrictEqs.bind(null, '!=='),
    '<': binaryOrds.bind(null, '<'),
    '<=': binaryOrds.bind(null, '<='),
    '>': binaryOrds.bind(null, '>'),
    '>=': binaryOrds.bind(null, '>='),
    '<<': binaryShifts.bind(null, '<<'),
    '>>': binaryShifts.bind(null, '>>'),
    '>>>': binaryShifts.bind(null, '>>>'),
    '+': binaryPlus,
    '-': binaryArithmeticOps.bind(null, '-'),
    '*': binaryArithmeticOps.bind(null, '*'),
    '/': binaryArithmeticOps.bind(null, '/'),
    '%': binaryArithmeticOps.bind(null, '%'),
    '|': binaryBitwiseOps.bind(null, '|'),
    '&': binaryBitwiseOps.bind(null, '&'),
    '^': binaryBitwiseOps.bind(null, '^'),
    'in': binaryIn,
    'instanceof': binaryInstanceof
};
// -------------------------------------------------------------
// Binary Logical ||, 11.11
function binaryLogicalOr(wl, vs) {
    //@ts-ignore STACK
    var lval = GetValue_1.GetValue(vs.pop());
    vs.push(lval);
    var lb = ToBoolean_1.ToBoolean(lval);
    var right = wl.pop();
    if (lb.value) {
        return;
    }
    monitor.context.pushPC(lb.label);
    var ip = wl.top();
    ip.then(right);
    ip.then(binaryLogicalOr_end);
}
// ---
function binaryLogicalOr_end(wl, vs) {
    //@ts-ignore STACK
    var rval = GetValue_1.GetValue(vs.pop());
    //@ts-ignore
    var lval = vs.pop();
    monitor.context.popPC();
    vs.push(new Value_1.Value(rval.value, Label_1.lub(rval.label, lval.label)));
}
// -------------------------------------------------------------
// Binary Logical &&, 11.11
function binaryLogicalAnd(wl, vs) {
    //@ts-ignore STACK
    var lval = GetValue_1.GetValue(vs.pop());
    vs.push(lval);
    var lb = ToBoolean_1.ToBoolean(lval);
    var right = wl.pop();
    if (!lb.value) {
        return;
    }
    monitor.context.pushPC(lb.label);
    var ip = wl.top();
    ip.then(right);
    ip.then(binaryLogicalAnd_end);
}
// ---
function binaryLogicalAnd_end(wl, vs) {
    //@ts-ignore STACK
    var rval = GetValue_1.GetValue(vs.pop());
    //@ts-ignore STACK
    var lval = vs.pop();
    monitor.context.popPC();
    vs.push(new Value_1.Value(rval.value, Label_1.lub(rval.label, lval.label)));
}
// -------------------------------------------------------------
exports.logicaltbl = {
    '||': binaryLogicalOr,
    '&&': binaryLogicalAnd
};
// -------------------------------------------------------------
function assignmentOps(op, wl, vs) {
    //@ts-ignore STACK
    var rval = GetValue_1.GetValue(vs.pop());
    var lref = vs.pop();
    if (op !== null) {
        vs.push(lref);
        //@ts-ignore STACK
        vs.push(GetValue_1.GetValue(lref));
        vs.push(rval);
        exports.binarytbl[op](wl, vs);
    }
    else {
        vs.push(lref);
        vs.push(rval);
    }
}
exports.assignmenttbl = {
    '=': assignmentOps.bind(null, null),
    '+=': assignmentOps.bind(null, '+'),
    '-=': assignmentOps.bind(null, '-'),
    '*=': assignmentOps.bind(null, '*'),
    '/=': assignmentOps.bind(null, '/'),
    '%=': assignmentOps.bind(null, '%'),
    '>>=': assignmentOps.bind(null, '>>'),
    '<<=': assignmentOps.bind(null, '<<'),
    '>>>=': assignmentOps.bind(null, '>>>'),
    '|=': assignmentOps.bind(null, '|'),
    '&=': assignmentOps.bind(null, '&'),
    '^=': assignmentOps.bind(null, '^')
};

},{"../Conversion/ToBoolean":81,"../Conversion/ToInt32":82,"../Conversion/ToNumber":84,"../Conversion/ToPrimitive":86,"../Conversion/ToString":87,"../Conversion/ToUInt32":89,"../GetValue":119,"../Label":123,"../Value":184}],93:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
var FunctionObject_1 = require("../Objects/FunctionObject");
var ArgumentsObject_1 = require("../Objects/ArgumentsObject");
var Value_1 = require("../Value");
var Label_1 = require("../Label");
var constants = require("../Constants");
var estraverse = require("estraverse");
// ------------------------------------------------------------
// 10.5 - strict ignored
function DeclarationBindingInstantiation(context, F, args) {
    var isFunctionCode, isEvalCode, code;
    if (F instanceof FunctionObject_1.FunctionObject) {
        isFunctionCode = true;
        isEvalCode = false;
        code = F.Code;
    }
    else {
        isFunctionCode = false;
        isEvalCode = true;
        code = F;
    }
    var env = context.variableEnv;
    var configurableBindings = isEvalCode;
    if (isFunctionCode) {
        BindArguments(env, F.FormalParameters, args);
    }
    var pc = context.effectivePC;
    HoistFunctions(env, code, configurableBindings, pc);
    var argumentsAlreadyDeclared = env.HasBinding(constants['arguments']);
    if (isFunctionCode && !argumentsAlreadyDeclared.value) {
        // make sure it returns a Value
        var argsObj = ArgumentsObject_1.CreateArgumentsObject(env, F, args);
        // Should no longer be supported
        // F.DefineOwnProperty(constants['arguments'], argsObj, false);
        env.CreateMutableBinding(constants['arguments']);
        env.SetMutableBinding(constants['arguments'], argsObj, false);
    }
    HoistVariables(env, code, configurableBindings, pc);
}
exports.DeclarationBindingInstantiation = DeclarationBindingInstantiation;
// ------------------------------------------------------------
// Function hoisting, part of 10.5
function HoistFunctions(env, script, configurableBinding, pc) {
    if (!script.functionDeclarations) {
        // 
        script.functionDeclarations = [];
        var visitor = {};
        //@ts-ignore SYNTAX
        visitor.leave = function () { };
        //@ts-ignore SYNTAX
        visitor.enter = function (node) {
            if (node.type === 'FunctionDeclaration') {
                script.functionDeclarations.push(node);
            }
            // Do not hoist inside functions
            if (node.type === 'FunctionDeclaration' ||
                node.type === 'FunctionExpression') {
                this.skip();
            }
        };
        estraverse.traverse(script, visitor);
    }
    var ds = script.functionDeclarations;
    var i;
    var len = ds.length;
    for (i = 0; i < len; i++) {
        var fn = new Value_1.Value(ds[i].id.name, Label_1.bot);
        var fo = new FunctionObject_1.FunctionObject(ds[i].params, ds[i].body, env);
        fo.Name = ds[i].id.name;
        fo.Source = ds[i];
        var funcAlreadyDeclared = env.HasBinding(fn);
        if (!funcAlreadyDeclared.value) {
            env.CreateMutableBinding(fn, configurableBinding);
        }
        env.SetMutableBinding(fn, new Value_1.Value(fo, pc));
    }
}
exports.HoistFunctions = HoistFunctions;
// ------------------------------------------------------------
// Variable hoisting, part of 10.5
function HoistVariables(env, script, configurableBindings, pc) {
    if (!script.variableDeclarations) {
        script.variableDeclarations = [];
        var visitor = {};
        //@ts-ignore SYNTAX
        visitor.leave = function () { };
        //@ts-ignore SYNTAX
        visitor.enter = function (node) {
            // Do not hoist inside functions
            if (node.type === 'FunctionDeclaration' ||
                node.type === 'FunctionExpression') {
                this.skip();
            }
            if (node.type === 'VariableDeclaration') {
                for (var i = 0, len = node.declarations.length; i < len; i++) {
                    var declarator = node.declarations[i];
                    var pattern = declarator.id;
                    script.variableDeclarations.push(pattern);
                }
            }
        };
        estraverse.traverse(script, visitor);
    }
    var ds = script.variableDeclarations;
    var i;
    var len = ds.length;
    for (i = 0; i < len; i++) {
        if (ds[i].type !== 'Identifier') {
            monitor.fatal('Patters is variable declarations not supported');
        }
        // declarations are indentifiers, not general patterns
        var dn = new Value_1.Value(ds[i].name, Label_1.bot);
        var varAlreadyDeclared = env.HasBinding(dn);
        if (!varAlreadyDeclared.value) {
            env.CreateMutableBinding(dn, configurableBindings);
            env.SetMutableBinding(dn, new Value_1.Value(undefined, pc));
        }
    }
}
exports.HoistVariables = HoistVariables;
// ------------------------------------------------------------
// Bind Arguments, 
function BindArguments(env, names, args) {
    if (args == undefined)
        return;
    var argCount = args.length;
    var nameCount = names.length;
    monitor.context.pushPC(Label_1.bot);
    for (var n = 0; n < nameCount; n++) {
        var v;
        if (n >= argCount)
            v = new Value_1.Value(undefined, Label_1.bot);
        else
            v = args[n];
        var id = names[n];
        if (id.type !== 'Identifier') {
            monitor.fatal(id.type + ' is not supported in BindArguments');
        }
        var argName = new Value_1.Value(id.name, Label_1.bot);
        var argAlreadyDeclared = env.HasBinding(argName);
        monitor.context.raisePC(argAlreadyDeclared.label);
        if (!argAlreadyDeclared.value) {
            env.CreateMutableBinding(argName);
        }
        env.SetMutableBinding(argName, v);
    }
    monitor.context.popPC();
}
exports.BindArguments = BindArguments;

},{"../Constants":64,"../Label":123,"../Objects/ArgumentsObject":131,"../Objects/FunctionObject":140,"../Value":184,"estraverse":19}],94:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var JSFlowDebugError = /** @class */ (function (_super) {
    __extends(JSFlowDebugError, _super);
    function JSFlowDebugError() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return _super.apply(this, __spread(args)) || this;
    }
    return JSFlowDebugError;
}(Error));
exports.JSFlowDebugError = JSFlowDebugError;
function AssertValueStackSize(expectedSize, vs) {
    if (vs.size() !== expectedSize) {
        throw new JSFlowDebugError("Expected size of value stack to be " + expectedSize + " but it is " + vs.size());
    }
}
exports.AssertValueStackSize = AssertValueStackSize;
function CheckValueStackSize(expectedSize, msg) {
    var exc = new JSFlowDebugError();
    return function (wl, vs) {
        if (vs.size() !== expectedSize) {
            exc.message = "Expected size of value stack to be " + expectedSize + " but it is " + vs.size();
            throw exc;
        }
    };
}
exports.CheckValueStackSize = CheckValueStackSize;
function IsCanary(x) {
    return typeof x === 'object' && x !== null && x.token !== undefined && x.vssize !== undefined;
}
function PushCanary(vs, owner) {
    var canary = { token: Math.floor(Math.random() * Number.MAX_SAFE_INTEGER), owner: owner, vssize: vs.size() };
    //@ts-ignore CANARY
    vs.push(canary);
    return canary;
}
exports.PushCanary = PushCanary;
function AssertValidCanary(vs, expected) {
    var x = vs.pop();
    if (!IsCanary(x) || x.token !== expected.token) {
        vs.push(x);
        console.log('[JSFlow FATAL] Canary verification failed:', Error().stack);
        throw new JSFlowDebugError("Cannot verify canary");
    }
}
exports.AssertValidCanary = AssertValidCanary;

},{}],95:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Result_1 = require("../Result");
var Value_1 = require("../Value");
var Label_1 = require("../Label");
var SyntaxErrorObject_1 = require("../Objects/SyntaxErrorObject");
var Context_1 = require("../Context");
var Expression_1 = require("./Expression");
var Statement_1 = require("./Statement");
var esprima = require("esprima");
var Binding_1 = require("./Binding");
var DeclarativeEnvironmentRecord_1 = require("../DeclarativeEnvironmentRecord");
var ObjectEnvironmentRecord_1 = require("../ObjectEnvironmentRecord");
var Task_1 = require("./Task");
var CrawlerUtil_1 = require("../Toplevel/crawler/CrawlerUtil");
// ------------------------------------------------------------
function running() {
    return !monitor.context.workList.empty();
}
exports.running = running;
// ------------------------------------------------------------
function execute(ast, debugEnabled) {
    monitor.context.workList.push(ast);
    monitor.context.result = new Result_1.Result();
    if (debugEnabled === undefined) {
        debugEnabled = true;
    }
    var cont = true;
    do {
        if (debugEnabled && monitor.debug.active) {
            return monitor.context.result;
        }
        cont = step();
        monitor.executionInfo.step();
    } while (cont);
    // #CRAWLER
    if (CrawlerUtil_1.IsCrawler(monitor)) {
        monitor.CrawlerData.DumpToCrawler();
    }
    return monitor.context.result;
}
exports.execute = execute;
// ------------------------------------------------------------
function resume() {
    var cont = true;
    do {
        cont = step();
        if (monitor.debug.active) {
            return monitor.context.result;
        }
    } while (cont);
    return monitor.context.result;
}
exports.resume = resume;
// ------------------------------------------------------------
function executeGlobalCode(code, origin, options) {
    try {
        /* convert code to es5, using sourceType 'unambigious', meaning it will be
         * interpreted as script in a browser and _not_ add "use strict", and
         * either a script or module in nodejs (and add "use strict" if it is a
         * module) */
        var transformed = monitor.transform(code);
        monitor.code = code;
        monitor.ast = esprima.parse(transformed, { loc: true, range: true, tolerant: true });
    }
    catch (e) {
        var msg = new Value_1.Value(e.description + " in " + origin + " : " + e.lineNumber + " : " + e.column, Label_1.bot);
        var obj = new SyntaxErrorObject_1.SyntaxErrorObject(msg);
        var result_1 = new Result_1.Result();
        result_1.type = 'throw';
        result_1.value = new Value_1.Value(obj, Label_1.bot);
        return result_1;
    }
    var debugEnabled = true;
    if (options && typeof options.debugEnabled !== 'undefined') {
        debugEnabled = options.debugEnabled;
    }
    enterGlobalCode(monitor.ast);
    var result = execute(monitor.ast, debugEnabled);
    monitor.executionInfo.report();
    return result;
}
exports.executeGlobalCode = executeGlobalCode;
// ------------------------------------------------------------
//   contains the declaration binding (10.5) of global code
function enterGlobalCode(ast) {
    var c = monitor.context;
    // 10.5 - hoisting
    Binding_1.HoistFunctions(c.variableEnv, ast, false, Label_1.bot);
    Binding_1.HoistVariables(c.variableEnv, ast, false, Label_1.bot);
}
exports.enterGlobalCode = enterGlobalCode;
// ---
function enterEvalCode(code, _eval) {
    var c = monitor.context;
    // 15.1.2.1.1, is direct call
    var isDirect;
    //@ts-ignore TYPES
    isDirect = c.currentCall.reference.base.value instanceof ObjectEnvironmentRecord_1.ObjectEnvironmentRecord ||
        //@ts-ignore TYPES
        c.currentCall.reference.base.value instanceof DeclarativeEnvironmentRecord_1.DeclarativeEnvironmentRecord;
    //@ts-ignore TYPES
    isDirect = isDirect && c.currentCall.reference.propertyName.value === 'eval';
    //@ts-ignore TYPES
    isDirect = isDirect && c.currentCall.target.actualFunction === _eval;
    var context = c.clone();
    // 10.4.2 - no calling context or not direct call
    if (!isDirect) {
        var global = monitor.GlobalObject;
        var globalEnv = monitor.GlobalEnvironment;
        context.thisValue = new Value_1.Value(global, Label_1.bot);
        context.lexicalEnv = new Value_1.Value(globalEnv, Label_1.bot);
        context.variableEnv = new Value_1.Value(globalEnv, Label_1.bot);
    }
    //@ts-ignore TYPES
    Binding_1.DeclarationBindingInstantiation(context, code);
    // for stack trace 
    context.owner = 'eval';
    return context;
}
exports.enterEvalCode = enterEvalCode;
// -------------------------------------------------------------
function step() {
    //@ts-ignore .LAST
    if (monitor.last === undefined)
        monitor.last = [];
    var c = monitor.context;
    var wl = c.workList;
    var vs = c.valueStack;
    var result = c.result;
    if (wl.empty()) {
        return false;
    }
    var task = wl.pop();
    //@ts-ignore .LAST
    if (monitor.last.length > 100) {
        //@ts-ignore .LAST
        monitor.last.shift();
    }
    //@ts-ignore .LAST
    monitor.last.push(task);
    try {
        // throw, continue, or break state
        if (result.type !== 'normal') {
            while (true) {
                if (task instanceof Task_1.Task && task.RunFor(result.type)) {
                    task.Execute(wl, vs);
                    return true;
                }
                if (Context_1.isGuardedFunction(task) && task.runfor !== undefined && result.type in task.runfor) {
                    //console.log(task.name);
                    task(wl, vs);
                    return true;
                }
                if (Context_1.isClosure(task) && task.func.runfor !== undefined && result.type in task.func.runfor) {
                    //console.log(task.func.name);
                    task.func.call(task.data, wl, vs);
                    return true;
                }
                if (wl.empty()) {
                    break;
                }
                //      console.log('skipping', task);
                task = wl.pop();
                //@ts-ignore .LAST
                if (monitor.last.length > 100) {
                    //@ts-ignore .LAST
                    monitor.last.shift();
                }
                //@ts-ignore .LAST
                monitor.last.push(task);
            }
            return false;
        }
        if (task instanceof Task_1.Task) {
            task.Execute(wl, vs);
            return true;
        }
        // function?
        if (typeof task === 'function') {
            //console.log(task.name);
            task(wl, vs);
            return true;
        }
        // closure?
        if ('func' in task && 'data' in task) {
            //console.log(task.func.name);
            task.func.call(task.data, wl, vs);
            return true;
        }
        // otherwise, syntax
        var node = task;
        // expressions
        if (node.type in Expression_1.expressiontbl) {
            //console.log('expression', node.type);
            Expression_1.expressiontbl[node.type](node, wl, vs);
            return true;
        }
        // statement 
        // for stack trace
        c.codeStack.push(node);
        wl.top().then(PopCodeStack.Instance);
        if (node.type in Statement_1.statementtbl) {
            //   console.log('statement', node.type);
            Statement_1.statementtbl[node.type](node, wl, vs);
            return true;
        }
        monitor.fatal(node.type + ' not implemented');
    }
    catch (e) {
        if (e instanceof Value_1.Value) {
            // Verfiy that the exception is allowed 
            monitor.assert(Label_1.le(c.effectivePC, c.labels.exc), "exception in " + c.effectivePC + " not allowed with exception label " + c.labels.exc);
            // For observable flows
            c.labels.exc = Label_1.lub(c.labels.exc, c.effectivePC);
            result.type = 'throw';
            result.value = e;
            return true;
        }
        throw e;
    }
    return true;
}
var PopCodeStack = /** @class */ (function (_super) {
    __extends(PopCodeStack, _super);
    function PopCodeStack() {
        return _super.call(this, Task_1.Task.runfor_all) || this;
    }
    PopCodeStack.prototype.Execute = function (wl, vs) {
        monitor.context.codeStack.pop();
    };
    PopCodeStack.Instance = new PopCodeStack();
    return PopCodeStack;
}(Task_1.Task));

},{"../Context":80,"../DeclarativeEnvironmentRecord":90,"../Label":123,"../ObjectEnvironmentRecord":130,"../Objects/SyntaxErrorObject":151,"../Result":174,"../Toplevel/crawler/CrawlerUtil":178,"../Value":184,"./Binding":93,"./Expression":96,"./Statement":97,"./Task":98,"esprima":18}],96:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
var Value_1 = require("../Value");
var Reference_1 = require("../Reference");
var ArrayObject_1 = require("../Objects/ArrayObject");
var Label_1 = require("../Label");
var GetValue_1 = require("../GetValue");
var ObjectObject_1 = require("../Objects/ObjectObject");
var PropertyDescriptor_1 = require("../PropertyDescriptor");
var FunctionObject_1 = require("../Objects/FunctionObject");
var DeclarativeEnvironmentRecord_1 = require("../DeclarativeEnvironmentRecord");
var UnaryOperators_1 = require("./UnaryOperators");
var BinaryOperators_1 = require("./BinaryOperators");
var PutValue_1 = require("../PutValue");
var ToBoolean_1 = require("../Conversion/ToBoolean");
var IsCallable_1 = require("../Utility/IsCallable");
var CheckObjectCoercible_1 = require("../Utility/CheckObjectCoercible");
var ToString_1 = require("../Conversion/ToString");
var GetIdentifierReference_1 = require("../GetIdentifierReference");
var RegExpObject_1 = require("../Objects/RegExpObject");
var pp = require("../PP");
var constants = require("../Constants");
var Debug_1 = require("./Debug");
// -------------------------------------------------------------
function _GetValue() {
    var vs = monitor.context.valueStack;
    // @ts-ignore
    var val = vs.pop();
    vs.push(GetValue_1.GetValue(val));
}
// expression handler functions 
exports.expressiontbl = {
    'ThisExpression': thisExpression,
    'ArrayExpression': arrayExpression,
    'ObjectExpression': objectExpression,
    'FunctionExpression': functionExpression,
    'SequenceExpression': sequenceExpression,
    'UnaryExpression': unaryExpression,
    'BinaryExpression': binaryExpression,
    'UpdateExpression': updateExpression,
    'LogicalExpression': logicalExpression,
    'AssignmentExpression': assignmentExpression,
    'ConditionalExpression': conditionalExpression,
    'NewExpression': newExpression,
    'CallExpression': callExpression,
    'MemberExpression': memberExpression,
    'Identifier': identifierExpression,
    'Literal': literalExpression
};
function CheckCanary(wl, vs, canary) {
    var result = vs.pop();
    Debug_1.AssertValidCanary(vs, canary);
    vs.push(result);
}
// This, 11.1.1 -------------------------------------------- 
function thisExpression(node, wl, vs) {
    var c = monitor.context;
    vs.push(c.thisValue.clone());
}
// Array Initializer, 11.1.4 -------------------------------
function arrayExpression(node, wl, vs) {
    var canary;
    if (JSFLOW_STACK_CHECK) {
        canary = Debug_1.PushCanary(vs, "arrayExpression : " + pp.pretty(node));
    }
    var ip = wl.top();
    var arr = new Value_1.Value(new ArrayObject_1.ArrayObject(), Label_1.bot);
    var es = node.elements;
    var len = es.length;
    arr.Put(constants.length, new Value_1.Value(len, Label_1.bot));
    vs.push(arr);
    var _loop_1 = function (i) {
        if (es[i]) {
            ip.then(es[i]);
            ip.then(function (wl, vs) { return arrayExpressionUpdate(arr, i, wl, vs); });
        }
    };
    for (var i = 0; i < len; i++) {
        _loop_1(i);
    }
    if (JSFLOW_STACK_CHECK) {
        ip.then(function (wl, vs) { return CheckCanary(wl, vs, canary); });
    }
}
// ---
function arrayExpressionUpdate(array, index, wl, vs) {
    //@ts-ignore STACK
    var initValue = GetValue_1.GetValue(vs.pop());
    array.Put(new Value_1.Value(index, Label_1.bot), initValue);
}
// Object Initializer, 11.1.5 ------------------------------
function objectExpression(node, wl, vs) {
    var canary;
    if (JSFLOW_STACK_CHECK) {
        canary = Debug_1.PushCanary(vs, "objectExpression : " + pp.pretty(node));
    }
    var ip = wl.top();
    var obj = new Value_1.Value(new ObjectObject_1.ObjectObject(), Label_1.bot);
    vs.push(obj);
    var ps = node.properties;
    var _loop_2 = function (i, len) {
        ip.then(ps[i].value);
        ip.then(function (wl, vs) { return objectExpressionUpdate(ps, obj, i, wl, vs); });
    };
    for (var i = 0, len = ps.length; i < len; i++) {
        _loop_2(i, len);
    }
    if (JSFLOW_STACK_CHECK) {
        ip.then(function (wl, vs) { return CheckCanary(wl, vs, canary); });
    }
}
// ---
function objectExpressionUpdate(properties, object, index, wl, vs) {
    var prop = properties[index];
    var propName;
    switch (prop.key.type) {
        case 'Identifier':
            propName = new Value_1.Value(prop.key.name, Label_1.bot);
            break;
        case 'Literal':
            // can only be string or number; conversion will occur once assigned to the object
            // TODO: fix
            //@ts-ignore SYNTAX
            propName = new Value_1.Value(prop.key.value, Label_1.bot);
            break;
    }
    //@ts-ignore STACK
    var propValue = GetValue_1.GetValue(vs.pop());
    var propDesc = { enumerable: true, configurable: true, label: Label_1.bot };
    switch (prop.kind) {
        case 'init':
            propDesc.value = propValue.value;
            propDesc.label = propValue.label;
            propDesc.writable = true;
            break;
        case 'get':
            // TODO: fix 
            //@ts-ignore DESC HELL
            propDesc.get = propValue.value;
            propDesc.label = propValue.label;
            break;
        case 'set':
            // TODO: fix 
            //@ts-ignore DESC HELL
            propDesc.set = propValue.value;
            propDesc.label = propValue.label;
            break;
    }
    var previous = object.GetOwnProperty(propName);
    monitor.context.pushPC(previous.label);
    if (previous.value !== undefined) {
        if ((PropertyDescriptor_1.IsDataDescriptor(previous) && PropertyDescriptor_1.IsAccessorDescriptor(propDesc)) ||
            (PropertyDescriptor_1.IsAccessorDescriptor(previous) && PropertyDescriptor_1.IsDataDescriptor(propDesc)) ||
            (PropertyDescriptor_1.IsAccessorDescriptor(previous) && PropertyDescriptor_1.IsAccessorDescriptor(propDesc) &&
                //@ts-ignore DESC HELL
                ((previous.get && propDesc.get) || (previous.set && propDesc.set)))) {
            monitor.Throw("SyntaxError", 'Object initializer: illegal redefine of property', Label_1.bot);
        }
    }
    monitor.context.popPC();
    var obj = object;
    //@ts-ignore TYPES
    obj.DefineOwnProperty(propName, propDesc);
}
// Function Definition, 13 ----------------------------------------------
function functionExpression(node, wl, vs) {
    var fun;
    if (node.id) {
        var funcEnv = DeclarativeEnvironmentRecord_1.NewDeclarativeEnvironment(monitor.context.lexicalEnv);
        var identifier = new Value_1.Value(node.id.name, Label_1.bot);
        funcEnv.CreateImmutableBinding(identifier);
        fun = new FunctionObject_1.FunctionObject(node.params, node.body, new Value_1.Value(funcEnv, Label_1.bot));
        fun.Name = node.id.name;
        fun.Source = node;
        funcEnv.InitializeImmutableBinding(identifier, new Value_1.Value(fun, Label_1.bot));
    }
    else {
        fun = new FunctionObject_1.FunctionObject(node.params, node.body, monitor.context.lexicalEnv);
        fun.Source = node;
    }
    vs.push(new Value_1.Value(fun, Label_1.bot));
}
// Comma Operator, 11.14 ------------------------------------------------
function sequenceExpression(node, wl, vs) {
    var canary;
    if (JSFLOW_STACK_CHECK) {
        canary = Debug_1.PushCanary(vs, "sequenceExpression : " + pp.pretty(node));
    }
    var ip = wl.top();
    var es = node.expressions;
    var len = es.length;
    var i = 0;
    for (; i < len - 1; i++) {
        ip.then(es[i]);
    }
    if (i < len) {
        ip.then(es[i]);
        ip.then(function (wl, vs) { return sequenceExpressionEnd(len, wl, vs); });
    }
    if (JSFLOW_STACK_CHECK) {
        ip.then(function (wl, vs) { return CheckCanary(wl, vs, canary); });
    }
}
// ---
function sequenceExpressionEnd(length, wl, vs) {
    var result = vs.pop();
    // Pop all but last and execute GetValue on result for eventual side effects.
    for (var i = 0; i < length - 1; i++) {
        //@ts-ignore STACK
        GetValue_1.GetValue(vs.pop());
    }
    vs.push(result);
}
// Unary Operators, 11.4 ------------------------------------------------
function unaryExpression(node, wl, vs) {
    var canary;
    if (JSFLOW_STACK_CHECK) {
        canary = Debug_1.PushCanary(vs, "unaryExpression : " + pp.pretty(node));
    }
    var ip = wl.top();
    ip.then(node.argument);
    ip.then(UnaryOperators_1.unarytbl[node.operator]);
    if (JSFLOW_STACK_CHECK) {
        ip.then(function (wl, vs) { return CheckCanary(wl, vs, canary); });
    }
}
// Binary Operators, 11.5-11.9 -----------------------------------
function binaryExpression(node, wl, vs) {
    var canary;
    if (JSFLOW_STACK_CHECK) {
        canary = Debug_1.PushCanary(vs, "binaryExpression : " + pp.pretty(node));
    }
    var ip = wl.top();
    ip.then(node.left);
    ip.then(_GetValue);
    ip.then(node.right);
    ip.then(_GetValue);
    ip.then(BinaryOperators_1.binarytbl[node.operator]);
    if (JSFLOW_STACK_CHECK) {
        ip.then(function (wl, vs) { return CheckCanary(wl, vs, canary); });
    }
}
// Prefix, and Postfix Expressions, 11.3, 11.4.4, 11.4.5 -----------------
function updateExpression(node, wl, vs) {
    var canary;
    if (JSFLOW_STACK_CHECK) {
        canary = Debug_1.PushCanary(vs, "updateExpression : " + pp.pretty(node));
    }
    var ip = wl.top();
    ip.then(node.argument);
    if (node.prefix) {
        ip.then(UnaryOperators_1.prefixtbl[node.operator]);
    }
    else {
        ip.then(UnaryOperators_1.postfixtbl[node.operator]);
    }
    if (JSFLOW_STACK_CHECK) {
        ip.then(function (wl, vs) { return CheckCanary(wl, vs, canary); });
    }
}
// Binary Operators, 11.5-11.9 -----------------------------------
function logicalExpression(node, wl, vs) {
    var canary;
    if (JSFLOW_STACK_CHECK) {
        canary = Debug_1.PushCanary(vs, "logicalExpression : " + pp.pretty(node));
    }
    var ip = wl.top();
    ip.then(node.left);
    ip.then(BinaryOperators_1.logicaltbl[node.operator]);
    ip.then(node.right);
    if (JSFLOW_STACK_CHECK) {
        ip.then(function (wl, vs) { return CheckCanary(wl, vs, canary); });
    }
}
// Assignment, 11.13 -----------------------------------------------------
function assignmentExpression(node, wl, vs) {
    var canary;
    if (JSFLOW_STACK_CHECK) {
        canary = Debug_1.PushCanary(vs, "assignmentExpression : " + pp.pretty(node));
    }
    var ip = wl.top();
    ip.then(node.left);
    ip.then(node.right);
    ip.then(BinaryOperators_1.assignmenttbl[node.operator]);
    ip.then(assignmentExpressionEnd);
    if (JSFLOW_STACK_CHECK) {
        ip.then(function (wl, vs) { return CheckCanary(wl, vs, canary); });
    }
}
// ---
function assignmentExpressionEnd(wl, vs) {
    //@ts-ignore
    var rval = vs.pop();
    //@ts-ignore
    var lref = vs.pop();
    PutValue_1.PutValue(lref, rval);
    vs.push(rval);
}
// Conditional Operator, 11.12 ------------------------------------------
function conditionalExpression(node, wl, vs) {
    var canary;
    if (JSFLOW_STACK_CHECK) {
        canary = Debug_1.PushCanary(vs, "conditionalExpression : " + pp.pretty(node));
    }
    var ip = wl.top();
    ip.then(node.test);
    ip.then(function (wl, vs) { return conditionalExpressionChoose(node, wl, vs); });
    if (JSFLOW_STACK_CHECK) {
        ip.then(function (wl, vs) { return CheckCanary(wl, vs, canary); });
    }
}
// ---
function conditionalExpressionChoose(node, wl, vs) {
    var ip = wl.top();
    //@ts-ignore STACK
    var lval = GetValue_1.GetValue(vs.pop());
    var lb = ToBoolean_1.ToBoolean(lval);
    monitor.context.pushPC(lb.label);
    if (lb.value) {
        ip.then(node.consequent);
    }
    else {
        ip.then(node.alternate);
    }
    ip.then(function (wl, vs) { return conditionalExpressionEnd(lval, wl, vs); });
}
// ---
function conditionalExpressionEnd(test, wl, vs) {
    //@ts-ignore STACK
    var val = GetValue_1.GetValue(vs.pop());
    monitor.context.popPC();
    vs.push(new Value_1.Value(val.value, Label_1.lub(val.label, test.label)));
}
// The new Operator, 11.2.2 ---------------------------------------------
function newExpression(node, wl, vs) {
    var canary;
    if (JSFLOW_STACK_CHECK) {
        canary = Debug_1.PushCanary(vs, "newExpression : " + pp.pretty(node));
    }
    var ip = wl.top();
    ip.then(node.callee);
    var as = node.arguments;
    var len = as.length;
    for (var i = 0; i < len; i++) {
        ip.then(as[i]);
    }
    ip.then(function (wl, vs) { return newExpressionExecute(len, wl, vs, pp.pretty(node)); });
    if (JSFLOW_STACK_CHECK) {
        ip.then(function (wl, vs) { return CheckCanary(wl, vs, canary); });
    }
}
// ---
function newExpressionExecute(length, wl, vs, data) {
    var c = monitor.context;
    var ip = wl.top();
    var argList = [];
    for (var i = length - 1; i >= 0; i--) {
        //@ts-ignore STACK
        argList[i] = GetValue_1.GetValue(vs.pop());
    }
    //@ts-ignore STACK
    var constructor = GetValue_1.GetValue(vs.pop());
    if (constructor.value === null || typeof constructor.value !== 'object') {
        if (false) { // SILENT ERROR
            var v = new Value_1.Value(undefined, constructor.label);
            return;
        }
        monitor.Throw("TypeError", "invalid 'new' parameter: not a constructor", constructor.label);
        throw 'TypeScript';
    }
    if (!('Construct' in constructor.value)) {
        if (false) { // SILENT ERROR
            var v = new Value_1.Value(undefined, constructor.label);
            return;
        }
        monitor.Throw("TypeError", "invalid 'new' parameter: not a constructor", constructor.label);
        throw 'TypeScript';
    }
    if (constructor.value.AsyncConstruct) {
        c.pushPC(constructor.label);
        ip = constructor.value.AsyncConstruct(argList);
        ip.then(function (wl, vs) { return callExpressionEnd(constructor.label, wl, vs, data); });
    }
    else {
        try {
            var retval = constructor.Construct(argList);
            retval.raise(constructor.label);
            vs.push(retval);
        }
        catch (e) {
            if (!(e instanceof Value_1.Value)) {
                throw e;
            }
            var result = c.result;
            // Verfiy that the exception is allowed 
            monitor.assert(Label_1.le(c.effectivePC, c.labels.exc), "exception in " + c.effectivePC + " not allowed with exception label " + c.labels.exc);
            // For observable flows
            c.labels.exc = Label_1.lub(c.labels.exc, c.effectivePC);
            result.type = 'throw';
            result.value = e;
        }
    }
}
// Function Calls, 11.2.3 -----------------------------------------------
function callExpression(node, wl, vs) {
    var canary;
    if (JSFLOW_STACK_CHECK) {
        canary = Debug_1.PushCanary(vs, "callExpression : " + pp.pretty(node));
    }
    var ip = wl.top();
    var as = node.arguments;
    var len = as.length;
    ip.then(node.callee);
    for (var i = 0; i < len; i++) {
        ip.then(as[i]);
    }
    ip.then(function (wl, vs) { return callExpressionExecute(len, node, wl, vs, pp.pretty(node)); });
    if (JSFLOW_STACK_CHECK) {
        ip.then(function (wl, vs) { return CheckCanary(wl, vs, canary); });
    }
}
// callExpressionExecute
function callExpressionExecute(length, node, wl, vs, data) {
    var c = monitor.context;
    var ip = wl.top();
    var argList = [];
    for (var i = length - 1; i >= 0; i--) {
        var arg = vs.pop();
        //@ts-ignore STACK
        argList[i] = GetValue_1.GetValue(arg);
    }
    var ref = vs.pop();
    //@ts-ignore STACK
    var func = GetValue_1.GetValue(ref);
    if (!IsCallable_1.IsCallable(func)) {
        if (false) { // SILENT ERRORS
            var v = new Value_1.Value(undefined, func.label);
            return;
        }
        monitor.Throw("TypeError", 'Invalid call target; ' + pp.pretty(node.callee) + ' evaluates to ' + func.value + ' in ' + pp.pretty(node), func.label);
        throw 'TypeScript';
    }
    // used to decide if eval is a direct call in function.enterEvalCode
    //@ts-ignore TYPES
    c.currentCall = { reference: ref, target: func.value, source: node };
    // for eval
    //@ts-ignore TYPES
    c.call = { ref: ref, func: func };
    var thisValue;
    if (ref instanceof Reference_1.Reference) {
        if (ref.IsPropertyReference()) {
            thisValue = ref.base;
        }
        else {
            //@ts-ignore TYPES
            thisValue = ref.base.ImplicitThisValue();
        }
    }
    else {
        //@ts-ignore TYPES
        thisValue = new Value_1.Value(undefined, ref.label);
    }
    if (func.value.AsyncCall) {
        monitor.context.pushPC(func.label);
        func.value.AsyncCall(thisValue, argList);
        ip.then(function (wl, vs) { return callExpressionEnd(func.label, wl, vs, data); });
    }
    else {
        try {
            var retval = func.Call(thisValue, argList);
            retval.raise(func.label);
            vs.push(retval);
        }
        catch (e) {
            if (!(e instanceof Value_1.Value)) {
                throw e;
            }
            var result = c.result;
            // Verfiy that the exception is allowed 
            monitor.assert(Label_1.le(c.effectivePC, c.labels.exc), "exception in " + c.effectivePC + " not allowed with exception label " + c.labels.exc);
            // For observable flows
            c.labels.exc = Label_1.lub(c.labels.exc, c.effectivePC);
            result.type = 'throw';
            result.value = e;
        }
    }
}
// callExpressionEnd 
function callExpressionEnd(label, wl, vs, data) {
    // @ts-ignore
    var callResult = vs.pop();
    var c = monitor.context;
    var result = c.result;
    if (callResult === undefined || callResult.value === undefined) {
        monitor.error(data);
        monitor.error(callResult);
    }
    callResult.value.raise(label);
    if (callResult.type === 'throw') {
        result.type = 'throw';
        result.value = callResult.value;
        return;
    }
    c.popPC();
    vs.push(callResult.value);
}
// Property Accessors, 11.2.1 -------------------------------------------
function memberExpression(node, wl, vs) {
    var canary;
    if (JSFLOW_STACK_CHECK) {
        canary = Debug_1.PushCanary(vs, "memberExpression : " + pp.pretty(node));
    }
    var ip = wl.top();
    ip.then(node.object);
    ip.then(_GetValue);
    if (node.computed) {
        ip.then(node.property);
        ip.then(_GetValue);
    }
    ip.then(function (wl, vs) { return memberExpressionExecute(node, wl, vs); });
    if (JSFLOW_STACK_CHECK) {
        ip.then(function (wl, vs) { return CheckCanary(wl, vs, canary); });
    }
}
// ---
function memberExpressionExecute(node, wl, vs) {
    var propertyNameValue;
    if (node.computed) {
        propertyNameValue = vs.pop();
    }
    else {
        //@ts-ignore TYPES
        propertyNameValue = new Value_1.Value(node.property.name, Label_1.bot);
    }
    // @ts-ignore
    var baseValue = vs.pop();
    /*
    if (baseValue.value === undefined || baseValue.value === null) {
      monitor.warn(pp.pretty(node.object) + ' evaluates to ' + String(baseValue.value) + ' in ' + pp.pretty(node), node);
    }
    */
    CheckObjectCoercible_1.CheckObjectCoercible(baseValue);
    //@ts-ignore TYPES
    vs.push(new Reference_1.Reference(baseValue, ToString_1.ToString(propertyNameValue)));
}
// Identifier, 11.1.2 -> 10.3.1 -----------------------------------------
function identifierExpression(node, wl, vs) {
    vs.push(GetIdentifierReference_1.GetIdentifierReference(monitor.context.lexicalEnv, node.name));
}
// Literals, 11.1.3 -> 7.8 ----------------------------------------------
function literalExpression(node, wl, vs) {
    // @ts-ignore
    var res = new Value_1.Value(node.value, Label_1.bot);
    if (node.value instanceof RegExp) {
        res.value = new RegExpObject_1.RegExpObject(node.value, Label_1.bot);
    }
    vs.push(res);
}

},{"../Constants":64,"../Conversion/ToBoolean":81,"../Conversion/ToString":87,"../DeclarativeEnvironmentRecord":90,"../GetIdentifierReference":118,"../GetValue":119,"../Label":123,"../Objects/ArrayObject":132,"../Objects/FunctionObject":140,"../Objects/ObjectObject":146,"../Objects/RegExpObject":149,"../PP":155,"../PropertyDescriptor":156,"../PutValue":172,"../Reference":173,"../Utility/CheckObjectCoercible":181,"../Utility/IsCallable":182,"../Value":184,"./BinaryOperators":92,"./Debug":94,"./UnaryOperators":116}],97:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
var SwitchStatement_1 = require("./Tracing/SwitchStatement");
var BlockStatement_1 = require("./Tracing/BlockStatement");
var EmptyStatement_1 = require("./Tracing/EmptyStatement");
var ExpressionStatement_1 = require("./Tracing/ExpressionStatement");
var IfStatement_1 = require("./Tracing/IfStatement");
var LabeledStatement_1 = require("./Tracing/LabeledStatement");
var BreakStatement_1 = require("./Tracing/BreakStatement");
var ContinueStatement_1 = require("./Tracing/ContinueStatement");
var WithStatement_1 = require("./Tracing/WithStatement");
var ReturnStatement_1 = require("./Tracing/ReturnStatement");
var ThrowStatement_1 = require("./Tracing/ThrowStatement");
var WhileStatement_1 = require("./Tracing/WhileStatement");
var ForStatement_1 = require("./Tracing/ForStatement");
var ForInStatement_1 = require("./Tracing/ForInStatement");
var VariableDeclaration_1 = require("./Tracing/VariableDeclaration");
var DebuggerStatement_1 = require("./Tracing/DebuggerStatement");
var TryCatchStatement_1 = require("./Tracing/TryCatchStatement");
// ------------------------------------------------------------
function ExecuteStatement(statement, wl, vs) {
    switch (statement.type) {
        case "BlockStatement":
            BlockStatement_1.blockStatement(statement, wl, vs);
            break;
        case "BreakStatement":
            BreakStatement_1.breakStatement(statement, wl, vs);
            break;
        case "ClassDeclaration": throw "TODO";
        case "ContinueStatement":
            ContinueStatement_1.continueStatement(statement, wl, vs);
            break;
        case "DebuggerStatement":
            DebuggerStatement_1.debuggerStatement(statement, wl, vs);
            break;
        case "DoWhileStatement":
            WhileStatement_1.doWhileStatement(statement, wl, vs);
            break;
        case "EmptyStatement":
            EmptyStatement_1.emptyStatement(statement, wl, vs);
            break;
        case 'ExpressionStatement':
            ExpressionStatement_1.expressionStatement(statement, wl, vs);
            break;
        case "ForInStatement":
            ForInStatement_1.forInStatement(statement, wl, vs);
            break;
        case "ForOfStatement": throw "TODO";
        case "ForStatement":
            ForStatement_1.forStatement(statement, wl, vs);
            break;
        case "FunctionDeclaration":
            // handled via function hoisting
            break;
        case "IfStatement":
            IfStatement_1.ifStatement(statement, wl, vs);
            break;
        case "LabeledStatement":
            LabeledStatement_1.labeledStatement(statement, wl, vs);
            break;
        case "ReturnStatement":
            ReturnStatement_1.returnStatement(statement, wl, vs);
            break;
        case "SwitchStatement":
            SwitchStatement_1.switchStatement(statement, wl, vs);
            break;
        case "ThrowStatement":
            ThrowStatement_1.throwStatement(statement, wl, vs);
            break;
        case "TryStatement":
            TryCatchStatement_1.tryStatement(statement, wl, vs);
            break;
        case "VariableDeclaration":
            VariableDeclaration_1.variableDeclaration(statement, wl, vs);
            break;
        case "WhileStatement":
            WhileStatement_1.whileStatement(statement, wl, vs);
            break;
        case "WithStatement":
            WithStatement_1.withStatement(statement, wl, vs);
            break;
    }
    monitor.fatal(statement.type + ' not implemented');
}
exports.ExecuteStatement = ExecuteStatement;
// statement handler functions
exports.statementtbl = {
    'Program': BlockStatement_1.blockStatement,
    'BlockStatement': BlockStatement_1.blockStatement,
    'EmptyStatement': EmptyStatement_1.emptyStatement,
    'ExpressionStatement': ExpressionStatement_1.expressionStatement,
    'IfStatement': IfStatement_1.ifStatement,
    'SwitchStatement': SwitchStatement_1.switchStatement,
    'LabeledStatement': LabeledStatement_1.labeledStatement,
    'BreakStatement': BreakStatement_1.breakStatement,
    'ContinueStatement': ContinueStatement_1.continueStatement,
    'WithStatement': WithStatement_1.withStatement,
    'ReturnStatement': ReturnStatement_1.returnStatement,
    'ThrowStatement': ThrowStatement_1.throwStatement,
    'TryStatement': TryCatchStatement_1.tryStatement,
    'WhileStatement': WhileStatement_1.whileStatement,
    'DoWhileStatement': WhileStatement_1.doWhileStatement,
    'ForStatement': ForStatement_1.forStatement,
    'ForInStatement': ForInStatement_1.forInStatement,
    'VariableDeclaration': VariableDeclaration_1.variableDeclaration,
    'FunctionDeclaration': EmptyStatement_1.emptyStatement,
    'DebuggerStatement': DebuggerStatement_1.debuggerStatement
};
var emptyLabel = 'default'; // default is a reserved word so no actual label can be named default 

},{"./Tracing/BlockStatement":99,"./Tracing/BreakStatement":100,"./Tracing/ContinueStatement":101,"./Tracing/DebuggerStatement":102,"./Tracing/EmptyStatement":103,"./Tracing/ExpressionStatement":104,"./Tracing/ForInStatement":105,"./Tracing/ForStatement":106,"./Tracing/IfStatement":107,"./Tracing/LabeledStatement":108,"./Tracing/ReturnStatement":109,"./Tracing/SwitchStatement":110,"./Tracing/ThrowStatement":111,"./Tracing/TryCatchStatement":112,"./Tracing/VariableDeclaration":113,"./Tracing/WhileStatement":114,"./Tracing/WithStatement":115}],98:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
var Debug_1 = require("./Debug");
var Task = /** @class */ (function () {
    function Task(runfor) {
        this.runfor = runfor || {};
    }
    Task.prototype.RunFor = function (x) {
        return x in this.runfor;
    };
    Task.runfor_all = { 'throw': true, 'continue': true, 'break': true, 'return': true };
    Task.runfor_throw = { 'throw': true };
    Task.runfor_continue = { 'continue': true };
    Task.runfor_break = { 'break': true };
    Task.runfor_continue_break = { 'break': true, 'continue': true };
    return Task;
}());
exports.Task = Task;
// ---
function CheckCanary(wl, vs, canary) {
    Debug_1.AssertValidCanary(vs, canary);
}

},{"./Debug":94}],99:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
function blockStatement(node, wl, vs) {
    wl.prepend(node.body);
}
exports.blockStatement = blockStatement;

},{}],100:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
var Label_1 = require("../../Label");
var emptyLabel = 'default'; // default is a reserved word so no actual label can be named default 
// 12.8 ----------------------------------------------------------------------
function breakStatement(node, wl, vs) {
    var c = monitor.context;
    var result = monitor.context.result;
    var name = node.label ? node.label.name : emptyLabel;
    var lblcontext = c.labels.labelmap[name].label;
    var displayName = node.label ? '(' + name + ')' : '';
    monitor.assert(Label_1.le(c.effectivePC, lblcontext), 'write context ' + c.effectivePC + ' not below ' +
        'label context ' + lblcontext + ' ' + displayName);
    // For observable flows
    c.labels.labelmap[name].label = Label_1.lub(lblcontext, c.effectivePC);
    result.type = 'break';
    result.target = name;
}
exports.breakStatement = breakStatement;

},{"../../Label":123}],101:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
var Label_1 = require("../../Label");
var emptyLabel = 'default'; // default is a reserved word so no actual label can be named default 
// 12.7 ----------------------------------------------------------------------
function continueStatement(node, wl, vs) {
    var c = monitor.context;
    var result = monitor.context.result;
    var name = node.label ? node.label.name : emptyLabel;
    var lblcontext = c.labels.labelmap[name].label;
    var displayName = node.label ? '(' + name + ')' : '';
    monitor.assert(Label_1.le(c.effectivePC, lblcontext), 'write context ' + c.effectivePC + ' not below ' +
        'label context ' + lblcontext + displayName);
    // For observable flows
    c.labels.labelmap[name].label = Label_1.lub(lblcontext, c.effectivePC);
    result.type = 'continue';
    result.target = name;
}
exports.continueStatement = continueStatement;

},{"../../Label":123}],102:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
// ------------------------------------------------------------
function debuggerStatement(node, wl, vs) {
    monitor.debug.active = true;
}
exports.debuggerStatement = debuggerStatement;

},{}],103:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
function emptyStatement(node, wl, vs) {
}
exports.emptyStatement = emptyStatement;

},{}],104:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var GetValue_1 = require("../../GetValue");
var Task_1 = require("../Task");
function expressionStatement(node, wl, vs) {
    var ip = wl.top();
    ip.then(node.expression);
    ip.then(ExpressionStatementEnd.Instance);
}
exports.expressionStatement = expressionStatement;
var ExpressionStatementEnd = /** @class */ (function (_super) {
    __extends(ExpressionStatementEnd, _super);
    function ExpressionStatementEnd() {
        return _super.call(this) || this;
    }
    ExpressionStatementEnd.prototype.Execute = function (wl, vs) {
        var c = monitor.context;
        // @ts-ignore
        var val = vs.pop();
        c.result.value = GetValue_1.GetValue(val);
    };
    ExpressionStatementEnd.Instance = new ExpressionStatementEnd();
    return ExpressionStatementEnd;
}(Task_1.Task));

},{"../../GetValue":119,"../Task":98}],105:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Task_1 = require("../Task");
var GetValue_1 = require("../../GetValue");
var ToObject_1 = require("../../Conversion/ToObject");
var PutValue_1 = require("../../PutValue");
var emptyLabel = 'default'; // default is a reserved word so no actual label can be named default 
var MySet = Set;
// ------------------------------------------------------------
function forInStatement(node, wl, vs) {
    var ip = wl.top();
    var left;
    if (node.left.type === 'VariableDeclaration') {
        ip.then(node.left);
        // the standard only allows for one declaration, get the name
        left = node.left.declarations[0].id;
    }
    else {
        left = node.left;
    }
    ip.then(node.right);
    ip.then(new ForInStatementSetup(node, left));
}
exports.forInStatement = forInStatement;
// ---
var ForInStatementSetup = /** @class */ (function (_super) {
    __extends(ForInStatementSetup, _super);
    function ForInStatementSetup(node, left) {
        var _this = _super.call(this) || this;
        _this.node = node;
        _this.left = left;
        return _this;
    }
    ForInStatementSetup.prototype.Execute = function (wl, vs) {
        var c = monitor.context;
        var ip = wl.top();
        var lmap = c.labels.labelmap;
        var node = this.node;
        if (!node.labelset) {
            node.labelset = new MySet();
        }
        node.labelset.add(emptyLabel);
        var outerEmptyLabelData = lmap[emptyLabel];
        lmap[emptyLabel] = {
            label: c.effectivePC,
            pcmarker: c.pcStack.marker()
        };
        var contextLabel = lmap[emptyLabel].label;
        c.pushPC(contextLabel);
        //@ts-ignore STACK
        var val = GetValue_1.GetValue(vs.pop());
        if (val.value === null || val.value === undefined) {
            return;
        }
        var obj = ToObject_1.ToObject(val);
        var maxProperty = obj.value.getEnumerablePropertyNames(obj.label).length;
        // monitor.context.pushPC(obj.label);
        ip.then(new ForInExecute(node, this.left, obj, maxProperty, outerEmptyLabelData));
    };
    return ForInStatementSetup;
}(Task_1.Task));
// ---
var ForInExecute = /** @class */ (function (_super) {
    __extends(ForInExecute, _super);
    function ForInExecute(node, left, obj, maxProperty, outerEmptyLabelData) {
        var _this = _super.call(this, Task_1.Task.runfor_continue_break) || this;
        _this.node = node;
        _this.left = left;
        _this.obj = obj;
        _this.maxProperty = maxProperty;
        _this.outerEmptyLabelData = outerEmptyLabelData;
        _this.nextProperty = 0;
        _this.update = new ForInUpdate(node, _this);
        return _this;
    }
    ForInExecute.prototype.Execute = function (wl, vs) {
        var ip = wl.top();
        var c = monitor.context;
        var result = c.result;
        if (result.type === 'break' && this.node.labelset.has(result.target)) {
            result.type = 'normal';
            result.target = null;
            c.labels.labelmap[emptyLabel] = this.outerEmptyLabelData;
            c.popPC(); // contextLabel
            return;
        }
        if (result.type !== 'continue' || !this.node.labelset.has(result.target)) {
            if (result.type !== 'normal') {
                return;
            }
        }
        // continue gets us here
        result.type = 'normal';
        result.target = null;
        var properties = this.obj.value.getEnumerablePropertyNames(this.obj.label);
        if (this.nextProperty >= properties.length || this.nextProperty >= this.maxProperty) {
            c.labels.labelmap[emptyLabel] = this.outerEmptyLabelData;
            c.popPC(); // contextLabel
            return;
        }
        var propName = properties[this.nextProperty];
        this.nextProperty++;
        vs.push(propName);
        ip.then(this.left);
        ip.then(this.update);
    };
    return ForInExecute;
}(Task_1.Task));
// ---
var ForInUpdate = /** @class */ (function (_super) {
    __extends(ForInUpdate, _super);
    function ForInUpdate(node, execute) {
        var _this = _super.call(this) || this;
        _this.node = node;
        _this.execute = execute;
        return _this;
    }
    ForInUpdate.prototype.Execute = function (wl, vs) {
        var ip = wl.top();
        // @ts-ignore
        var lhs = vs.pop();
        // @ts-ignore
        var propName = vs.pop();
        PutValue_1.PutValue(lhs, propName);
        monitor.context.pushPC(propName.label);
        ip.then(this.node.body);
        ip.then(ForInSecurityContextEnd.Instance);
        ip.then(this.execute);
    };
    return ForInUpdate;
}(Task_1.Task));
// ---
var ForInSecurityContextEnd = /** @class */ (function (_super) {
    __extends(ForInSecurityContextEnd, _super);
    function ForInSecurityContextEnd() {
        return _super.call(this) || this;
    }
    ForInSecurityContextEnd.prototype.Execute = function (wl, vs) {
        monitor.context.popPC();
    };
    ForInSecurityContextEnd.Instance = new ForInSecurityContextEnd();
    return ForInSecurityContextEnd;
}(Task_1.Task));

},{"../../Conversion/ToObject":85,"../../GetValue":119,"../../PutValue":172,"../Task":98}],106:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Task_1 = require("../Task");
var Label_1 = require("../../Label");
var GetValue_1 = require("../../GetValue");
var ToBoolean_1 = require("../../Conversion/ToBoolean");
var emptyLabel = 'default'; // default is a reserved word so no actual label can be named default 
var ResetValueStack = /** @class */ (function (_super) {
    __extends(ResetValueStack, _super);
    function ResetValueStack(targetSize) {
        return _super.call(this) || this;
    }
    ResetValueStack.prototype.Execute = function (wl, vs) {
        while (vs.size() > this.targetSize) {
            vs.pop();
        }
    };
    return ResetValueStack;
}(Task_1.Task));
var MySet = Set;
// ------------------------------------------------------------
function forStatement(node, wl, vs) {
    var c = monitor.context;
    var ip = wl.top();
    var lmap = c.labels.labelmap;
    if (node.init) {
        ip.then(node.init);
        ip.then(new ResetValueStack(vs.size()));
    }
    if (!node.labelset) {
        node.labelset = new MySet([]);
    }
    node.labelset.add(emptyLabel);
    var outerEmptyLabelData = lmap[emptyLabel];
    lmap[emptyLabel] = {
        label: c.effectivePC,
        pcmarker: c.pcStack.marker()
    };
    var contextLabel = lmap[emptyLabel].label;
    c.pushPC(contextLabel);
    ip.then(new ForStatementMain(node));
    ip.then(new ForStatementEnd(outerEmptyLabelData));
}
exports.forStatement = forStatement;
// ---
var ForStatementMain = /** @class */ (function (_super) {
    __extends(ForStatementMain, _super);
    function ForStatementMain(node) {
        var _this = _super.call(this, Task_1.Task.runfor_continue_break) || this;
        _this.node = node;
        _this.execute = new ForStatementExecute(node, _this);
        _this.choose = new ForStatementChoose(node, _this);
        _this.update = new ForStatementUpdate(node);
        return _this;
    }
    ForStatementMain.prototype.Execute = function (wl, vs) {
        var c = monitor.context;
        var ip = wl.top();
        var result = c.result;
        if (result.type === 'break' && this.node.labelset.has(result.target)) {
            result.type = 'normal';
            result.target = null;
            return;
        }
        if (result.type !== 'continue' || !this.node.labelset.has(result.target)) {
            if (result.type !== 'normal') {
                return;
            }
        }
        result.type = 'normal';
        result.target = null;
        if (this.node.test) {
            ip.then(this.node.test);
            ip.then(this.choose);
        }
        else {
            ip.then(this.execute);
        }
    };
    return ForStatementMain;
}(Task_1.Task));
// ---
var ForStatementChoose = /** @class */ (function (_super) {
    __extends(ForStatementChoose, _super);
    function ForStatementChoose(node, main) {
        var _this = _super.call(this, Task_1.Task.runfor_continue) || this;
        _this.node = node;
        _this.main = main;
        return _this;
    }
    ForStatementChoose.prototype.Execute = function (wl, vs) {
        var ip = wl.top();
        var c = monitor.context;
        var result = c.result;
        //@ts-ignore STACK
        var cond = GetValue_1.GetValue(vs.pop());
        var condb = ToBoolean_1.ToBoolean(cond);
        c.labels.pc = Label_1.lub(c.labels.pc, condb.label);
        if (!condb.value) {
            result.type = 'normal';
            result.target = null;
            return;
        }
        ip.then(this.main.execute);
    };
    return ForStatementChoose;
}(Task_1.Task));
var ForStatementExecute = /** @class */ (function (_super) {
    __extends(ForStatementExecute, _super);
    function ForStatementExecute(node, main) {
        var _this = _super.call(this) || this;
        _this.node = node;
        _this.main = main;
        return _this;
    }
    ForStatementExecute.prototype.Execute = function (wl, vs) {
        var ip = wl.top();
        ip.then(this.node.body);
        ip.then(this.main.update);
        ip.then(this.main);
    };
    return ForStatementExecute;
}(Task_1.Task));
var ForStatementUpdate = /** @class */ (function (_super) {
    __extends(ForStatementUpdate, _super);
    function ForStatementUpdate(node) {
        var _this = _super.call(this, Task_1.Task.runfor_continue) || this;
        _this.node = node;
        return _this;
    }
    ForStatementUpdate.prototype.Execute = function (wl, vs) {
        var ip = wl.top();
        var c = monitor.context;
        var result = c.result;
        if (result.type !== 'continue' || !this.node.labelset.has(result.target)) {
            if (result.type !== 'normal') {
                return;
            }
        }
        result.type = 'normal';
        result.target = null;
        if (this.node.update) {
            ip.then(this.node.update);
            ip.then(new ResetValueStack(vs.size()));
        }
    };
    return ForStatementUpdate;
}(Task_1.Task));
// forStatementeEnd
var ForStatementEnd = /** @class */ (function (_super) {
    __extends(ForStatementEnd, _super);
    function ForStatementEnd(outerEmptyLabelData) {
        var _this = _super.call(this) || this;
        _this.outerEmptyLabelData = outerEmptyLabelData;
        return _this;
    }
    ForStatementEnd.prototype.Execute = function (wl, vs) {
        var c = monitor.context;
        c.labels.labelmap[emptyLabel] = this.outerEmptyLabelData;
        c.popPC();
    };
    return ForStatementEnd;
}(Task_1.Task));

},{"../../Conversion/ToBoolean":81,"../../GetValue":119,"../../Label":123,"../Task":98}],107:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Task_1 = require("../Task");
var GetValue_1 = require("../../GetValue");
var ToBoolean_1 = require("../../Conversion/ToBoolean");
// ------------------------------------------------------------
function ifStatement(node, wl, vs) {
    var ip = wl.top();
    ip.then(node.test);
    ip.then(new IfStatementChoose(node));
}
exports.ifStatement = ifStatement;
// ---
var IfStatementChoose = /** @class */ (function (_super) {
    __extends(IfStatementChoose, _super);
    function IfStatementChoose(node) {
        var _this = _super.call(this) || this;
        _this.node = node;
        return _this;
    }
    IfStatementChoose.prototype.Execute = function (wl, vs) {
        var ip = wl.top();
        //@ts-ignore STACK
        var cond = GetValue_1.GetValue(vs.pop());
        cond = ToBoolean_1.ToBoolean(cond);
        monitor.context.pushPC(cond.label);
        if (cond.value) {
            ip.then(this.node.consequent);
        }
        else {
            this.node.alternate && ip.then(this.node.alternate);
        }
        ip.then(new IfStatementEnd(cond.label));
    };
    return IfStatementChoose;
}(Task_1.Task));
// ---
var IfStatementEnd = /** @class */ (function (_super) {
    __extends(IfStatementEnd, _super);
    function IfStatementEnd(label) {
        var _this = _super.call(this, Task_1.Task.runfor_continue_break) || this;
        _this.label = label;
        return _this;
    }
    IfStatementEnd.prototype.Execute = function (wl, vs) {
        var c = monitor.context;
        c.popPC();
        if (c.result.value) {
            c.result.value.raise(this.label);
        }
    };
    return IfStatementEnd;
}(Task_1.Task));

},{"../../Conversion/ToBoolean":81,"../../GetValue":119,"../Task":98}],108:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Task_1 = require("../Task");
var Label_1 = require("../../Label");
var MySet = Set;
// 12.12 ---------------------------------------------------------------------
function labeledStatement(node, wl, vs) {
    var ip = wl.top();
    var c = monitor.context;
    var pcmarker = c.pcStack.marker();
    var vsmarker = c.valueStack.marker();
    //@ts-ignore LABELSET
    if (!node.body.labelset) {
        //@ts-ignore LABELSET
        node.body.labelset = new MySet([node.label.name]);
        //@ts-ignore LABELSET
        if (node.labelset) {
            //@ts-ignore LABELSET
            node.body.labelset.union(node.labelset);
        }
    }
    var name = node.label.name;
    var outerlabel = setupStatementLabel(name);
    var labeldata = c.labels.labelmap[name];
    labeldata.pcmarker = c.pcStack.marker();
    c.pushPC(labeldata.label);
    ip.then(node.body);
    ip.then(new LabeledStatementEnd(name, labeldata.label, pcmarker, vsmarker));
}
exports.labeledStatement = labeledStatement;
// labeledStatementEnd
var LabeledStatementEnd = /** @class */ (function (_super) {
    __extends(LabeledStatementEnd, _super);
    function LabeledStatementEnd(name, outerlabel, pcmarker, vsmarker) {
        var _this = _super.call(this, Task_1.Task.runfor_continue_break) || this;
        _this.name = name;
        _this.outerlabel = outerlabel;
        _this.pcmarker = pcmarker;
        _this.vsmarker = vsmarker;
        return _this;
    }
    LabeledStatementEnd.prototype.Execute = function (wl, vs) {
        var c = monitor.context;
        var result = c.result;
        // reset the outer label - no need to reset pcmarker since
        // statement labels with the same name cannot be nested
        c.labels.labelmap[this.name].label = this.outerlabel;
        c.pcStack.reset(this.pcmarker);
        c.valueStack.reset(this.vsmarker);
        if (result.type === 'break' && result.target === this.name) {
            result = c.result;
            result.type = 'normal';
            result.target = null;
        }
    };
    return LabeledStatementEnd;
}(Task_1.Task));
function setupStatementLabel(name) {
    var c = monitor.context;
    var lmap = c.labels.labelmap;
    if (!lmap[name]) {
        lmap[name] = { label: Label_1.bot, pcmarker: undefined };
    }
    var labeldata = lmap[name];
    var outerlabel = labeldata.label;
    // raise to effective pc
    labeldata.label = Label_1.lub(labeldata.label, c.effectivePC);
    return outerlabel;
}

},{"../../Label":123,"../Task":98}],109:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Task_1 = require("../Task");
var GetValue_1 = require("../../GetValue");
var Value_1 = require("../../Value");
var Label_1 = require("../../Label");
//---------------------------------------------------------------------------- 
function returnStatement(node, wl, vs) {
    var c = monitor.context;
    var ip = wl.top();
    monitor.assert(Label_1.le(c.effectivePC, c.labels.ret), 'write context ' + c.effectivePC + ' not below ' +
        'return context ' + c.labels.ret);
    // This is for the new mode of operation, for observable flows
    c.labels.ret = Label_1.lub(c.labels.ret, c.effectivePC);
    if (node.argument) {
        ip.then(node.argument);
    }
    else {
        c.valueStack.push(new Value_1.Value(undefined, Label_1.bot));
    }
    ip.then(ReturnStatementEnd.Instance);
}
exports.returnStatement = returnStatement;
// returnStatementEnd
var ReturnStatementEnd = /** @class */ (function (_super) {
    __extends(ReturnStatementEnd, _super);
    function ReturnStatementEnd() {
        return _super.call(this) || this;
    }
    ReturnStatementEnd.prototype.Execute = function (wl, vs) {
        var result = monitor.context.result;
        result.type = 'return';
        //@ts-ignore STACK
        result.value = GetValue_1.GetValue(vs.pop());
        result.target = null;
    };
    ReturnStatementEnd.Instance = new ReturnStatementEnd();
    return ReturnStatementEnd;
}(Task_1.Task));

},{"../../GetValue":119,"../../Label":123,"../../Value":184,"../Task":98}],110:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Task_1 = require("../Task");
var Label_1 = require("../../Label");
var BinaryOperators_1 = require("../BinaryOperators");
var GetValue_1 = require("../../GetValue");
function _GetValue() {
    var vs = monitor.context.valueStack;
    // @ts-ignore
    var val = vs.pop();
    vs.push(GetValue_1.GetValue(val));
}
var emptyLabel = 'default'; // default is a reserved word so no actual label can be named default 
var MySet = Set;
function switchStatement(node, wl, vs) {
    var c = monitor.context;
    var lmap = monitor.context.labels.labelmap;
    if (!node.labelset) {
        node.labelset = new MySet([]);
    }
    node.labelset.add(emptyLabel);
    var outerEmptyLabelData = lmap[emptyLabel];
    lmap[emptyLabel] = {
        label: c.effectivePC,
        pcmarker: c.pcStack.marker()
    };
    var contextLabel = lmap[emptyLabel].label;
    c.pushPC(contextLabel);
    var switchState = {
        defaultCaseIndex: null,
        nextCase: 0
    };
    if (node.cases) {
        for (var i = 0; i < node.cases.length; i++) {
            if (node.cases[i].test === null) {
                switchState.defaultCaseIndex = i;
                break;
            }
        }
    }
    var ip = wl.top();
    // Store the discriminant value on the value stack.
    // It is later popped by switchStatementEnd.
    ip.then(node.discriminant);
    ip.then(_GetValue);
    // Set up statement labels
    ip.then(new SwitchStatementUpgradeLabels(node));
    // Kick off the first case
    ip.then(new SwitchStatementCase(node, switchState));
    // Clean up and handle breaks
    ip.then(new SwitchStatementEnd(node, outerEmptyLabelData));
}
exports.switchStatement = switchStatement;
// ---
var SwitchStatementUpgradeLabels = /** @class */ (function (_super) {
    __extends(SwitchStatementUpgradeLabels, _super);
    function SwitchStatementUpgradeLabels(node) {
        var _this = _super.call(this) || this;
        _this.node = node;
        return _this;
    }
    SwitchStatementUpgradeLabels.prototype.Execute = function (wl, vs) {
        var c = monitor.context;
        //@ts-ignore STACK
        var discriminantLabel = vs.peek().label;
        var lblmap = c.labels.labelmap;
        c.labels.pc = Label_1.lub(c.labels.pc, discriminantLabel);
        for (var name in this.node.labelset) {
            lblmap[name].label = Label_1.lub(lblmap[name].label, discriminantLabel);
        }
    };
    return SwitchStatementUpgradeLabels;
}(Task_1.Task));
// ---
var SwitchStatementCase = /** @class */ (function (_super) {
    __extends(SwitchStatementCase, _super);
    function SwitchStatementCase(node, switchState) {
        var _this = _super.call(this) || this;
        _this.node = node;
        _this.switchState = switchState;
        return _this;
    }
    SwitchStatementCase.prototype.Execute = function (wl, vs) {
        var ip = wl.top();
        var idx = this.switchState.nextCase;
        if (this.node.cases === undefined || idx >= this.node.cases.length) {
            // No more cases to try, schedule the default 
            // case if there is one
            if (this.switchState.defaultCaseIndex !== null) {
                for (var i = this.switchState.defaultCaseIndex; i < this.node.cases.length; i++) {
                    for (var j = 0; j < this.node.cases[i].consequent.length; j++) {
                        ip.then(this.node.cases[i].consequent[j]);
                    }
                }
            }
            return;
        }
        if (idx === this.switchState.defaultCaseIndex) {
            // Skip the default case during matching
            this.switchState.nextCase += 1;
            ip.then(new SwitchStatementCase(this.node, this.switchState));
            return;
        }
        vs.dup(); // Duplicate the discriminant value
        // Push the test value
        ip.then(this.node.cases[idx].test);
        ip.then(_GetValue);
        // Test for equality and decide what to do next
        ip.then(new SwitchStatementTest(this.node, this.switchState));
    };
    return SwitchStatementCase;
}(Task_1.Task));
// ---
var SwitchStatementTest = /** @class */ (function (_super) {
    __extends(SwitchStatementTest, _super);
    function SwitchStatementTest(node, switchState) {
        var _this = _super.call(this) || this;
        _this.node = node;
        _this.switchState = switchState;
        return _this;
    }
    SwitchStatementTest.prototype.Execute = function (wl, vs) {
        var ip = wl.top();
        BinaryOperators_1.binaryStrictEqs('===', wl, vs);
        // @ts-ignore
        var bresult = vs.pop();
        monitor.context.labels.pc = Label_1.lub(monitor.context.labels.pc, bresult.label);
        if (bresult.value) {
            // Found a match, schedule all statements from here down
            for (var i = this.switchState.nextCase; i < this.node.cases.length; i++) {
                for (var j = 0; j < this.node.cases[i].consequent.length; j++) {
                    ip.then(this.node.cases[i].consequent[j]);
                }
            }
        }
        else {
            this.switchState.nextCase += 1;
            ip.then(new SwitchStatementCase(this.node, this.switchState));
        }
    };
    return SwitchStatementTest;
}(Task_1.Task));
// ---
var SwitchStatementEnd = /** @class */ (function (_super) {
    __extends(SwitchStatementEnd, _super);
    function SwitchStatementEnd(node, outerEmptyLabelData) {
        var _this = _super.call(this, Task_1.Task.runfor_break) || this;
        _this.node = node;
        _this.outerEmptyLabelData = outerEmptyLabelData;
        return _this;
    }
    SwitchStatementEnd.prototype.Execute = function (wl, vs) {
        var c = monitor.context;
        vs.pop(); // pop the discriminant value
        c.popPC(); // pop the labelContext
        if (c.result.type === 'break' && this.node.labelset.has(c.result.target)) {
            c.result.type = 'normal';
            c.result.target = null;
            c.labels.labelmap['empty'] = this.outerEmptyLabelData;
        }
    };
    return SwitchStatementEnd;
}(Task_1.Task));

},{"../../GetValue":119,"../../Label":123,"../BinaryOperators":92,"../Task":98}],111:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Task_1 = require("../Task");
var GetValue_1 = require("../../GetValue");
var Label_1 = require("../../Label");
//---------------------------------------------------------------------------- 
function throwStatement(node, wl, vs) {
    var ip = wl.top();
    ip.then(node.argument);
    ip.then(ThrowStatementEnd.Instance);
}
exports.throwStatement = throwStatement;
// ---
var ThrowStatementEnd = /** @class */ (function (_super) {
    __extends(ThrowStatementEnd, _super);
    function ThrowStatementEnd() {
        return _super.call(this) || this;
    }
    ThrowStatementEnd.prototype.Execute = function (wl, vs) {
        var c = monitor.context;
        var result = c.result;
        //@ts-ignore
        var exprRef = vs.pop();
        // Verfiy that the exception is allowed 
        monitor.assert(Label_1.le(c.effectivePC, c.labels.exc), "exception in " + c.effectivePC + " not allowed with exception label " + c.labels.exc);
        // For observable flows
        c.labels.exc = Label_1.lub(c.labels.exc, c.effectivePC);
        result.type = 'throw';
        result.value = GetValue_1.GetValue(exprRef);
        monitor.offendingTrace = monitor.stackTrace();
    };
    ThrowStatementEnd.Instance = new ThrowStatementEnd();
    return ThrowStatementEnd;
}(Task_1.Task));

},{"../../GetValue":119,"../../Label":123,"../Task":98}],112:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Task_1 = require("../Task");
var Label_1 = require("../../Label");
var Value_1 = require("../../Value");
var DeclarativeEnvironmentRecord_1 = require("../../DeclarativeEnvironmentRecord");
var Result_1 = require("../../Result");
//---------------------------------------------------------------------------- 
function tryStatement(node, wl, vs) {
    var ip = wl.top();
    var c = monitor.context;
    ip.then(node.block);
    // Expression evaluation might cause exceptions; if so the state of
    // the context might need some cleaning up.
    // The result stack and the worklist are not affected by expression so their
    // states are fine.
    // The ret label cannot be affected by exceptions.
    // The stacks needs to be reset. 
    var pcmarker = c.pcStack.marker();
    var vsmarker = c.valueStack.marker();
    var exc = c.labels.exc;
    // esprima seems to generate a list of handlers --- standard only supports one
    //@ts-ignore SYNTAX
    ip.then(new TryStatementCatch(node.handlers[0], pcmarker, vsmarker, exc));
    // The finalizer 
    var lexicalEnv = c.lexicalEnv;
    ip.then(new TryStatementFinally(node.finalizer, pcmarker, vsmarker, lexicalEnv));
}
exports.tryStatement = tryStatement;
// ---
var TryStatementCatch = /** @class */ (function (_super) {
    __extends(TryStatementCatch, _super);
    function TryStatementCatch(handler, pcmarker, vsmarker, exc) {
        var _this = _super.call(this, Task_1.Task.runfor_throw) || this;
        _this.handler = handler;
        _this.pcmarker = pcmarker;
        _this.vsmarker = vsmarker;
        _this.exc = exc;
        return _this;
    }
    TryStatementCatch.prototype.Execute = function (wl, vs) {
        var c = monitor.context;
        var result = c.result;
        // We are in charge of resetting the exc label, the finally does the rest 
        // of the cleaning.
        // The pc of the catch block is pc + exc of body
        var handlerPC = Label_1.lub(c.labels.pc, c.labels.exc);
        // The exc of the catch block is the exc of _catch, that resets the exc
        c.labels.exc = this.exc;
        // if there is no handler or no exception was thrown, there's nothing more to do
        if (!this.handler || result.type !== 'throw') {
            return;
        }
        c.pcStack.reset(this.pcmarker);
        c.valueStack.reset(this.vsmarker);
        c.pcStack.push(handlerPC);
        var catchEnv = DeclarativeEnvironmentRecord_1.NewDeclarativeEnvironment(c.lexicalEnv);
        // ECMA-262 allows only idenfifiers, but the parser allows patterns;
        if (this.handler.param.type !== 'Identifier') {
            monitor.fatal('Pattern in catch not supported');
        }
        //@ts-ignore SYNTAX
        var identifier = new Value_1.Value(this.handler.param.name, Label_1.bot);
        catchEnv.CreateMutableBinding(identifier);
        catchEnv.SetMutableBinding(identifier, result.value);
        c.lexicalEnv = new Value_1.Value(catchEnv, c.effectivePC);
        result.type = 'normal';
        result.value = null;
        wl.push(this.handler.body);
    };
    return TryStatementCatch;
}(Task_1.Task));
// ---
var TryStatementFinally = /** @class */ (function (_super) {
    __extends(TryStatementFinally, _super);
    function TryStatementFinally(body, pcmarker, vsmarker, lexicalEnv) {
        var _this = _super.call(this, Task_1.Task.runfor_all) || this;
        _this.body = body;
        _this.pcmarker = pcmarker;
        _this.vsmarker = vsmarker;
        _this.lexicalEnv = lexicalEnv;
        return _this;
    }
    TryStatementFinally.prototype.Execute = function (wl, vs) {
        var c = monitor.context;
        // The pc of the finally is the pc of the try.
        // The exc of the finally is the exc of the _catch, which is either
        // the exc of theee try, unless it was raised by a handler, in which
        // case it escapes the try, and should affect the finally too.
        // We are in charge of resetting the pcStack, and the lexicalEnv 
        c.pcStack.reset(this.pcmarker);
        c.valueStack.reset(this.vsmarker);
        c.lexicalEnv = this.lexicalEnv;
        // if there is no finally block, we're done
        if (!this.body) {
            return;
        }
        // Allocate a new result --- _finally env choses between the result
        // of the body/handler, and the result of the finally
        var result = c.result;
        c.result = new Result_1.Result();
        var ip = c.workList.top();
        ip.then(this.body);
        ip.then(new TryStatementFinallyEnd(result));
    };
    return TryStatementFinally;
}(Task_1.Task));
// ---
var TryStatementFinallyEnd = /** @class */ (function (_super) {
    __extends(TryStatementFinallyEnd, _super);
    function TryStatementFinallyEnd(result) {
        var _this = _super.call(this, Task_1.Task.runfor_all) || this;
        _this.result = result;
        return _this;
    }
    TryStatementFinallyEnd.prototype.Execute = function (wl, vs) {
        var c = monitor.context;
        if (c.result.type === 'normal') {
            c.result = this.result;
        }
    };
    return TryStatementFinallyEnd;
}(Task_1.Task));

},{"../../DeclarativeEnvironmentRecord":90,"../../Label":123,"../../Result":174,"../../Value":184,"../Task":98}],113:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var GetValue_1 = require("../../GetValue");
var PutValue_1 = require("../../PutValue");
var GetIdentifierReference_1 = require("../../GetIdentifierReference");
var Task_1 = require("../Task");
function variableDeclaration(node, wl, vs) {
    var ip = wl.top();
    for (var i = 0, len = node.declarations.length; i < len; i++) {
        var vd = node.declarations[i];
        if (vd.init) {
            if (vd.id.type !== 'Identifier') {
                monitor.fatal(vd.id.type + ' not supported in variable declarations');
            }
            //@ts-ignore SYNTAX
            var lhs = GetIdentifierReference_1.GetIdentifierReference(monitor.context.lexicalEnv, vd.id.name);
            ip.then(vd.init);
            ip.then(new VariableDeclarationUpdate(lhs));
        }
    }
}
exports.variableDeclaration = variableDeclaration;
// ---
var VariableDeclarationUpdate = /** @class */ (function (_super) {
    __extends(VariableDeclarationUpdate, _super);
    function VariableDeclarationUpdate(lhs) {
        var _this = _super.call(this) || this;
        _this.lhs = lhs;
        return _this;
    }
    VariableDeclarationUpdate.prototype.Execute = function (wl, vs) {
        //@ts-ignore STACK
        var rhs = GetValue_1.GetValue(vs.pop());
        PutValue_1.PutValue(this.lhs, rhs);
    };
    return VariableDeclarationUpdate;
}(Task_1.Task));

},{"../../GetIdentifierReference":118,"../../GetValue":119,"../../PutValue":172,"../Task":98}],114:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Task_1 = require("../Task");
var Label_1 = require("../../Label");
var GetValue_1 = require("../../GetValue");
var ToBoolean_1 = require("../../Conversion/ToBoolean");
var emptyLabel = 'default'; // default is a reserved word so no actual label can be named default 
var MySet = Set;
// ------------------------------------------------------------
function whileStatement(node, wl, vs) {
    var c = monitor.context;
    var ip = wl.top();
    var lmap = c.labels.labelmap;
    if (!node.labelset) {
        node.labelset = new MySet([]);
    }
    node.labelset.add(emptyLabel);
    var outerEmptyLabelData = lmap[emptyLabel];
    lmap[emptyLabel] = {
        label: c.effectivePC,
        pcmarker: c.pcStack.marker()
    };
    var contextLabel = lmap[emptyLabel].label;
    c.pushPC(contextLabel);
    ip.then(new WhileStatementShared(node, outerEmptyLabelData));
}
exports.whileStatement = whileStatement;
// ------------------------------------------------------------
function doWhileStatement(node, wl, vs) {
    var c = monitor.context;
    var ip = wl.top();
    var lmap = c.labels.labelmap;
    if (!node.labelset) {
        node.labelset = new MySet([]);
    }
    node.labelset.add(emptyLabel);
    var outerEmptyLabelData = lmap[emptyLabel];
    lmap[emptyLabel] = {
        label: c.effectivePC,
        pcmarker: c.pcStack.marker()
    };
    // used for both statement label security labels and control security label
    var contextLabel = lmap[emptyLabel].label;
    c.pushPC(contextLabel);
    ip.then(node.body);
    ip.then(new WhileStatementShared(node, outerEmptyLabelData));
}
exports.doWhileStatement = doWhileStatement;
// ------------------------------------------------------------
var WhileStatementShared = /** @class */ (function (_super) {
    __extends(WhileStatementShared, _super);
    function WhileStatementShared(node, outerEmptyLabelData) {
        var _this = _super.call(this, Task_1.Task.runfor_continue_break) || this;
        _this.node = node;
        _this.outerEmptyLabelData = outerEmptyLabelData;
        _this.choser = new WhileStatementSharedChoose(_this);
        return _this;
    }
    WhileStatementShared.prototype.Execute = function (wl, vs) {
        var ip = wl.top();
        var c = monitor.context;
        var result = c.result;
        if (result.type === 'break' && this.node.labelset.has(result.target)) {
            result.type = 'normal';
            result.target = null;
            c.labels.labelmap[emptyLabel] = this.outerEmptyLabelData;
            c.popPC(); // contextLabel
            return;
        }
        if (result.type !== 'continue' || !this.node.labelset.has(result.target)) {
            if (result.type !== 'normal') {
                return;
            }
        }
        // continue gets us here
        result.type = 'normal';
        result.target = null;
        ip.then(this.node.test);
        ip.then(this.choser);
    };
    return WhileStatementShared;
}(Task_1.Task));
// ---
var WhileStatementSharedChoose = /** @class */ (function (_super) {
    __extends(WhileStatementSharedChoose, _super);
    function WhileStatementSharedChoose(controller) {
        var _this = _super.call(this, Task_1.Task.runfor_continue) || this;
        _this.controller = controller;
        return _this;
    }
    WhileStatementSharedChoose.prototype.Execute = function (wl, vs) {
        var c = monitor.context;
        //@ts-ignore STACK
        var cond = GetValue_1.GetValue(vs.pop());
        var condb = ToBoolean_1.ToBoolean(cond);
        c.labels.pc = Label_1.lub(c.labels.pc, condb.label);
        if (condb.value) {
            var ip = wl.top();
            ip.then(this.controller.node.body);
            ip.then(this.controller);
        }
        else {
            c.labels.labelmap[emptyLabel] = this.controller.outerEmptyLabelData;
            c.popPC(); // contextLabel
        }
    };
    return WhileStatementSharedChoose;
}(Task_1.Task));

},{"../../Conversion/ToBoolean":81,"../../GetValue":119,"../../Label":123,"../Task":98}],115:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Task_1 = require("../Task");
var GetValue_1 = require("../../GetValue");
var ToObject_1 = require("../../Conversion/ToObject");
var ObjectEnvironmentRecord_1 = require("../../ObjectEnvironmentRecord");
var Value_1 = require("../../Value");
// 12.10 ---------------------------------------------------------------------
function withStatement(node, wl, vs) {
    var ip = wl.top();
    ip.then(node.object);
    ip.then(new WithStatementBody(node));
}
exports.withStatement = withStatement;
// ---
var WithStatementBody = /** @class */ (function (_super) {
    __extends(WithStatementBody, _super);
    function WithStatementBody(node) {
        var _this = _super.call(this) || this;
        _this.node = node;
        return _this;
    }
    WithStatementBody.prototype.Execute = function (wl, vs) {
        var ip = wl.top();
        var c = monitor.context;
        //@ts-ignore STACK
        var val = GetValue_1.GetValue(vs.pop());
        var obj = ToObject_1.ToObject(val);
        var oldEnv = c.lexicalEnv;
        var newEnv = ObjectEnvironmentRecord_1.NewObjectEnvironment(obj, oldEnv);
        newEnv.provideThis();
        c.lexicalEnv = new Value_1.Value(newEnv, obj.label);
        ip.then(this.node.body);
        ip.then(new WithStatementEnd(oldEnv));
    };
    return WithStatementBody;
}(Task_1.Task));
// withStatementEnd
var WithStatementEnd = /** @class */ (function (_super) {
    __extends(WithStatementEnd, _super);
    function WithStatementEnd(lexicalEnv) {
        var _this = _super.call(this, Task_1.Task.runfor_continue_break) || this;
        _this.lexicalEnv = lexicalEnv;
        return _this;
    }
    WithStatementEnd.prototype.Execute = function (wl, vs) {
        monitor.context.lexicalEnv = this.lexicalEnv;
    };
    return WithStatementEnd;
}(Task_1.Task));

},{"../../Conversion/ToObject":85,"../../GetValue":119,"../../ObjectEnvironmentRecord":130,"../../Value":184,"../Task":98}],116:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
var Value_1 = require("../Value");
var Reference_1 = require("../Reference");
var ToNumber_1 = require("../Conversion/ToNumber");
var GetValue_1 = require("../GetValue");
var ToBoolean_1 = require("../Conversion/ToBoolean");
var ToInt32_1 = require("../Conversion/ToInt32");
var Label_1 = require("../Label");
var ToObject_1 = require("../Conversion/ToObject");
var PutValue_1 = require("../PutValue");
// -------------------------------------------------------------
// Unary operators
// -------------------------------------------------------------
// Unary -, 11.4.7
function unaryMinus(wl, vs) {
    var ref = vs.pop();
    //@ts-ignore STACK
    var n = ToNumber_1.ToNumber(GetValue_1.GetValue(ref));
    n.value = -n.value;
    vs.push(n);
}
// -------------------------------------------------------------
// Unary +, 11.4.6
function unaryPlus(wl, vs) {
    var ref = vs.pop();
    //@ts-ignore STACK
    var n = ToNumber_1.ToNumber(GetValue_1.GetValue(ref));
    vs.push(n);
}
// -------------------------------------------------------------
// Logical NOT, 11.4.9
function unaryLogicalNot(wl, vs) {
    var ref = vs.pop();
    //@ts-ignore STACK
    var b = ToBoolean_1.ToBoolean(GetValue_1.GetValue(ref));
    b.value = !b.value;
    vs.push(b);
}
// -------------------------------------------------------------
// Bitwise NOT, 11.4.8
function unaryBitwiseNot(wl, vs) {
    var ref = vs.pop();
    //@ts-ignore STACK
    var n = ToInt32_1.ToInt32(GetValue_1.GetValue(ref));
    n.value = ~n.value;
    vs.push(n);
}
// -------------------------------------------------------------
// The typeof Operator, 11.4.3
function unaryTypeof(wl, vs) {
    var ref = vs.pop();
    if (ref instanceof Reference_1.Reference && ref.IsUnresolvableReference()) {
        vs.push(new Value_1.Value('undefined', ref.base.label));
    }
    else {
        var val = void 0;
        if (ref instanceof Reference_1.Reference) {
            val = GetValue_1.GetValue(ref);
        }
        else {
            //@ts-ignore TYPES
            val = ref;
        }
        if (val.value === null) {
            vs.push(new Value_1.Value('object', val.label));
            return;
        }
        if (typeof val.value === 'object') {
            // TODO: use type predicate
            if ('Call' in val.value) {
                vs.push(new Value_1.Value('function', val.label));
            }
            else {
                vs.push(new Value_1.Value('object', val.label));
            }
        }
        else {
            vs.push(new Value_1.Value(typeof val.value, val.label));
        }
    }
}
// -------------------------------------------------------------
// The void Operator, 11.4.2
function unaryVoid(wl, vs) {
    var ref = vs.pop();
    //@ts-ignore STACK
    var _ignore = GetValue_1.GetValue(ref);
    vs.push(new Value_1.Value(undefined, Label_1.bot));
}
// -------------------------------------------------------------
// The delete Operator, 11.4.1
function unaryDelete(wl, vs) {
    var ref = vs.pop();
    if (ref instanceof Reference_1.Reference) {
        if (ref.IsUnresolvableReference()) {
            vs.push(new Value_1.Value(true, ref.base.label));
        }
        else {
            if (ref.IsPropertyReference()) {
                var object = ToObject_1.ToObject(ref.base);
                vs.push(object.Delete(ref.propertyName));
            }
            else {
                vs.push(ref.base.DeleteBinding(ref.propertyName));
            }
        }
    }
    else {
        //@ts-ignore TYPES
        vs.push(new Value_1.Value(true, ref.label));
    }
}
// -------------------------------------------------------------
exports.unarytbl = {
    '-': unaryMinus,
    '+': unaryPlus,
    '!': unaryLogicalNot,
    '~': unaryBitwiseNot,
    'typeof': unaryTypeof,
    'void': unaryVoid,
    'delete': unaryDelete
};
// ------------------------------------------------------------- 
// Prefix, and Postfix Expressions, 11.3, 11.4.4, 11.4.5
function prefixOps(op, wl, vs) {
    //@ts-ignore
    var ref = vs.pop();
    var oldValue = ToNumber_1.ToNumber(GetValue_1.GetValue(ref));
    var val = op === '++' ? oldValue.value + 1 : oldValue.value - 1;
    var newValue = new Value_1.Value(val, oldValue.label);
    PutValue_1.PutValue(ref, newValue);
    vs.push(newValue);
}
function postfixOps(op, wl, vs) {
    //@ts-ignore
    var ref = vs.pop();
    var oldValue = ToNumber_1.ToNumber(GetValue_1.GetValue(ref));
    var val = op === '++' ? oldValue.value + 1 : oldValue.value - 1;
    var newValue = new Value_1.Value(val, oldValue.label);
    PutValue_1.PutValue(ref, newValue);
    vs.push(oldValue);
}
// -------------------------------------------------------------
exports.prefixtbl = {
    '++': prefixOps.bind(null, '++'),
    '--': prefixOps.bind(null, '--')
};
exports.postfixtbl = {
    '++': postfixOps.bind(null, '++'),
    '--': postfixOps.bind(null, '--')
};

},{"../Conversion/ToBoolean":81,"../Conversion/ToInt32":82,"../Conversion/ToNumber":84,"../Conversion/ToObject":85,"../GetValue":119,"../Label":123,"../PutValue":172,"../Reference":173,"../Value":184}],117:[function(require,module,exports){
// --------------------------------------------------------------------------
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
function isJSFlowError(e) {
    return e !== undefined && e !== null && e.type !== undefined;
}
exports.isJSFlowError = isJSFlowError;
// --------------------------------------------------------------------------
var SecurityError = /** @class */ (function (_super) {
    __extends(SecurityError, _super);
    function SecurityError(msg) {
        var _this = _super.call(this, msg) || this;
        _this.type = 'SecurityError';
        return _this;
    }
    return SecurityError;
}(Error));
exports.SecurityError = SecurityError;
// --------------------------------------------------------------------------
var FatalError = /** @class */ (function (_super) {
    __extends(FatalError, _super);
    function FatalError(msg) {
        var _this = _super.call(this, msg) || this;
        _this.type = 'FatalError';
        return _this;
    }
    return FatalError;
}(Error));
exports.FatalError = FatalError;

},{}],118:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
var Label_1 = require("./Label");
var Reference_1 = require("./Reference");
var Value_1 = require("./Value");
// ------------------------------------------------------------
// GetIdentifierReference, 10.2.2.1
function GetIdentifierReference(p, x) {
    if (!p) {
        monitor.fatal('GetIdentifierReference: p undefined or null for ' + x);
    }
    if (p.value == null) {
        return new Reference_1.Reference(new Value_1.Value(undefined, p.label), new Value_1.Value(x, Label_1.bot));
    }
    var erp = new Value_1.Value(p.value.EnvironmentRecord, p.label);
    var b = erp.HasBinding(new Value_1.Value(x, Label_1.bot));
    if (b.value) {
        erp.label = b.label;
        return new Reference_1.Reference(erp, new Value_1.Value(x, Label_1.bot));
    }
    else {
        var res = GetIdentifierReference(p.value.OuterLexicalEnvironment, x);
        res.base.raise(b.label);
        return res;
    }
}
exports.GetIdentifierReference = GetIdentifierReference;

},{"./Label":123,"./Reference":173,"./Value":184}],119:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
var Reference_1 = require("./Reference");
var Value_1 = require("./Value");
var ToObject_1 = require("./Conversion/ToObject");
var Label_1 = require("./Label");
var PropertyDescriptor_1 = require("./PropertyDescriptor");
function GetValue(v) {
    if (!v || !(v instanceof Reference_1.Reference)) {
        //@ts-ignore TYPES
        return v;
    }
    if (v.base.label === undefined)
        monitor.fatal('GetValue, base.label undefined');
    if (v.IsUnresolvableReference()) {
        monitor.Throw("ReferenceError", v.propertyName.value + ' not defined', v.base.label);
    }
    var p = v.base;
    var s = v.propertyName;
    if (v.IsPropertyReference()) {
        if (!v.HasPrimitiveBase()) {
            return p.Get(s);
        }
        else {
            var o = ToObject_1.ToObject(p);
            var ldesc = o.GetProperty(s);
            if (ldesc.value === undefined) {
                //@ts-ignore TYPES
                return ldesc;
            }
            var lbl = Label_1.lub(ldesc.label, ldesc.value.label);
            var desc = ldesc.value;
            if (PropertyDescriptor_1.IsDataDescriptor(desc)) {
                return new Value_1.Value(desc.value, lbl);
            }
            var get = desc.get;
            if (get === undefined) {
                new Value_1.Value(undefined, lbl);
            }
            // TODO: this must be wrong! part of old handling of getter/setters?
            monitor.context.pushPC(lbl);
            //@ts-ignore TYPES
            var res = get.Call(get, v.base);
            monitor.context.popPC();
            res.raise(lbl);
            return res;
        }
    }
    return p.GetBindingValue(s);
}
exports.GetValue = GetValue;

},{"./Conversion/ToObject":85,"./Label":123,"./PropertyDescriptor":156,"./Reference":173,"./Value":184}],120:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
var Label_1 = require("./Label");
var Value_1 = require("./Value");
var constants = require("./Constants");
var Interfaces_1 = require("./Interfaces");
// ------------------------------------------------------------
function HasInstance(X) {
    var F = this;
    var l = X.label;
    if (Interfaces_1.IsIEcmaObject(X)) {
        // needed to make typechecking work, otherwise V gets type Value<ValueTypes> in while below
        var V = X;
        var O = F.Get(constants.prototype);
        if (!Interfaces_1.IsIEcmaObject(O)) {
            monitor.Throw("TypeError", 'HasInstance', Label_1.bot);
            throw "TypeScript";
        }
        while (V.value !== null) {
            V = V.value.Prototype;
            l = Label_1.lub(l, V.label);
            if (O.value === V.value)
                return new Value_1.Value(true, l);
        }
    }
    return new Value_1.Value(false, l);
}
exports.HasInstance = HasInstance;

},{"./Constants":64,"./Interfaces":122,"./Label":123,"./Value":184}],121:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
var FunctionPrototype_1 = require("./Prototypes/FunctionPrototype");
var FunctionConstructor_1 = require("./Constructors/FunctionConstructor");
var ObjectConstructor_1 = require("./Constructors/ObjectConstructor");
var ObjectPrototype_1 = require("./Prototypes/ObjectPrototype");
var ErrorPrototype_1 = require("./Prototypes/ErrorPrototype");
var ErrorConstructor_1 = require("./Constructors/ErrorConstructor");
var EvalErrorPrototype_1 = require("./Prototypes/EvalErrorPrototype");
var EvalErrorConstructor_1 = require("./Constructors/EvalErrorConstructor");
var RangeErrorPrototype_1 = require("./Prototypes/RangeErrorPrototype");
var RangeErrorConstructor_1 = require("./Constructors/RangeErrorConstructor");
var ReferenceErrorPrototype_1 = require("./Prototypes/ReferenceErrorPrototype");
var ReferenceErrorConstructor_1 = require("./Constructors/ReferenceErrorConstructor");
var SyntaxErrorPrototype_1 = require("./Prototypes/SyntaxErrorPrototype");
var SyntaxErrorConstructor_1 = require("./Constructors/SyntaxErrorConstructor");
var TypeErrorPrototype_1 = require("./Prototypes/TypeErrorPrototype");
var TypeErrorConstructor_1 = require("./Constructors/TypeErrorConstructor");
var URIErrorPrototype_1 = require("./Prototypes/URIErrorPrototype");
var URIErrorConstructor_1 = require("./Constructors/URIErrorConstructor");
var BooleanConstructor_1 = require("./Constructors/BooleanConstructor");
var BooleanPrototype_1 = require("./Prototypes/BooleanPrototype");
var ArrayPrototype_1 = require("./Prototypes/ArrayPrototype");
var ArrayConstructor_1 = require("./Constructors/ArrayConstructor");
var NumberPrototype_1 = require("./Prototypes/NumberPrototype");
var NumberConstructor_1 = require("./Constructors/NumberConstructor");
var StringPrototype_1 = require("./Prototypes/StringPrototype");
var StringConstructor_1 = require("./Constructors/StringConstructor");
var RegExpPrototype_1 = require("./Prototypes/RegExpPrototype");
var RegExpConstructor_1 = require("./Constructors/RegExpConstructor");
var DatePrototype_1 = require("./Prototypes/DatePrototype");
var DateConstructor_1 = require("./Constructors/DateConstructor");
var MathObject_1 = require("./Objects/MathObject");
var JSONObject_1 = require("./Objects/JSONObject");
var Instances = /** @class */ (function () {
    function Instances(global) {
        // pre-allocates instances, without setting them up due to circularity
        this.FunctionConstructor = new FunctionConstructor_1.FunctionConstructor(global.Function);
        this.FunctionPrototype = new FunctionPrototype_1.FunctionPrototype(global.Function.prototype);
        this.ObjectConstructor = new ObjectConstructor_1.ObjectConstructor(global.Object);
        this.ObjectPrototype = new ObjectPrototype_1.ObjectPrototype(global.Object.prototype);
        this.ErrorConstructor = new ErrorConstructor_1.ErrorConstructor(global.Error);
        this.ErrorPrototype = new ErrorPrototype_1.ErrorPrototype(global.Error.prototype);
        this.EvalErrorConstructor = new EvalErrorConstructor_1.EvalErrorConstructor(global.EvalError);
        this.EvalErrorPrototype = new EvalErrorPrototype_1.EvalErrorPrototype(global.EvalError.prototype);
        this.RangeErrorConstructor = new RangeErrorConstructor_1.RangeErrorConstructor(global.RangeError);
        this.RangeErrorPrototype = new RangeErrorPrototype_1.RangeErrorPrototype(global.RangeError.prototype);
        this.ReferenceErrorConstructor = new ReferenceErrorConstructor_1.ReferenceErrorConstructor(global.ReferenceError);
        this.ReferenceErrorPrototype = new ReferenceErrorPrototype_1.ReferenceErrorPrototype(global.ReferenceError.prototype);
        this.SyntaxErrorConstructor = new SyntaxErrorConstructor_1.SyntaxErrorConstructor(global.SyntaxError);
        this.SyntaxErrorPrototype = new SyntaxErrorPrototype_1.SyntaxErrorPrototype(global.SyntaxError.prototype);
        this.TypeErrorConstructor = new TypeErrorConstructor_1.TypeErrorConstructor(global.TypeError);
        this.TypeErrorPrototype = new TypeErrorPrototype_1.TypeErrorPrototype(global.TypeError.prototype);
        this.URIErrorConstructor = new URIErrorConstructor_1.URIErrorConstructor(global.URIError);
        this.URIErrorPrototype = new URIErrorPrototype_1.URIErrorPrototype(global.URIError.prototype);
        this.BooleanConstructor = new BooleanConstructor_1.BooleanConstructor(global.Boolean);
        this.BooleanPrototype = new BooleanPrototype_1.BooleanPrototype(global.Boolean.prototype);
        this.ArrayConstructor = new ArrayConstructor_1.ArrayConstructor(global.Array);
        this.ArrayPrototype = new ArrayPrototype_1.ArrayPrototype(global.Array.prototype);
        this.NumberConstructor = new NumberConstructor_1.NumberConstructor(global.Number);
        this.NumberPrototype = new NumberPrototype_1.NumberPrototype(global.Number.prototype);
        this.StringConstructor = new StringConstructor_1.StringConstructor(global.String);
        this.StringPrototype = new StringPrototype_1.StringPrototype(global.String.prototype);
        this.RegExpConstructor = new RegExpConstructor_1.RegExpConstructor(global.RegExp);
        this.RegExpPrototype = new RegExpPrototype_1.RegExpPrototype(global.RegExp.prototype);
        this.DateConstructor = new DateConstructor_1.DateConstructor(global.Date);
        this.DatePrototype = new DatePrototype_1.DatePrototype(global.Date.prototype);
        this.MathObject = new MathObject_1.MathObject(global.Math);
        this.JSONObject = new JSONObject_1.JSONObject(global.JSON);
    }
    Instances.prototype.Setup = function () {
        this.FunctionConstructor.Setup();
        this.FunctionPrototype.Setup();
        this.ObjectConstructor.Setup();
        this.ObjectPrototype.Setup();
        this.ErrorConstructor.Setup();
        this.ErrorPrototype.Setup();
        this.EvalErrorConstructor.Setup();
        this.EvalErrorPrototype.Setup();
        this.RangeErrorConstructor.Setup();
        this.RangeErrorPrototype.Setup();
        this.ReferenceErrorConstructor.Setup();
        this.ReferenceErrorPrototype.Setup();
        this.SyntaxErrorConstructor.Setup();
        this.SyntaxErrorPrototype.Setup();
        this.TypeErrorConstructor.Setup();
        this.TypeErrorPrototype.Setup();
        this.URIErrorConstructor.Setup();
        this.URIErrorPrototype.Setup();
        this.BooleanConstructor.Setup();
        this.BooleanPrototype.Setup();
        this.ArrayConstructor.Setup();
        this.ArrayPrototype.Setup();
        this.NumberConstructor.Setup();
        this.NumberPrototype.Setup();
        this.StringConstructor.Setup();
        this.StringPrototype.Setup();
        this.RegExpConstructor.Setup();
        this.RegExpPrototype.Setup();
        this.DateConstructor.Setup();
        this.DatePrototype.Setup();
        this.MathObject.Setup();
        this.JSONObject.Setup();
    };
    return Instances;
}());
exports.Instances = Instances;

},{"./Constructors/ArrayConstructor":65,"./Constructors/BooleanConstructor":66,"./Constructors/DateConstructor":67,"./Constructors/ErrorConstructor":68,"./Constructors/EvalErrorConstructor":69,"./Constructors/FunctionConstructor":70,"./Constructors/NumberConstructor":71,"./Constructors/ObjectConstructor":72,"./Constructors/RangeErrorConstructor":73,"./Constructors/ReferenceErrorConstructor":74,"./Constructors/RegExpConstructor":75,"./Constructors/StringConstructor":76,"./Constructors/SyntaxErrorConstructor":77,"./Constructors/TypeErrorConstructor":78,"./Constructors/URIErrorConstructor":79,"./Objects/JSONObject":142,"./Objects/MathObject":143,"./Prototypes/ArrayPrototype":157,"./Prototypes/BooleanPrototype":158,"./Prototypes/DatePrototype":159,"./Prototypes/ErrorPrototype":160,"./Prototypes/EvalErrorPrototype":161,"./Prototypes/FunctionPrototype":162,"./Prototypes/NumberPrototype":163,"./Prototypes/ObjectPrototype":164,"./Prototypes/RangeErrorPrototype":165,"./Prototypes/ReferenceErrorPrototype":166,"./Prototypes/RegExpPrototype":167,"./Prototypes/StringPrototype":168,"./Prototypes/SyntaxErrorPrototype":169,"./Prototypes/TypeErrorPrototype":170,"./Prototypes/URIErrorPrototype":171}],122:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
function IsIEcmaObject(x) {
    return typeof x.value === 'object' && x.value !== null && "Class" in x.value;
}
exports.IsIEcmaObject = IsIEcmaObject;

},{}],123:[function(require,module,exports){
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
var CrawlerUtil_1 = require("./Toplevel/crawler/CrawlerUtil");
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
// -------------------------------------------------------------------------- 
// #CRAWLER
var include = {
    'global.AudioContext.destination.channelCount': true,
    'global.AudioContext.destination.channelCountMode': true,
    'global.AudioContext.destination.channelInterpretation': true,
    'global.AudioContext.destination.maxChannelCount': true,
    'global.AudioContext.destination.numberOfInputs': true,
    'global.AudioContext.destination.numberOfOutputs': true,
    'global.AudioContext.sampleRate': true,
    'global.HTMLFormElement.addBehavior': true,
    'global.HTMLFormElement.clientHeight': true,
    'global.HTMLFormElement.clientWidth': true,
    'global.HTMLFormElement.offsetHeight': true,
    'global.HTMLFormElement.offsetWidth': true,
    'global.Int8Array.reduce': true,
    'global.Int8Array.slice.reduce': true,
    'global.Intl.DateTimeFormat.resolvedOptions.timeZone': true,
    'global.OfflineAudioContext.oncomplete[0][0].renderedBuffer.getChannelData.reduce': true,
    'global.OfflineAudioContext.oncomplete[0][0].renderedBuffer.getChannelData.slice': true,
    'global.Plugin.description': true,
    'global.Plugin.length': true,
    'global.Plugin.name': true,
    'global.PluginArray.length': true,
    'global.RTCPeerConnection.onicecandidate[0][0].candidate.candidate': true,
    'global.WebGLRenderingContext': true,
    'global.XMLHttpRequest.readyState': true,
    'global.XMLHttpRequest.responseText': true,
    'global.XMLHttpRequest.status': true,
    'global.addBehavior': true,
    'global.devicePixelRatio': true,
    'global.doNotTrack': true,
    'global.document.appendChild': true,
    'global.document.body.addBehavior': true,
    'global.document.createElement.clientHeight': true,
    'global.document.createElement.clientWidth': true,
    'global.document.createElement.getContext.canvas': true,
    'global.document.createElement.getContext.getContextAttributes.antialias': true,
    'global.document.createElement.getContext.getExtension': true,
    'global.document.createElement.getContext.getParameter': true,
    'global.document.createElement.getContext.getParameter.0': true,
    'global.document.createElement.getContext.getParameter.1': true,
    'global.document.createElement.getContext.getShaderPrecisionFormat.precision': true,
    'global.document.createElement.getContext.getShaderPrecisionFormat.rangeMax': true,
    'global.document.createElement.getContext.getShaderPrecisionFormat.rangeMin': true,
    'global.document.createElement.getContext.getSupportedExtensions': true,
    'global.document.createElement.getContext.getSupportedExtensions.0': true,
    'global.document.createElement.getContext.getSupportedExtensions.1': true,
    'global.document.createElement.getContext.getSupportedExtensions.10': true,
    'global.document.createElement.getContext.getSupportedExtensions.11': true,
    'global.document.createElement.getContext.getSupportedExtensions.12': true,
    'global.document.createElement.getContext.getSupportedExtensions.13': true,
    'global.document.createElement.getContext.getSupportedExtensions.14': true,
    'global.document.createElement.getContext.getSupportedExtensions.15': true,
    'global.document.createElement.getContext.getSupportedExtensions.16': true,
    'global.document.createElement.getContext.getSupportedExtensions.17': true,
    'global.document.createElement.getContext.getSupportedExtensions.18': true,
    'global.document.createElement.getContext.getSupportedExtensions.19': true,
    'global.document.createElement.getContext.getSupportedExtensions.2': true,
    'global.document.createElement.getContext.getSupportedExtensions.20': true,
    'global.document.createElement.getContext.getSupportedExtensions.21': true,
    'global.document.createElement.getContext.getSupportedExtensions.22': true,
    'global.document.createElement.getContext.getSupportedExtensions.23': true,
    'global.document.createElement.getContext.getSupportedExtensions.24': true,
    'global.document.createElement.getContext.getSupportedExtensions.25': true,
    'global.document.createElement.getContext.getSupportedExtensions.3': true,
    'global.document.createElement.getContext.getSupportedExtensions.4': true,
    'global.document.createElement.getContext.getSupportedExtensions.5': true,
    'global.document.createElement.getContext.getSupportedExtensions.6': true,
    'global.document.createElement.getContext.getSupportedExtensions.7': true,
    'global.document.createElement.getContext.getSupportedExtensions.8': true,
    'global.document.createElement.getContext.getSupportedExtensions.9': true,
    'global.document.createElement.getContext.getSupportedExtensions.join': true,
    'global.document.createElement.getContext.getSupportedExtensions.length': true,
    'global.document.createElement.getContext.isPointInPath': true,
    'global.document.createElement.offsetHeight': true,
    'global.document.createElement.offsetWidth': true,
    'global.document.createElement.toDataURL': true,
    'global.document.createEvent': true,
    'global.document.getElementById': true,
    'global.document.getElementsByClassName': true,
    'global.document.getElementsByClassName.0': true,
    'global.document.getElementsByTagName': true,
    'global.document.getElementsByTagName.0.appendChild': true,
    'global.document.getElementsByTagName.0.offsetHeight': true,
    'global.document.getElementsByTagName.0.offsetWidth': true,
    'global.document.getElementsByTagName.appendChild': true,
    'global.document.getElementsByTagName.offsetHeight': true,
    'global.document.getElementsByTagName.offsetWidth': true,
    'global.indexedDB': true,
    'global.localStorage': true,
    'global.navigator.cookieEnabled': true,
    'global.navigator.cpuClass': true,
    'global.navigator.deviceMemory': true,
    'global.navigator.doNotTrack': true,
    'global.navigator.hardwareConcurrency': true,
    'global.navigator.language': true,
    'global.navigator.maxTouchPoints': true,
    'global.navigator.mediaDevices': true,
    'global.navigator.msDoNotTrack': true,
    'global.navigator.platform': true,
    'global.navigator.plugins': true,
    'global.navigator.plugins.0.0.suffixes': true,
    'global.navigator.plugins.0.0.type': true,
    'global.navigator.plugins.0.description': true,
    'global.navigator.plugins.0.forEach': true,
    'global.navigator.plugins.0.length': true,
    'global.navigator.plugins.0.name': true,
    'global.navigator.plugins.1.0.suffixes': true,
    'global.navigator.plugins.1.0.type': true,
    'global.navigator.plugins.1.description': true,
    'global.navigator.plugins.1.forEach': true,
    'global.navigator.plugins.1.length': true,
    'global.navigator.plugins.1.name': true,
    'global.navigator.plugins.2.0.suffixes': true,
    'global.navigator.plugins.2.0.type': true,
    'global.navigator.plugins.2.1.suffixes': true,
    'global.navigator.plugins.2.1.type': true,
    'global.navigator.plugins.2.description': true,
    'global.navigator.plugins.2.forEach': true,
    'global.navigator.plugins.2.length': true,
    'global.navigator.plugins.2.name': true,
    'global.navigator.plugins.description': true,
    'global.navigator.plugins.forEach': true,
    'global.navigator.plugins.length': true,
    'global.navigator.plugins.name': true,
    'global.navigator.plugins.suffixes': true,
    'global.navigator.plugins.type': true,
    'global.navigator.systemLanguage': true,
    'global.navigator.userAgent': true,
    'global.navigator.webdriver': true,
    'global.ontouchstart': true,
    'global.openDatabase': true,
    'global.screen.availHeight': true,
    'global.screen.availWidth': true,
    'global.screen.colorDepth': true,
    'global.screen.deviceXDPI': true,
    'global.screen.deviceYDPI': true,
    'global.screen.height': true,
    'global.screen.width': true,
    'global.sessionStorage': true,
    'global.swfobject': true
};
// 
var Top;
(function (Top) {
    Top[Top["Top"] = 0] = "Top";
})(Top || (Top = {}));
;
var MySet = Set;
var Label = /** @class */ (function () {
    function Label(p) {
        var e_1, _a;
        var rest = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            rest[_i - 1] = arguments[_i];
        }
        if (p === Top.Top) {
            this.principals = Top.Top;
            return;
        }
        this.principals = new MySet(rest);
        if (typeof p === "string") {
            // #CRAWLER - if not in the interesting label set, become bot
            if (!include[p]) {
                return;
            }
            this.principals.add(p);
            return;
        }
        if (typeof p !== 'undefined') {
            try {
                for (var p_1 = __values(p), p_1_1 = p_1.next(); !p_1_1.done; p_1_1 = p_1.next()) {
                    var x = p_1_1.value;
                    // #CRAWLER - if not in the interesting label set don't add
                    if (include[x]) {
                        this.principals.add(x);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (p_1_1 && !p_1_1.done && (_a = p_1.return)) _a.call(p_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
    }
    // -------------------------------------------------------------------------- 
    Label.fromString = function (l) {
        return new Label(l.split(','));
    };
    // -------------------------------------------------------------------------- 
    Label.fromURL = function (l) {
        var re = new RegExp('http://[^/]*/');
        var res = re.exec(l);
        if (res === null) {
            return new Label(l.split(','));
        }
        else {
            return new Label([res[0]]);
        }
    };
    // -------------------------------------------------------------------------- 
    Label.prototype.equals = function (l) {
        var e_2, _a, e_3, _b;
        var A = this.principals;
        var B = l.principals;
        if (A === Top.Top || B === Top.Top) {
            return A === B;
        }
        try {
            for (var A_1 = __values(A), A_1_1 = A_1.next(); !A_1_1.done; A_1_1 = A_1.next()) {
                var p = A_1_1.value;
                if (!B.has(p)) {
                    return false;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (A_1_1 && !A_1_1.done && (_a = A_1.return)) _a.call(A_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        try {
            for (var B_1 = __values(B), B_1_1 = B_1.next(); !B_1_1.done; B_1_1 = B_1.next()) {
                var p = B_1_1.value;
                if (!A.has(p)) {
                    return false;
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (B_1_1 && !B_1_1.done && (_b = B_1.return)) _b.call(B_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return true;
    };
    // -------------------------------------------------------------------------- 
    Label.prototype.le = function (l) {
        var e_4, _a;
        var A = this.principals;
        var B = l.principals;
        if (B === Top.Top) {
            return true;
        }
        if (A === Top.Top) {
            return false;
        }
        try {
            for (var A_2 = __values(A), A_2_1 = A_2.next(); !A_2_1.done; A_2_1 = A_2.next()) {
                var p = A_2_1.value;
                if (!B.has(p)) {
                    return false;
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (A_2_1 && !A_2_1.done && (_a = A_2.return)) _a.call(A_2);
            }
            finally { if (e_4) throw e_4.error; }
        }
        return true;
    };
    // -------------------------------------------------------------------------- 
    Label.prototype.toString = function () {
        var str = 'T';
        if (this.principals !== Top.Top) {
            str = Array.from(this.principals).join(', ');
        }
        return "<" + str + ">";
    };
    // ---
    Label.prototype.ToArray = function () {
        if (this.principals === Top.Top) {
            return ["T"];
        }
        return Array.from(this.principals).sort();
    };
    return Label;
}());
exports.Label = Label;
// -------------------------------------------------------------------------- 
exports.top = new Label(Top.Top);
exports.bot = new Label();
// -------------------------------------------------------------------------- 
function le(l1, l2) {
    return (l1.le(l2));
}
exports.le = le;
function ge(l1, l2) {
    return !l1.le(l2) || l1.equals(l2);
}
exports.ge = ge;
function lub() {
    var e_5, _a, e_6, _b;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    if (args.length === 0) {
        return exports.bot;
    }
    var combinedPrincipals = new MySet();
    try {
        for (var args_1 = __values(args), args_1_1 = args_1.next(); !args_1_1.done; args_1_1 = args_1.next()) {
            var l = args_1_1.value;
            if (l.principals === Top.Top) {
                return exports.top;
            }
            try {
                for (var _c = (e_6 = void 0, __values(l.principals)), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var p = _d.value;
                    combinedPrincipals.add(p);
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                }
                finally { if (e_6) throw e_6.error; }
            }
        }
    }
    catch (e_5_1) { e_5 = { error: e_5_1 }; }
    finally {
        try {
            if (args_1_1 && !args_1_1.done && (_a = args_1.return)) _a.call(args_1);
        }
        finally { if (e_5) throw e_5.error; }
    }
    var ret = new Label();
    ret.principals = combinedPrincipals;
    // #CRAWLER
    if (CrawlerUtil_1.IsCrawler(monitor)) {
        monitor.CrawlerData.AddGenerated(ret);
    }
    return ret;
}
exports.lub = lub;
function glb() {
    var e_7, _a, e_8, _b, e_9, _c;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    if (args.length === 0) {
        return exports.bot;
    }
    var intersectedPrincipals = new MySet();
    var allIsTop = true;
    try {
        for (var args_2 = __values(args), args_2_1 = args_2.next(); !args_2_1.done; args_2_1 = args_2.next()) {
            var l = args_2_1.value;
            if (l.principals !== Top.Top) {
                intersectedPrincipals = l.principals;
                allIsTop = false;
                break;
            }
        }
    }
    catch (e_7_1) { e_7 = { error: e_7_1 }; }
    finally {
        try {
            if (args_2_1 && !args_2_1.done && (_a = args_2.return)) _a.call(args_2);
        }
        finally { if (e_7) throw e_7.error; }
    }
    if (allIsTop) {
        // All is Top!
        return exports.top;
    }
    try {
        for (var args_3 = __values(args), args_3_1 = args_3.next(); !args_3_1.done; args_3_1 = args_3.next()) {
            var l = args_3_1.value;
            if (l.principals === Top.Top) {
                continue;
            }
            try {
                for (var intersectedPrincipals_1 = (e_9 = void 0, __values(intersectedPrincipals)), intersectedPrincipals_1_1 = intersectedPrincipals_1.next(); !intersectedPrincipals_1_1.done; intersectedPrincipals_1_1 = intersectedPrincipals_1.next()) {
                    var p = intersectedPrincipals_1_1.value;
                    if (!l.principals.has(p)) {
                        intersectedPrincipals.delete(p);
                    }
                }
            }
            catch (e_9_1) { e_9 = { error: e_9_1 }; }
            finally {
                try {
                    if (intersectedPrincipals_1_1 && !intersectedPrincipals_1_1.done && (_c = intersectedPrincipals_1.return)) _c.call(intersectedPrincipals_1);
                }
                finally { if (e_9) throw e_9.error; }
            }
        }
    }
    catch (e_8_1) { e_8 = { error: e_8_1 }; }
    finally {
        try {
            if (args_3_1 && !args_3_1.done && (_b = args_3.return)) _b.call(args_3);
        }
        finally { if (e_8) throw e_8.error; }
    }
    var ret = new Label();
    ret.principals = intersectedPrincipals;
    return ret;
}
exports.glb = glb;

},{"./Toplevel/crawler/CrawlerUtil":178}],124:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
var ObjectEnvironmentRecord_1 = require("./ObjectEnvironmentRecord");
// ---
var LexicalEnvironment = /** @class */ (function () {
    function LexicalEnvironment(er, le) {
        this.EnvironmentRecord = er;
        this.OuterLexicalEnvironment = le;
    }
    LexicalEnvironment.prototype.provideThis = function () {
        if (this.EnvironmentRecord instanceof ObjectEnvironmentRecord_1.ObjectEnvironmentRecord) {
            this.EnvironmentRecord.provideThis = true;
        }
    };
    LexicalEnvironment.prototype.HasBinding = function (s) {
        return this.EnvironmentRecord.HasBinding(s);
    };
    LexicalEnvironment.prototype.CreateMutableBinding = function (p, d) {
        return this.EnvironmentRecord.CreateMutableBinding(p, d);
    };
    LexicalEnvironment.prototype.SetMutableBinding = function (p, v, s) {
        return this.EnvironmentRecord.SetMutableBinding(p, v, s);
    };
    LexicalEnvironment.prototype.GetBindingValue = function (p, s) {
        return this.EnvironmentRecord.GetBindingValue(p, s);
    };
    LexicalEnvironment.prototype.DeleteBinding = function (p) {
        return this.EnvironmentRecord.DeleteBinding(p);
    };
    LexicalEnvironment.prototype.ImplicitThisValue = function () {
        return this.EnvironmentRecord.ImplicitThisValue();
    };
    // TODO: fix
    // Only meaningful if the underlying environment record is 
    //  a declarative environment record
    LexicalEnvironment.prototype.CreateImmutableBinding = function (p, s) {
        //@ts-ignore TYPES
        this.EnvironmentRecord.CreateImmutableBinding(p);
    };
    LexicalEnvironment.prototype.InitializeImmutableBinding = function (p, v) {
        //@ts-ignore TYPES
        this.EnvironmentRecord.InitializeImmutableBinding(p, v);
    };
    return LexicalEnvironment;
}());
exports.LexicalEnvironment = LexicalEnvironment;

},{"./ObjectEnvironmentRecord":130}],125:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Value_1 = require("../../Value");
var Label_1 = require("../../Label");
var Require_1 = require("../Require");
var Module_1 = require("../Module");
var fs_1 = require("fs");
var path_1 = require("path");
var Require_2 = require("./Require");
//---
var CommonJSModule = /** @class */ (function (_super) {
    __extends(CommonJSModule, _super);
    function CommonJSModule(filename, parent) {
        var _this = _super.call(this, filename, parent) || this;
        _this.parent = parent;
        _this.require = new Require_2.CommonJSRequire(_this);
        _this.Put(new Value_1.Value('require', Label_1.bot), new Value_1.Value(_this.require, Label_1.bot), false);
        return _this;
    }
    CommonJSModule.LoadModule = function (path, parent) {
        var script = fs_1.readFileSync(path.value).toString();
        var moduleFunction = monitor.instances.FunctionConstructor.Construct([
            new Value_1.Value('require', Label_1.bot),
            new Value_1.Value('module', Label_1.bot),
            new Value_1.Value('exports', Label_1.bot),
            new Value_1.Value('__filename', Label_1.bot),
            new Value_1.Value('__dirname', Label_1.bot),
            new Value_1.Value(script, path.label)
        ]);
        var module = new CommonJSModule(path, parent);
        var exportsObject = module.Get(new Value_1.Value('exports', Label_1.bot));
        Require_1.Require.cache.set(path.value, exportsObject);
        moduleFunction.Call(new Value_1.Value(undefined, Label_1.bot), [
            new Value_1.Value(module.require, Label_1.bot),
            new Value_1.Value(module, Label_1.bot),
            exportsObject,
            new Value_1.Value(path_1.basename(path.value), path.label),
            new Value_1.Value(path_1.dirname(path.value), path.label)
        ]);
        return module.Get(new Value_1.Value('exports', Label_1.bot));
    };
    return CommonJSModule;
}(Module_1.Module));
exports.CommonJSModule = CommonJSModule;

},{"../../Label":123,"../../Value":184,"../Module":127,"../Require":128,"./Require":126,"fs":2,"path":50}],126:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
var path_1 = require("path");
var fs_1 = require("fs");
var Require_1 = require("../Require");
var Value_1 = require("../../Value");
var Label_1 = require("../../Label");
var Module_1 = require("./Module");
var CommonJSRequire = /** @class */ (function (_super) {
    __extends(CommonJSRequire, _super);
    function CommonJSRequire(module) {
        return _super.call(this, module) || this;
    }
    CommonJSRequire.prototype.TryLoad = function (labeledID) {
        var e_1, _a;
        var id = labeledID.value;
        try {
            for (var _b = __values(this.module.paths), _c = _b.next(); !_c.done; _c = _b.next()) {
                var parentPath = _c.value;
                if (id.startsWith('/')) {
                    parentPath = '/';
                }
                if (id.startsWith('./') || id.startsWith('/') || id.startsWith('../')) {
                    var modulePath = path_1.resolve(path_1.join(parentPath, id));
                    if (fs_1.existsSync(modulePath)) {
                        if (Require_1.Require.cache.get(modulePath)) {
                            var module_1 = Require_1.Require.cache.get(modulePath);
                            module_1.raise(Label_1.lub(this.label, labeledID.label));
                            return module_1;
                        }
                        return Module_1.CommonJSModule.LoadModule(new Value_1.Value(modulePath, labeledID.label), this.module);
                    }
                    modulePath = path_1.resolve(path_1.join(parentPath, id + '.js'));
                    if (fs_1.existsSync(modulePath)) {
                        if (Require_1.Require.cache.get(modulePath)) {
                            var module_2 = Require_1.Require.cache.get(modulePath);
                            module_2.raise(Label_1.lub(this.label, labeledID.label));
                            return module_2;
                        }
                        return Module_1.CommonJSModule.LoadModule(new Value_1.Value(modulePath, labeledID.label), this.module);
                    }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return undefined;
    };
    return CommonJSRequire;
}(Require_1.Require));
exports.CommonJSRequire = CommonJSRequire;

},{"../../Label":123,"../../Value":184,"../Require":128,"./Module":125,"fs":2,"path":50}],127:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Value_1 = require("../Value");
var ObjectObject_1 = require("../Objects/ObjectObject");
var path_1 = require("path");
var EcmaObject_1 = require("../Objects/EcmaObject");
var Label_1 = require("../Label");
var process_1 = require("process");
// ---
var Module = /** @class */ (function (_super) {
    __extends(Module, _super);
    function Module(filename, parent) {
        var _this = _super.call(this) || this;
        _this.Class = 'Module';
        if (filename !== undefined) {
            _this.label = Label_1.lub(filename.label, monitor.context.effectivePC);
            _this.filename = filename.value;
            _this.paths = _this.computePaths(path_1.dirname(_this.filename));
            _this.Put(new Value_1.Value('filename', Label_1.bot), filename, false);
            _this.Put(new Value_1.Value('id', Label_1.bot), filename, false);
        }
        else {
            _this.label = monitor.context.effectivePC;
            _this.paths = _this.computePaths(process_1.cwd());
            _this.Put(new Value_1.Value('filename', Label_1.bot), new Value_1.Value(undefined, Label_1.bot), false);
            _this.Put(new Value_1.Value('id', Label_1.bot), new Value_1.Value("<repl>", Label_1.bot), false);
        }
        var exportsObject = new ObjectObject_1.ObjectObject();
        _this.Put(new Value_1.Value('exports', Label_1.bot), new Value_1.Value(exportsObject, Label_1.bot), false);
        return _this;
    }
    Module.prototype.computePaths = function (dirname) {
        return [dirname];
    };
    return Module;
}(EcmaObject_1.EcmaObject));
exports.Module = Module;

},{"../Label":123,"../Objects/EcmaObject":137,"../Objects/ObjectObject":146,"../Value":184,"path":50,"process":51}],128:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var EcmaObject_1 = require("../Objects/EcmaObject");
var Label_1 = require("../Label");
// ---
var Require = /** @class */ (function (_super) {
    __extends(Require, _super);
    function Require(module) {
        var _this = _super.call(this) || this;
        _this.Class = 'Require';
        _this.module = module;
        // this is the topmost require
        if (module.parent === undefined) {
            _this.label = monitor.context.effectivePC;
        }
        else {
            _this.main = module.parent.require.main;
            _this.label = Label_1.lub(module.label, monitor.context.effectivePC);
        }
        return _this;
    }
    // ---
    Require.prototype.Call = function (thisArg, args) {
        var labeledID = args[0];
        if (typeof labeledID.value !== 'string') {
            monitor.Throw("TypeError", 'require expects a string', thisArg.label);
            throw 'TypeScript';
        }
        var module = this.TryLoad(labeledID);
        if (module === undefined) {
            monitor.Throw("Error", labeledID.value + " not found", thisArg.label);
            throw 'TypeScript';
        }
        return module;
    };
    Require.prototype.Construct = function (args) {
        monitor.fatal('Cannot use require as a constructor');
        throw 'TypeScript';
    };
    Require.cache = new Map();
    return Require;
}(EcmaObject_1.EcmaObject));
exports.Require = Require;

},{"../Label":123,"../Objects/EcmaObject":137}],129:[function(require,module,exports){
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
var Label_1 = require("./Label");
var Value_1 = require("./Value");
var Context_1 = require("./Context");
var Options_1 = require("./Options");
var Stack_1 = require("./Stack");
var ErrorObject_1 = require("./Objects/ErrorObject");
var EvalErrorObject_1 = require("./Objects/EvalErrorObject");
var RangeErrorObject_1 = require("./Objects/RangeErrorObject");
var ReferenceErrorObject_1 = require("./Objects/ReferenceErrorObject");
var SyntaxErrorObject_1 = require("./Objects/SyntaxErrorObject");
var TypeErrorObject_1 = require("./Objects/TypeErrorObject");
var URIErrorObject_1 = require("./Objects/URIErrorObject");
var StackTrace_1 = require("./StackTrace");
var Execute_1 = require("./Engine/Execute");
var Error_1 = require("./Error");
var beautify = require("js-beautify");
// --------------------------------------------------------------------------
var ExecutionInfo = /** @class */ (function () {
    function ExecutionInfo() {
        this.delta = 100000;
        this.steps = 0;
        this.time = Date.now();
    }
    ExecutionInfo.prototype.step = function () {
        this.steps++;
        if (this.steps % this.delta === 0) {
            this.report();
        }
    };
    ExecutionInfo.prototype.report = function () {
        if (!monitor.options.get('monitor.progress')) {
            return;
        }
        var currentTime = Date.now();
        var elapsed = (currentTime - this.time) / 1000;
        monitor.info("Executed a total of " + this.steps + " steps in " + elapsed + " seconds at an average rate of " + Math.floor(this.steps / elapsed) + " steps/second");
    };
    return ExecutionInfo;
}());
exports.ExecutionInfo = ExecutionInfo;
//
var MonitorBase = /** @class */ (function () {
    // ---
    // constructor
    function MonitorBase(global, print, log, info, warn, error) {
        this.contextStack = new Stack_1.Stack();
        global.monitor = this;
        global.JSFLOW_STACK_CHECK = true;
        this.print = print ? print : console.log;
        this.log = log ? log : console.log;
        this.warn = warn ? warn : console.warn;
        this.info = info ? info : console.info;
        this.error = error ? error : console.error;
        this.options = new Options_1.Options();
        /*
        * taintMode disables the context computation by overriding exc, ret, pc, and effectivePC
        * forcing them to return bot
        */
        this.options.declare('monitor.taintMode', 'boolean', false, 'taint mode');
        /*
        * testMode supresses label printing in output and security errors
        * to make jsflow compatible with the test harness set by the spiderflow and nodeflow commands
        */
        this.options.declare('monitor.testMode', 'boolean', false, 'test mode');
        /* observableMode supresses stop-on-security-error allowing execution to continue with
        * a printed warning message.
        */
        this.options.declare('monitor.observableMode', 'boolean', false, 'observable mode');
        /* progress causes jsflow to regularly report its execution progress.
        */
        this.options.declare('monitor.progress', 'boolean', false, 'progress mode');
        /* crawler turns on crawler specific gathering code that documents different aspects of the execution.
        */
        this.options.declare('monitor.crawler', 'boolean', false, 'crawler');
        this.debug = { active: false };
        //@ts-ignore
        var context = new Context_1.Context(null, null, null);
        this.contextStack.push(context);
        this.executionInfo = new ExecutionInfo();
    }
    Object.defineProperty(MonitorBase.prototype, "context", {
        // ---
        get: function () {
            return this.contextStack.peek();
        },
        enumerable: true,
        configurable: true
    });
    // ---
    MonitorBase.prototype.running = function () {
        return Execute_1.running();
    };
    ;
    // ---
    // ---
    // throws:
    //  Value<ValueType> or
    //  JSFlowError, when security error or fatal error
    MonitorBase.prototype.Execute = function (code, origin) {
        var result = Execute_1.executeGlobalCode(code, origin);
        if (result.type === 'throw') {
            throw result.value;
        }
        return result.value;
    };
    // ---
    // code transformation support
    MonitorBase.prototype.transform = function (code) {
        return code;
    };
    // ---
    MonitorBase.prototype.beautify = function (code) {
        return beautify.js(code);
    };
    // ---
    // ---
    MonitorBase.prototype.resume = function () {
        this.debug.active = false;
        return Execute_1.resume();
    };
    // ---
    MonitorBase.prototype.step = function () {
        return Execute_1.resume();
    };
    // ---
    MonitorBase.prototype.printWorkList = function () {
        this.log('context owner: ' + this.context.owner);
        this.log(String(this.context.workList));
    };
    // ---
    // TODO: fix proper printing
    MonitorBase.prototype.fatal = function (msg) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var exc = new Error_1.FatalError(msg + args.map(function (x) { return JSON.stringify(x); }).join(' '));
        throw exc;
    };
    // ---
    MonitorBase.prototype.stop = function (msg) {
        var exc = new Error(msg);
        //@ts-ignore TYPES
        exc.type = 'Stop';
        throw exc;
    };
    // ---
    MonitorBase.prototype.Throw = function (error, msg, lbl) {
        this.assert(Label_1.le(this.context.effectivePC, this.context.labels.exc), 'throw: effective pc ' + this.context.effectivePC +
            ' not below exception label ' + this.context.labels.exc);
        var msgValue = new Value_1.Value(msg, lbl);
        this.offendingTrace = this.stackTrace();
        switch (error) {
            case "Error": throw new Value_1.Value(new ErrorObject_1.ErrorObject(msgValue), Label_1.bot);
            case "EvalError": throw new Value_1.Value(new EvalErrorObject_1.EvalErrorObject(msgValue), Label_1.bot);
            case "RangeError": throw new Value_1.Value(new RangeErrorObject_1.RangeErrorObject(msgValue), Label_1.bot);
            case "ReferenceError": throw new Value_1.Value(new ReferenceErrorObject_1.ReferenceErrorObject(msgValue), Label_1.bot);
            case "SyntaxError": throw new Value_1.Value(new SyntaxErrorObject_1.SyntaxErrorObject(msgValue), Label_1.bot);
            case "TypeError": throw new Value_1.Value(new TypeErrorObject_1.TypeErrorObject(msgValue), Label_1.bot);
            case "URIError": throw new Value_1.Value(new URIErrorObject_1.URIErrorObject(msgValue), Label_1.bot);
        }
        this.fatal("Throw: Don't know how to deal with " + error);
    };
    // ---
    MonitorBase.prototype.stackTrace = function () {
        return new StackTrace_1.StackTrace(this.contextStack.toArray());
    };
    // ---
    MonitorBase.prototype.securityError = function (message) {
        if (this.options.get('monitor.testMode')) {
            return;
        }
        if (this.options.get('monitor.taintMode') || this.options.get('monitor.observableMode')) {
            this.warn("[JSFlow NORMAL] Security violation:", message);
        }
        else {
            var exc = new Error_1.SecurityError(message);
            throw exc;
        }
    };
    // ---
    MonitorBase.prototype.assert = function (b, msg) {
        if (!b)
            this.securityError(msg);
    };
    // lifts exceptions that 
    // 1. are not JSFlow internal exceptions 
    // 2. have a a JSFlow modeled counterpart
    // otherwise returns
    MonitorBase.prototype.tryRethrow = function (e, Throw) {
        if ((typeof e !== 'object' && typeof e !== 'function') || e === null) {
            return false;
        }
        if (Error_1.isJSFlowError(e)) {
            throw e;
        }
        if (e instanceof Value_1.Value) {
            throw e;
        }
        var isNative = e.name == "Error" ||
            e.name === "EvalError" ||
            e.name === "RangeError" ||
            e.name === "ReferenceError" ||
            e.name === "SyntaxError" ||
            e.name === "TypeError" ||
            e.name === "URIError";
        if (Throw && isNative) {
            this.Throw(e.name, e.stack, Label_1.bot);
        }
    };
    return MonitorBase;
}());
exports.MonitorBase = MonitorBase;

},{"./Context":80,"./Engine/Execute":95,"./Error":117,"./Label":123,"./Objects/ErrorObject":138,"./Objects/EvalErrorObject":139,"./Objects/RangeErrorObject":147,"./Objects/ReferenceErrorObject":148,"./Objects/SyntaxErrorObject":151,"./Objects/TypeErrorObject":152,"./Objects/URIErrorObject":153,"./Options":154,"./Stack":175,"./StackTrace":176,"./Value":184,"js-beautify":26}],130:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Label_1 = require("./Label");
var Value_1 = require("./Value");
var EcmaObject_1 = require("./Objects/EcmaObject");
var LexicalEnvironment_1 = require("./LexicalEnvironment");
// ------------------------------------------------------------
// 10.2.2.3
function NewObjectEnvironment(o, e) {
    var envRec = new ObjectEnvironmentRecord(o);
    var env = new LexicalEnvironment_1.LexicalEnvironment(envRec, e);
    return env;
}
exports.NewObjectEnvironment = NewObjectEnvironment;
// ------------------------------------------------------------
// Environment records, 10.2.1.2
var ObjectEnvironmentRecord = /** @class */ (function (_super) {
    __extends(ObjectEnvironmentRecord, _super);
    function ObjectEnvironmentRecord(p) {
        var _this = _super.call(this) || this;
        _this.provideThis = false;
        if (p.value === undefined)
            monitor.fatal('ObjectEnvironmentRecord, undefined binding object');
        _this.bindingObject = p; // Value
        return _this;
    }
    // ---
    ObjectEnvironmentRecord.prototype.raise = function (l) {
        this.bindingObject.raise(l);
    };
    // ---
    // HasBinding, 10.2.1.2.1
    ObjectEnvironmentRecord.prototype.HasBinding = function (p) {
        return this.bindingObject.HasProperty(p);
    };
    // ---
    // CreateMutableBinding, 10.2.1.2.2
    ObjectEnvironmentRecord.prototype.CreateMutableBinding = function (p, d) {
        var desc = {
            value: undefined,
            label: monitor.context.effectivePC,
            writable: true,
            enumerable: true,
            configurable: !!d
        };
        this.bindingObject.DefineOwnProperty(p, desc, true);
    };
    // ---
    // GetBindingValue, 10.2.1.2.4
    ObjectEnvironmentRecord.prototype.GetBindingValue = function (p, s) {
        return this.bindingObject.Get(p);
    };
    // SetMutableBinding, 10.2.1.2.3
    ObjectEnvironmentRecord.prototype.SetMutableBinding = function (p, v, s) {
        this.bindingObject.Put(p, v, s);
    };
    // DeleteBinding, 10.2.1.2.5
    ObjectEnvironmentRecord.prototype.DeleteBinding = function (p) {
        return this.bindingObject.Delete(p);
    };
    // ImplicitThisValue, 10.2.1.2.6
    ObjectEnvironmentRecord.prototype.ImplicitThisValue = function () {
        if (this.provideThis) {
            return this.bindingObject.clone();
        }
        else {
            return new Value_1.Value(undefined, Label_1.bot);
        }
    };
    return ObjectEnvironmentRecord;
}(EcmaObject_1.EcmaObject));
exports.ObjectEnvironmentRecord = ObjectEnvironmentRecord;

},{"./Label":123,"./LexicalEnvironment":124,"./Objects/EcmaObject":137,"./Value":184}],131:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var EcmaObject_1 = require("./EcmaObject");
var Value_1 = require("../Value");
var Label_1 = require("../Label");
var ArgumentsObject = /** @class */ (function (_super) {
    __extends(ArgumentsObject, _super);
    function ArgumentsObject(F, args) {
        var _this = _super.call(this) || this;
        _this.Prototype = new Value_1.Value(monitor.instances.ObjectPrototype, Label_1.bot);
        _this.Class = 'Arguments';
        _this.Extensible = true;
        var formalParams = F.FormalParameters;
        var args = args || [];
        for (var i = 0; i < args.length; i++) {
            _this.Put(new Value_1.Value(i, Label_1.bot), args[i], false);
        }
        for (var i = 0; i < formalParams.length; i++) {
            var id = formalParams[i];
            if (id.type !== 'Identifier') {
                monitor.fatal(id.type + ' is not supported in ArgumentsObject');
            }
            if (args[i]) {
                _this.Put(new Value_1.Value(id.name, Label_1.bot), args[i], false);
            }
        }
        _this.Put(new Value_1.Value('length', Label_1.bot), new Value_1.Value(args.length, Label_1.bot), false);
        _this.Put(new Value_1.Value('callee', Label_1.bot), new Value_1.Value(F, Label_1.bot), false);
        return _this;
    }
    return ArgumentsObject;
}(EcmaObject_1.EcmaObject));
exports.ArgumentsObject = ArgumentsObject;
// ------------------------------------------------------------
// Create Arguments Object, 10.6
function CreateArgumentsObject(env, F, args) {
    return new Value_1.Value(new ArgumentsObject(F, args), Label_1.bot);
}
exports.CreateArgumentsObject = CreateArgumentsObject;

},{"../Label":123,"../Value":184,"./EcmaObject":137}],132:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Value_1 = require("../Value");
var EcmaObject_1 = require("../Objects/EcmaObject");
var Label_1 = require("../Label");
var ToUInt32_1 = require("../Conversion/ToUInt32");
var ToNumber_1 = require("../Conversion/ToNumber");
// ------------------------------------------------------------
// 15.4.2.1, and 15.4.2.2
var ArrayObject = /** @class */ (function (_super) {
    __extends(ArrayObject, _super);
    function ArrayObject(struct) {
        var _this = _super.call(this) || this;
        _this.Class = 'Array';
        _this.Prototype = new Value_1.Value(monitor.instances.ArrayPrototype, Label_1.bot);
        _this.Extensible = true;
        _this.properties = [];
        _this.labels = {};
        struct = struct || Label_1.bot;
        _this.labels.length = {
            value: struct,
            existence: Label_1.bot
        };
        _this.struct = struct;
        return _this;
    }
    // ---
    ArrayObject.fromValueArray = function (values, struct) {
        var array = new ArrayObject(struct);
        for (var i = 0, len = values.length; i < len; i++) {
            var value = values[i];
            array.properties[i] = value.value;
            array.labels[i] = {
                value: value.label,
                existence: Label_1.bot
            };
        }
        return array;
    };
    // ---
    ArrayObject.fromPropertyArray = function (values, struct) {
        var array = new ArrayObject(struct);
        for (var i = 0, len = values.length; i < len; i++) {
            var value = values[i];
            array.properties[i] = value.value;
            array.labels[i] = {
                value: value.label,
                existence: value.label
            };
        }
        return array;
    };
    // ---
    ArrayObject.fromArray = function (values, label, existence) {
        var array = new ArrayObject(existence);
        for (var i = 0, len = values.length; i < len; i++) {
            array.properties[i] = values[i];
            array.labels[i] = {
                value: label,
                existence: existence
            };
        }
        return array;
    };
    // ---
    ArrayObject.prototype.toString = function () {
        return this.properties.toString();
    };
    // ---
    ArrayObject.prototype.toLabeledString = function () {
        var strs = [];
        for (var p in this.properties) {
            strs.push(this.properties[p] + '_' + this.labels[p].value.toString() + '(' + this.labels[p].existence.toString() + ')');
        }
        return '[ ' + strs.join(', ') + ' | ' + this.struct.toString() + ', length : ' + this.labels.length.value.toString() + '(' + this.labels.length.existence.toString() + ')' + ' ]';
    };
    // ---
    // 15.4.5.1
    ArrayObject.prototype.DefineOwnProperty = function (s, desc, Throw) {
        var c = monitor.context;
        /* Instead of lengthContext = lub(c.effectivePC, s.label), push s.label to
           pc-stack, and use pc (to make taintMode easier) */
        c.pushPC(s.label);
        if (!Label_1.le(c.effectivePC, this.labels.length.value)) {
            monitor.securityError("Array.prototype.DefineOwnProperty: write context " + c.effectivePC + " not below length label " + this.labels.length.value);
            // For observable flows
            this.labels.length.value = Label_1.lub(this.labels.length.value, c.effectivePC);
        }
        c.popPC();
        var oldLenDesc = this.GetOwnProperty(new Value_1.Value('length', Label_1.bot));
        var oldLen = new Value_1.Value(oldLenDesc.value.value, oldLenDesc.label);
        if (s.value === 'length') {
            if (desc.value === undefined) {
                return _super.prototype.DefineOwnProperty.call(this, s, desc, Throw);
            }
            var newLen = ToUInt32_1.ToUInt32(new Value_1.Value(desc.value, desc.label));
            if (newLen.value !== ToNumber_1.ToNumber(new Value_1.Value(desc.value, desc.label)).value) {
                monitor.Throw('RangeError', 'Invalid length in Array.DefineOwnProperty', Label_1.bot);
            }
            if (newLen.value >= oldLen.value) {
                return _super.prototype.DefineOwnProperty.call(this, s, { value: newLen.value, label: Label_1.lub(newLen.label, desc.label) }, Throw);
            }
            if (oldLenDesc.value.writable === false) {
                if (Throw) {
                    monitor.Throw('TypeError', 'Non-writable descriptor in Array.DefineOwnProperty', Label_1.bot);
                }
                else {
                    return new Value_1.Value(false, Label_1.bot);
                }
            }
            desc.value = newLen.value;
            desc.label = Label_1.lub(desc.label, newLen.label);
        }
        return _super.prototype.DefineOwnProperty.call(this, s, desc, Throw);
    };
    return ArrayObject;
}(EcmaObject_1.EcmaObject));
exports.ArrayObject = ArrayObject;

},{"../Conversion/ToNumber":84,"../Conversion/ToUInt32":89,"../Label":123,"../Objects/EcmaObject":137,"../Value":184}],133:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Value_1 = require("../Value");
var EcmaObject_1 = require("../Objects/EcmaObject");
var Label_1 = require("../Label");
// ------------------------------------------------------------
// Boolean Object, 15.6.5
var BooleanObject = /** @class */ (function (_super) {
    __extends(BooleanObject, _super);
    function BooleanObject(val, lbl) {
        var _this = _super.call(this) || this;
        _this.Class = 'Boolean';
        _this.PrimitiveValue = new Boolean(val);
        _this.PrimitiveLabel = lbl;
        _this.Extensible = true;
        _this.Prototype = new Value_1.Value(monitor.instances.BooleanPrototype, Label_1.bot);
        return _this;
    }
    return BooleanObject;
}(EcmaObject_1.EcmaObject));
exports.BooleanObject = BooleanObject;
// ---
function IsBooleanObject(x) {
    return typeof x.value === 'object' && x.value !== null && x.value.Class === 'Boolean';
}
exports.IsBooleanObject = IsBooleanObject;

},{"../Label":123,"../Objects/EcmaObject":137,"../Value":184}],134:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var BuiltinMethodObject_1 = require("./BuiltinMethodObject");
// ------------------------------------------------------------
var BuiltinFunctionObject = /** @class */ (function (_super) {
    __extends(BuiltinFunctionObject, _super);
    function BuiltinFunctionObject(f, n, host) {
        return _super.call(this, undefined, f, n, host) || this;
    }
    return BuiltinFunctionObject;
}(BuiltinMethodObject_1.BuiltinMethodObject));
exports.BuiltinFunctionObject = BuiltinFunctionObject;

},{"./BuiltinMethodObject":135}],135:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Label_1 = require("../Label");
var Value_1 = require("../Value");
var Define_1 = require("../Define");
var EcmaObject_1 = require("./EcmaObject");
var constants = require("../Constants");
// ------------------------------------------------------------
var BuiltinMethodObject = /** @class */ (function (_super) {
    __extends(BuiltinMethodObject, _super);
    function BuiltinMethodObject(self, f, n, host) {
        var _this = _super.call(this) || this;
        _this.host = host;
        _this.actualFunction = f;
        _this.self = self || _this;
        _this.Class = 'Function';
        _this.Prototype = new Value_1.Value(monitor.instances.FunctionPrototype, Label_1.bot);
        _this.Extensible = true;
        Define_1.DefineFFF(_this, constants.length, n);
        return _this;
    }
    BuiltinMethodObject.prototype.Call = function (thisArg, args) {
        try {
            return this.actualFunction.call(this.self, thisArg, args);
        }
        catch (e) {
            monitor.tryRethrow(e, true);
            monitor.fatal("BuiltinMethodObject.Call, unable to lift " + e + " (error is of type " + typeof e + " \noriginating from " + this.actualFunction + " \nrepresenting host " + this.host + ") \ncalled with this: " + thisArg.value + " \nand args: " + args);
            throw 'TypeScript';
        }
    };
    BuiltinMethodObject.prototype.Construct = function (args) {
        monitor.Throw("TypeError", 'cannot be used as a constructor', Label_1.bot);
        throw 'TypeScript';
    };
    BuiltinMethodObject.prototype.toString = function () {
        if (this.host) {
            return this.host.toString();
        }
        else {
            return this.actualFunction.toString();
        }
    };
    return BuiltinMethodObject;
}(EcmaObject_1.EcmaObject));
exports.BuiltinMethodObject = BuiltinMethodObject;

},{"../Constants":64,"../Define":91,"../Label":123,"../Value":184,"./EcmaObject":137}],136:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Value_1 = require("../Value");
var EcmaObject_1 = require("../Objects/EcmaObject");
var Label_1 = require("../Label");
// ------------------------------------------------------------
// Date Object, 15.9.5
var DateObject = /** @class */ (function (_super) {
    __extends(DateObject, _super);
    function DateObject(date, label) {
        var _this = _super.call(this) || this;
        _this.Class = 'Date';
        _this.PrimitiveValue = date;
        _this.PrimitiveLabel = label;
        _this.Extensible = true;
        _this.Prototype = new Value_1.Value(monitor.instances.DatePrototype, Label_1.bot);
        return _this;
    }
    return DateObject;
}(EcmaObject_1.EcmaObject));
exports.DateObject = DateObject;
function IsDateObject(x) {
    return typeof x.value === 'object' && x.value !== null && x.value.Class === 'Date';
}
exports.IsDateObject = IsDateObject;

},{"../Label":123,"../Objects/EcmaObject":137,"../Value":184}],137:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
var Value_1 = require("../Value");
var Label_1 = require("../Label");
var PropertyDescriptor_1 = require("../PropertyDescriptor");
var constants = require("../Constants");
var IsCallable_1 = require("../Utility/IsCallable");
// ------------------------------------------------------------
// Ecma Objects, 8.6.2
var EcmaObject = /** @class */ (function () {
    function EcmaObject() {
        this._prototype = new Value_1.Value(null, Label_1.bot);
        this.Extensible = true;
        this.properties = {};
        this.labels = {};
        this.properties = {};
        this.labels = {};
        this.struct = monitor.context.effectivePC;
        Object.defineProperty(this, 'map', {
            get: function () {
                throw new Error('Something touched Ecma.map');
            },
            configurable: true
        });
    }
    Object.defineProperty(EcmaObject.prototype, "Prototype", {
        get: function () {
            return this._prototype;
        },
        set: function (p) {
            this._prototype = p;
        },
        enumerable: true,
        configurable: true
    });
    // ---
    EcmaObject.prototype.toString = function () {
        return this.Class ? this.Class : 'EcmaObject';
    };
    // --- used by lprint
    EcmaObject.prototype.toLabeledString = function () {
        return this.toString();
    };
    // ---
    EcmaObject.prototype.getOwnPropertyNames = function (label) {
        var names = Object.getOwnPropertyNames(this.properties);
        var result = [];
        for (var i = 0, len = names.length; i < len; i++) {
            var name = names[i];
            result[i] = new Value_1.Value(name, Label_1.lub(label, this.labels[name].existence));
        }
        return result;
    };
    // ---
    EcmaObject.prototype.getOwnEnumerablePropertyNames = function (label) {
        var names = Object.getOwnPropertyNames(this.properties);
        var enumerable = [];
        var j = 0;
        for (var i = 0, len = names.length; i < len; i++) {
            var name = names[i];
            // from getOwnPropertyNames; guaranteed to be found
            var desc = Object.getOwnPropertyDescriptor(this.properties, name);
            if (desc.enumerable) {
                enumerable[j++] = new Value_1.Value(name, Label_1.lub(label, this.labels[name].existence));
            }
        }
        return enumerable;
    };
    // ---
    EcmaObject.prototype.getEnumerablePropertyNames = function (initialLabel) {
        var defined = {};
        var result = [];
        var j = 0;
        var current = this;
        var lbl = initialLabel || Label_1.bot;
        while (current) {
            var enumerable = current.getOwnEnumerablePropertyNames(lbl);
            for (var i = 0, len = enumerable.length; i < len; i++) {
                var name = enumerable[i];
                if (!defined.hasOwnProperty(name.value)) {
                    defined[name.value] = true;
                    result[j++] = name;
                }
            }
            var next = current.Prototype;
            //@ts-ignore TYPES
            current = next.value;
            lbl = Label_1.lub(lbl, next.label);
        }
        return result;
    };
    // GetOwnProperty, 8.12.1 -----------------------------------------------------
    EcmaObject.prototype.GetOwnProperty = function (s) {
        var propName = s.value;
        var propNameLabel = s.label;
        var jsdesc = Object.getOwnPropertyDescriptor(this.properties, propName);
        if (jsdesc === undefined) {
            return new Value_1.Value(undefined, Label_1.lub(this.struct, propNameLabel));
        }
        var propLabel = this.labels[propName];
        // @ts-ignore
        jsdesc.label = propLabel.value;
        var result = new Value_1.Value(jsdesc, Label_1.lub(propNameLabel, propLabel.existence));
        return result;
    };
    // GetProperty, 8.12.2 --------------------------------------------------------
    EcmaObject.prototype.GetProperty = function (s) {
        var prop = this.GetOwnProperty(s);
        if (prop.value !== undefined) {
            return prop;
        }
        var proto = this.Prototype;
        var lbl = Label_1.lub(prop.label, proto.label);
        if (proto.value === null) {
            return new Value_1.Value(undefined, lbl);
        }
        // DEBUG: remove
        if (proto.value === undefined) {
            monitor.fatal('ECMA Object with undefined Prototype');
        }
        var res = proto.GetProperty(s);
        res.label = Label_1.lub(lbl, res.label);
        return res;
    };
    // Get, 8.12.3 ----------------------------------------------------------------
    EcmaObject.prototype.Get = function (s) {
        var descValue = this.GetProperty(s);
        if (descValue.value === undefined) {
            return new Value_1.Value(undefined, descValue.label);
        }
        var v;
        var desc = descValue.value;
        monitor.context.pushPC(descValue.label);
        if ('value' in desc) {
            v = new Value_1.Value(desc.value, desc.label);
        }
        else if (desc.get) {
            monitor.context.pushPC(desc.label);
            v = desc.get.call(this);
            monitor.context.popPC();
        }
        else {
            v = new Value_1.Value(undefined, descValue.label);
        }
        monitor.context.popPC();
        v.raise(descValue.label);
        return v;
    };
    // CanPut, 8.12.4 -------------------------------------------------------------
    EcmaObject.prototype.CanPut = function (p) {
        var labeledDesc = this.GetOwnProperty(p);
        var label = labeledDesc.label;
        if (labeledDesc.value) {
            var desc = labeledDesc.value;
            label = Label_1.lub(label, desc.label);
            if (PropertyDescriptor_1.IsAccessorDescriptor(desc)) {
                return new Value_1.Value(desc.set !== undefined, label);
            }
            else {
                return new Value_1.Value(!!desc.writable, label);
            }
        }
        var proto = this.Prototype;
        if (proto.value === null) {
            return new Value_1.Value(this.Extensible, label);
        }
        var lableledPrototypeDesc = proto.GetProperty(p);
        label = Label_1.lub(label, lableledPrototypeDesc.label);
        if (lableledPrototypeDesc.value === undefined) {
            return new Value_1.Value(this.Extensible, label);
        }
        var prototypeDesc = lableledPrototypeDesc.value;
        label = Label_1.lub(label, prototypeDesc.label);
        if (PropertyDescriptor_1.IsAccessorDescriptor(prototypeDesc)) {
            return new Value_1.Value(prototypeDesc.set !== undefined, label);
        }
        else {
            if (!this.Extensible) {
                return new Value_1.Value(false, label);
            }
            else {
                return new Value_1.Value(!!prototypeDesc.writable, label);
            }
        }
    };
    // Put, 8.12.5 ----------------------------------------------------------------
    EcmaObject.prototype.Put = function (s, v, Throw) {
        var c = monitor.context;
        var canPut = this.CanPut(s);
        if (!canPut.value) {
            if (Throw) {
                c.pushPC(canPut.label);
                monitor.Throw("TypeError", 'illegal access', Label_1.bot);
            }
            return;
        }
        c.pushPC(new Label_1.Label());
        var ownDesc = this.GetOwnProperty(s);
        if (ownDesc.value && PropertyDescriptor_1.IsDataDescriptor(ownDesc.value)) {
            this.DefineOwnProperty(s, { value: v.value, label: v.label }, Throw);
            c.popPC();
            return;
        }
        var desc = this.GetProperty(s);
        if (desc.value && PropertyDescriptor_1.IsAccessorDescriptor(desc.value)) {
            this.struct = Label_1.lub(this.struct, s.label);
            if (desc.value.set) {
                c.labels.pc = Label_1.lub(c.labels.pc, desc.label);
                try {
                    desc.value.set.call(this, v);
                }
                catch (e) {
                    monitor.tryRethrow(e, Throw);
                    monitor.fatal("EcmaObject.Put, unable to lift " + e + " of type " + typeof e + " (Put(" + s.value + ", " + v.value + ") on " + this.properties + ")");
                }
            }
            c.popPC();
            return;
        }
        c.labels.pc = Label_1.lub(c.labels.pc, desc.label);
        this.DefineOwnProperty(s, {
            value: v.value,
            label: v.label,
            writable: true,
            enumerable: true,
            configurable: true
        }, Throw);
        c.popPC();
        return;
    };
    // HasProperty, 8.12.6 --------------------------------------------------------
    EcmaObject.prototype.HasProperty = function (s) {
        var desc = this.GetProperty(s);
        var val = new Value_1.Value(desc.value !== undefined, desc.label);
        return val;
    };
    // Delete, 8.12.7 -------------------------------------------------------------
    EcmaObject.prototype.Delete = function (s, Throw) {
        var c = monitor.context;
        var propertyName = s.value;
        var desc = this.GetOwnProperty(s);
        if (desc.value === undefined) {
            return new Value_1.Value(true, desc.label);
        }
        if (!Label_1.le(c.effectivePC, this.struct)) {
            var msg = "Ecma.prototype.Delete: security context " + c.effectivePC + " not below structure " + this.struct;
            monitor.securityError(msg);
            // For observable flows
            this.struct = Label_1.lub(this.struct, c.effectivePC);
        }
        var lbl = Label_1.lub(c.effectivePC, desc.label);
        var existence = this.labels[propertyName].existence;
        // use pc stack for taint mode
        c.pushPC(lbl);
        if (!Label_1.le(c.effectivePC, existence)) {
            var msg = "Ecma.prototype.Delete: security context " + lbl + " not below exstence label " + existence;
            monitor.securityError(msg);
            // For observable flows
            existence = Label_1.lub(existence, lbl);
        }
        c.popPC();
        var res;
        try {
            res = delete this.properties[propertyName];
            if (res) {
                delete this.labels[propertyName];
            }
        }
        catch (e) {
            monitor.tryRethrow(e, Throw);
            monitor.fatal("EcmaObject.Delete, unable to lift " + e + " of type " + typeof e + " (Delete(" + s.value + ") on " + this.properties + ")");
        }
        return new Value_1.Value(res, Label_1.lub(desc.label, existence));
    };
    // DefaultValue, 8.12.8 -------------------------------------------------------
    EcmaObject.prototype.DefaultValue = function (hint) {
        if (hint === undefined) {
            if (this.Class === 'Date')
                hint = 'string';
            else
                hint = 'number';
        }
        if (hint === 'string') {
            var toString_1 = this.Get(constants.toString);
            if (IsCallable_1.IsCallable(toString_1)) {
                var str = toString_1.Call(new Value_1.Value(this, Label_1.bot), []);
                if (isDefinedPrimitiveValue(str))
                    return str;
            }
            monitor.context.pushPC(toString_1.label);
            var valueOf_1 = this.Get(constants.valueOf);
            if (IsCallable_1.IsCallable(valueOf_1)) {
                var str = valueOf_1.Call(new Value_1.Value(this, Label_1.bot), []);
                if (isDefinedPrimitiveValue(str)) {
                    str.raise(toString_1.label);
                    monitor.context.popPC();
                    return str;
                }
            }
            // return new Value('DefaultValue: unable to convert', bot);
            monitor.Throw("TypeError", 'default value, unable to convert', Label_1.lub(toString_1.label, valueOf_1.label));
        }
        // hint must be 'number'
        var valueOf = this.Get(constants.valueOf);
        if (IsCallable_1.IsCallable(valueOf)) {
            var str = valueOf.Call(new Value_1.Value(this, Label_1.bot), []);
            if (isDefinedPrimitiveValue(str))
                return str;
        }
        monitor.context.pushPC(valueOf.label);
        var toString = this.Get(constants.toString);
        if (IsCallable_1.IsCallable(toString)) {
            var str = toString.Call(new Value_1.Value(this, Label_1.bot), []);
            if (isDefinedPrimitiveValue(str)) {
                str.raise(valueOf.label);
                monitor.context.popPC();
                return str;
            }
        }
        return monitor.Throw("TypeError", 'default value, unable to convert', Label_1.lub(toString.label, valueOf.label));
    };
    // DefineOwnProperty, 8.12.9 --------------------------------------------------
    EcmaObject.prototype.DefineOwnProperty = function (s, desc, Throw) {
        var c = monitor.context;
        var propName = s.value;
        var propNameLabel = s.label;
        var contextLabel = Label_1.lub(c.effectivePC, propNameLabel);
        try {
            if (Object.hasOwnProperty.call(this.properties, propName)) {
                var valueLabel = this.labels[propName].value;
                // use the pc stack to make taint mode easier
                c.pushPC(contextLabel);
                if (!Label_1.le(c.effectivePC, valueLabel)) {
                    var msg = "Ecma.prototype.DefineOwnProperty: security context " + contextLabel + " not below existing value label " + valueLabel + " for property " + propName;
                    monitor.securityError(msg);
                    // For observable flows
                    valueLabel = Label_1.lub(valueLabel, contextLabel);
                }
                c.popPC();
            }
            else {
                if (!Label_1.le(c.effectivePC, this.struct)) {
                    var msg = "Ecma.prototype.DefineOwnProperty: security context " + c.effectivePC + " not below structure " + this.struct;
                    monitor.securityError(msg);
                    // For observable flows
                    this.struct = Label_1.lub(this.struct, c.effectivePC);
                }
            }
            this.struct = Label_1.lub(this.struct, propNameLabel);
            if (desc.get) {
                var get_1 = desc.get;
                //@ts-ignore DESC HELL
                desc.get = function () { return get_1.Call(new Value_1.Value(this, Label_1.bot), []); };
                //@ts-ignore DESC HELL
                desc.get.actualFunction = get_1;
            }
            if (desc.set) {
                var set_1 = desc.set;
                //@ts-ignore DESC HELL
                desc.set = function (v) { return set_1.Call(new Value_1.Value(this, Label_1.bot), [v]); };
                //@ts-ignore DESC HELL
                desc.set.actualFunction = set_1;
            }
            //@ts-ignore DESC HELL
            Object.defineProperty(this.properties, propName, desc);
            this.labels[propName] = { value: Label_1.lub(desc.label, contextLabel), existence: contextLabel };
        }
        catch (e) {
            //@ts-ignore TYPES
            monitor.tryRethrow(e, Throw);
            monitor.fatal("EcmaObject.DefineOwnProperty, unable to lift " + e + " of type " + typeof e + " (DefineOwnProperty(" + s.value + ", " + desc + ") on " + this.properties + ")");
        }
        return new Value_1.Value(true, Label_1.bot);
    };
    return EcmaObject;
}());
exports.EcmaObject = EcmaObject;
function isDefinedPrimitiveValue(value) {
    return typeof value.value === 'boolean' || typeof value.value === 'string' || typeof value.value === 'number';
}

},{"../Constants":64,"../Label":123,"../PropertyDescriptor":156,"../Utility/IsCallable":182,"../Value":184}],138:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Value_1 = require("../Value");
var EcmaObject_1 = require("../Objects/EcmaObject");
var constants = require("../Constants");
var ToString_1 = require("../Conversion/ToString");
var Label_1 = require("../Label");
// ------------------------------------------------------------
var ErrorObject = /** @class */ (function (_super) {
    __extends(ErrorObject, _super);
    function ErrorObject(v) {
        var _this = _super.call(this) || this;
        _this.Prototype = new Value_1.Value(monitor.instances.ErrorPrototype, Label_1.bot);
        _this.Class = 'Error';
        _this.Extensible = true;
        var message = new Value_1.Value("", Label_1.bot);
        if (v.value !== undefined) {
            message = ToString_1.ToString(v);
        }
        _this.DefineOwnProperty(constants.message, {
            value: message.value,
            label: message.label,
            writable: true,
            enumerable: false,
            configurable: true
        });
        // for toString
        _this.message = message.value;
        _this.stack = monitor.stackTrace();
        return _this;
    }
    ErrorObject.prototype.toString = function () {
        var str = 'Error: ' + this.message + '\n' + this.stack.toString();
        return str;
    };
    return ErrorObject;
}(EcmaObject_1.EcmaObject));
exports.ErrorObject = ErrorObject;

},{"../Constants":64,"../Conversion/ToString":87,"../Label":123,"../Objects/EcmaObject":137,"../Value":184}],139:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var NativeErrorObject_1 = require("./NativeErrorObject");
// ------------------------------------------------------------
var EvalErrorObject = /** @class */ (function (_super) {
    __extends(EvalErrorObject, _super);
    function EvalErrorObject(v) {
        var _this = _super.call(this, monitor.instances.EvalErrorPrototype, v) || this;
        _this.Type = 'NativeError';
        return _this;
    }
    return EvalErrorObject;
}(NativeErrorObject_1.NativeErrorObject));
exports.EvalErrorObject = EvalErrorObject;

},{"./NativeErrorObject":144}],140:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Label_1 = require("../Label");
var Value_1 = require("../Value");
var Define_1 = require("../Define");
var EcmaObject_1 = require("../Objects/EcmaObject");
var constants = require("../Constants");
var ObjectObject_1 = require("../Objects/ObjectObject");
var HasInstance_1 = require("../HasInstance");
var Interfaces_1 = require("../Interfaces");
var PP_1 = require("../PP");
var Execute_1 = require("../Engine/Execute");
var ToObject_1 = require("../Conversion/ToObject");
var DeclarativeEnvironmentRecord_1 = require("../DeclarativeEnvironmentRecord");
var Binding_1 = require("../Engine/Binding");
// ------------------------------------------------------------
// 10.4.3
function enterFunctionCode(F, thisArg, args) {
    var c = monitor.context;
    var thisBinding;
    if (thisArg.value === null || thisArg.value === undefined) {
        thisBinding = new Value_1.Value(monitor.GlobalObject, thisArg.label);
    }
    else if (typeof thisArg.value !== 'object' && typeof thisArg.value !== 'function') {
        thisBinding = ToObject_1.ToObject(thisArg);
    }
    else {
        //@ts-ignore TypeScript doesn't narrow generic types
        thisBinding = thisArg;
    }
    var localEnv = new Value_1.Value(DeclarativeEnvironmentRecord_1.NewDeclarativeEnvironment(F.Scope), c.effectivePC);
    var newContext = c.clone(thisBinding, localEnv, localEnv);
    newContext.labels.ret = Label_1.lub(newContext.labels.ret, newContext.labels.pc);
    newContext.owner = F.Name;
    Binding_1.DeclarationBindingInstantiation(newContext, F, args);
    return newContext;
}
// ------------------------------------------------------------
// Function objects, 13.2
var FunctionObject = /** @class */ (function (_super) {
    __extends(FunctionObject, _super);
    function FunctionObject(parms, code, scope) {
        var _this = _super.call(this) || this;
        _this.Class = 'Function';
        _this.Prototype = new Value_1.Value(monitor.instances.FunctionPrototype, Label_1.bot);
        _this.Scope = scope;
        _this.FormalParameters = parms ? parms : [];
        _this.Code = code;
        _this.Extensible = true;
        Define_1.DefineFFT(_this, constants.length, _this.FormalParameters.length);
        // NOTE: will be updated when called and since we piggyback properties on native properties
        // defining as FFF will cause future updates to fail. Thus we define it as TFT even though
        // this violates the standard.
        Define_1.DefineFFF(_this, constants.arguments, null);
        Define_1.DefineFFF(_this, constants.caller, null);
        var proto = new ObjectObject_1.ObjectObject();
        Define_1.DefineTFT(proto, constants.constructor, _this);
        Define_1.DefineTFF(_this, constants.prototype, proto);
        return _this;
    }
    // ---
    FunctionObject.prototype.AsyncCall = function (thisArg, args) {
        // step 1, as in 10.4.3 embodied in enterFunctionCode
        var funcCtx = enterFunctionCode(this, thisArg, args);
        // for stack trace
        funcCtx.owner = this.Name;
        monitor.contextStack.push(funcCtx);
        var ip = funcCtx.workList.top();
        if (this.Code) {
            ip.then(this.Code);
            ip.then(AsyncCallEnd);
        }
        else {
            ip.then(AsyncCallEnd);
        }
    };
    // ---
    // 13.2.1 
    FunctionObject.prototype.Call = function (thisArg, args) {
        // step 1, as in 10.4.3 embodied in enterFunctionCode
        var funcCtx = enterFunctionCode(this, thisArg, args);
        // for stack trace
        funcCtx.owner = this.Name;
        var res;
        monitor.contextStack.push(funcCtx);
        if (this.Code) {
            res = Execute_1.execute(this.Code, false);
        }
        if (funcCtx.result.value) {
            funcCtx.result.value.raise(funcCtx.labels.ret);
        }
        monitor.contextStack.pop();
        // copy out the inner exception level
        monitor.context.labels.exc = Label_1.lub(monitor.context.labels.exc, funcCtx.labels.exc);
        if (res !== undefined) {
            switch (res.type) {
                case 'throw':
                    throw res.value;
                case 'return':
                    // TODO: should be fixed by making Result a tagged union
                    if (res.value === null) {
                        monitor.fatal('Call: malformed result');
                        throw 'TypeScript';
                    }
                    return res.value;
            }
        }
        return new Value_1.Value(undefined, funcCtx.labels.ret);
    };
    // ---
    FunctionObject.prototype.AsyncConstruct = function (args) {
        var obj = new EcmaObject_1.EcmaObject();
        obj.Class = 'Object';
        obj.Extensible = true;
        var proto = this.Get(constants.prototype);
        if (!Interfaces_1.IsIEcmaObject(proto)) {
            proto = new Value_1.Value(monitor.instances.ObjectPrototype, Label_1.bot);
        }
        // @ts-ignore, we know proto is Value<EcmaObject>
        obj.Prototype = proto;
        var ip = monitor.context.workList.top();
        this.AsyncCall(new Value_1.Value(obj, Label_1.bot), args);
        // TODO: it seems that the closure data is not used
        ip.then(AsyncConstructEnd, { object: obj });
        return ip;
    };
    // ---
    // ---
    // 13.2.2
    FunctionObject.prototype.Construct = function (args) {
        var obj = new EcmaObject_1.EcmaObject();
        obj.Class = 'Object';
        obj.Extensible = true;
        var proto = this.Get(constants.prototype);
        if (!Interfaces_1.IsIEcmaObject(proto)) {
            proto = new Value_1.Value(monitor.instances.ObjectPrototype, Label_1.bot);
        }
        // @ts-ignore, we know proto is Value<EcmaObject>
        obj.Prototype = proto;
        var result = this.Call(new Value_1.Value(obj, Label_1.bot), args);
        if (!Interfaces_1.IsIEcmaObject(result)) {
            result = new Value_1.Value(obj, Label_1.bot);
        }
        // @ts-ignore, we know result is Value<EcmaObject>
        return result;
    };
    FunctionObject.prototype.HasInstance = function (V) {
        return HasInstance_1.HasInstance.call(this, V);
    };
    FunctionObject.prototype.toString = function () {
        return PP_1.pretty(this.Source);
    };
    return FunctionObject;
}(EcmaObject_1.EcmaObject));
exports.FunctionObject = FunctionObject;
// ---
function AsyncCallEnd() {
    var callContext = monitor.context;
    monitor.contextStack.pop();
    var callerContext = monitor.context;
    var result = callContext.result;
    var retlabel = callContext.labels.ret;
    if (result.type !== 'normal' && result.value) {
        result.value.raise(retlabel);
    }
    else {
        result.value = new Value_1.Value(undefined, retlabel);
    }
    // copy out the inner exception level
    callerContext.labels.exc = Label_1.lub(callerContext.labels.exc, callContext.labels.exc);
    callerContext.valueStack.push(result);
}
exports.AsyncCallEnd = AsyncCallEnd;
AsyncCallEnd.runfor = { 'return': true, 'throw': true };
function AsyncConstructEnd() {
    // @ts-ignore
    var retval = monitor.context.valueStack.peek();
    // TODO: what about throw?
    // TODO: this is not a correct way of checking if returned object is an ecmaobject
    if (typeof retval.value.value !== 'object') {
        retval.value = new Value_1.Value(this.object, Label_1.bot);
    }
}
exports.AsyncConstructEnd = AsyncConstructEnd;
AsyncConstructEnd.runfor = { 'return': true, 'throw': true };

},{"../Constants":64,"../Conversion/ToObject":85,"../DeclarativeEnvironmentRecord":90,"../Define":91,"../Engine/Binding":93,"../Engine/Execute":95,"../HasInstance":120,"../Interfaces":122,"../Label":123,"../Objects/EcmaObject":137,"../Objects/ObjectObject":146,"../PP":155,"../Value":184}],141:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Value_1 = require("../Value");
var constants = require("../Constants");
var esprima = require("esprima");
var BuiltinFunctionObject_1 = require("./BuiltinFunctionObject");
var ToNumber_1 = require("../Conversion/ToNumber");
var ToString_1 = require("../Conversion/ToString");
var Define_1 = require("../Define");
var EcmaObject_1 = require("../Objects/EcmaObject");
var Label_1 = require("../Label");
var Interfaces_1 = require("../Interfaces");
var ToInt32_1 = require("../Conversion/ToInt32");
var Execute_1 = require("../Engine/Execute");
// ------------------------------------------------------------
var GlobalObject = /** @class */ (function (_super) {
    __extends(GlobalObject, _super);
    function GlobalObject(host) {
        var _this = _super.call(this) || this;
        _this.Class = 'global';
        if (_this.Prototype === undefined || _this.Prototype.value === null) {
            _this.Prototype = new Value_1.Value(monitor.instances.ObjectPrototype, Label_1.bot);
        }
        _this.host = host;
        // 15.1.1
        Define_1.DefineFFF(_this, constants.NaN, NaN);
        Define_1.DefineFFF(_this, constants['Infinity'], Infinity);
        Define_1.DefineFFF(_this, constants['undefined'], undefined);
        // 15.1.2
        Define_1.DefineTFT(_this, constants['eval'], new BuiltinFunctionObject_1.BuiltinFunctionObject(__eval, 1, host.eval));
        Define_1.DefineTFT(_this, constants.parseInt, new BuiltinFunctionObject_1.BuiltinFunctionObject(__parseInt, 2, host.parseInt));
        Define_1.DefineTFT(_this, constants.parseFloat, new BuiltinFunctionObject_1.BuiltinFunctionObject(__parseFloat, 1, host.parseFloat));
        Define_1.DefineTFT(_this, constants.isNaN, new BuiltinFunctionObject_1.BuiltinFunctionObject(__isNaN, 1, host.isNaN));
        Define_1.DefineTFT(_this, constants.isFinite, new BuiltinFunctionObject_1.BuiltinFunctionObject(__isFinite, 1, host.isFinite));
        // 15.1.3
        Define_1.DefineTFT(_this, constants.decodeURI, new BuiltinFunctionObject_1.BuiltinFunctionObject(__decodeURI, 1, host.decodeURI));
        Define_1.DefineTFT(_this, constants.decodeURIComponent, new BuiltinFunctionObject_1.BuiltinFunctionObject(__decodeURIComponent, 1, host.decodeURIComponent));
        Define_1.DefineTFT(_this, constants.encodeURI, new BuiltinFunctionObject_1.BuiltinFunctionObject(__encodeURI, 1, host.encodeURI));
        Define_1.DefineTFT(_this, constants.encodeURIComponent, new BuiltinFunctionObject_1.BuiltinFunctionObject(__encodeURIComponent, 1, host.encodeURIComponent));
        // 15.1.4
        Define_1.DefineTFT(_this, constants.Object, monitor.instances.ObjectConstructor);
        Define_1.DefineTFT(_this, constants.Function, monitor.instances.FunctionConstructor);
        Define_1.DefineTFT(_this, constants.Array, monitor.instances.ArrayConstructor);
        Define_1.DefineTFT(_this, constants.String, monitor.instances.StringConstructor);
        Define_1.DefineTFT(_this, constants.Boolean, monitor.instances.BooleanConstructor);
        Define_1.DefineTFT(_this, constants.Number, monitor.instances.NumberConstructor);
        Define_1.DefineTFT(_this, constants.Date, monitor.instances.DateConstructor);
        Define_1.DefineTFT(_this, constants.RegExp, monitor.instances.RegExpConstructor);
        Define_1.DefineTFT(_this, constants.Error, monitor.instances.ErrorConstructor);
        Define_1.DefineTFT(_this, constants.EvalError, monitor.instances.EvalErrorConstructor);
        Define_1.DefineTFT(_this, constants.RangeError, monitor.instances.RangeErrorConstructor);
        Define_1.DefineTFT(_this, constants.ReferenceError, monitor.instances.ReferenceErrorConstructor);
        Define_1.DefineTFT(_this, constants.SyntaxError, monitor.instances.SyntaxErrorConstructor);
        Define_1.DefineTFT(_this, constants.TypeError, monitor.instances.TypeErrorConstructor);
        Define_1.DefineTFT(_this, constants.URIError, monitor.instances.URIErrorConstructor);
        Define_1.DefineTFT(_this, constants.Math, monitor.instances.MathObject);
        Define_1.DefineTFT(_this, constants.JSON, monitor.instances.JSONObject);
        Define_1.DefineTFT(_this, new Value_1.Value("globalThis", Label_1.bot), _this);
        // B.2
        Define_1.DefineTFT(_this, constants.escape, new BuiltinFunctionObject_1.BuiltinFunctionObject(__escape, 1, host.escape));
        Define_1.DefineTFT(_this, constants.unescape, new BuiltinFunctionObject_1.BuiltinFunctionObject(__unescape, 1, host.unescape));
        Define_1.DefineTFT(_this, new Value_1.Value('write', Label_1.bot), new BuiltinFunctionObject_1.BuiltinFunctionObject(__print, 0, 'write'));
        Define_1.DefineTFT(_this, new Value_1.Value('print', Label_1.bot), new BuiltinFunctionObject_1.BuiltinFunctionObject(__lprint, 0, 'print'));
        // legacy
        Define_1.DefineTFT(_this, new Value_1.Value('jsflog', Label_1.bot), new BuiltinFunctionObject_1.BuiltinFunctionObject(__lprint, 0, 'lprint'));
        Define_1.DefineFFF(_this, new Value_1.Value('upg', Label_1.bot), new BuiltinFunctionObject_1.BuiltinFunctionObject(__dupg, 1, undefined));
        Define_1.DefineFFF(_this, new Value_1.Value('upgs', Label_1.bot), new BuiltinFunctionObject_1.BuiltinFunctionObject(__dupgs, 1, undefined));
        Define_1.DefineFFF(_this, new Value_1.Value('upge', Label_1.bot), new BuiltinFunctionObject_1.BuiltinFunctionObject(__dupge, 1, undefined));
        Define_1.DefineFFF(_this, new Value_1.Value('lbl', Label_1.bot), new BuiltinFunctionObject_1.BuiltinFunctionObject(__upg, 1, undefined));
        Define_1.DefineFFF(_this, new Value_1.Value('lbls', Label_1.bot), new BuiltinFunctionObject_1.BuiltinFunctionObject(__upgs, 1, undefined));
        Define_1.DefineFFF(_this, new Value_1.Value('lble', Label_1.bot), new BuiltinFunctionObject_1.BuiltinFunctionObject(__upge, 1, undefined));
        Define_1.DefineFFF(_this, new Value_1.Value('lblparts', Label_1.bot), new BuiltinFunctionObject_1.BuiltinFunctionObject(__upgparts, 1, undefined));
        Define_1.DefineFFF(_this, new Value_1.Value('upgl', Label_1.bot), new BuiltinFunctionObject_1.BuiltinFunctionObject(__upgl, 1, undefined));
        Define_1.DefineFFF(_this, new Value_1.Value('declassify', Label_1.bot), new BuiltinFunctionObject_1.BuiltinFunctionObject(__declassify, 1, undefined));
        return _this;
        /*
        DefineFFF(this , new Value('upgs'   , bot) , new BuiltinFunctionObject(__upgs   , 1, undefined));
        DefineFFF(this , new Value('dupgs'  , bot) , new BuiltinFunctionObject(__dupgs  , 1, undefined));
        DefineFFF(this , new Value('getPC'  , bot) , new BuiltinFunctionObject(__getPC  , 0, undefined));
        DefineFFF(this , new Value('setPC'  , bot) , new BuiltinFunctionObject(__setPC  , 1, undefined));
        DefineFFF(this , new Value('getEXC' , bot) , new BuiltinFunctionObject(__getEXC , 0, undefined));
        DefineFFF(this , new Value('setEXC' , bot) , new BuiltinFunctionObject(__setEXC , 1, undefined));
        DefineFFF(this , new Value('getRET' , bot) , new BuiltinFunctionObject(__getRET , 0, undefined));
        DefineFFF(this , new Value('setRET' , bot) , new BuiltinFunctionObject(__setRET , 1, undefined));
        */
    }
    GlobalObject.prototype.toString = function () { return '[global object]'; };
    return GlobalObject;
}(EcmaObject_1.EcmaObject));
exports.GlobalObject = GlobalObject;
// ------------------------------------------------------------
// B.2.1
function __escape(thisArg, args) {
    var arg = args[0] !== undefined ? args[0] : new Value_1.Value(undefined, Label_1.bot);
    var str = ToString_1.ToString(arg);
    return new Value_1.Value(escape(str.value), str.label);
}
// ------------------------------------------------------------
// unescape, B.2.2
function __unescape(thisArg, args) {
    var arg = args[0] ? args[0] : new Value_1.Value(undefined, Label_1.bot);
    var str = ToString_1.ToString(arg);
    return new Value_1.Value(unescape(str.value), str.label);
}
// ------------------------------------------------------------
// 15.1.2.1
function __eval(thisArg, args) {
    var arg0 = args[0];
    if (arg0 === undefined)
        return new Value_1.Value(undefined, Label_1.bot);
    if (typeof arg0.value !== 'string')
        return arg0;
    var prog;
    // raise the pc w.r.t. the program string; parsing may result in an exception
    monitor.context.pushPC(arg0.label);
    try {
        var transformed = monitor.transform(arg0.value);
        prog = esprima.parse(transformed, { loc: true });
    }
    catch (e) {
        var msg = e.description + ' in eval:' + e.lineNumber + ':' + e.column;
        monitor.Throw("SyntaxError", msg, arg0.label);
        throw 'TypeScript';
    }
    var evalCtx = Execute_1.enterEvalCode(prog, __eval);
    monitor.contextStack.push(evalCtx);
    // this is not a value, it is a result!!
    var result = Execute_1.execute(prog, false);
    // if value is 'empty' (represented by null)
    if (!result.value) {
        result.value = new Value_1.Value(undefined, Label_1.bot);
    }
    result.value.raise(arg0.label);
    // NOTE: parser should guarantee the result type is never return
    monitor.contextStack.pop();
    if (result.type === 'throw') {
        throw result.value;
    }
    monitor.context.popPC();
    return result.value;
}
// ------------------------------------------------------------
// 15.1.2.2
function __parseInt(thisArg, args) {
    var stringArg = args[0] || new Value_1.Value(undefined, Label_1.bot);
    var arg1 = args[1] || new Value_1.Value(undefined, Label_1.bot);
    var string = ToString_1.ToString(stringArg);
    var radix = ToInt32_1.ToInt32(arg1);
    var value = parseInt(string.value, radix.value);
    return new Value_1.Value(value, Label_1.lub(string.label, radix.label));
}
// ------------------------------------------------------------
// 15.1.2.3
function __parseFloat(thisArg, args) {
    var stringArg = args[0] || new Value_1.Value(undefined, Label_1.bot);
    var string = ToString_1.ToString(stringArg);
    var value = parseFloat(string.value);
    return new Value_1.Value(value, string.label);
}
// ------------------------------------------------------------
// 15.1.2.4
function __isNaN(thisArg, args) {
    var numberArg = args[0] || new Value_1.Value(undefined, Label_1.bot);
    var number = ToNumber_1.ToNumber(numberArg);
    var value = isNaN(number.value);
    return new Value_1.Value(value, number.label);
}
// ------------------------------------------------------------
// 15.1.2.5
function __isFinite(thisArg, args) {
    var numberArg = args[0] || new Value_1.Value(undefined, Label_1.bot);
    var number = ToNumber_1.ToNumber(numberArg);
    var value = isFinite(number.value);
    return new Value_1.Value(value, number.label);
}
// ------------------------------------------------------------
// 15.1.3.1
function __decodeURI(thisArg, args) {
    var arg0 = args[0] ? args[0] : new Value_1.Value(undefined, Label_1.bot);
    var enc = ToString_1.ToString(arg0);
    var res = new Value_1.Value(decodeURI(enc.value), enc.label);
    return res;
}
// ------------------------------------------------------------
// 15.1.3.2
function __decodeURIComponent(thisArg, args) {
    var arg0 = args[0] ? args[0] : new Value_1.Value(undefined, Label_1.bot);
    var enc = ToString_1.ToString(arg0);
    var res = new Value_1.Value(decodeURIComponent(enc.value), enc.label);
    return res;
}
// ------------------------------------------------------------
// 15.1.2.3
var __encodeURI = function __encodeURI(thisArg, args) {
    var arg0 = args[0] ? args[0] : new Value_1.Value(undefined, Label_1.bot);
    var enc = ToString_1.ToString(arg0);
    var res = new Value_1.Value(encodeURI(enc.value), enc.label);
    return res;
};
// ------------------------------------------------------------
// 15.1.3.4
function __encodeURIComponent(thisArg, args) {
    var arg0 = args[0] !== undefined ? args[0] : new Value_1.Value(undefined, Label_1.bot);
    var componentString = ToString_1.ToString(arg0);
    return new Value_1.Value(encodeURIComponent(componentString.value), componentString.label);
}
// ------------------------------------------------------------
function __print(thisArg, args) {
    var str = '';
    for (var i = 0; i < args.length; i++)
        str += args[i].value;
    monitor.print(str);
    return new Value_1.Value(undefined, Label_1.bot);
}
function __lprint(thisArg, args) {
    if (monitor.options.get('monitor.testMode')) {
        __print(thisArg, args);
        return new Value_1.Value(undefined, Label_1.bot);
    }
    var str = '';
    for (var i = 0; i < args.length; i++)
        str += ToString_1.ToString(args[i]);
    if (monitor.options.get('monitor.taintMode')) {
        monitor.print(str);
    }
    else {
        monitor.print('(' + monitor.context.effectivePC + '):' + str);
    }
    return new Value_1.Value(undefined, Label_1.bot);
}
// ------------------------------------------------------------
function __upgl(thisArg, args) {
    var arg0 = args[0] ? args[0] : new Value_1.Value('default', Label_1.bot);
    var labelName = ToString_1.ToString(arg0);
    monitor.assert(Label_1.le(labelName.label, Label_1.bot), 'upgl expected label of label string to be bot');
    var lbl = Label_1.bot;
    for (var i = 1; i < args.length; i++) {
        var arg = ToString_1.ToString(args[i]);
        monitor.assert(Label_1.le(arg.label, Label_1.bot), 'upgl expected label of label string to be bot');
        lbl = Label_1.lub(lbl, Label_1.Label.fromString(arg.value));
    }
    lbl = lbl.equals(Label_1.bot) ? Label_1.top : lbl;
    var lblmap = monitor.context.labels.labelmap;
    var name = labelName.value;
    if (!lblmap[name]) {
        lblmap[name] = {
            label: lbl,
            pcmarker: undefined
        };
    }
    lblmap[name].label = Label_1.lub(lblmap[name].label, lbl);
    var marker = lblmap[name].pcmarker;
    if (marker !== undefined) {
        monitor.context.pcStack.map(function (l) {
            return Label_1.lub(l, lbl);
        }, marker);
    }
    return new Value_1.Value(undefined, Label_1.bot);
}
// ------------------------------------------------------------
function __upg(thisArg, args) {
    var arg0 = args[0] ? args[0] : new Value_1.Value(undefined, Label_1.bot);
    var lbl = Label_1.bot;
    for (var i = 1; i < args.length; i++) {
        var arg = ToString_1.ToString(args[i]);
        monitor.assert(Label_1.le(arg.label, Label_1.bot), 'upg expected label of label string to be bot');
        lbl = Label_1.lub(lbl, Label_1.Label.fromString(arg.value));
    }
    lbl = lbl.equals(Label_1.bot) ? Label_1.top : lbl;
    return new Value_1.Value(arg0.value, Label_1.lub(arg0.label, lbl));
}
// ---
function __upgparts(thisArg, args) {
    var arg0 = args[0] ? args[0] : new Value_1.Value(undefined, Label_1.bot);
    var lbl = Label_1.bot;
    for (var i = 1; i < args.length; i++) {
        var arg = ToString_1.ToString(args[i]);
        monitor.assert(Label_1.le(arg.label, Label_1.bot), 'upg expected label of label string to be bot');
        lbl = Label_1.lub(lbl, Label_1.Label.fromString(arg.value));
    }
    lbl = lbl.equals(Label_1.bot) ? Label_1.top : lbl;
    if (Interfaces_1.IsIEcmaObject(arg0)) {
        for (var prop in arg0.value.labels) {
            var labelData = arg0.value.labels[prop];
            labelData.value = Label_1.lub(labelData.value, lbl);
            labelData.existence = Label_1.lub(labelData.existence, lbl);
        }
        arg0.value.struct = Label_1.lub(arg0.value.struct, lbl);
        return arg0;
    }
    return new Value_1.Value(arg0.value, Label_1.lub(arg0.label, lbl));
}
// ------------------------------------------------------------
function __dupg(thisArg, args) {
    var arg0 = args[0] ? args[0] : new Value_1.Value(undefined, Label_1.bot);
    var lbl = Label_1.bot;
    for (var i = 1; i < args.length; i++) {
        lbl = Label_1.lub(lbl, args[i].label);
    }
    return new Value_1.Value(arg0.value, Label_1.lub(arg0.label, lbl));
}
// ------------------------------------------------------------
function __upgs(thisArg, args) {
    var obj = args[0] ? args[0] : new Value_1.Value(undefined, Label_1.bot);
    var lbl = Label_1.bot;
    for (var i = 1; i < args.length; i++) {
        var arg = ToString_1.ToString(args[i]);
        monitor.assert(Label_1.le(arg.label, Label_1.bot), 'upgs expected label of label string to be bot');
        lbl = Label_1.lub(lbl, Label_1.Label.fromString(arg.value));
    }
    lbl = lbl.equals(Label_1.bot) ? Label_1.top : lbl;
    if (Interfaces_1.IsIEcmaObject(obj)) {
        obj.value.struct = Label_1.lub(obj.value.struct, lbl);
    }
    return obj;
}
// ------------------------------------------------------------
function __dupgs(thisArg, args) {
    var arg0 = args[0] ? args[0] : new Value_1.Value(undefined, Label_1.bot);
    var lbl = Label_1.bot;
    for (var i = 1; i < args.length; i++) {
        lbl = Label_1.lub(lbl, args[i].label);
    }
    if (Interfaces_1.IsIEcmaObject(arg0)) {
        arg0.value.struct = Label_1.lub(arg0.value.struct, lbl);
    }
    return arg0;
}
// ------------------------------------------------------------
function __upge(thisArg, args) {
    var obj = args[0] ? args[0] : new Value_1.Value(undefined, Label_1.bot);
    var arg1 = args[1] ? args[1] : new Value_1.Value(undefined, Label_1.bot);
    if (obj.value === undefined || obj.value === null) {
        return new Value_1.Value(undefined, Label_1.bot);
    }
    var ix = ToString_1.ToString(arg1);
    var lbl = Label_1.bot;
    for (var i = 2; i < args.length; i++) {
        var arg = ToString_1.ToString(args[i]);
        monitor.assert(Label_1.le(arg.label, Label_1.bot), 'upge expected label of label string to be bot');
        lbl = Label_1.lub(lbl, Label_1.Label.fromString(arg.value));
    }
    lbl = lbl.equals(Label_1.bot) ? Label_1.top : lbl;
    if (Interfaces_1.IsIEcmaObject(obj)) {
        var prop = obj.value.labels[ix.value];
        if (prop) {
            prop.existence = Label_1.lub(prop.existence, lbl);
        }
    }
    return new Value_1.Value(undefined, Label_1.bot);
}
// ------------------------------------------------------------
function __dupge(thisArg, args) {
    var obj = args[0] ? args[0] : new Value_1.Value(undefined, Label_1.bot);
    var arg1 = args[1] ? args[1] : new Value_1.Value(undefined, Label_1.bot);
    if (obj.value === undefined || obj.value === null) {
        return new Value_1.Value(undefined, Label_1.bot);
    }
    var ix = ToString_1.ToString(arg1);
    var lbl = Label_1.bot;
    for (var i = 1; i < args.length; i++) {
        lbl = Label_1.lub(lbl, args[i].label);
    }
    if (Interfaces_1.IsIEcmaObject(obj)) {
        var prop = obj.value.labels[ix.value];
        if (prop) {
            prop.existence = Label_1.lub(prop.existence, lbl);
        }
    }
    return new Value_1.Value(undefined, Label_1.bot);
}
function __declassify(thisArg, args) {
    var val = new Value_1.Value(args[0] ? args[0].value : undefined, Label_1.bot);
    return val;
}

},{"../Constants":64,"../Conversion/ToInt32":82,"../Conversion/ToNumber":84,"../Conversion/ToString":87,"../Define":91,"../Engine/Execute":95,"../Interfaces":122,"../Label":123,"../Objects/EcmaObject":137,"../Value":184,"./BuiltinFunctionObject":134,"esprima":18}],142:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Value_1 = require("../Value");
var constants = require("../Constants");
var BuiltinFunctionObject_1 = require("./BuiltinFunctionObject");
var ObjectObject_1 = require("../Objects/ObjectObject");
var ArrayObject_1 = require("../Objects/ArrayObject");
var ToNumber_1 = require("../Conversion/ToNumber");
var ToInteger_1 = require("../Conversion/ToInteger");
var ToString_1 = require("../Conversion/ToString");
var IsCallable_1 = require("../Utility/IsCallable");
var Define_1 = require("../Define");
var EcmaObject_1 = require("../Objects/EcmaObject");
var Label_1 = require("../Label");
// ------------------------------------------------------------
// The JSON object, 15.12
var JSONObject = /** @class */ (function (_super) {
    __extends(JSONObject, _super);
    function JSONObject(host) {
        var _this = _super.call(this) || this;
        _this.Class = 'JSON';
        _this.Extensible = true;
        _this.host = host;
        return _this;
    }
    JSONObject.prototype.Setup = function () {
        this.Prototype = new Value_1.Value(monitor.instances.ObjectPrototype, Label_1.bot);
        Define_1.DefineFFF(this, constants.prototype, monitor.instances.ObjectPrototype);
        Define_1.DefineTFT(this, constants.parse, new BuiltinFunctionObject_1.BuiltinFunctionObject(parse, 2, this.host.parse));
        Define_1.DefineTFT(this, constants.stringify, new BuiltinFunctionObject_1.BuiltinFunctionObject(stringify, 3, this.host.stringify));
    };
    // By the standard, there should be no Call or Construct for JSON object,
    // so throw a TypeError (as SpiderMonkey seem to do)
    JSONObject.prototype.Call = function (thisArg, args) {
        monitor.Throw("TypeError", 'JSON is not a function', Label_1.bot);
        throw 'TypeScript';
    };
    JSONObject.prototype.Construct = function (args) {
        monitor.Throw("TypeError", 'JSON is not a constructor', Label_1.bot);
        throw 'TypeScript';
    };
    return JSONObject;
}(EcmaObject_1.EcmaObject));
exports.JSONObject = JSONObject;
// ------------------------------------------------------------
// parse, 15.12.2
function parse(thisArg, args) {
    if (args[0] === undefined) {
        monitor.Throw("SyntaxError", 'JSON.parse: No string to parse', Label_1.bot);
    }
    var JText = ToString_1.ToString(args[0]) || new Value_1.Value(undefined, Label_1.bot);
    var reviver = args[1] || new Value_1.Value(undefined, Label_1.bot);
    var unfiltered = parseAndEvaluate(JText);
    // Do we have any junk characters left? If so, a bad string!
    //@ts-ignore JSON
    if (unfiltered.finalIndex <= JText.value.length) {
        monitor.Throw("SyntaxError", 'JSON.parse: String contains bad symbols in the end', Label_1.bot);
    }
    var isReviverCallable = IsCallable_1.IsCallable(reviver);
    monitor.context.pushPC(reviver.label);
    if (isReviverCallable) {
        var root = new ObjectObject_1.ObjectObject();
        root.DefineOwnProperty(new Value_1.Value("", Label_1.bot), {
            value: unfiltered.value,
            writable: true,
            enumerable: true,
            configurable: true,
            label: unfiltered.label
        }, false);
        monitor.context.popPC();
        return Walk(new Value_1.Value(root, Label_1.bot), new Value_1.Value("", Label_1.lub(unfiltered.label, Label_1.lub(JText.label, reviver.label))), reviver);
    }
    else {
        monitor.context.popPC();
        return unfiltered;
    }
}
// Walk, part of 15.12.2
function Walk(holder, name, reviver) {
    var val = holder.Get(name);
    monitor.context.pushPC(val.label);
    if (val.value && typeof val.value === 'object') {
        val = val.value;
        monitor.context.pushPC(val.label);
        if (val.value.Class === 'Array') {
            var I = new Value_1.Value(0, Label_1.bot);
            var len = val.value.Get(constants.length);
            while (I.value < len.value) {
                var newElement = Walk(val, ToString_1.ToString(I), reviver);
                if (newElement === undefined) {
                    val.Delete(ToString_1.ToString(I), false);
                }
                else {
                    val.DefineOwnProperty(ToString_1.ToString(I), {
                        value: newElement.value,
                        writable: true,
                        enumerable: true,
                        configurable: true,
                        label: val.label
                    }, false);
                }
                I.value++;
            }
        }
        else {
            var keys = [];
            var allKeys = Object.keys(val.value.properties);
            for (var i = 0; i < allKeys.length; i++) {
                var keyVal = val.GetProperty(new Value_1.Value(allKeys[i], Label_1.bot));
                if (keyVal.value && keyVal.value.enumerable) {
                    keys.push(new Value_1.Value(allKeys[i], Label_1.bot)); //keyVal.label?
                }
            }
            for (var i = 0; i < keys.length; i++) {
                var P = ToString_1.ToString(keys[i]);
                var newElement = Walk(val, P, reviver);
                if (newElement === undefined) {
                    val.Delete(P, false);
                }
                else {
                    val.DefineOwnProperty(P, {
                        value: newElement.value,
                        writable: true,
                        enumerable: true,
                        configurable: true,
                        label: val.label
                    }, false);
                }
            }
        }
        monitor.context.popPC();
    }
    monitor.context.popPC();
    return reviver.Call(holder, [name, val]);
}
// Inspiration from Douglas Crockford, https://github.com/douglascrockford/JSON-js/blob/master/json_parse.js
// This is used for the 2nd and 3rd step in parse, 15.12.2
function parseAndEvaluate(text) {
    var currentChar = ' ';
    var currentIndex = 0;
    // From 15.12.1.1, JSONEscapeCharacter :: one of " / \ b f n r t
    var escapeCharacters = {
        '"': '"',
        '/': '/',
        '\\': '\\',
        b: '\b',
        f: '\f',
        n: '\n',
        r: '\r',
        t: '\t'
    };
    // These are not allowed to have in a string!
    var invalidStringCharacters = {};
    for (var i = 0x00; i <= 0x1F; i++) {
        var s = String.fromCharCode(i);
        invalidStringCharacters[s] = s;
    }
    var mkError = function (message) {
        monitor.Throw("SyntaxError", 'JSON.parse: ' + message, Label_1.bot);
    };
    var nextChar = function (char) {
        if (char && char !== currentChar) {
            mkError('expected ' + char + ' to match ' + currentChar);
        }
        currentChar = text.charAt(currentIndex);
        currentIndex++;
        return currentChar;
    };
    //JSONWhiteSpace :: <TAB> <CR> <LF> <SP>
    var eatWhiteSpace = function () {
        while (currentChar && currentChar <= ' ') {
            //@ts-ignore JSON
            nextChar();
        }
    };
    /* JSONValue :
         JSONNullLiteral
         JSONBooleanLiteral
         JSONObject
         JSONArray
         JSONString
         JSONNumber
    */
    var jsonValue = function () {
        eatWhiteSpace();
        switch (currentChar) {
            case '{':
                // It must be an object
                return jsonObject();
            case '[':
                // It must be an array
                return jsonArray();
            case '"':
                // It must be a string
                return jsonString();
            case '-':
                // It must be a number
                return jsonNumber();
            case 'n':
                // It must be a null literal
                return jsonNull();
            case 't':
            case 'f':
                // It must be a boolean literal
                return jsonBool();
            default:
                if (currentChar >= '0' && currentChar <= '9') {
                    // It must be a number
                    return jsonNumber();
                }
                // Otherwise, something has gone wrong!
                mkError('Cannot parse the structure!');
        }
    };
    var jsonObject = function () {
        var result = new ObjectObject_1.ObjectObject();
        if (currentChar === '{') {
            nextChar('{');
            eatWhiteSpace();
            //@ts-ignore TYPESCRIPT
            if (currentChar === '}') {
                // Enter here and we have an "empty" object
                nextChar('}');
                return result;
            }
            while (currentChar) {
                var key = jsonString();
                eatWhiteSpace();
                nextChar(':');
                if (result.hasOwnProperty(key)) {
                    mkError('Bad object, duplicate key ' + key);
                }
                result.DefineOwnProperty(new Value_1.Value(key, Label_1.bot), {
                    value: jsonValue(),
                    writable: true,
                    enumerable: true,
                    configurable: true,
                    label: Label_1.bot
                }, false);
                eatWhiteSpace();
                //@ts-ignore TYPESCRIPT
                if (currentChar === '}') {
                    nextChar('}');
                    return result;
                }
                nextChar(',');
                eatWhiteSpace();
            }
        }
        mkError('Malformed object');
    };
    var jsonArray = function () {
        var result = [];
        if (currentChar === '[') {
            nextChar('[');
            eatWhiteSpace();
            //@ts-ignore TYPESCRIPT
            if (currentChar === ']') {
                // Enter here and we have an empty array..
                nextChar(']');
                //@ts-ignore JSON
                return ArrayObject_1.ArrayObject.fromValueArray(result);
            }
            while (currentChar) {
                result.push(jsonValue());
                eatWhiteSpace();
                //@ts-ignore TYPESCRIPT
                if (currentChar === ']') {
                    // Enter here and we are done..
                    nextChar(']');
                    for (var i = 0; i < result.length; i++) {
                        result[i] = new Value_1.Value(result[i], Label_1.bot);
                    }
                    //@ts-ignore JSON
                    return ArrayObject_1.ArrayObject.fromValueArray(result);
                }
                nextChar(','); // If we are not done, we expect a ','
                eatWhiteSpace();
            }
        }
        mkError('Could not parse the array');
    };
    /*
      JSONString :: " JSONStringCharacters_opt "
      JSONStringCharacters :: JSONStringCharacter JSONStringCharacters_opt
      JSONStringCharacter :: SourceCharacter but not one of " or \ or U+0000 through U+001F \ JSONEscapeSequence
      JSONEscapeSequence :: JSONEscapeCharacter UnicodeEscapeSequence
     */
    var jsonString = function () {
        var result = "";
        if (currentChar === '"') {
            //@ts-ignore JSON
            while (nextChar()) {
                if (currentChar === '"') {
                    //@ts-ignore JSON
                    nextChar();
                    return result;
                }
                // Check if the current character is an invalid string
                if (invalidStringCharacters[currentChar]) {
                    mkError("Invalid character in string");
                }
                if (currentChar === '\\') {
                    //@ts-ignore JSON
                    nextChar();
                    if (currentChar === 'u') {
                        var hexValue = 0;
                        for (var i = 0; i < 4; i++) {
                            //@ts-ignore JSON
                            var hex = parseInt(nextChar(), 16);
                            if (!isFinite(hex)) {
                                break;
                            }
                            hexValue = hexValue * 16 + hex;
                        }
                        result += String.fromCharCode(hexValue);
                    }
                    else if (typeof escapeCharacters[currentChar] === 'string') {
                        result += escapeCharacters[currentChar];
                    }
                    else {
                        break;
                    }
                }
                else {
                    result += currentChar;
                }
            }
        }
        mkError('Bad input string');
    };
    // JSONNumber :: -_opt DecimalIntegerLiteral JSONFraction_opt ExponentPart_opt
    var jsonNumber = function () {
        var result = "", checkOctal = false, checkFloat = false;
        if (currentChar === '-') {
            result += currentChar;
            nextChar('-');
        }
        if (currentChar === '0') {
            checkOctal = true;
        }
        // Get all the numbers
        while (currentChar >= '0' && currentChar <= '9') {
            result += currentChar;
            //@ts-ignore JSON
            nextChar();
        }
        if (checkOctal && result.length > 1) {
            mkError("JSON.parse: Numbers cannot start with a 0");
        }
        // Check if it is a float
        if (currentChar === '.') {
            result += currentChar;
            checkFloat = true;
            // Get all the remaining numbers in the float
            //@ts-ignore JSON
            while (nextChar() && currentChar >= '0' && currentChar <= '9') {
                result += currentChar;
                checkFloat = false;
            }
        }
        if (checkFloat) {
            mkError("JSON.parse: Number with nothing after the decimal");
        }
        if (currentChar === 'e' || currentChar === 'E') {
            result += currentChar;
            //@ts-ignore JSON
            nextChar();
            //@ts-ignore TYPESCRIPT
            if (currentChar === '-' || currentChar === '+') {
                result += currentChar;
                //@ts-ignore JSON
                nextChar();
            }
            while (currentChar >= '0' && currentChar <= '9') {
                result += currentChar;
                //@ts-ignore JSON
                nextChar();
            }
        }
        var num = +result; // Nasty conversion. :)
        if (!isFinite(num)) {
            mkError('Bad number, not finite');
        }
        return num;
    };
    // JSONNullLiteral :: NullLiteral
    var jsonNull = function () {
        nextChar('n');
        nextChar('u');
        nextChar('l');
        nextChar('l');
        return null;
    };
    // JSONBooleanLiteral :: BooleanLiteral
    var jsonBool = function () {
        switch (currentChar) {
            case 't':
                nextChar('t');
                nextChar('r');
                nextChar('u');
                nextChar('e');
                return true;
            case 'f':
                nextChar('f');
                nextChar('a');
                nextChar('l');
                nextChar('s');
                nextChar('e');
                return false;
            default:
                mkError('Could not deduce a boolean');
        }
    };
    if (text.value) {
        var textLabel = text.label;
        text = text.value;
        var res = new Value_1.Value(jsonValue(), textLabel);
        eatWhiteSpace(); // Eat all trailing white spaces
        //@ts-ignore JSON
        res.finalIndex = currentIndex; // This is needed to know if we have some garbage at the end of the string
        return res;
    }
    else {
        mkError('Bad format on input');
    }
}
// ------------------------------------------------------------
// stringify, 15.12.3
function stringify(thisArg, args) {
    // These are used for cycle detection
    var JA_counter = 0;
    var JO_counter = 0;
    //-------------------------------------------
    var stack = [];
    var indent = "";
    var PropertyList, ReplacerFunction;
    var gap = "";
    var value = args[0] || new Value_1.Value(undefined, Label_1.bot);
    var replacer = args[1] || new Value_1.Value(undefined, Label_1.bot);
    var space = args[2] || new Value_1.Value(undefined, Label_1.bot);
    var retLabel = Label_1.lub(value.label, Label_1.lub(replacer.label, space.label));
    monitor.context.pushPC(replacer.label);
    if (typeof replacer.value === 'object' || typeof replacer.value === 'function') {
        if (IsCallable_1.IsCallable(replacer)) {
            ReplacerFunction = replacer;
        }
        else if (replacer.value && replacer.value.Class === 'Array') {
            PropertyList = [];
            var initialReplacerLength = replacer.value.properties.length;
            for (var i = 0; i < initialReplacerLength; i++) {
                var item = undefined;
                var v = replacer.Get(new Value_1.Value(i, Label_1.bot));
                if (v.value !== undefined) {
                    if (typeof v.value === 'string') {
                        item = v;
                    }
                    else if (typeof v.value === 'number') {
                        item = ToString_1.ToString(v);
                    }
                    else if (typeof v.value === 'object') {
                        if (v.value && (v.value.Class === 'String' || v.value.Class === 'Number')) {
                            item = ToString_1.ToString(v);
                        }
                    }
                    if (item !== undefined) {
                        var itemNotInArray = true;
                        for (var j = 0; j < PropertyList.length; j++) {
                            if (item.value === PropertyList[j].value) {
                                itemNotInArray = false;
                                break;
                            }
                        }
                        if (itemNotInArray) {
                            PropertyList.push(item);
                        }
                    }
                }
            }
        }
    }
    monitor.context.popPC();
    monitor.context.pushPC(space.label);
    if (typeof space.value === 'object') {
        if (space.value.Class === 'Number') {
            space = ToNumber_1.ToNumber(space);
        }
        else if (space.value.Class === 'String') {
            space = ToString_1.ToString(space);
        }
    }
    if (typeof space.value === 'number') {
        var intSpace = ToInteger_1.ToInteger(space);
        if (intSpace.value > 10) {
            space = new Value_1.Value(10, space.label);
        }
        else {
            space = intSpace;
        }
        for (var i = 0; i < space.value; i++) {
            gap = gap + " ";
        }
    }
    else if (typeof space.value === 'string') {
        if (space.value.length <= 10) {
            gap = space.value;
        }
        else {
            gap = space.value.substring(0, 10);
        }
    }
    // Leave the last else, gap will be empty string if none of the above has been hit
    monitor.context.popPC(); // Pop space.label from the PC stack
    var wrapper = new ObjectObject_1.ObjectObject();
    wrapper.DefineOwnProperty(new Value_1.Value("", Label_1.bot), {
        value: value.value,
        writable: true,
        enumerable: true,
        configurable: true,
        label: value.label
    }, false);
    var Str = function (key, holder) {
        var value = holder.Get(key);
        retLabel = Label_1.lub(retLabel, value.label);
        monitor.context.pushPC(value.label);
        if (value.value && typeof value.value === 'object') {
            var toJSON = value.Get(new Value_1.Value("toJSON", Label_1.bot));
            if (IsCallable_1.IsCallable(toJSON)) {
                value = toJSON.Call(value, [key]);
            }
        }
        monitor.context.popPC(); // As it is being pushed again later, is this needed?
        if (ReplacerFunction) {
            monitor.context.pushPC(ReplacerFunction.label);
            if (ReplacerFunction.value) {
                value = ReplacerFunction.Call(holder, [key, value]);
            }
            monitor.context.popPC();
        }
        monitor.context.pushPC(value.label);
        if (value.value && typeof value.value === 'object') {
            if (value.value.Class === 'Number') {
                value = ToNumber_1.ToNumber(value);
            }
            else if (value.value.Class === 'String') {
                value = ToString_1.ToString(value);
            }
            else if (value.value.Class === 'Boolean') {
                value = new Value_1.Value(value.value.PrimitiveValue.valueOf(), retLabel);
            }
        }
        if (value.value === null) {
            monitor.context.popPC();
            return new Value_1.Value("null", retLabel);
        }
        if (value.value === true) {
            monitor.context.popPC();
            return new Value_1.Value("true", retLabel);
        }
        if (value.value === false) {
            monitor.context.popPC();
            return new Value_1.Value("false", retLabel);
        }
        if (typeof value.value === 'string') {
            var res = Quote(value);
            monitor.context.popPC();
            return res;
        }
        if (typeof value.value === 'number') {
            if (isFinite(value.value)) {
                var res = ToString_1.ToString(value);
                monitor.context.popPC();
                return res;
            }
            monitor.context.popPC();
            return new Value_1.Value("null", retLabel);
        }
        if (typeof value.value === 'object' && !IsCallable_1.IsCallable(value)) {
            if (value.value.Class === 'Array') {
                //@ts-ignore JSON
                var res = JA(value);
                monitor.context.popPC();
                return res;
            }
            //@ts-ignore JSON
            var res = JO(value);
            monitor.context.popPC();
            return res;
        }
        monitor.context.popPC();
        return new Value_1.Value(undefined, retLabel);
    };
    var Quote = function (value) {
        var product = "\"";
        for (var i = 0; i < value.value.length; i++) {
            var C = value.value[i];
            var cCodePointValue = C.codePointAt(0);
            var spaceCodePointValue = (" ").codePointAt(0);
            if (C === "\"" || C === "\\") {
                product += "\\";
                product += C;
            }
            else if (C === "\b" || C === "\f" || C === "\n" || C === "\r" || C === "\t") {
                product += "\\";
                var abbrev;
                if (C === "\b")
                    abbrev = "b";
                else if (C === "\f")
                    abbrev = "f";
                else if (C === "\n")
                    abbrev = "n";
                else if (C === "\r")
                    abbrev = "r";
                else
                    abbrev = "t";
                product += abbrev;
            }
            else if (cCodePointValue < spaceCodePointValue) {
                product += "\\";
                product += "u";
                var hex = cCodePointValue.toString(16);
                for (var j = hex.length; j < 4; j++) {
                    hex = "0" + hex;
                }
                product += hex;
            }
            else {
                product += C;
            }
        }
        product += "\"";
        return new Value_1.Value(product, Label_1.lub(monitor.context.effectivePC, value.label));
    };
    var JO = function (value) {
        var JO_key = new Value_1.Value("JO_property", Label_1.bot);
        if (!value.Get(JO_key).value) {
            JO_counter++;
            value.DefineOwnProperty(JO_key, {
                value: JO_counter,
                writable: false,
                enumerable: false,
                configurable: false,
                label: Label_1.bot
            }, false);
        }
        else {
            checkCycle(JO_key, value);
        }
        stack.push(value);
        var stepback = indent;
        indent = indent + gap;
        if (PropertyList !== undefined) {
            var K = PropertyList;
        }
        else {
            //@ts-ignore JSON
            var K = [];
            var allKeys = Object.keys(value.value.properties);
            for (var i = 0; i < allKeys.length; i++) {
                var keyVal = value.GetProperty(new Value_1.Value(allKeys[i], Label_1.bot));
                if (keyVal.value && keyVal.value.enumerable) {
                    K.push(new Value_1.Value(allKeys[i], retLabel));
                }
            }
        }
        var partial = [];
        for (var i = 0; i < K.length; i++) {
            var P = K[i];
            var strP = Str(P, value);
            if (strP && strP.value !== undefined) {
                var member = Quote(P);
                member.value += ":";
                if (gap !== "") {
                    member.value += ' ';
                }
                member.value += strP.value;
                partial.push(member);
            }
        }
        var final;
        if (partial.length === 0) {
            final = "{}";
        }
        else {
            var properties = "";
            if (gap === "") {
                for (var i = 0; i < partial.length - 1; i++) {
                    properties += partial[i].value + ',';
                    retLabel = Label_1.lub(retLabel, partial[i].label);
                }
                properties += partial[partial.length - 1].value;
                retLabel = Label_1.lub(retLabel, partial[partial.length - 1].label);
                final = '{' + properties + '}';
            }
            else {
                var separator = ",\n" + indent;
                for (var i = 0; i < partial.length - 1; i++) {
                    properties += partial[i].value + separator;
                    retLabel = Label_1.lub(retLabel, partial[i].label);
                }
                properties += partial[partial.length - 1].value;
                retLabel = Label_1.lub(retLabel, partial[partial.length - 1].label);
                final = '{\n' + indent + properties + '\n' + stepback + '}';
            }
        }
        // Pop and remove JO_property
        var v = stack.pop();
        v.Delete(JO_key);
        indent = stepback;
        return new Value_1.Value(final, retLabel);
    };
    var JA = function (value) {
        var JA_key = new Value_1.Value("JA_property", Label_1.bot);
        if (!value.Get(JA_key).value) {
            JA_counter++;
            value.DefineOwnProperty(JA_key, {
                value: JA_counter,
                writable: false,
                enumerable: false,
                configurable: false,
                label: Label_1.bot
            }, false);
        }
        else {
            checkCycle(JA_key, value);
        }
        stack.push(value);
        var stepback = indent;
        indent = indent + gap;
        var partial = [];
        var len = value.Get(new Value_1.Value('length', Label_1.bot));
        var index = new Value_1.Value(0, Label_1.bot);
        while (index.value < len.value) {
            var strP = Str(ToString_1.ToString(index), value);
            if (!strP || strP.value === undefined) {
                partial.push(new Value_1.Value("null", retLabel));
            }
            else {
                partial.push(strP);
                retLabel = Label_1.lub(retLabel, strP.label);
            }
            index.value++;
        }
        var final;
        if (partial.length === 0) {
            final = "[]";
        }
        else {
            var properties = "";
            if (gap === "") {
                for (var i = 0; i < partial.length - 1; i++) {
                    properties += partial[i].value + ',';
                    retLabel = Label_1.lub(retLabel, partial[i].label);
                }
                properties += partial[partial.length - 1].value;
                retLabel = Label_1.lub(retLabel, partial[partial.length - 1].label);
                final = '[' + properties + ']';
            }
            else {
                var separator = ",\n" + indent;
                for (var i = 0; i < partial.length - 1; i++) {
                    properties += partial[i].value + separator;
                    retLabel = Label_1.lub(retLabel, partial[i].label);
                }
                properties += partial[partial.length - 1].value;
                retLabel = Label_1.lub(retLabel, partial[partial.length - 1].label);
                final = '[\n' + indent + properties + '\n' + stepback + ']';
            }
        }
        // Pop and remove property of JA_key
        var v = stack.pop();
        v.Delete(JA_key);
        indent = stepback;
        return new Value_1.Value(final, retLabel);
    };
    var checkCycle = function (key, value) {
        for (var i = 0; i < stack.length; i++) {
            if (value.Get(key).value === stack[i].Get(key).value) {
                monitor.Throw("TypeError", 'JSON.stringify: Cyclic structure', Label_1.bot);
            }
        }
    };
    return Str(new Value_1.Value("", Label_1.bot), new Value_1.Value(wrapper, Label_1.bot));
}

},{"../Constants":64,"../Conversion/ToInteger":83,"../Conversion/ToNumber":84,"../Conversion/ToString":87,"../Define":91,"../Label":123,"../Objects/ArrayObject":132,"../Objects/EcmaObject":137,"../Objects/ObjectObject":146,"../Utility/IsCallable":182,"../Value":184,"./BuiltinFunctionObject":134}],143:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Value_1 = require("../Value");
var constants = require("../Constants");
var BuiltinFunctionObject_1 = require("./BuiltinFunctionObject");
var ToNumber_1 = require("../Conversion/ToNumber");
var Define_1 = require("../Define");
var EcmaObject_1 = require("../Objects/EcmaObject");
var Label_1 = require("../Label");
// ------------------------------------------------------------
// The Math Object, 15.8.2
var MathObject = /** @class */ (function (_super) {
    __extends(MathObject, _super);
    function MathObject(host) {
        var _this = _super.call(this) || this;
        _this.Class = 'Math';
        // not mandated by standard
        _this.Extensible = true;
        _this.host = host;
        return _this;
    }
    MathObject.prototype.Setup = function () {
        this.Prototype = new Value_1.Value(monitor.instances.ObjectPrototype, Label_1.bot);
        Define_1.DefineFFF(this, constants.length, 1);
        Define_1.DefineFFF(this, constants.prototype, monitor.instances.ObjectPrototype);
        Define_1.DefineFFF(this, constants.E, this.host.E);
        Define_1.DefineFFF(this, constants.LN10, this.host.LN10);
        Define_1.DefineFFF(this, constants.LN2, this.host.LN2);
        Define_1.DefineFFF(this, constants.LOG2E, this.host.LOG2E);
        Define_1.DefineFFF(this, constants.LOG10E, this.host.LOG10E);
        Define_1.DefineFFF(this, constants.PI, this.host.PI);
        Define_1.DefineFFF(this, constants.SQRT1_2, this.host.SQRT1_2);
        Define_1.DefineFFF(this, constants.SQRT2, this.host.SQRT2);
        //@ts-ignore TYPES
        Define_1.DefineTFT(this, constants.abs, new BuiltinFunctionObject_1.BuiltinFunctionObject(abs, 1, this.host.abs));
        //@ts-ignore TYPES
        Define_1.DefineTFT(this, constants.acos, new BuiltinFunctionObject_1.BuiltinFunctionObject(acos, 1, this.host.acos));
        //@ts-ignore TYPES
        Define_1.DefineTFT(this, constants.asin, new BuiltinFunctionObject_1.BuiltinFunctionObject(asin, 1, this.host.asin));
        //@ts-ignore TYPES
        Define_1.DefineTFT(this, constants.atan, new BuiltinFunctionObject_1.BuiltinFunctionObject(atan, 1, this.host.atan));
        //@ts-ignore TYPES
        Define_1.DefineTFT(this, constants.atan2, new BuiltinFunctionObject_1.BuiltinFunctionObject(atan2, 2, this.host.atan2));
        //@ts-ignore TYPES
        Define_1.DefineTFT(this, constants.ceil, new BuiltinFunctionObject_1.BuiltinFunctionObject(ceil, 1, this.host.ceil));
        //@ts-ignore TYPES
        Define_1.DefineTFT(this, constants.cos, new BuiltinFunctionObject_1.BuiltinFunctionObject(cos, 1, this.host.cos));
        //@ts-ignore TYPES
        Define_1.DefineTFT(this, constants.exp, new BuiltinFunctionObject_1.BuiltinFunctionObject(exp, 1, this.host.exp));
        //@ts-ignore TYPES
        Define_1.DefineTFT(this, constants.floor, new BuiltinFunctionObject_1.BuiltinFunctionObject(floor, 1, this.host.floor));
        //@ts-ignore TYPES
        Define_1.DefineTFT(this, constants.log, new BuiltinFunctionObject_1.BuiltinFunctionObject(log, 1, this.host.log));
        //@ts-ignore TYPES
        Define_1.DefineTFT(this, constants.max, new BuiltinFunctionObject_1.BuiltinFunctionObject(max, 2, this.host.max));
        //@ts-ignore TYPES
        Define_1.DefineTFT(this, constants.min, new BuiltinFunctionObject_1.BuiltinFunctionObject(min, 2, this.host.min));
        //@ts-ignore TYPES
        Define_1.DefineTFT(this, constants.pow, new BuiltinFunctionObject_1.BuiltinFunctionObject(pow, 2, this.host.pow));
        //@ts-ignore TYPES
        Define_1.DefineTFT(this, constants.random, new BuiltinFunctionObject_1.BuiltinFunctionObject(random, 0, this.host.random));
        //@ts-ignore TYPES
        Define_1.DefineTFT(this, constants.round, new BuiltinFunctionObject_1.BuiltinFunctionObject(round, 1, this.host.round));
        //@ts-ignore TYPES
        Define_1.DefineTFT(this, constants.sin, new BuiltinFunctionObject_1.BuiltinFunctionObject(sin, 1, this.host.sin));
        //@ts-ignore TYPES
        Define_1.DefineTFT(this, constants.sqrt, new BuiltinFunctionObject_1.BuiltinFunctionObject(sqrt, 1, this.host.sqrt));
        //@ts-ignore TYPES
        Define_1.DefineTFT(this, constants.tan, new BuiltinFunctionObject_1.BuiltinFunctionObject(tan, 1, this.host.tan));
    };
    return MathObject;
}(EcmaObject_1.EcmaObject));
exports.MathObject = MathObject;
// ------------------------------------------------------------
// abs, 15.8.2.1
function abs(thisArg, args) {
    var x = args[0] ? ToNumber_1.ToNumber(args[0]) : new Value_1.Value(NaN, Label_1.bot);
    return new Value_1.Value(this.host(x.value), x.label);
}
// ------------------------------------------------------------
// acos, 15.8.2.2
function acos(thisArg, args) {
    var x = args[0] ? ToNumber_1.ToNumber(args[0]) : new Value_1.Value(NaN, Label_1.bot);
    return new Value_1.Value(this.host(x.value), x.label);
}
// ------------------------------------------------------------
// asin, 15.8.2.3
function asin(thisArg, args) {
    var x = args[0] ? ToNumber_1.ToNumber(args[0]) : new Value_1.Value(NaN, Label_1.bot);
    return new Value_1.Value(this.host(x.value), x.label);
}
// ------------------------------------------------------------
// atan, 15.8.2.4
function atan(thisArg, args) {
    var x = args[0] ? ToNumber_1.ToNumber(args[0]) : new Value_1.Value(NaN, Label_1.bot);
    return new Value_1.Value(this.host(x.value), x.label);
}
// ------------------------------------------------------------
// atan2, 15.8.2.5
function atan2(thisArg, args) {
    var x = args[0] ? ToNumber_1.ToNumber(args[0]) : new Value_1.Value(NaN, Label_1.bot);
    var y = args[1] ? ToNumber_1.ToNumber(args[1]) : new Value_1.Value(NaN, Label_1.bot);
    return new Value_1.Value(this.host(x.value, y.value), Label_1.lub(x.label, y.label));
}
// ------------------------------------------------------------
// ceil, 15.8.2.6
function ceil(thisArg, args) {
    var x = args[0] ? ToNumber_1.ToNumber(args[0]) : new Value_1.Value(NaN, Label_1.bot);
    return new Value_1.Value(this.host(x.value), x.label);
}
// ------------------------------------------------------------
// cos, 15.8.2.7
function cos(thisArg, args) {
    var x = args[0] ? ToNumber_1.ToNumber(args[0]) : new Value_1.Value(NaN, Label_1.bot);
    return new Value_1.Value(this.host(x.value), x.label);
}
// ------------------------------------------------------------
// exp, 15.8.2.8
function exp(thisArg, args) {
    var x = args[0] ? ToNumber_1.ToNumber(args[0]) : new Value_1.Value(NaN, Label_1.bot);
    return new Value_1.Value(this.host(x.value), x.label);
}
// ------------------------------------------------------------
// floor, 15.8.2.9
function floor(thisArg, args) {
    var x = args[0] ? ToNumber_1.ToNumber(args[0]) : new Value_1.Value(NaN, Label_1.bot);
    return new Value_1.Value(this.host(x.value), x.label);
}
// ------------------------------------------------------------
// log, 15.8.2.10
function log(thisArg, args) {
    var x = args[0] ? ToNumber_1.ToNumber(args[0]) : new Value_1.Value(NaN, Label_1.bot);
    return new Value_1.Value(this.host(x.value), x.label);
}
// ------------------------------------------------------------
// max, 15.8.2.11
function max(thisArg, args) {
    if (args.length === 0)
        return new Value_1.Value(Number.NEGATIVE_INFINITY, Label_1.bot);
    var myArgs = [];
    var l = Label_1.bot;
    for (var i = 0; i < args.length; i++) {
        myArgs[i] = args[i].value;
        l = Label_1.lub(l, args[i].label);
    }
    return new Value_1.Value(this.host.apply(null, myArgs), l);
}
// ------------------------------------------------------------
// min, 15.8.2.12
function min(thisArg, args) {
    if (args.length === 0)
        return new Value_1.Value(Number.POSITIVE_INFINITY, Label_1.bot);
    var myArgs = [];
    var l = Label_1.bot;
    for (var i = 0; i < args.length; i++) {
        myArgs[i] = args[i].value;
        l = Label_1.lub(l, args[i].label);
    }
    return new Value_1.Value(this.host.apply(null, myArgs), l);
}
// ------------------------------------------------------------
// pow, 15.8.2.13
function pow(thisArg, args) {
    var x = args[0] ? ToNumber_1.ToNumber(args[0]) : new Value_1.Value(NaN, Label_1.bot);
    var y = args[1] ? ToNumber_1.ToNumber(args[1]) : new Value_1.Value(NaN, Label_1.bot);
    return new Value_1.Value(this.host(x.value, y.value), Label_1.lub(x.label, y.label));
}
// ------------------------------------------------------------
// random, 15.8.2.14
function random(thisArg, args) {
    return new Value_1.Value(this.host(), Label_1.bot);
}
// ------------------------------------------------------------
// round, 15.8.2.15
function round(thisArg, args) {
    var x = args[0] ? ToNumber_1.ToNumber(args[0]) : new Value_1.Value(NaN, Label_1.bot);
    return new Value_1.Value(this.host(x.value), x.label);
}
// ------------------------------------------------------------
// sin, 15.8.2.16
function sin(thisArg, args) {
    var x = args[0] ? ToNumber_1.ToNumber(args[0]) : new Value_1.Value(NaN, Label_1.bot);
    return new Value_1.Value(this.host(x.value), x.label);
}
// ------------------------------------------------------------
// sqrt, 15.8.2.17
function sqrt(thisArg, args) {
    var x = args[0] ? ToNumber_1.ToNumber(args[0]) : new Value_1.Value(NaN, Label_1.bot);
    return new Value_1.Value(this.host(x.value), x.label);
}
// ------------------------------------------------------------
// tan, 15.8.2.18
function tan(thisArg, args) {
    var x = args[0] ? ToNumber_1.ToNumber(args[0]) : new Value_1.Value(NaN, Label_1.bot);
    return new Value_1.Value(this.host(x.value), x.label);
}

},{"../Constants":64,"../Conversion/ToNumber":84,"../Define":91,"../Label":123,"../Objects/EcmaObject":137,"../Value":184,"./BuiltinFunctionObject":134}],144:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Value_1 = require("../Value");
var EcmaObject_1 = require("../Objects/EcmaObject");
var constants = require("../Constants");
var ToString_1 = require("../Conversion/ToString");
var Label_1 = require("../Label");
// ------------------------------------------------------------
var NativeErrorObject = /** @class */ (function (_super) {
    __extends(NativeErrorObject, _super);
    function NativeErrorObject(proto, v) {
        var _this = _super.call(this) || this;
        _this.Prototype = new Value_1.Value(proto, Label_1.bot);
        _this.Class = 'Error';
        _this.Extensible = true;
        var message = new Value_1.Value("", Label_1.bot);
        if (v.value !== undefined) {
            message = ToString_1.ToString(v);
        }
        _this.DefineOwnProperty(constants.message, {
            value: message.value,
            label: message.label,
            writable: true,
            enumerable: false,
            configurable: true
        });
        // for toString
        _this.message = message.value;
        _this.stack = monitor.stackTrace();
        _this.nativeStack = Error().stack;
        return _this;
    }
    NativeErrorObject.prototype.toString = function () {
        var str = this.Type + ': ' + this.message + '\n' + this.stack.toString() + '\n' + this.nativeStack;
        return str;
    };
    return NativeErrorObject;
}(EcmaObject_1.EcmaObject));
exports.NativeErrorObject = NativeErrorObject;

},{"../Constants":64,"../Conversion/ToString":87,"../Label":123,"../Objects/EcmaObject":137,"../Value":184}],145:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Label_1 = require("../Label");
var Value_1 = require("../Value");
var EcmaObject_1 = require("../Objects/EcmaObject");
// ------------------------------------------------------------
// Number Object, 15.7.5
var NumberObject = /** @class */ (function (_super) {
    __extends(NumberObject, _super);
    function NumberObject(val, lbl) {
        var _this = _super.call(this) || this;
        _this.Class = 'Number';
        _this.PrimitiveValue = new monitor.instances.NumberConstructor.host(val);
        _this.PrimitiveLabel = lbl;
        _this.Extensible = true;
        _this.Prototype = new Value_1.Value(monitor.instances.NumberPrototype, Label_1.bot);
        return _this;
    }
    return NumberObject;
}(EcmaObject_1.EcmaObject));
exports.NumberObject = NumberObject;
// ---
function IsNumberObject(x) {
    return typeof x.value === 'object' && x.value !== null && x.value.Class === 'Number';
}
exports.IsNumberObject = IsNumberObject;

},{"../Label":123,"../Objects/EcmaObject":137,"../Value":184}],146:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Label_1 = require("../Label");
var Value_1 = require("../Value");
var EcmaObject_1 = require("../Objects/EcmaObject");
// ------------------------------------------------------------
// Object objects, 15.2.2.1
var ObjectObject = /** @class */ (function (_super) {
    __extends(ObjectObject, _super);
    function ObjectObject() {
        var _this = _super.call(this) || this;
        _this.Prototype = new Value_1.Value(monitor.instances.ObjectPrototype, Label_1.bot);
        _this.Class = 'Object';
        _this.Extensible = true;
        return _this;
        // this.host      = {};
    }
    return ObjectObject;
}(EcmaObject_1.EcmaObject));
exports.ObjectObject = ObjectObject;
// ---
ObjectObject.prototype.toString = function () {
    var properties = [];
    for (var x in this.properties) {
        if (this.properties.hasOwnProperty(x)) {
            properties.push(x + ': ' + this.properties[x]);
        }
    }
    return '{' + properties.join(', ') + '}';
};
// ------------------------------------------------------------

},{"../Label":123,"../Objects/EcmaObject":137,"../Value":184}],147:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var NativeErrorObject_1 = require("./NativeErrorObject");
// ------------------------------------------------------------
var RangeErrorObject = /** @class */ (function (_super) {
    __extends(RangeErrorObject, _super);
    function RangeErrorObject(v) {
        var _this = _super.call(this, monitor.instances.RangeErrorPrototype, v) || this;
        _this.Type = 'RangeError';
        return _this;
    }
    return RangeErrorObject;
}(NativeErrorObject_1.NativeErrorObject));
exports.RangeErrorObject = RangeErrorObject;

},{"./NativeErrorObject":144}],148:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var NativeErrorObject_1 = require("./NativeErrorObject");
// ------------------------------------------------------------
var ReferenceErrorObject = /** @class */ (function (_super) {
    __extends(ReferenceErrorObject, _super);
    function ReferenceErrorObject(v) {
        var _this = _super.call(this, monitor.instances.ReferenceErrorPrototype, v) || this;
        _this.Type = 'ReferenceError';
        return _this;
    }
    return ReferenceErrorObject;
}(NativeErrorObject_1.NativeErrorObject));
exports.ReferenceErrorObject = ReferenceErrorObject;

},{"./NativeErrorObject":144}],149:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Value_1 = require("../Value");
var constants = require("../Constants");
var Label_1 = require("../Label");
var EcmaObject_1 = require("../Objects/EcmaObject");
// ------------------------------------------------------------
// RegExp Object, 15.10.4.1
var RegExpObject = /** @class */ (function (_super) {
    __extends(RegExpObject, _super);
    function RegExpObject(nativeRegExp, l) {
        var _this = _super.call(this) || this;
        _this.Class = 'RegExp';
        _this.PrimitiveValue = nativeRegExp;
        _this.PrimitiveLabel = l;
        _this.Extensible = true;
        _this.Prototype = new Value_1.Value(monitor.instances.RegExpPrototype, Label_1.bot);
        _this.DefineOwnProperty(constants.source, {
            value: _this.PrimitiveValue.source,
            writable: false,
            enumerable: false,
            configurable: false,
            label: l
        });
        _this.DefineOwnProperty(constants.global, {
            value: _this.PrimitiveValue.global,
            writable: false,
            enumerable: false,
            configurable: false,
            label: l
        });
        _this.DefineOwnProperty(constants.ignoreCase, {
            value: _this.PrimitiveValue.ignoreCase,
            writable: false,
            enumerable: false,
            configurable: false,
            label: l
        });
        _this.DefineOwnProperty(constants.multiline, {
            value: _this.PrimitiveValue.multiline,
            writable: false,
            enumerable: false,
            configurable: false,
            label: l
        });
        _this.DefineOwnProperty(constants.lastIndex, {
            value: _this.PrimitiveValue.lastIndex,
            writable: true,
            enumerable: false,
            configurable: false,
            label: l
        });
        return _this;
    }
    RegExpObject.prototype.toString = function () {
        var v = this.PrimitiveValue.toString();
        return v;
    };
    return RegExpObject;
}(EcmaObject_1.EcmaObject));
exports.RegExpObject = RegExpObject;
function IsRegExpObject(x) {
    return typeof x.value === 'object' && x.value !== null && x.value !== undefined && x.value.Class === 'RegExp';
}
exports.IsRegExpObject = IsRegExpObject;

},{"../Constants":64,"../Label":123,"../Objects/EcmaObject":137,"../Value":184}],150:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Value_1 = require("../Value");
var EcmaObject_1 = require("../Objects/EcmaObject");
var Label_1 = require("../Label");
// ------------------------------------------------------------
// String Object, 15.5.5
var StringObject = /** @class */ (function (_super) {
    __extends(StringObject, _super);
    function StringObject(val, lbl) {
        var _this = _super.call(this) || this;
        _this.Class = 'String';
        _this.PrimitiveValue = val;
        lbl = lbl || Label_1.bot;
        _this.PrimitiveLabel = lbl;
        // TODO: how to solve this to work with EcmaObject properly
        //@ts-ignore TYPES
        _this.properties = new String(val);
        for (var i = 0, len = val.length; i < len; i++) {
            _this.labels[i] = {
                value: lbl,
                existence: lbl
            };
        }
        _this.labels.length = {
            value: lbl,
            existence: lbl
        };
        _this.Extensible = true;
        _this.Prototype = new Value_1.Value(monitor.instances.StringPrototype, Label_1.bot);
        return _this;
        // length is not modeled in this way, but by GetOwnProperty; however, e.g.,
        // delete will use the properties field for deletion. Thus, we add a fake model.
        //   ecma.DefineFFF(this, constants.length, 0);
    }
    return StringObject;
}(EcmaObject_1.EcmaObject));
exports.StringObject = StringObject;
function IsStringObject(x) {
    return typeof x.value === 'object' && x.value !== null && x.value.Class === 'String';
}
exports.IsStringObject = IsStringObject;

},{"../Label":123,"../Objects/EcmaObject":137,"../Value":184}],151:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var NativeErrorObject_1 = require("./NativeErrorObject");
// ------------------------------------------------------------
var SyntaxErrorObject = /** @class */ (function (_super) {
    __extends(SyntaxErrorObject, _super);
    function SyntaxErrorObject(v) {
        var _this = _super.call(this, monitor.instances.SyntaxErrorPrototype, v) || this;
        _this.Type = 'SyntaxError';
        return _this;
    }
    return SyntaxErrorObject;
}(NativeErrorObject_1.NativeErrorObject));
exports.SyntaxErrorObject = SyntaxErrorObject;

},{"./NativeErrorObject":144}],152:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var NativeErrorObject_1 = require("./NativeErrorObject");
// ------------------------------------------------------------
var TypeErrorObject = /** @class */ (function (_super) {
    __extends(TypeErrorObject, _super);
    function TypeErrorObject(v) {
        var _this = _super.call(this, monitor.instances.TypeErrorPrototype, v) || this;
        _this.Type = 'TypeError';
        return _this;
    }
    return TypeErrorObject;
}(NativeErrorObject_1.NativeErrorObject));
exports.TypeErrorObject = TypeErrorObject;

},{"./NativeErrorObject":144}],153:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var NativeErrorObject_1 = require("./NativeErrorObject");
// ------------------------------------------------------------
var URIErrorObject = /** @class */ (function (_super) {
    __extends(URIErrorObject, _super);
    function URIErrorObject(v) {
        var _this = _super.call(this, monitor.instances.URIErrorPrototype, v) || this;
        _this.Type = 'URIError';
        return _this;
    }
    return URIErrorObject;
}(NativeErrorObject_1.NativeErrorObject));
exports.URIErrorObject = URIErrorObject;

},{"./NativeErrorObject":144}],154:[function(require,module,exports){
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
var Option = /** @class */ (function () {
    function Option(type, val, desc) {
        this.type = type;
        this.set(val);
        this.def = this.value;
        this.description = desc;
    }
    Option.prototype.set = function (val) {
        var v = String(val);
        if (this.type === 'string') {
            this.value = v;
        }
        else if (this.type === 'boolean') {
            this.value = v === 'true' || v === '1';
        }
        else if (this.type === 'number') {
            this.value = Number(v);
        }
    };
    Option.prototype.getDefault = function () {
        return this.def;
    };
    Option.prototype.valueOf = function () {
        return this.value;
    };
    Option.prototype.toString = function () {
        return String(this.value);
    };
    return Option;
}());
// -------------------------------------------------------------
// Options
var Options = /** @class */ (function () {
    function Options() {
        this.options = {};
    }
    Options.prototype.declare = function (name, type, def, desc) {
        var description = desc ? desc : name;
        this.options[name] = new Option(type, def, description);
    };
    Options.prototype.has = function (name) {
        return this.options[name] !== undefined;
    };
    Options.prototype.get = function (name) {
        return this.options[name].valueOf();
    };
    Options.prototype.getOption = function (name) {
        return this.options[name];
    };
    Options.prototype.set = function (name, value) {
        this.options[name].set(value);
    };
    Options.prototype.keys = function () {
        var res = [];
        for (var x in this.options) {
            if (this.options.hasOwnProperty(x)) {
                res.push(x);
            }
        }
        return res;
    };
    Options.prototype.report = function () {
        for (var name in this.options) {
            monitor.info(name + " : " + this.options[name].toString());
        }
    };
    return Options;
}());
exports.Options = Options;

},{}],155:[function(require,module,exports){
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
var escodegen_1 = require("escodegen");
exports.pretty = escodegen_1.generate;

},{"escodegen":5}],156:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
// ------------------------------------------------------------
// Property descriptors, 8.10
function IsAccessorDescriptor(pd) {
    if (pd === undefined) {
        return false;
    }
    else {
        return ('get' in pd || 'put' in pd);
    }
}
exports.IsAccessorDescriptor = IsAccessorDescriptor;
function IsDataDescriptor(pd) {
    if (pd === undefined) {
        return false;
    }
    else {
        return ('value' in pd || 'writable' in pd);
    }
}
exports.IsDataDescriptor = IsDataDescriptor;

},{}],157:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Value_1 = require("../Value");
var constants = require("../Constants");
var BuiltinFunctionObject_1 = require("../Objects/BuiltinFunctionObject");
var Label_1 = require("../Label");
var Define_1 = require("../Define");
var EcmaObject_1 = require("../Objects/EcmaObject");
var ArrayObject_1 = require("../Objects/ArrayObject");
var ToBoolean_1 = require("../Conversion/ToBoolean");
var ToInteger_1 = require("../Conversion/ToInteger");
var ToString_1 = require("../Conversion/ToString");
var ToObject_1 = require("../Conversion/ToObject");
var IsCallable_1 = require("../Utility/IsCallable");
var ToUInt32_1 = require("../Conversion/ToUInt32");
// ------------------------------------------------------------
// 15.4.4
var ArrayPrototype = /** @class */ (function (_super) {
    __extends(ArrayPrototype, _super);
    function ArrayPrototype(host) {
        var _this = _super.call(this) || this;
        _this.Class = 'Array';
        _this.host = host;
        return _this;
    }
    ArrayPrototype.prototype.Setup = function () {
        this.Prototype = new Value_1.Value(monitor.instances.ObjectPrototype, Label_1.bot);
        Define_1.DefineTFT(this, constants.constructor, monitor.instances.ArrayConstructor);
        Define_1.DefineTFF(this, constants.length, 0);
        Define_1.DefineTFT(this, constants.toString, new BuiltinFunctionObject_1.BuiltinFunctionObject(toString, 0, Array.prototype.toString));
        Define_1.DefineTFT(this, constants.toLocaleString, new BuiltinFunctionObject_1.BuiltinFunctionObject(toLocaleString, 0, Array.prototype.toLocaleString));
        Define_1.DefineTFT(this, constants.concat, new BuiltinFunctionObject_1.BuiltinFunctionObject(concat, 1, Array.prototype.concat));
        Define_1.DefineTFT(this, constants.join, new BuiltinFunctionObject_1.BuiltinFunctionObject(join, 1, Array.prototype.join));
        Define_1.DefineTFT(this, constants.pop, new BuiltinFunctionObject_1.BuiltinFunctionObject(pop, 0, Array.prototype.pop));
        Define_1.DefineTFT(this, constants.push, new BuiltinFunctionObject_1.BuiltinFunctionObject(push, 1, Array.prototype.push));
        Define_1.DefineTFT(this, constants.reverse, new BuiltinFunctionObject_1.BuiltinFunctionObject(reverse, 0, Array.prototype.reverse));
        Define_1.DefineTFT(this, constants.shift, new BuiltinFunctionObject_1.BuiltinFunctionObject(shift, 0, Array.prototype.shift));
        Define_1.DefineTFT(this, constants.slice, new BuiltinFunctionObject_1.BuiltinFunctionObject(slice, 2, Array.prototype.slice));
        Define_1.DefineTFT(this, constants.sort, new BuiltinFunctionObject_1.BuiltinFunctionObject(sort, 1, Array.prototype.sort));
        Define_1.DefineTFT(this, constants.splice, new BuiltinFunctionObject_1.BuiltinFunctionObject(splice, 2, Array.prototype.splice));
        Define_1.DefineTFT(this, constants.unshift, new BuiltinFunctionObject_1.BuiltinFunctionObject(unshift, 1, Array.prototype.unshift));
        Define_1.DefineTFT(this, constants.indexOf, new BuiltinFunctionObject_1.BuiltinFunctionObject(indexOf, 1, Array.prototype.indexOf));
        Define_1.DefineTFT(this, constants.lastIndexOf, new BuiltinFunctionObject_1.BuiltinFunctionObject(lastIndexOf, 1, Array.prototype.lastIndexOf));
        Define_1.DefineTFT(this, constants.every, new BuiltinFunctionObject_1.BuiltinFunctionObject(every, 1, Array.prototype.every));
        Define_1.DefineTFT(this, constants.some, new BuiltinFunctionObject_1.BuiltinFunctionObject(some, 1, Array.prototype.some));
        Define_1.DefineTFT(this, constants.forEach, new BuiltinFunctionObject_1.BuiltinFunctionObject(forEach, 1, Array.prototype.forEach));
        Define_1.DefineTFT(this, constants.map, new BuiltinFunctionObject_1.BuiltinFunctionObject(map, 1, Array.prototype.map));
        Define_1.DefineTFT(this, constants.filter, new BuiltinFunctionObject_1.BuiltinFunctionObject(filter, 1, Array.prototype.filter));
        Define_1.DefineTFT(this, constants.reduce, new BuiltinFunctionObject_1.BuiltinFunctionObject(reduce, 1, Array.prototype.reduce));
        Define_1.DefineTFT(this, constants.reduceRight, new BuiltinFunctionObject_1.BuiltinFunctionObject(reduceRight, 1, Array.prototype.reduceRight));
    };
    return ArrayPrototype;
}(EcmaObject_1.EcmaObject));
exports.ArrayPrototype = ArrayPrototype;
// ------------------------------------------------------------
// toString, 15.4.4.2
function toString(thisArg, args) {
    var array = ToObject_1.ToObject(thisArg);
    var func = array.Get(constants.join);
    if (!IsCallable_1.IsCallable(func)) {
        func = monitor.instances.ObjectPrototype.Get(constants.toString);
    }
    // @ts-ignore
    return func.value.Call(array, []);
}
// ------------------------------------------------------------
// toLocaleString, 15.4.4.3
function toLocaleString(thisArg, args) {
    var array = ToObject_1.ToObject(thisArg);
    var arrayLen = array.Get(new Value_1.Value("length", Label_1.bot));
    var len = ToUInt32_1.ToUInt32(arrayLen);
    var separator = ',';
    var label = Label_1.lub(monitor.context.effectivePC, array.label);
    if (len.value === 0) {
        return new Value_1.Value("", label);
    }
    var firstElement = array.Get(new Value_1.Value("0", Label_1.bot));
    var R;
    if (firstElement.value === undefined || firstElement.value === null) {
        R = new Value_1.Value("", label);
    }
    else {
        var elementObj = ToObject_1.ToObject(firstElement);
        var func = elementObj.Get(new Value_1.Value("toLocaleString", Label_1.bot));
        if (!IsCallable_1.IsCallable(func)) {
            monitor.Throw("TypeError", 'Array.prototype.toLocaleString: not a function', Label_1.bot);
            throw 'TypeScript;';
        }
        // ES6 standard is doing this, and ES5 should be able to handle it
        R = ToString_1.ToString(func.value.Call(elementObj, []));
    }
    var k = 1;
    while (k < len.value) {
        //@ts-ignore TYPES
        var S = R.value.concat(separator);
        var nextElement = array.Get(new Value_1.Value('' + k, Label_1.bot));
        if (nextElement.value === undefined || firstElement.value === null) {
            R = new Value_1.Value("", label);
        }
        else {
            var elementObj = ToObject_1.ToObject(nextElement);
            var func = elementObj.Get(new Value_1.Value("toLocaleString", Label_1.bot));
            if (!IsCallable_1.IsCallable(func)) {
                monitor.Throw("TypeError", 'Array.prototype.toLocaleString: not a function', Label_1.bot);
                throw 'TypeScript;';
            }
            // ES6 standard is doing this, and ES5 should be able to handle it
            R = ToString_1.ToString(func.value.Call(elementObj, []));
        }
        R = new Value_1.Value(S.concat(R.value), R.label);
        k++;
    }
    R.raise(label);
    //@ts-ignore TYPES
    return R;
}
// ------------------------------------------------------------
// concat, 15.4.4.4
function concat(thisArg, args) {
    var O = ToObject_1.ToObject(thisArg);
    var A = new ArrayObject_1.ArrayObject();
    var n = 0;
    var c = monitor.context;
    var label = new Label_1.Label();
    function aux(E) {
        c.pushPC(E.label);
        label = Label_1.lub(label, E.label);
        if (E.value && E.value.Class === 'Array') {
            var k = 0;
            var len = E.Get(constants.length);
            label = Label_1.lub(label, len.label);
            monitor.context.pushPC(len.label);
            while (k < len.value) {
                var _k = new Value_1.Value(k, Label_1.bot);
                var exists = E.HasProperty(_k);
                if (exists.value) {
                    monitor.context.pushPC(exists.label);
                    var subElement = E.Get(_k);
                    A.DefineOwnProperty(new Value_1.Value(n, label), {
                        value: subElement.value,
                        label: subElement.label,
                        writable: true,
                        enumerable: true,
                        configurable: true
                    }, false);
                    monitor.context.popPC();
                }
                n++;
                k++;
            }
            monitor.context.popPC();
        }
        else {
            A.DefineOwnProperty(new Value_1.Value(n, label), {
                value: E.value,
                label: E.label,
                writable: true,
                enumerable: true,
                configurable: true
            }, false);
            n++;
        }
        c.popPC();
    }
    aux(O);
    for (var i = 0, len = args.length; i < len; i++) {
        aux(args[i]);
    }
    // This is a fix they added in ECMA-262 v6 standard, but browsers used it
    // in ECMA-262 v5 as well.
    A.Put(new Value_1.Value("length", Label_1.bot), new Value_1.Value(n, Label_1.bot), false);
    return new Value_1.Value(A, Label_1.bot);
}
;
// ------------------------------------------------------------
// join, 15.4.4.5
function join(thisArg, args) {
    var O = ToObject_1.ToObject(thisArg);
    var len = ToUInt32_1.ToUInt32(O.Get(constants.length));
    var arg0 = args[0] || new Value_1.Value(',', Label_1.bot);
    var separator;
    if (arg0.value === undefined) {
        separator = new Value_1.Value(',', arg0.label);
    }
    else {
        separator = ToString_1.ToString(arg0);
    }
    var label = Label_1.lub(len.label, separator.label);
    var arr = [];
    for (var i = 0; i < len.value; i++) {
        var v = O.Get(new Value_1.Value(i, Label_1.bot));
        var y = void 0;
        if (v.value === undefined || v.value === null) {
            y = new Value_1.Value('', v.label);
        }
        else {
            y = ToString_1.ToString(v);
        }
        arr[i] = y.value;
        label = Label_1.lub(label, y.label);
    }
    var res = arr.join(separator.value);
    return new Value_1.Value(res, label);
}
// ------------------------------------------------------------
// pop, 15.4.4.6
function pop(thisArg, args) {
    var O = ToObject_1.ToObject(thisArg);
    var len = ToUInt32_1.ToUInt32(O.Get(constants.length));
    if (len.value === 0) {
        O.Put(constants.length, len, true);
        return new Value_1.Value(undefined, len.label);
    }
    var indx = new Value_1.Value(len.value - 1, len.label);
    var element = O.Get(indx);
    O.Delete(indx, true);
    O.Put(constants.length, indx, true);
    return element;
}
// ------------------------------------------------------------
// push, 15.4.4.7
function push(thisArg, args) {
    var O = ToObject_1.ToObject(thisArg);
    var n = ToUInt32_1.ToUInt32(O.Get(constants.length));
    for (var i = 0, len = args.length; i < len; i++) {
        var E = args[i];
        O.Put(n, E);
        n.value++;
    }
    O.Put(constants.length, n, true);
    return n;
}
// ------------------------------------------------------------
// reverse, 15.4.4.8
function reverse(thisArg, args) {
    var O = ToObject_1.ToObject(thisArg);
    var len = ToUInt32_1.ToUInt32(O.Get(constants.length));
    var middle = Math.floor(len.value / 2);
    var lower = 0;
    var c = monitor.context;
    while (lower !== middle && lower > -2) {
        var upper = len.value - lower - 1;
        var upperP = ToString_1.ToString(new Value_1.Value(upper, len.label));
        var lowerP = ToString_1.ToString(new Value_1.Value(lower, len.label));
        var lowerValue = O.Get(lowerP);
        var upperValue = O.Get(upperP);
        var lowerExists = O.HasProperty(lowerP);
        var upperExists = O.HasProperty(upperP);
        c.pushPC(Label_1.lub(lowerExists.label, upperExists.label, len.label));
        if (lowerExists.value && upperExists.value) {
            O.Put(lowerP, upperValue, true);
            O.Put(upperP, lowerValue, true);
        }
        else if (!lowerExists.value && upperExists.value) {
            O.Put(lowerP, upperValue, true);
            O.Delete(upperP, true);
        }
        else if (lowerExists.value && !upperExists.value) {
            O.Delete(lowerP, true);
            O.Put(upperP, lowerValue, true);
        }
        c.popPC();
        lower++;
    }
    return O;
}
// ------------------------------------------------------------
// shift, 15.4.4.9
function shift(thisArg, args) {
    var O = ToObject_1.ToObject(thisArg);
    var lenVal = O.Get(constants.length);
    var len = ToUInt32_1.ToUInt32(lenVal);
    if (len.value === 0) {
        monitor.context.pushPC(len.label);
        O.Put(constants.length, len, true);
        monitor.context.popPC();
        return new Value_1.Value(undefined, len.label);
    }
    var first = O.Get(new Value_1.Value(0, Label_1.bot));
    var k = 1;
    monitor.context.pushPC(len.label);
    while (k < len.value) {
        var from = k;
        var _from = new Value_1.Value(from, len.label);
        var to = k - 1;
        var _to = new Value_1.Value(to, len.label);
        var fromPresent = O.HasProperty(_from);
        if (fromPresent.value) {
            monitor.context.pushPC(fromPresent.label);
            var fromVal = O.Get(_from);
            O.Put(_to, fromVal, true);
            monitor.context.popPC();
        }
        else {
            O.Delete(_to, true);
        }
        k++;
    }
    monitor.context.popPC();
    len.value--;
    O.Delete(len, true);
    O.Put(constants.length, len, true);
    return first;
}
// ------------------------------------------------------------
// slice, 15.4.4.10
function slice(thisArg, args) {
    var O = ToObject_1.ToObject(thisArg);
    var A = new ArrayObject_1.ArrayObject();
    var lenVal = O.Get(constants.length);
    var len = ToUInt32_1.ToUInt32(lenVal);
    var start = args[0] ? args[0] : new Value_1.Value(undefined, Label_1.bot);
    var end = args[1] ? args[1] : new Value_1.Value(undefined, Label_1.bot);
    var relativeStart = ToInteger_1.ToInteger(start);
    var k = new Value_1.Value(0, Label_1.lub(len.label, relativeStart.label));
    if (relativeStart.value < 0) {
        k.value = Math.max(len.value + relativeStart.value, 0);
    }
    else {
        k.value = Math.min(relativeStart.value, len.value);
    }
    var relativeEnd;
    if (end.value === undefined) {
        relativeEnd = len;
    }
    else {
        relativeEnd = ToInteger_1.ToInteger(end);
    }
    var _final = new Value_1.Value(0, Label_1.lub(len.label, relativeStart.label));
    if (relativeEnd.value < 0) {
        _final.value = Math.max(len.value + relativeEnd.value, 0);
    }
    else {
        _final.value = Math.min(relativeEnd.value, len.value);
    }
    var n = 0;
    monitor.context.pushPC(Label_1.lub(k.label, _final.label));
    while (k.value < _final.value) {
        var Pk = ToString_1.ToString(k);
        var kPresent = O.HasProperty(Pk);
        if (kPresent.value) {
            var kValue = O.Get(Pk);
            A.DefineOwnProperty(new Value_1.Value(n, Label_1.bot), {
                value: kValue.value,
                label: kValue.label,
                writable: true,
                enumerable: true,
                configurable: true
            }, false);
        }
        k.value++;
        n++;
    }
    monitor.context.popPC();
    return new Value_1.Value(A, Label_1.bot);
}
// ------------------------------------------------------------
// sort, 15.4.4.11
function sort(thisArg, args) {
    var comparefun = args[0] || new Value_1.Value(undefined, Label_1.bot);
    var O = ToObject_1.ToObject(thisArg);
    var lenVal = O.Get(constants.length);
    var len = ToUInt32_1.ToUInt32(lenVal);
    var label = Label_1.lub(O.label, len.label);
    var c = monitor.context;
    c.pushPC(len.label);
    var array = [];
    var k = new Value_1.Value(0, len.label);
    while (k.value < len.value) {
        var kPresent = O.HasProperty(k);
        c.labels.pc = Label_1.lub(c.labels.pc, kPresent.label);
        label = Label_1.lub(label, kPresent.label);
        if (kPresent.value) {
            var kValue = O.Get(k);
            kValue.raise(label);
            array[k.value] = kValue;
        }
        k.value++;
    }
    var isCallable = IsCallable_1.IsCallable(comparefun);
    c.labels.pc = Label_1.lub(c.labels.pc, comparefun.label);
    if (comparefun.value !== undefined && !isCallable) {
        monitor.Throw("TypeError", 'Array.prototype.sort: not a function', Label_1.bot);
    }
    var comparefunWrapper;
    if (comparefun.value) {
        comparefunWrapper = function (x, y) {
            if (x.value === undefined) {
                label = Label_1.lub(label, x.label);
                return 1;
            }
            if (y.value === undefined) {
                label = Label_1.lub(label, y.label);
                return -1;
            }
            var result = comparefun.Call(new Value_1.Value(undefined, Label_1.bot), [x, y]);
            c.labels.pc = Label_1.lub(c.labels.pc, result.label, x.label, y.label);
            label = Label_1.lub(label, result.label, x.label, y.label);
            return result.value;
        };
    }
    else {
        comparefunWrapper = function (x, y) {
            if (x.value === undefined) {
                label = Label_1.lub(label, x.label);
                return 1;
            }
            if (y.value === undefined) {
                label = Label_1.lub(label, y.label);
                return -1;
            }
            var xString = ToString_1.ToString(x);
            var yString = ToString_1.ToString(y);
            c.labels.pc = Label_1.lub(c.labels.pc, xString.label, yString.label);
            label = Label_1.lub(label, xString.label, yString.label);
            if (xString.value < yString.value) {
                return -1;
            }
            if (xString.value > yString.value) {
                return 1;
            }
            return 0;
        };
    }
    //@ts-ignore TYPES
    array = array.sort(comparefunWrapper);
    for (var i = 0, len_1 = array.length; i < len_1; i++) {
        var v = array[i];
        if (v) {
            O.Put(new Value_1.Value(i, label), v, true);
        }
        else {
            O.Delete(new Value_1.Value(i, label), true);
        }
    }
    c.popPC();
    return O;
}
// ------------------------------------------------------------
// splice, 15.4.4.12
function splice(thisArg, args) {
    var start = args[0] || new Value_1.Value(undefined, Label_1.bot);
    var arg1 = args[1] || new Value_1.Value(undefined, Label_1.bot);
    var O = ToObject_1.ToObject(thisArg);
    var A = new ArrayObject_1.ArrayObject();
    var lenVal = O.Get(constants.length);
    var len = ToUInt32_1.ToUInt32(lenVal);
    var relativeStart = ToInteger_1.ToInteger(start);
    var actualStart = new Value_1.Value(null, Label_1.lub(len.label, relativeStart.label));
    if (relativeStart.value < 0) {
        actualStart.value = Math.max((len.value + relativeStart.value), 0);
    }
    else {
        actualStart.value = Math.min(relativeStart.value, len.value);
    }
    var deleteCount = ToInteger_1.ToInteger(arg1);
    var actualDeleteCount = new Value_1.Value(null, Label_1.lub(deleteCount.label, actualStart.label));
    actualDeleteCount.value = Math.min(Math.max(deleteCount.value, 0), len.value - actualStart.value);
    var k = 0;
    monitor.context.pushPC(actualDeleteCount.label);
    while (k < actualDeleteCount.value) {
        var from = new Value_1.Value(actualStart.value + k, actualStart.label);
        var fromPresent = O.HasProperty(from);
        monitor.context.pushPC(fromPresent.label);
        if (fromPresent.value) {
            var fromValue = O.Get(from);
            A.DefineOwnProperty(new Value_1.Value(k, actualDeleteCount.label), {
                value: fromValue.value,
                label: fromValue.label,
                writable: true,
                enumerable: true,
                configurable: true
            });
        }
        monitor.context.popPC();
        k++;
    }
    monitor.context.popPC();
    var items = [];
    for (var i = 0; i < args.length - 2; i++) {
        items[i] = args[i + 2];
    }
    var itemCount = items.length;
    if (itemCount < actualDeleteCount.value) {
        var k_1 = actualStart.value;
        monitor.context.pushPC(actualStart.label);
        while (k_1 < len.value - actualDeleteCount.value) {
            var from = new Value_1.Value(k_1 + actualDeleteCount.value, Label_1.lub(actualStart.label, actualDeleteCount.label));
            var to = new Value_1.Value(k_1 + itemCount, actualStart.label);
            var fromPresent = O.HasProperty(from);
            monitor.context.pushPC(fromPresent.label);
            if (fromPresent.value) {
                var fromValue = O.Get(from);
                O.Put(to, fromValue, true);
            }
            else {
                O.Delete(to, true);
            }
            k_1++;
            monitor.context.popPC();
        }
        monitor.context.popPC();
        k_1 = len.value;
        monitor.context.pushPC(Label_1.lub(len.label, actualDeleteCount.label));
        while (k_1 > (len.value - actualDeleteCount.value + itemCount)) {
            O.Delete(new Value_1.Value(k_1, len.label));
            k_1--;
        }
        monitor.context.popPC();
    }
    else if (itemCount > actualDeleteCount.value) {
        var k_2 = len.value - actualDeleteCount.value;
        monitor.context.pushPC(Label_1.lub(len.label, actualDeleteCount.label));
        while (k_2 > actualStart.value) {
            var from = new Value_1.Value(k_2 + actualDeleteCount.value - 1, actualDeleteCount.label);
            var to = new Value_1.Value(k_2 + itemCount - 1, Label_1.bot);
            var fromPresent = O.HasProperty(from);
            if (fromPresent.value) {
                var fromValue = O.Get(from);
                O.Put(to, fromValue, true);
            }
            else {
                O.Delete(to, true);
            }
            k_2--;
        }
        monitor.context.popPC();
    }
    k = actualStart.value;
    for (var i = 0; i < items.length; i++) {
        O.Put(new Value_1.Value(k + i, actualStart.label), items[i], true);
    }
    O.Put(constants.length, new Value_1.Value(len.value - actualDeleteCount.value + itemCount, Label_1.lub(len.label, actualDeleteCount.label)), true);
    return new Value_1.Value(A, Label_1.bot);
}
// ------------------------------------------------------------
// unshift, 15.4.4.13
function unshift(thisArg, args) {
    var O = ToObject_1.ToObject(thisArg);
    var lenVal = O.Get(constants.length);
    var len = ToUInt32_1.ToUInt32(lenVal);
    var argCount = args.length;
    var k = len.value;
    monitor.context.pushPC(len.label);
    while (k > 0) {
        var from = new Value_1.Value(k - 1, len.label);
        var to = new Value_1.Value(k + argCount - 1, len.label);
        var fromPresent = O.HasProperty(from);
        monitor.context.pushPC(fromPresent.label);
        if (fromPresent.value) {
            var fromValue = O.Get(from);
            O.Put(to, fromValue, true);
        }
        else {
            O.Delete(to, true);
        }
        monitor.context.popPC();
        k--;
    }
    monitor.context.popPC();
    var j = 0;
    var items = args;
    for (; j < argCount; j++) {
        var E = items[j];
        O.Put(new Value_1.Value(j, Label_1.bot), E, true);
    }
    O.Put(constants.length, new Value_1.Value(len.value + argCount, len.label));
    return new Value_1.Value(len.value + argCount, len.label);
}
;
// ------------------------------------------------------------
// indexOf, 15.4.4.14
function indexOf(thisArg, args) {
    var searchElement = args[0] || new Value_1.Value(undefined, Label_1.bot);
    var fromIndex = args[1];
    var O = ToObject_1.ToObject(thisArg);
    var lenVal = O.Get(constants.length);
    var len = ToUInt32_1.ToUInt32(lenVal);
    var c = monitor.context;
    if (len.value === 0) {
        return new Value_1.Value(-1, len.label);
    }
    var label = Label_1.lub(len.label);
    c.pushPC(len.label);
    var n = fromIndex ? ToInteger_1.ToInteger(fromIndex) : new Value_1.Value(0, Label_1.bot);
    c.labels.pc = Label_1.lub(c.labels.pc, n.label);
    label = Label_1.lub(label, n.label);
    if (n.value >= len.value) {
        c.popPC();
        return new Value_1.Value(-1, label);
    }
    var k;
    if (n.value >= 0) {
        k = n;
    }
    else {
        k = new Value_1.Value(len.value - Math.abs(n.value), Label_1.lub(len.label, n.label));
        if (k.value < 0) {
            k.value = 0;
        }
    }
    while (k.value < len.value) {
        var kString = ToString_1.ToString(k);
        var kPresent = O.HasProperty(kString);
        c.labels.pc = Label_1.lub(c.labels.pc, kPresent.label);
        label = Label_1.lub(label, kPresent.label);
        if (kPresent.value) {
            var elementK = O.Get(kString);
            c.labels.pc = Label_1.lub(c.labels.pc, elementK.label);
            label = Label_1.lub(label, elementK.label);
            var same = searchElement.value === elementK.value;
            if (same) {
                k.label = label;
                c.popPC();
                return k;
            }
        }
        k.value++;
    }
    c.popPC();
    k.value = -1;
    k.label = label;
    return k;
}
// ------------------------------------------------------------
// lastIndexOf, 15.4.4.15
function lastIndexOf(thisArg, args) {
    var searchElement = args[0] || new Value_1.Value(undefined, Label_1.bot);
    var fromIndex = args[1];
    var O = ToObject_1.ToObject(thisArg);
    var lenVal = O.Get(constants.length);
    var len = ToUInt32_1.ToUInt32(lenVal);
    var c = monitor.context;
    if (len.value === 0) {
        return new Value_1.Value(-1, len.label);
    }
    var label = Label_1.lub(len.label);
    c.pushPC(len.label);
    var n = fromIndex ? ToInteger_1.ToInteger(fromIndex) : new Value_1.Value(len.value - 1, len.label);
    var k;
    if (n.value >= 0) {
        k = new Value_1.Value(Math.min(n.value, len.value - 1), Label_1.lub(n.label, len.label));
    }
    else {
        k = new Value_1.Value(len.value - Math.abs(n.value), Label_1.lub(n.label, len.label));
    }
    c.labels.pc = Label_1.lub(c.labels.pc, k.label);
    label = Label_1.lub(label, k.label);
    while (k.value >= 0) {
        var kPresent = O.HasProperty(k);
        c.labels.pc = Label_1.lub(c.labels.pc, kPresent.label);
        label = Label_1.lub(label, kPresent.label);
        if (kPresent.value) {
            var elementK = O.Get(k);
            c.labels.pc = Label_1.lub(c.labels.pc, elementK.label);
            label = Label_1.lub(label, elementK.label);
            var same = searchElement.value === elementK.value;
            if (same) {
                k.label = label;
                c.popPC();
                return k;
            }
        }
        k.value--;
    }
    c.popPC();
    k.value = -1;
    k.label = label;
    return k;
}
// ------------------------------------------------------------
// every, 15.4.4.16
function every(thisArg, args) {
    var callbackfn = args[0] || new Value_1.Value(undefined, Label_1.bot);
    var callbackthisArg = args[1] || new Value_1.Value(undefined, Label_1.bot);
    var O = ToObject_1.ToObject(thisArg);
    var lenVal = O.Get(constants.length);
    var len = ToUInt32_1.ToUInt32(lenVal);
    var c = monitor.context;
    var isCallable = IsCallable_1.IsCallable(callbackfn);
    var label = Label_1.lub(callbackfn.label);
    c.pushPC(callbackfn.label);
    if (!isCallable) {
        monitor.Throw("TypeError", 'Array.prototype.every: not a function', Label_1.bot);
    }
    var k = new Value_1.Value(0, len.label);
    c.labels.pc = Label_1.lub(c.labels.pc, len.label);
    label = Label_1.lub(label, len.label);
    while (k.value < len.value) {
        var kPresent = O.HasProperty(k);
        c.labels.pc = Label_1.lub(c.labels.pc, kPresent.label);
        label = Label_1.lub(label, kPresent.label);
        if (kPresent.value) {
            var kValue = O.Get(k);
            var testResult = callbackfn.Call(callbackthisArg, [kValue, k, O]);
            var b = ToBoolean_1.ToBoolean(testResult);
            c.labels.pc = Label_1.lub(c.labels.pc, b.label);
            label = Label_1.lub(label, b.label);
            if (!b.value) {
                c.popPC();
                return new Value_1.Value(false, label);
            }
        }
        k.value++;
    }
    c.popPC();
    return new Value_1.Value(true, label);
}
// ------------------------------------------------------------
// some, 15.4.4.17
function some(thisArg, args) {
    var callbackfn = args[0] || new Value_1.Value(undefined, Label_1.bot);
    var callbackthisArg = args[1] || new Value_1.Value(undefined, Label_1.bot);
    var O = ToObject_1.ToObject(thisArg);
    var lenVal = O.Get(constants.length);
    var len = ToUInt32_1.ToUInt32(lenVal);
    var c = monitor.context;
    var isCallable = IsCallable_1.IsCallable(callbackfn);
    var label = Label_1.lub(callbackfn.label);
    c.pushPC(callbackfn.label);
    if (!isCallable) {
        monitor.Throw("TypeError", 'Array.prototype.every: not a function', Label_1.bot);
    }
    var k = new Value_1.Value(0, len.label);
    c.labels.pc = Label_1.lub(c.labels.pc, len.label);
    label = Label_1.lub(label, len.label);
    while (k.value < len.value) {
        var kPresent = O.HasProperty(k);
        c.labels.pc = Label_1.lub(c.labels.pc, kPresent.label);
        label = Label_1.lub(label, kPresent.label);
        if (kPresent.value) {
            var kValue = O.Get(k);
            var testResult = callbackfn.Call(callbackthisArg, [kValue, k, O]);
            var b = ToBoolean_1.ToBoolean(testResult);
            c.labels.pc = Label_1.lub(c.labels.pc, b.label);
            label = Label_1.lub(label, b.label);
            if (b.value) {
                c.popPC();
                return new Value_1.Value(true, label);
            }
        }
        k.value++;
    }
    c.popPC();
    return new Value_1.Value(false, label);
}
// ------------------------------------------------------------
// forEach, 15.4.4.18
function forEach(thisArg, args) {
    var callbackfn = args[0] || new Value_1.Value(undefined, Label_1.bot);
    var callbackthisArg = args[1] || new Value_1.Value(undefined, Label_1.bot);
    var O = ToObject_1.ToObject(thisArg);
    var lenVal = O.Get(constants.length);
    var len = ToUInt32_1.ToUInt32(lenVal);
    var c = monitor.context;
    var isCallable = IsCallable_1.IsCallable(callbackfn);
    c.pushPC(callbackfn.label);
    if (!isCallable) {
        monitor.Throw("TypeError", 'Array.prototype.every: not a function', Label_1.bot);
    }
    var k = new Value_1.Value(0, len.label);
    c.labels.pc = Label_1.lub(c.labels.pc, len.label);
    while (k.value < len.value) {
        var kPresent = O.HasProperty(k);
        c.labels.pc = Label_1.lub(c.labels.pc, kPresent.label);
        if (kPresent.value) {
            var kValue = O.Get(k);
            callbackfn.Call(callbackthisArg, [kValue, k, O]);
        }
        k.value++;
    }
    c.popPC();
    return new Value_1.Value(undefined, Label_1.bot);
}
// ------------------------------------------------------------
// map, 15.4.4.19
function map(thisArg, args) {
    var callbackfn = args[0] || new Value_1.Value(undefined, Label_1.bot);
    var callbackthisArg = args[1] || new Value_1.Value(undefined, Label_1.bot);
    var O = ToObject_1.ToObject(thisArg);
    var lenVal = O.Get(constants.length);
    var len = ToUInt32_1.ToUInt32(lenVal);
    var c = monitor.context;
    var isCallable = IsCallable_1.IsCallable(callbackfn);
    c.pushPC(callbackfn.label);
    if (!isCallable) {
        monitor.Throw("TypeError", 'Array.prototype.every: not a function', Label_1.bot);
    }
    var A = new ArrayObject_1.ArrayObject();
    A.properties.length = len.value;
    A.labels.length = {
        value: len.label,
        existence: Label_1.bot
    };
    var k = new Value_1.Value(0, len.label);
    c.labels.pc = Label_1.lub(c.labels.pc, len.label);
    while (k.value < len.value) {
        var kPresent = O.HasProperty(k);
        c.labels.pc = Label_1.lub(c.labels.pc, kPresent.label);
        if (kPresent.value) {
            var kValue = O.Get(k);
            var mappedValue = callbackfn.Call(callbackthisArg, [kValue, k, O]);
            A.DefineOwnProperty(k, {
                value: mappedValue.value,
                label: mappedValue.label,
                writable: true,
                enumerable: true,
                configurable: true
            }, false);
        }
        k.value++;
    }
    c.popPC();
    return new Value_1.Value(A, Label_1.bot);
}
// ------------------------------------------------------------
// filter, 15.4.4.20
function filter(thisArg, args) {
    var callbackfn = args[0] || new Value_1.Value(undefined, Label_1.bot);
    var callbackthisArg = args[1] || new Value_1.Value(undefined, Label_1.bot);
    var O = ToObject_1.ToObject(thisArg);
    var lenVal = O.Get(constants.length);
    var len = ToUInt32_1.ToUInt32(lenVal);
    var c = monitor.context;
    var isCallable = IsCallable_1.IsCallable(callbackfn);
    c.pushPC(callbackfn.label);
    if (!isCallable) {
        monitor.Throw("TypeError", 'Array.prototype.every: not a function', Label_1.bot);
    }
    var A = new ArrayObject_1.ArrayObject();
    var k = new Value_1.Value(0, len.label);
    var to = new Value_1.Value(0, len.label);
    c.labels.pc = Label_1.lub(c.labels.pc, len.label);
    while (k.value < len.value) {
        var kPresent = O.HasProperty(k);
        c.labels.pc = Label_1.lub(c.labels.pc, kPresent.label);
        if (kPresent.value) {
            var kValue = O.Get(k);
            var selected = callbackfn.Call(callbackthisArg, [kValue, k, O]);
            selected = ToBoolean_1.ToBoolean(selected);
            c.labels.pc = Label_1.lub(c.labels.pc, selected.label);
            if (selected.value) {
                A.DefineOwnProperty(to, {
                    value: kValue.value,
                    label: kValue.label,
                    writable: true,
                    enumerable: true,
                    configurable: true
                }, false);
                to.value++;
            }
        }
        k.value++;
    }
    c.popPC();
    return new Value_1.Value(A, Label_1.bot);
}
// ------------------------------------------------------------
// reduce, 15.4.4.21
function reduce(thisArg, args) {
    var callbackfn = args[0] || new Value_1.Value(undefined, Label_1.bot);
    var initialValue = args[1];
    var O = ToObject_1.ToObject(thisArg);
    var lenVal = O.Get(constants.length);
    var len = ToUInt32_1.ToUInt32(lenVal);
    var c = monitor.context;
    var isCallable = IsCallable_1.IsCallable(callbackfn);
    var label = Label_1.lub(callbackfn.label);
    c.pushPC(callbackfn.label);
    if (!isCallable) {
        monitor.Throw("TypeError", 'Array.prototype.every: not a function', Label_1.bot);
    }
    var k = new Value_1.Value(0, len.label);
    var accumulator = new Value_1.Value(undefined, Label_1.bot);
    if (initialValue) {
        accumulator = initialValue;
    }
    else {
        var kPresent = new Value_1.Value(false, Label_1.bot);
        c.labels.pc = Label_1.lub(c.labels.pc, len.label);
        label = Label_1.lub(label, len.label);
        while (!kPresent.value && k.value < len.value) {
            kPresent = O.HasProperty(k);
            c.labels.pc = Label_1.lub(c.labels.pc, kPresent.label);
            label = Label_1.lub(label, kPresent.label);
            if (kPresent.value) {
                accumulator = O.Get(k);
            }
            k.value++;
        }
        if (!kPresent.value) {
            monitor.Throw("TypeError", 'Array.prototype.reduce: empty array with no initial value', Label_1.bot);
        }
    }
    while (k.value < len.value) {
        var kPresent = O.HasProperty(k);
        c.labels.pc = Label_1.lub(c.labels.pc, kPresent.label);
        label = Label_1.lub(label, kPresent.label);
        if (kPresent.value) {
            var kValue = O.Get(k);
            accumulator = callbackfn.Call(new Value_1.Value(undefined, Label_1.bot), [accumulator, kValue, k, O]);
        }
        k.value++;
    }
    c.popPC();
    accumulator.raise(label);
    return accumulator;
}
// ------------------------------------------------------------
// reduceRight, 15.4.4.22
function reduceRight(thisArg, args) {
    var callbackfn = args[0] || new Value_1.Value(undefined, Label_1.bot);
    var initialValue = args[1];
    var O = ToObject_1.ToObject(thisArg);
    var lenVal = O.Get(constants.length);
    var len = ToUInt32_1.ToUInt32(lenVal);
    var c = monitor.context;
    var isCallable = IsCallable_1.IsCallable(callbackfn);
    var label = Label_1.lub(callbackfn.label);
    c.pushPC(callbackfn.label);
    if (!isCallable) {
        monitor.Throw("TypeError", 'Array.prototype.every: not a function', Label_1.bot);
    }
    var k = new Value_1.Value(len.value - 1, len.label);
    var accumulator = new Value_1.Value(undefined, Label_1.bot);
    if (initialValue) {
        accumulator = initialValue;
    }
    else {
        var kPresent = new Value_1.Value(false, Label_1.bot);
        c.labels.pc = Label_1.lub(c.labels.pc, len.label);
        label = Label_1.lub(label, len.label);
        while (!kPresent.value && k.value >= 0) {
            kPresent = O.HasProperty(k);
            c.labels.pc = Label_1.lub(c.labels.pc, kPresent.label);
            label = Label_1.lub(label, kPresent.label);
            if (kPresent.value) {
                accumulator = O.Get(k);
            }
            k.value--;
        }
        if (!kPresent.value) {
            monitor.Throw("TypeError", 'Array.prototype.reduce: empty array with no initial value', Label_1.bot);
        }
    }
    while (k.value >= 0) {
        var kPresent = O.HasProperty(k);
        c.labels.pc = Label_1.lub(c.labels.pc, kPresent.label);
        label = Label_1.lub(label, kPresent.label);
        if (kPresent.value) {
            var kValue = O.Get(k);
            accumulator = callbackfn.Call(new Value_1.Value(undefined, Label_1.bot), [accumulator, kValue, k, O]);
        }
        k.value--;
    }
    c.popPC();
    accumulator.raise(label);
    return accumulator;
}

},{"../Constants":64,"../Conversion/ToBoolean":81,"../Conversion/ToInteger":83,"../Conversion/ToObject":85,"../Conversion/ToString":87,"../Conversion/ToUInt32":89,"../Define":91,"../Label":123,"../Objects/ArrayObject":132,"../Objects/BuiltinFunctionObject":134,"../Objects/EcmaObject":137,"../Utility/IsCallable":182,"../Value":184}],158:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Value_1 = require("../Value");
var constants = require("../Constants");
var BuiltinFunctionObject_1 = require("../Objects/BuiltinFunctionObject");
var Define_1 = require("../Define");
var EcmaObject_1 = require("../Objects/EcmaObject");
var Label_1 = require("../Label");
var BooleanObject_1 = require("../Objects/BooleanObject");
// 15.6.4 ------------------------------------------------------------
var BooleanPrototype = /** @class */ (function (_super) {
    __extends(BooleanPrototype, _super);
    function BooleanPrototype(host) {
        var _this = _super.call(this) || this;
        _this.Class = 'Boolean';
        _this.PrimitiveValue = new Boolean(false);
        _this.host = host;
        return _this;
    }
    BooleanPrototype.prototype.Setup = function () {
        this.Prototype = new Value_1.Value(monitor.instances.ObjectPrototype, Label_1.bot);
        Define_1.DefineTFT(this, constants.constructor, monitor.instances.BooleanConstructor);
        Define_1.DefineTFT(this, constants.toString, new BuiltinFunctionObject_1.BuiltinFunctionObject(toString, 0, this.host.toString));
        Define_1.DefineTFT(this, new Value_1.Value('valueOf', Label_1.bot), new BuiltinFunctionObject_1.BuiltinFunctionObject(valueOf, 0, this.host.valueOf));
    };
    return BooleanPrototype;
}(EcmaObject_1.EcmaObject));
exports.BooleanPrototype = BooleanPrototype;
// toString, 15.6.4.2 -----------------------------------------
function toString(thisArg, args) {
    var b = valueOf(thisArg, args);
    var s = b.value ? 'true' : 'false';
    return new Value_1.Value(s, b.label);
}
;
// valueOf, 15.6.4.3 ------------------------------------------ 
function valueOf(thisArg, args) {
    if (typeof thisArg.value === 'boolean') {
        return new Value_1.Value(thisArg.value, thisArg.label);
    }
    if (BooleanObject_1.IsBooleanObject(thisArg)) {
        return new Value_1.Value(thisArg.value.PrimitiveValue.valueOf(), thisArg.label);
    }
    monitor.Throw("TypeError", 'Boolean.prototype.valueOf is not generic', thisArg.label);
    throw 'TypeScript';
}
;

},{"../Constants":64,"../Define":91,"../Label":123,"../Objects/BooleanObject":133,"../Objects/BuiltinFunctionObject":134,"../Objects/EcmaObject":137,"../Value":184}],159:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Value_1 = require("../Value");
var constants = require("../Constants");
var BuiltinFunctionObject_1 = require("../Objects/BuiltinFunctionObject");
var ToNumber_1 = require("../Conversion/ToNumber");
var Define_1 = require("../Define");
var EcmaObject_1 = require("../Objects/EcmaObject");
var Label_1 = require("../Label");
var DateObject_1 = require("../Objects/DateObject");
// ------------------------------------------------------------
// The Date Prototype, 15.9.5
var DatePrototype = /** @class */ (function (_super) {
    __extends(DatePrototype, _super);
    function DatePrototype(host) {
        var _this = _super.call(this) || this;
        _this.Class = 'Date';
        _this.PrimitiveValue = new Value_1.Value(NaN, Label_1.bot);
        _this.host = host;
        return _this;
    }
    DatePrototype.prototype.Setup = function () {
        this.Prototype = new Value_1.Value(monitor.instances.ObjectPrototype, Label_1.bot);
        Define_1.DefineTFT(this, constants.constructor, monitor.instances.DateConstructor);
        Define_1.DefineTFT(this, constants.toString, new BuiltinFunctionObject_1.BuiltinFunctionObject(toString, 0, this.host.toString));
        Define_1.DefineTFT(this, constants.toDateString, new BuiltinFunctionObject_1.BuiltinFunctionObject(toDateString, 0, this.host.toDateString));
        Define_1.DefineTFT(this, constants.toTimeString, new BuiltinFunctionObject_1.BuiltinFunctionObject(toTimeString, 0, this.host.toTimeString));
        Define_1.DefineTFT(this, constants.toLocaleString, new BuiltinFunctionObject_1.BuiltinFunctionObject(toLocaleString, 0, this.host.toLocaleString));
        Define_1.DefineTFT(this, constants.toLocaleDateString, new BuiltinFunctionObject_1.BuiltinFunctionObject(toLocaleDateString, 0, this.host.toLocaleDateString));
        Define_1.DefineTFT(this, constants.toLocaleTimeString, new BuiltinFunctionObject_1.BuiltinFunctionObject(toLocaleTimeString, 0, this.host.toLocaleTimeString));
        Define_1.DefineTFT(this, new Value_1.Value('valueOf', Label_1.bot), new BuiltinFunctionObject_1.BuiltinFunctionObject(valueOf, 0, this.host.valueOf));
        Define_1.DefineTFT(this, constants.getTime, new BuiltinFunctionObject_1.BuiltinFunctionObject(getTime, 0, this.host.getTime));
        Define_1.DefineTFT(this, constants.getFullYear, new BuiltinFunctionObject_1.BuiltinFunctionObject(getFullYear, 0, this.host.getFullYear));
        Define_1.DefineTFT(this, constants.getUTCFullYear, new BuiltinFunctionObject_1.BuiltinFunctionObject(getUTCFullYear, 0, this.host.getUTCFullYear));
        Define_1.DefineTFT(this, constants.getMonth, new BuiltinFunctionObject_1.BuiltinFunctionObject(getMonth, 0, this.host.getMonth));
        Define_1.DefineTFT(this, constants.getUTCMonth, new BuiltinFunctionObject_1.BuiltinFunctionObject(getUTCMonth, 0, this.host.getUTCMonth));
        Define_1.DefineTFT(this, constants.getDate, new BuiltinFunctionObject_1.BuiltinFunctionObject(getDate, 0, this.host.getDate));
        Define_1.DefineTFT(this, constants.getUTCDate, new BuiltinFunctionObject_1.BuiltinFunctionObject(getUTCDate, 0, this.host.getUTCDate));
        Define_1.DefineTFT(this, constants.getDay, new BuiltinFunctionObject_1.BuiltinFunctionObject(getDay, 0, this.host.getDay));
        Define_1.DefineTFT(this, constants.getUTCDay, new BuiltinFunctionObject_1.BuiltinFunctionObject(getUTCDay, 0, this.host.getUTCDay));
        Define_1.DefineTFT(this, constants.getHours, new BuiltinFunctionObject_1.BuiltinFunctionObject(getHours, 0, this.host.getHours));
        Define_1.DefineTFT(this, constants.getUTCHours, new BuiltinFunctionObject_1.BuiltinFunctionObject(getUTCHours, 0, this.host.getUTCHours));
        Define_1.DefineTFT(this, constants.getMinutes, new BuiltinFunctionObject_1.BuiltinFunctionObject(getMinutes, 0, this.host.getMinutes));
        Define_1.DefineTFT(this, constants.getUTCMinutes, new BuiltinFunctionObject_1.BuiltinFunctionObject(getUTCMinutes, 0, this.host.getUTCMinutes));
        Define_1.DefineTFT(this, constants.getSeconds, new BuiltinFunctionObject_1.BuiltinFunctionObject(getSeconds, 0, this.host.getSeconds));
        Define_1.DefineTFT(this, constants.getUTCSeconds, new BuiltinFunctionObject_1.BuiltinFunctionObject(getUTCSeconds, 0, this.host.getUTCSeconds));
        Define_1.DefineTFT(this, constants.getMilliseconds, new BuiltinFunctionObject_1.BuiltinFunctionObject(getMilliseconds, 0, this.host.getMilliseconds));
        Define_1.DefineTFT(this, constants.getUTCMilliseconds, new BuiltinFunctionObject_1.BuiltinFunctionObject(getUTCMilliseconds, 0, this.host.getUTCMilliseconds));
        Define_1.DefineTFT(this, constants.getTimezoneOffset, new BuiltinFunctionObject_1.BuiltinFunctionObject(getTimezoneOffset, 0, this.host.getTimezoneOffset));
        Define_1.DefineTFT(this, constants.setTime, new BuiltinFunctionObject_1.BuiltinFunctionObject(setTime, 1, this.host.setTime));
        Define_1.DefineTFT(this, constants.setMilliseconds, new BuiltinFunctionObject_1.BuiltinFunctionObject(setMilliseconds, 0, this.host.setMilliseconds));
        Define_1.DefineTFT(this, constants.setUTCMilliseconds, new BuiltinFunctionObject_1.BuiltinFunctionObject(setUTCMilliseconds, 0, this.host.setUTCMilliseconds));
        Define_1.DefineTFT(this, constants.setSeconds, new BuiltinFunctionObject_1.BuiltinFunctionObject(setSeconds, 0, this.host.setSeconds));
        Define_1.DefineTFT(this, constants.setUTCSeconds, new BuiltinFunctionObject_1.BuiltinFunctionObject(setUTCSeconds, 0, this.host.setUTCSeconds));
        Define_1.DefineTFT(this, constants.setMinutes, new BuiltinFunctionObject_1.BuiltinFunctionObject(setMinutes, 0, this.host.setMinutes));
        Define_1.DefineTFT(this, constants.setUTCMinutes, new BuiltinFunctionObject_1.BuiltinFunctionObject(setUTCMinutes, 0, this.host.setUTCMinutes));
        Define_1.DefineTFT(this, constants.setHours, new BuiltinFunctionObject_1.BuiltinFunctionObject(setHours, 0, this.host.setHours));
        Define_1.DefineTFT(this, constants.setUTCHours, new BuiltinFunctionObject_1.BuiltinFunctionObject(setUTCHours, 0, this.host.setUTCHours));
        Define_1.DefineTFT(this, constants.setDate, new BuiltinFunctionObject_1.BuiltinFunctionObject(setDate, 0, this.host.setDate));
        Define_1.DefineTFT(this, constants.setUTCDate, new BuiltinFunctionObject_1.BuiltinFunctionObject(setUTCDate, 0, this.host.setUTCDate));
        Define_1.DefineTFT(this, constants.setMonth, new BuiltinFunctionObject_1.BuiltinFunctionObject(setMonth, 2, this.host.setMonth));
        Define_1.DefineTFT(this, constants.setUTCMonth, new BuiltinFunctionObject_1.BuiltinFunctionObject(setUTCMonth, 0, this.host.setUTCMonth));
        Define_1.DefineTFT(this, constants.setFullYear, new BuiltinFunctionObject_1.BuiltinFunctionObject(setFullYear, 0, this.host.setFullYear));
        Define_1.DefineTFT(this, constants.setUTCFullYear, new BuiltinFunctionObject_1.BuiltinFunctionObject(setUTCFullYear, 0, this.host.setUTCFullYear));
        Define_1.DefineTFT(this, constants.toUTCString, new BuiltinFunctionObject_1.BuiltinFunctionObject(toUTCString, 0, this.host.toUTCString));
        Define_1.DefineTFT(this, constants.toISOString, new BuiltinFunctionObject_1.BuiltinFunctionObject(toISOString, 0, this.host.toISOString));
        Define_1.DefineTFT(this, constants.toJSON, new BuiltinFunctionObject_1.BuiltinFunctionObject(toJSON, 0, this.host.toJSON));
        // @ts-ignore
        Define_1.DefineTFT(this, constants.setYear, new BuiltinFunctionObject_1.BuiltinFunctionObject(setYear, 1, this.host.setYear));
        // @ts-ignore
        Define_1.DefineTFT(this, constants.getYear, new BuiltinFunctionObject_1.BuiltinFunctionObject(getYear, 0, this.host.getYear));
        // @ts-ignore
        Define_1.DefineTFT(this, constants.toGMTString, new BuiltinFunctionObject_1.BuiltinFunctionObject(toUTCString, 0, this.host.toGTMString));
    };
    return DatePrototype;
}(EcmaObject_1.EcmaObject));
exports.DatePrototype = DatePrototype;
function assertDate(v, caller) {
    if (!DateObject_1.IsDateObject(v)) {
        monitor.context.pushPC(v.label);
        monitor.Throw("TypeError", caller + ' is not generic', Label_1.bot);
    }
}
// ------------------------------------------------------------
function mkGenericGet(fname) {
    return function (thisArg, args) {
        assertDate(thisArg, fname);
        var label = Label_1.lub(thisArg.label, thisArg.value.PrimitiveLabel);
        var date = thisArg.value.PrimitiveValue;
        var value = date[fname].call(date);
        return new Value_1.Value(value, label);
    };
}
// ------------------------------------------------------------
function mkGenericSet(fname) {
    return function (thisArg, args) {
        assertDate(thisArg, fname);
        var context = Label_1.lub(thisArg.label, monitor.context.effectivePC);
        monitor.assert(Label_1.le(context, thisArg.value.PrimitiveLabel), fname + ': context ' + context + ' not below state label of Date object ' + thisArg.value.PrimitiveLabel);
        var _args = [];
        var label = new Label_1.Label();
        for (var i = 0, len = args.length; i < len; i++) {
            var x = ToNumber_1.ToNumber(args[i]);
            label = Label_1.lub(label, x.label);
            _args[i] = x.value;
        }
        thisArg.value.PrimitiveLabel = Label_1.lub(thisArg.value.PrimitiveLabel, label);
        label = Label_1.lub(thisArg.label, thisArg.value.PrimitiveLabel);
        var date = thisArg.value.PrimitiveValue;
        var value = date[fname].apply(date, _args);
        return new Value_1.Value(value, label);
    };
}
// ------------------------------------------------------------
// toISOString, 15.9.5.43
var toISOString = mkGenericGet('toISOString');
// ------------------------------------------------------------
// toString, 15.9.5.2
var toString = mkGenericGet('toString');
// ------------------------------------------------------------
// toDateString, 15.9.5.?
var toDateString = mkGenericGet('toDateString');
// ------------------------------------------------------------
// toTimeString, 15.9.5.?
var toTimeString = mkGenericGet('toTimeString');
// ------------------------------------------------------------
// toLocaleString, 15.9.5.?
var toLocaleString = mkGenericGet('toLocaleString');
// ------------------------------------------------------------
// toLocaleDateString, 15.9.5.?
var toLocaleDateString = mkGenericGet('toLocaleDateString');
// ------------------------------------------------------------
// toLocaleTimeString, 15.9.5.?
var toLocaleTimeString = mkGenericGet('toLocaleTimeString');
// ------------------------------------------------------------
// valueOf, 15.9.5.?
function valueOf(thisArg, args) {
    assertDate(thisArg, 'valueOf');
    return new Value_1.Value(thisArg.value.PrimitiveValue.valueOf(), thisArg.label);
}
// ------------------------------------------------------------
// getTime, 15.9.5.9
var getTime = mkGenericGet('getTime');
// ------------------------------------------------------------
// getFullYear, 15.9.5.?
var getFullYear = mkGenericGet('getFullYear');
// ------------------------------------------------------------
// getUTCFullYear, 15.9.5.?
var getUTCFullYear = mkGenericGet('getUTCFullYear');
// ------------------------------------------------------------
// getMonth, 15.9.5.?
var getMonth = mkGenericGet('getMonth');
// ------------------------------------------------------------
// getUTCMonth, 15.9.5.?
var getUTCMonth = mkGenericGet('getUTCMonth');
// ------------------------------------------------------------
// getDate, 15.9.5.?
var getDate = mkGenericGet('getDate');
// ------------------------------------------------------------
// getUTCDate, 15.9.5.?
var getUTCDate = mkGenericGet('getUTCDate');
// ------------------------------------------------------------
// getDay, 15.9.5.?
var getDay = mkGenericGet('getDay');
// ------------------------------------------------------------
// getUTCDay, 15.9.5.?
var getUTCDay = mkGenericGet('getUTCDay');
// ------------------------------------------------------------
// getHours, 15.9.5.?
var getHours = mkGenericGet('getHours');
// ------------------------------------------------------------
// getUTCHours, 15.9.5.?
var getUTCHours = mkGenericGet('getUTCHours');
// ------------------------------------------------------------
// getMinutes, 15.9.5.?
var getMinutes = mkGenericGet('getMinutes');
// ------------------------------------------------------------
// getUTCMinutes, 15.9.5.?
var getUTCMinutes = mkGenericGet('getUTCMinutes');
// ------------------------------------------------------------
// getSeconds, 15.9.5.?
var getSeconds = mkGenericGet('getSeconds');
// ------------------------------------------------------------
// getUTCSeconds, 15.9.5.?
var getUTCSeconds = mkGenericGet('getUTCSeconds');
// ------------------------------------------------------------
// getMilliseconds, 15.9.5.?
var getMilliseconds = mkGenericGet('getMilliseconds');
// ------------------------------------------------------------
// getUTCMilliseconds, 15.9.5.?
var getUTCMilliseconds = mkGenericGet('getUTCMilliseconds');
// ------------------------------------------------------------
// getTimezoneOffset, 15.9.5.?
var getTimezoneOffset = mkGenericGet('getTimezoneOffset');
// ------------------------------------------------------------
// setTime, 15.9.5.?
var setTime = mkGenericSet('setTime');
// ------------------------------------------------------------
// setMilliseconds, 15.9.5.?
var setMilliseconds = mkGenericSet('setMilliseconds');
// ------------------------------------------------------------
// setUTCMilliseconds, 15.9.5.?
var setUTCMilliseconds = mkGenericSet('setUTCMilliseconds');
// ------------------------------------------------------------
// setSeconds, 15.9.5.?
var setSeconds = mkGenericSet('setSeconds');
// ------------------------------------------------------------
// setUTCSeconds, 15.9.5.?
var setUTCSeconds = mkGenericSet('setUTCSeconds');
// ------------------------------------------------------------
// setMinutes, 15.9.5.?
var setMinutes = mkGenericSet('setMinutes');
// ------------------------------------------------------------
// setUTCMinutes, 15.9.5.?
var setUTCMinutes = mkGenericSet('setUTCMinutes');
// ------------------------------------------------------------
// setHours, 15.9.5.?
var setHours = mkGenericSet('setHours');
// ------------------------------------------------------------
// setUTCHours, 15.9.5.?
var setUTCHours = mkGenericSet('setUTCHours');
// ------------------------------------------------------------
// setDate, 15.9.5.?
var setDate = mkGenericSet('setDate');
// ------------------------------------------------------------
// setUTCDate, 15.9.5.?
var setUTCDate = mkGenericSet('setUTCDate');
// ------------------------------------------------------------
// setMonth, 15.9.5.?
var setMonth = mkGenericSet('setMonth');
// ------------------------------------------------------------
// setUTCMonth, 15.9.5.?
var setUTCMonth = mkGenericSet('setUTCMonth');
// ------------------------------------------------------------
// setFullYear, 15.9.5.?
var setFullYear = mkGenericSet('setFullYear');
// ------------------------------------------------------------
// setUTCFullYear, 15.9.5.?
var setUTCFullYear = mkGenericSet('setUTCFullYear');
// ------------------------------------------------------------
// toUTCString, 15.9.5.?
var toUTCString = mkGenericGet('toUTCString');
// ------------------------------------------------------------
// toJSON, 15.9.5.?
var toJSON = mkGenericGet('toJSON');
// ------------------------------------------------------------
// getYear, B.2.4
var getYear = mkGenericGet('getYear');
// ------------------------------------------------------------
// setYear, B.2.5
var setYear = mkGenericSet('setYear');
// ------------------------------------------------------------
// setYear, B.2.6
var toGMTString = mkGenericSet('toGMTString');

},{"../Constants":64,"../Conversion/ToNumber":84,"../Define":91,"../Label":123,"../Objects/BuiltinFunctionObject":134,"../Objects/DateObject":136,"../Objects/EcmaObject":137,"../Value":184}],160:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Value_1 = require("../Value");
var EcmaObject_1 = require("../Objects/EcmaObject");
var constants = require("../Constants");
var BuiltinFunctionObject_1 = require("../Objects/BuiltinFunctionObject");
var ToString_1 = require("../Conversion/ToString");
var Define_1 = require("../Define");
var Label_1 = require("../Label");
// ------------------------------------------------------------
// 15.11.4 The Error Prototype
var ErrorPrototype = /** @class */ (function (_super) {
    __extends(ErrorPrototype, _super);
    function ErrorPrototype(host) {
        var _this = _super.call(this) || this;
        _this.Class = 'Error';
        _this.host = host;
        return _this;
    }
    ErrorPrototype.prototype.Setup = function () {
        this.SetupBase(monitor.instances.ErrorConstructor, 'Error');
    };
    ErrorPrototype.prototype.SetupBase = function (constructor, name) {
        this.Prototype = new Value_1.Value(monitor.instances.ObjectPrototype, Label_1.bot);
        Define_1.DefineTFT(this, constants.constructor, constructor);
        Define_1.DefineTFT(this, constants.name, name);
        Define_1.DefineTFT(this, constants.message, '');
        Define_1.DefineTFT(this, constants.toString, new BuiltinFunctionObject_1.BuiltinFunctionObject(tostring, 0, undefined));
    };
    return ErrorPrototype;
}(EcmaObject_1.EcmaObject));
exports.ErrorPrototype = ErrorPrototype;
// ------------------------------------------------------------
function tostring(thisArg, args) {
    var c = monitor.context;
    if (thisArg.value === null || typeof thisArg.value !== 'object') {
        c.pushPC(thisArg.label);
        monitor.Throw("TypeError", 'Error object expected', Label_1.bot);
    }
    var name = thisArg.Get(constants.name);
    if (name.value === undefined) {
        name.value = 'Error';
    }
    else {
        c.pushPC(name.label);
        name = ToString_1.ToString(name);
        c.popPC();
    }
    var msg = thisArg.Get(constants.message);
    if (msg.value === undefined) {
        msg.value = '';
    }
    else {
        c.pushPC(msg.label);
        msg = ToString_1.ToString(msg);
        c.popPC();
    }
    if (name.value === '') {
        msg.raise(name.label);
        return msg;
    }
    if (msg.value === '') {
        name.raise(msg.label);
        return name;
    }
    name.value += ': ' + msg.value;
    name.raise(msg.label);
    return name;
}

},{"../Constants":64,"../Conversion/ToString":87,"../Define":91,"../Label":123,"../Objects/BuiltinFunctionObject":134,"../Objects/EcmaObject":137,"../Value":184}],161:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ErrorPrototype_1 = require("./ErrorPrototype");
var EvalErrorPrototype = /** @class */ (function (_super) {
    __extends(EvalErrorPrototype, _super);
    function EvalErrorPrototype(host) {
        return _super.call(this, host) || this;
    }
    EvalErrorPrototype.prototype.Setup = function () {
        this.SetupBase(monitor.instances.ErrorConstructor, 'EvalError');
    };
    return EvalErrorPrototype;
}(ErrorPrototype_1.ErrorPrototype));
exports.EvalErrorPrototype = EvalErrorPrototype;

},{"./ErrorPrototype":160}],162:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Label_1 = require("../Label");
var Value_1 = require("../Value");
var Define_1 = require("../Define");
var EcmaObject_1 = require("../Objects/EcmaObject");
var constants = require("../Constants");
var BuiltinFunctionObject_1 = require("../Objects/BuiltinFunctionObject");
var ToUInt32_1 = require("../Conversion/ToUInt32");
var IsCallable_1 = require("../Utility/IsCallable");
var ThrowTypeError_1 = require("../ThrowTypeError");
// ------------------------------------------------------------
// Function Prototype, 15.3.4
var FunctionPrototype = /** @class */ (function (_super) {
    __extends(FunctionPrototype, _super);
    function FunctionPrototype(host) {
        var _this_1 = _super.call(this) || this;
        // 15.3.4
        _this_1.Class = 'Function';
        _this_1.Extensible = true;
        _this_1.host = host;
        return _this_1;
    }
    FunctionPrototype.prototype.Setup = function () {
        // 15.3.4.1
        Define_1.DefineTFT(this, constants.constructor, monitor.instances.FunctionConstructor);
        this.Prototype = new Value_1.Value(monitor.instances.ObjectPrototype, Label_1.bot);
        Define_1.DefineFFT(this, constants.length, 0);
        Define_1.DefineTFT(this, constants.toString, new BuiltinFunctionObject_1.BuiltinFunctionObject(toString, 0, Function.prototype.toString));
        Define_1.DefineTFT(this, constants.apply, new BuiltinFunctionObject_1.BuiltinFunctionObject(apply, 2, Function.prototype.apply));
        Define_1.DefineTFT(this, constants.call, new BuiltinFunctionObject_1.BuiltinFunctionObject(call, 1, Function.prototype.call));
        Define_1.DefineTFT(this, constants.bind, new BuiltinFunctionObject_1.BuiltinFunctionObject(bind, 1, Function.prototype.bind));
    };
    // 15.3.4
    FunctionPrototype.prototype.Call = function (thisArg, args) {
        return new Value_1.Value(undefined, Label_1.bot);
    };
    FunctionPrototype.prototype.Construct = function (args) {
        return new Value_1.Value(undefined, Label_1.bot);
    };
    return FunctionPrototype;
}(EcmaObject_1.EcmaObject));
exports.FunctionPrototype = FunctionPrototype;
// ------------------------------------------------------------
// 15.3.4.2 - Implementation Dependent
function toString(thisArg, args) {
    return new Value_1.Value(String(thisArg.value), thisArg.label);
}
// ------------------------------------------------------------
// 15.3.4.3
function apply(thisArg, args) {
    var _this = args[0] ? args[0] : new Value_1.Value(undefined, Label_1.bot);
    var argArray = args[1] ? args[1] : new Value_1.Value(undefined, Label_1.bot);
    monitor.context.pushPC(thisArg.label);
    if (!IsCallable_1.IsCallable(thisArg)) {
        monitor.Throw("TypeError", 'apply, not a function', Label_1.bot);
    }
    monitor.context.raisePC(argArray.label);
    if (argArray.value === null || argArray.value === undefined) {
        var res_1 = thisArg.Call(_this, []);
        monitor.context.popPC();
        return res_1;
    }
    if (typeof argArray.value !== 'object' || argArray.value.Class === undefined) {
        monitor.Throw("TypeError", 'apply, argument array not an object', Label_1.bot);
    }
    var len = argArray.Get(constants.length);
    var n = ToUInt32_1.ToUInt32(len);
    var argList = [];
    for (var index = 0; index < n.value; index++) {
        var nextArg = argArray.Get(new Value_1.Value(index, n.label));
        argList.push(nextArg);
    }
    // Since we cannot transfer the structural or existence info to
    //  the array used by Call, we raise the context accordingly.
    //  This is sound, but potentially an over approximation.
    monitor.context.raisePC(n.label);
    var res = thisArg.Call(_this, argList);
    monitor.context.popPC();
    return res;
}
// ------------------------------------------------------------
// 15.3.4.4
function call(thisArg, args) {
    var _this = args[0] ? args[0] : new Value_1.Value(undefined, Label_1.bot);
    var argList = [];
    for (var i = 1; i < args.length; i++) {
        argList[i - 1] = args[i];
    }
    monitor.context.pushPC(thisArg.label);
    if (!IsCallable_1.IsCallable(thisArg)) {
        monitor.Throw("TypeError", 'call, not a function', Label_1.bot);
    }
    var res = thisArg.Call(_this, argList);
    monitor.context.popPC();
    return res;
}
// ------------------------------------------------------------
// 15.3.4.5
function bind(thisArg, args) {
    var Target = thisArg;
    var _this = args[0] ? args[0] : new Value_1.Value(undefined, Label_1.bot);
    var argList = [];
    for (var i = 1; i < args.length; i++) {
        argList[i - 1] = args[i];
    }
    if (!IsCallable_1.IsCallable(Target)) {
        monitor.Throw("TypeError", 'bind: Target is not a function', Label_1.bot);
    }
    var F = new EcmaObject_1.EcmaObject();
    //@ts-ignore TYPES
    F.TargetFunction = Target;
    //@ts-ignore TYPES
    F.BoundThis = _this;
    //@ts-ignore TYPES
    F.BoundArgs = argList;
    F.Class = 'Function';
    F.Prototype = new Value_1.Value(monitor.instances.FunctionPrototype, Label_1.bot);
    //@ts-ignore TYPES
    F.Call = function (_thisVal, ExtraArgs) {
        //@ts-ignore TYPES
        var boundArgs = F.BoundArgs;
        //@ts-ignore TYPES
        var boundThis = F.BoundThis;
        //@ts-ignore TYPES
        var target = F.TargetFunction;
        var args = boundArgs.concat(ExtraArgs);
        return target.Call(boundThis, args);
    };
    //@ts-ignore TYPES
    F.Construct = function (ExtraArgs) {
        //@ts-ignore TYPES
        var target = F.TargetFunction;
        if (!target.Construct) {
            monitor.Throw("TypeError", 'bind construct: no internal method Construct', Label_1.bot);
        }
        //@ts-ignore TYPES
        var boundArgs = F.BoundArgs;
        var args = boundArgs.concat(ExtraArgs);
        return target.Construct(args);
    };
    //@ts-ignore TYPES
    F.HasInstance = function (V) {
        //@ts-ignore TYPES
        var target = F.TargetFunction;
        if (!target.HasInstance) {
            monitor.Throw("TypeError", 'bind HasInstance: no internal method HasInstance', Label_1.bot);
        }
        return target.HasInstance(V);
    };
    //@ts-ignore TYPES
    if (Target.Class === "Function") {
        //@ts-ignore TYPES
        var L = Target.length - args.length;
        //@ts-ignore TYPES
        F.length = L > 0 ? L : 0;
    }
    else {
        //@ts-ignore TYPES
        F.length = 0;
    }
    //@ts-ignore TYPES
    Define_1.DefineFFF(F, constants.length, F.length);
    F.Extensible = true;
    var thrower = ThrowTypeError_1.ThrowTypeError.Instance;
    F.DefineOwnProperty(constants.caller, {
        //@ts-ignore TYPES
        get: thrower,
        //@ts-ignore TYPES
        set: thrower,
        enumerable: false, configurable: false,
        label: Label_1.bot
    }, false);
    F.DefineOwnProperty(constants.arguments, {
        //@ts-ignore TYPES
        get: thrower,
        //@ts-ignore TYPES
        set: thrower,
        enumerable: false, configurable: false,
        label: Label_1.bot
    }, false);
    return new Value_1.Value(F, Label_1.bot);
}

},{"../Constants":64,"../Conversion/ToUInt32":89,"../Define":91,"../Label":123,"../Objects/BuiltinFunctionObject":134,"../Objects/EcmaObject":137,"../ThrowTypeError":177,"../Utility/IsCallable":182,"../Value":184}],163:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Label_1 = require("../Label");
var Value_1 = require("../Value");
var Define_1 = require("../Define");
var EcmaObject_1 = require("../Objects/EcmaObject");
var constants = require("../Constants");
var BuiltinFunctionObject_1 = require("../Objects/BuiltinFunctionObject");
var ToInteger_1 = require("../Conversion/ToInteger");
var ToString_1 = require("../Conversion/ToString");
var NumberObject_1 = require("../Objects/NumberObject");
// ------------------------------------------------------------
// The Number Prototype, 15.7.4
var NumberPrototype = /** @class */ (function (_super) {
    __extends(NumberPrototype, _super);
    function NumberPrototype(host) {
        var _this = _super.call(this) || this;
        _this.Class = 'Number';
        _this.PrimitiveValue = new Number(0);
        _this.PrimitiveLabel = Label_1.bot;
        _this.host = host;
        return _this;
    }
    NumberPrototype.prototype.Setup = function () {
        this.Prototype = new Value_1.Value(monitor.instances.ObjectPrototype, Label_1.bot);
        Define_1.DefineTFT(this, constants.constructor, monitor.instances.NumberConstructor);
        Define_1.DefineTFT(this, constants.toString, new BuiltinFunctionObject_1.BuiltinFunctionObject(toString, 1, this.host.toString));
        Define_1.DefineTFT(this, constants.toLocaleString, new BuiltinFunctionObject_1.BuiltinFunctionObject(toLocaleString, 0, this.host.toLocaleString));
        Define_1.DefineTFT(this, new Value_1.Value('valueOf', Label_1.bot), new BuiltinFunctionObject_1.BuiltinFunctionObject(valueOf, 0, this.host.valueOf));
        Define_1.DefineTFT(this, constants.toFixed, new BuiltinFunctionObject_1.BuiltinFunctionObject(toFixed, 0, this.host.toFixed));
        Define_1.DefineTFT(this, constants.toExponential, new BuiltinFunctionObject_1.BuiltinFunctionObject(toExponential, 0, this.host.toExponential));
        Define_1.DefineTFT(this, constants.toPrecision, new BuiltinFunctionObject_1.BuiltinFunctionObject(toPrecision, 0, this.host.toPrecision));
    };
    return NumberPrototype;
}(EcmaObject_1.EcmaObject));
exports.NumberPrototype = NumberPrototype;
function assertNumber(v, caller) {
    if (NumberObject_1.IsNumberObject(v)) {
        return v.value.PrimitiveValue.valueOf();
    }
    if (typeof v.value == "number") {
        return v.value;
    }
    monitor.context.pushPC(v.label);
    monitor.Throw("TypeError", caller + ' is not generic', Label_1.bot);
}
function IsNumberObjectOrNumber(x) {
    return typeof x.value === 'number' || NumberObject_1.IsNumberObject(x);
}
// ------------------------------------------------------------
// toString, 15.7.4.2
function toString(thisArg, args) {
    if (!IsNumberObjectOrNumber(thisArg)) {
        monitor.Throw("TypeError", 'Number.prototype.toString is not generic', thisArg.label);
        throw 'TypeScript';
    }
    var arg0 = args[0] || new Value_1.Value(undefined, Label_1.bot);
    if (arg0.value === undefined) {
        arg0.value = 10;
    }
    var radix = ToInteger_1.ToInteger(arg0);
    if (typeof thisArg.value === 'number') {
        var result = thisArg.value.toString(radix.value);
        return new Value_1.Value(result, Label_1.lub(thisArg.label, radix.label));
    }
    else {
        var result = thisArg.value.PrimitiveValue.toString(radix.value);
        return new Value_1.Value(result, Label_1.lub(thisArg.value.PrimitiveLabel, radix.label));
    }
}
;
// ------------------------------------------------------------
// toLocaleString, 15.7.4.3
function toLocaleString(thisArg, args) {
    var newArgs = args.length > 0 ? args.slice(1) : args;
    return toString(thisArg, newArgs);
}
// ------------------------------------------------------------
// valueOf, 15.7.4.4
function valueOf(thisArg, args) {
    if (!IsNumberObjectOrNumber(thisArg)) {
        monitor.Throw("TypeError", 'Number.prototype.toString is not generic', thisArg.label);
        throw 'TypeScript';
    }
    if (typeof thisArg.value === 'number') {
        return new Value_1.Value(thisArg.value, thisArg.label);
    }
    var result = thisArg.value.PrimitiveValue.valueOf();
    return new Value_1.Value(result, thisArg.value.PrimitiveLabel);
}
;
// ------------------------------------------------------------
// toFixed, 15.7.4.5
function toFixed(thisArg, args) {
    var primitiveValue = assertNumber(thisArg, 'toFixed');
    var arg0 = args[0] ? args[0] : new Value_1.Value(undefined, Label_1.bot);
    var precision = ToInteger_1.ToInteger(arg0);
    return new Value_1.Value(primitiveValue.toFixed(precision.value), Label_1.lub(precision.label, thisArg.label));
}
;
// ------------------------------------------------------------
// toExponential, 15.7.4.6
function toExponential(thisArg, args) {
    var primitiveValue = assertNumber(thisArg, 'toExponential');
    var arg0 = args[0] ? args[0] : new Value_1.Value(undefined, Label_1.bot);
    var precision = ToInteger_1.ToInteger(arg0);
    return new Value_1.Value(primitiveValue.toExponential(precision.value), Label_1.lub(precision.label, thisArg.label));
}
;
// ------------------------------------------------------------
// toPrecision, 15.7.4.7
function toPrecision(thisArg, args) {
    var primitiveValue = assertNumber(thisArg, 'toPrecision');
    var arg0 = args[0] ? args[0] : new Value_1.Value(undefined, Label_1.bot);
    var lbl = Label_1.lub(arg0.label, thisArg.label);
    if (arg0.value === undefined) {
        var strX = ToString_1.ToString(thisArg); //step 2
        return new Value_1.Value(strX.value, lbl);
    }
    var precision = ToInteger_1.ToInteger(arg0); //step 3
    if (primitiveValue === NaN)
        return new Value_1.Value('NaN', lbl); //step 4
    return new Value_1.Value(primitiveValue.toPrecision(precision.value), lbl);
}
;

},{"../Constants":64,"../Conversion/ToInteger":83,"../Conversion/ToString":87,"../Define":91,"../Label":123,"../Objects/BuiltinFunctionObject":134,"../Objects/EcmaObject":137,"../Objects/NumberObject":145,"../Value":184}],164:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Label_1 = require("../Label");
var Value_1 = require("../Value");
var Define_1 = require("../Define");
var EcmaObject_1 = require("../Objects/EcmaObject");
var constants = require("../Constants");
var BuiltinFunctionObject_1 = require("../Objects/BuiltinFunctionObject");
var ToString_1 = require("../Conversion/ToString");
var ToObject_1 = require("../Conversion/ToObject");
var IsCallable_1 = require("../Utility/IsCallable");
// ------------------------------------------------------------
// The object prototype, 15.2.4
var ObjectPrototype = /** @class */ (function (_super) {
    __extends(ObjectPrototype, _super);
    function ObjectPrototype(host) {
        var _this = _super.call(this) || this;
        _this.Prototype = new Value_1.Value(null, Label_1.bot);
        _this.Class = 'Object';
        _this.Extensible = true;
        _this.host = host;
        return _this;
    }
    ObjectPrototype.prototype.Setup = function () {
        // 15.2.4.1
        Define_1.DefineTFT(this, constants.constructor, monitor.instances.ObjectConstructor);
        Define_1.DefineTFT(this, constants.toString, new BuiltinFunctionObject_1.BuiltinFunctionObject(toString, 0, Object.prototype.toString));
        Define_1.DefineTFT(this, constants.toLocaleString, new BuiltinFunctionObject_1.BuiltinFunctionObject(toLocaleString, 0, Object.prototype.toLocaleString));
        Define_1.DefineTFT(this, new Value_1.Value('valueOf', Label_1.bot), new BuiltinFunctionObject_1.BuiltinFunctionObject(valueOf, 0, Object.prototype.valueOf));
        Define_1.DefineTFT(this, constants.hasOwnProperty, new BuiltinFunctionObject_1.BuiltinFunctionObject(hasOwnProperty, 1, Object.prototype.hasOwnProperty));
        Define_1.DefineTFT(this, constants.isPrototypeOf, new BuiltinFunctionObject_1.BuiltinFunctionObject(isPrototypeOf, 1, Object.prototype.isPrototypeOf));
        Define_1.DefineTFT(this, constants.propertyIsEnumerable, new BuiltinFunctionObject_1.BuiltinFunctionObject(propertyIsEnumerable, 1, Object.prototype.propertyIsEnumerable));
    };
    return ObjectPrototype;
}(EcmaObject_1.EcmaObject));
exports.ObjectPrototype = ObjectPrototype;
// ------------------------------------------------------------
// Object.prototype.toString(), 15.2.4.2
function toString(thisArg, args) {
    if (thisArg.value === undefined)
        return new Value_1.Value('[object Undefined]', thisArg.label);
    if (thisArg.value === null)
        return new Value_1.Value('[object Null]', thisArg.label);
    var O = ToObject_1.ToObject(thisArg);
    return new Value_1.Value('[object ' + O.value.Class + ']', thisArg.label);
}
// ------------------------------------------------------------
// 15.2.4.3
function toLocaleString(thisArg, args) {
    var O = ToObject_1.ToObject(thisArg);
    var toString = O.Get(constants.toString);
    var result;
    monitor.context.pushPC(toString.label);
    if (IsCallable_1.IsCallable(toString)) {
        result = toString.Call(O, []);
        result.raise(toString.label);
    }
    else {
        monitor.Throw("TypeError", "property 'toString' of object " + O + " is not a function ", Label_1.bot);
    }
    monitor.context.popPC();
    return result;
}
// ------------------------------------------------------------
// 15.2.4.4
function valueOf(thisArg, args) {
    var o = ToObject_1.ToObject(thisArg);
    return o;
}
// ------------------------------------------------------------
// 15.2.4.5
function hasOwnProperty(thisArg, args) {
    var V = args[0] || new Value_1.Value(undefined, Label_1.bot);
    var P = ToString_1.ToString(V);
    var O = ToObject_1.ToObject(thisArg);
    var desc = O.GetOwnProperty(P);
    var result = desc.value !== undefined;
    return new Value_1.Value(result, desc.label);
}
// ------------------------------------------------------------
// 15.2.4.6
function isPrototypeOf(thisArg, args) {
    var c = monitor.context;
    var V = args[0] || new Value_1.Value(undefined, Label_1.bot);
    if (V.value === null || V.value === undefined || typeof V.value !== 'object') {
        return new Value_1.Value(false, V.label);
    }
    c.pushPC(V.label);
    var O = ToObject_1.ToObject(thisArg);
    c.popPC();
    var lbl = Label_1.lub(V.label);
    var P = V.value.Prototype;
    while (true) {
        lbl = Label_1.lub(lbl, P.label);
        if (P.value === null) {
            return new Value_1.Value(false, lbl);
        }
        if (O.value === P.value) {
            return new Value_1.Value(true, lbl);
        }
        if (P === undefined) {
            throw new Error('Object.prototype.isPrototypeOf: object with undefined prototype');
        }
        P = P.value.Prototype;
    }
}
// ------------------------------------------------------------
// 15.2.4.7
function propertyIsEnumerable(thisArg, args) {
    var V = args[0] || new Value_1.Value(undefined, Label_1.bot);
    var P = ToString_1.ToString(V);
    var O = ToObject_1.ToObject(thisArg);
    var desc = O.GetOwnProperty(P);
    if (desc.value === undefined) {
        return new Value_1.Value(false, desc.label);
    }
    return new Value_1.Value(desc.value.enumerable === true, Label_1.lub(desc.label, desc.value.label));
}

},{"../Constants":64,"../Conversion/ToObject":85,"../Conversion/ToString":87,"../Define":91,"../Label":123,"../Objects/BuiltinFunctionObject":134,"../Objects/EcmaObject":137,"../Utility/IsCallable":182,"../Value":184}],165:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ErrorPrototype_1 = require("./ErrorPrototype");
var RangeErrorPrototype = /** @class */ (function (_super) {
    __extends(RangeErrorPrototype, _super);
    function RangeErrorPrototype(host) {
        return _super.call(this, host) || this;
    }
    RangeErrorPrototype.prototype.Setup = function () {
        this.SetupBase(monitor.instances.ErrorConstructor, 'RangeError');
    };
    return RangeErrorPrototype;
}(ErrorPrototype_1.ErrorPrototype));
exports.RangeErrorPrototype = RangeErrorPrototype;

},{"./ErrorPrototype":160}],166:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ErrorPrototype_1 = require("./ErrorPrototype");
var ReferenceErrorPrototype = /** @class */ (function (_super) {
    __extends(ReferenceErrorPrototype, _super);
    function ReferenceErrorPrototype(host) {
        return _super.call(this, host) || this;
    }
    ReferenceErrorPrototype.prototype.Setup = function () {
        this.SetupBase(monitor.instances.ErrorConstructor, 'ReferenceError');
    };
    return ReferenceErrorPrototype;
}(ErrorPrototype_1.ErrorPrototype));
exports.ReferenceErrorPrototype = ReferenceErrorPrototype;

},{"./ErrorPrototype":160}],167:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Value_1 = require("../Value");
var constants = require("../Constants");
var BuiltinFunctionObject_1 = require("../Objects/BuiltinFunctionObject");
var ArrayObject_1 = require("../Objects/ArrayObject");
var ToInteger_1 = require("../Conversion/ToInteger");
var ToString_1 = require("../Conversion/ToString");
var Label_1 = require("../Label");
var Define_1 = require("../Define");
var EcmaObject_1 = require("../Objects/EcmaObject");
var RegExpObject_1 = require("../Objects/RegExpObject");
// ------------------------------------------------------------
// The RegExp Prototype, 15.10.6
var RegExpPrototype = /** @class */ (function (_super) {
    __extends(RegExpPrototype, _super);
    function RegExpPrototype(host) {
        var _this = _super.call(this) || this;
        _this.Class = 'RegExp';
        _this.host = host;
        return _this;
    }
    RegExpPrototype.prototype.Setup = function () {
        this.Prototype = new Value_1.Value(monitor.instances.ObjectPrototype, Label_1.bot);
        Define_1.DefineFFF(this, constants.source, '');
        Define_1.DefineFFF(this, constants.global, false);
        Define_1.DefineFFF(this, constants.ignoreCase, false);
        Define_1.DefineFFF(this, constants.multiline, false);
        Define_1.DefineTFF(this, constants.lastIndex, 0);
        Define_1.DefineTFT(this, constants.constructor, monitor.instances.RegExpConstructor);
        Define_1.DefineTFT(this, constants.exec, new BuiltinFunctionObject_1.BuiltinFunctionObject(exec, 1, RegExp.prototype.exec));
        Define_1.DefineTFT(this, constants.test, new BuiltinFunctionObject_1.BuiltinFunctionObject(test, 1, RegExp.prototype.test));
        Define_1.DefineTFT(this, constants.toString, new BuiltinFunctionObject_1.BuiltinFunctionObject(toString, 0, RegExp.prototype.toString));
    };
    return RegExpPrototype;
}(EcmaObject_1.EcmaObject));
exports.RegExpPrototype = RegExpPrototype;
function assertRegExp(v, caller) {
    if (!RegExpObject_1.IsRegExpObject(v)) {
        monitor.context.pushPC(v.label);
        monitor.Throw("TypeError", caller + ' is not generic', Label_1.bot);
    }
}
// ------------------------------------------------------------
// exec, 15.10.6.2
function exec(thisArg, args) {
    assertRegExp(thisArg, 'exec');
    var string = args[0] || new Value_1.Value(undefined, Label_1.bot);
    var S = ToString_1.ToString(string);
    var lastIndex = ToInteger_1.ToInteger(thisArg.Get(constants.lastIndex));
    var pre = thisArg.value.PrimitiveValue;
    pre.lastIndex = lastIndex.value;
    var res = pre.exec(S.value);
    var l = Label_1.lub(thisArg.label, S.label, lastIndex.label);
    if (res === null) {
        return new Value_1.Value(null, l);
    }
    thisArg.Put(constants.lastIndex, new Value_1.Value(pre.lastIndex, l));
    var array = ArrayObject_1.ArrayObject.fromArray(res, l, l);
    array.DefineOwnProperty(constants.index, {
        value: res.index,
        writable: true,
        enumerable: true,
        configurable: true,
        label: l
    });
    array.DefineOwnProperty(constants.input, {
        value: res.input,
        writable: true,
        enumerable: true,
        configurable: true,
        label: l
    });
    return new Value_1.Value(array, Label_1.bot);
}
// ------------------------------------------------------------
// test, 15.10.6.3
function test(thisArg, args) {
    assertRegExp(thisArg, 'test');
    var res = exec(thisArg, args);
    return new Value_1.Value(res.value !== null, res.label);
}
// ------------------------------------------------------------
// toString, 15.10.6.3
function toString(thisArg, args) {
    assertRegExp(thisArg, 'toString');
    return new Value_1.Value(thisArg.value.PrimitiveValue.toString(), thisArg.label);
}

},{"../Constants":64,"../Conversion/ToInteger":83,"../Conversion/ToString":87,"../Define":91,"../Label":123,"../Objects/ArrayObject":132,"../Objects/BuiltinFunctionObject":134,"../Objects/EcmaObject":137,"../Objects/RegExpObject":149,"../Value":184}],168:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Value_1 = require("../Value");
var constants = require("../Constants");
var BuiltinFunctionObject_1 = require("../Objects/BuiltinFunctionObject");
var ArrayObject_1 = require("../Objects/ArrayObject");
var ToInteger_1 = require("../Conversion/ToInteger");
var ToString_1 = require("../Conversion/ToString");
var CheckObjectCoercible_1 = require("../Utility/CheckObjectCoercible");
var Define_1 = require("../Define");
var EcmaObject_1 = require("../Objects/EcmaObject");
var Label_1 = require("../Label");
var StringObject_1 = require("../Objects/StringObject");
var RegExpObject_1 = require("../Objects/RegExpObject");
var IsCallable_1 = require("../Utility/IsCallable");
var ToInt32_1 = require("../Conversion/ToInt32");
var ToNumber_1 = require("../Conversion/ToNumber");
// ------------------------------------------------------------
// The String Prototype, 15.5.4
var StringPrototype = /** @class */ (function (_super) {
    __extends(StringPrototype, _super);
    function StringPrototype(host) {
        var _this = _super.call(this) || this;
        _this.Class = 'String';
        _this.PrimitiveValue = '';
        _this.PrimitiveLabel = Label_1.bot;
        //@ts-ignore TYPES
        _this.properties = new String('');
        _this.labels.length = {
            value: Label_1.bot,
            existence: Label_1.bot
        };
        _this.host = host;
        return _this;
    }
    StringPrototype.prototype.Setup = function () {
        this.Prototype = new Value_1.Value(monitor.instances.ObjectPrototype, Label_1.bot);
        Define_1.DefineTFT(this, constants.constructor, monitor.instances.StringConstructor);
        Define_1.DefineTFT(this, constants.toString, new BuiltinFunctionObject_1.BuiltinFunctionObject(toString, 0, this.host.toString));
        Define_1.DefineTFT(this, constants.valueOf, new BuiltinFunctionObject_1.BuiltinFunctionObject(valueOf, 0, this.host.valueOf));
        Define_1.DefineTFT(this, constants.charAt, new BuiltinFunctionObject_1.BuiltinFunctionObject(charAt, 1, this.host.charAt));
        Define_1.DefineTFT(this, constants.charCodeAt, new BuiltinFunctionObject_1.BuiltinFunctionObject(charCodeAt, 1, this.host.charCodeAt));
        Define_1.DefineTFT(this, constants.concat, new BuiltinFunctionObject_1.BuiltinFunctionObject(concat, 1, this.host.concat));
        Define_1.DefineTFT(this, constants.indexOf, new BuiltinFunctionObject_1.BuiltinFunctionObject(indexOf, 1, this.host.indexOf));
        Define_1.DefineTFT(this, constants.lastIndexOf, new BuiltinFunctionObject_1.BuiltinFunctionObject(lastIndexOf, 1, this.host.lastIndexOf));
        Define_1.DefineTFT(this, constants.localeCompare, new BuiltinFunctionObject_1.BuiltinFunctionObject(localeCompare, 1, this.host.localeCompare));
        Define_1.DefineTFT(this, constants.match, new BuiltinFunctionObject_1.BuiltinFunctionObject(match, 1, this.host.match));
        Define_1.DefineTFT(this, constants.replace, new BuiltinFunctionObject_1.BuiltinFunctionObject(replace, 2, this.host.replace));
        Define_1.DefineTFT(this, constants.search, new BuiltinFunctionObject_1.BuiltinFunctionObject(search, 1, this.host.search));
        Define_1.DefineTFT(this, constants.slice, new BuiltinFunctionObject_1.BuiltinFunctionObject(slice, 2, this.host.slice));
        Define_1.DefineTFT(this, constants.split, new BuiltinFunctionObject_1.BuiltinFunctionObject(split, 2, this.host.split));
        Define_1.DefineTFT(this, constants.substring, new BuiltinFunctionObject_1.BuiltinFunctionObject(substring, 2, this.host.substring));
        Define_1.DefineTFT(this, constants.toLowerCase, new BuiltinFunctionObject_1.BuiltinFunctionObject(toLowerCase, 0, this.host.toLowerCase));
        Define_1.DefineTFT(this, constants.toLocaleLowerCase, new BuiltinFunctionObject_1.BuiltinFunctionObject(toLocaleLowerCase, 0, this.host.toLocaleLowerCase));
        Define_1.DefineTFT(this, constants.toUpperCase, new BuiltinFunctionObject_1.BuiltinFunctionObject(toUpperCase, 0, this.host.toUpperCase));
        Define_1.DefineTFT(this, constants.toLocaleUpperCase, new BuiltinFunctionObject_1.BuiltinFunctionObject(toLocaleUpperCase, 0, this.host.toLocaleUpperCase));
        Define_1.DefineTFT(this, constants.trim, new BuiltinFunctionObject_1.BuiltinFunctionObject(trim, 0, this.host.trim));
        Define_1.DefineTFT(this, constants.substr, new BuiltinFunctionObject_1.BuiltinFunctionObject(substr, 2, this.host.substr));
    };
    return StringPrototype;
}(EcmaObject_1.EcmaObject));
exports.StringPrototype = StringPrototype;
// ------------------------------------------------------------
// toString, 15.5.4.2
function toString(thisArg, args) {
    if (typeof thisArg.value === 'string') {
        return new Value_1.Value(thisArg.value, thisArg.label);
    }
    if (!StringObject_1.IsStringObject(thisArg)) {
        monitor.Throw("TypeError", 'String.prototype.toString is not generic', thisArg.label);
        throw 'TypeScript';
    }
    var result = thisArg.value.PrimitiveValue.toString();
    return new Value_1.Value(result, thisArg.value.PrimitiveLabel);
}
// ------------------------------------------------------------
// valueOf, 15.5.4.3
var valueOf = toString;
// ------------------------------------------------------------
// charAt, 15.5.4.4
function charAt(thisArg, args) {
    var pos = args[0] || new Value_1.Value(undefined, Label_1.bot);
    CheckObjectCoercible_1.CheckObjectCoercible(thisArg);
    var S = ToString_1.ToString(thisArg);
    var position = ToInteger_1.ToInteger(pos);
    var c = S.value.charAt(position.value);
    return new Value_1.Value(c, Label_1.lub(position.label, S.label));
}
// ------------------------------------------------------------
// charCodeAt, 15.5.4.5
function charCodeAt(thisArg, args) {
    var pos = args[0] || new Value_1.Value(undefined, Label_1.bot);
    CheckObjectCoercible_1.CheckObjectCoercible(thisArg);
    var S = ToString_1.ToString(thisArg);
    var position = ToInteger_1.ToInteger(pos);
    var c = S.value.charCodeAt(position.value);
    return new Value_1.Value(c, Label_1.lub(position.label, thisArg.label));
}
// ------------------------------------------------------------
// concat, 15.5.4.6
function concat(thisArg, args) {
    CheckObjectCoercible_1.CheckObjectCoercible(thisArg);
    var S = ToString_1.ToString(thisArg);
    var lbl = new Label_1.Label();
    var _args = [];
    for (var i = 0, len = args.length; i < len; i++) {
        var arg = ToString_1.ToString(args[i]);
        lbl = Label_1.lub(lbl, arg.label);
        _args[i] = arg.value;
    }
    var str = S.value.concat.apply(S.value, _args);
    lbl = Label_1.lub(lbl, thisArg.label);
    return new Value_1.Value(str, lbl);
}
// ------------------------------------------------------------
// indexOf, 15.5.4.7
function indexOf(thisArg, args) {
    var searchString = args[0] || new Value_1.Value(undefined, Label_1.bot);
    var position = args[1] || new Value_1.Value(0, Label_1.bot);
    CheckObjectCoercible_1.CheckObjectCoercible(thisArg);
    var S = ToString_1.ToString(thisArg);
    var searchStr = ToString_1.ToString(searchString);
    var pos = ToInteger_1.ToInteger(position);
    var lbl = Label_1.lub(S.label, searchStr.label, pos.label);
    var str = S.value.indexOf(searchStr.value, pos.value);
    return new Value_1.Value(str, lbl);
}
// ------------------------------------------------------------
// lastIndexOf, 15.5.4.8
function lastIndexOf(thisArg, args) {
    var searchString = args[0] || new Value_1.Value(undefined, Label_1.bot);
    var position = args[1] || new Value_1.Value(undefined, Label_1.bot);
    CheckObjectCoercible_1.CheckObjectCoercible(thisArg);
    var S = ToString_1.ToString(thisArg);
    var searchStr = ToString_1.ToString(searchString);
    var pos = ToNumber_1.ToNumber(position);
    if (isNaN(pos.value)) {
        pos.value = Infinity;
    }
    else {
        pos = ToInteger_1.ToInteger(pos);
    }
    var lbl = Label_1.lub(S.label, searchStr.label, pos.label);
    var str = S.value.lastIndexOf(searchStr.value, pos.value);
    return new Value_1.Value(str, lbl);
}
// ------------------------------------------------------------
// localeCompare, 15.5.4.9
function localeCompare(thisArg, args) {
    var arg0 = args[0] || new Value_1.Value(undefined, Label_1.bot);
    CheckObjectCoercible_1.CheckObjectCoercible(thisArg);
    var S = ToString_1.ToString(thisArg);
    var that = ToString_1.ToString(arg0);
    var lbl = Label_1.lub(S.label, that.label);
    var result = S.value.localeCompare(that.value);
    return new Value_1.Value(result, lbl);
}
// ------------------------------------------------------------
// match, 15.5.4.10
function match(thisArg, args) {
    var regexp = args[0] || new Value_1.Value(undefined, Label_1.bot);
    CheckObjectCoercible_1.CheckObjectCoercible(thisArg);
    var S = ToString_1.ToString(thisArg);
    var rx;
    if (RegExpObject_1.IsRegExpObject(regexp)) {
        rx = regexp;
    }
    else {
        rx = monitor.instances.RegExpConstructor.Construct([regexp]);
    }
    var lbl = Label_1.lub(S.label, rx.value.PrimitiveLabel);
    monitor.assert(Label_1.le(rx.label, rx.value.PrimitiveLabel), 'String.prototype.match: label of regular expression object not below regular expression label');
    rx.value.PrimitiveLabel = lbl;
    var primitiveArray = S.value.match(rx.value.PrimitiveValue);
    if (primitiveArray === null) {
        return new Value_1.Value(null, lbl);
    }
    var array = ArrayObject_1.ArrayObject.fromArray(primitiveArray, lbl, lbl);
    array.DefineOwnProperty(constants.index, {
        value: primitiveArray.index,
        writable: true,
        enumerable: true,
        configurable: true,
        label: lbl
    });
    array.DefineOwnProperty(constants.input, {
        value: primitiveArray.input,
        writable: true,
        enumerable: true,
        configurable: true,
        label: lbl
    });
    return new Value_1.Value(array, Label_1.bot);
}
// ------------------------------------------------------------
// replace, 15.5.4.11
function replace(thisArg, args) {
    var arg0 = args[0] || new Value_1.Value(undefined, Label_1.bot);
    var arg1 = args[1] || new Value_1.Value(undefined, Label_1.bot);
    CheckObjectCoercible_1.CheckObjectCoercible(thisArg);
    var S = ToString_1.ToString(thisArg);
    var sV, rV;
    var label = Label_1.lub(arg0.label, arg1.label);
    if (RegExpObject_1.IsRegExpObject(arg0)) {
        sV = arg0.value.PrimitiveValue;
    }
    else {
        var searchValue = ToString_1.ToString(arg0);
        label = Label_1.lub(label, searchValue.label);
        sV = searchValue.value;
    }
    var fL = Label_1.bot;
    if (IsCallable_1.IsCallable(arg1)) {
        rV = function () {
            var _args = [];
            for (var i = 0; i < arguments.length; i++) {
                _args[i] = new Value_1.Value(arguments[i], label);
            }
            _args.length = arguments.length;
            var res = arg1.Call(arg1, _args);
            var strRes = ToString_1.ToString(res);
            fL = Label_1.lub(fL, strRes.label);
            return strRes.value;
        };
    }
    else {
        var replaceValue = ToString_1.ToString(arg1);
        rV = replaceValue.value;
    }
    //@ts-ignore TYPES
    var res = S.value.replace(sV, rV);
    return new Value_1.Value(res, Label_1.lub(label, fL));
}
// ------------------------------------------------------------
// search, 15.5.4.12
function search(thisArg, args) {
    var regexp = args[0] || new Value_1.Value(undefined, Label_1.bot);
    CheckObjectCoercible_1.CheckObjectCoercible(thisArg);
    var string = ToString_1.ToString(thisArg);
    var rx;
    if (RegExpObject_1.IsRegExpObject(regexp)) {
        rx = regexp;
    }
    else {
        rx = monitor.instances.RegExpConstructor.Construct([regexp]);
    }
    var lbl = Label_1.lub(string.label, rx.value.PrimitiveLabel);
    monitor.assert(Label_1.le(rx.label, rx.value.PrimitiveLabel), 'String.prototype.match: label of regular expression object not below regular expression label');
    rx.value.PrimitiveLabel = lbl;
    var result = string.value.search(rx.value.PrimitiveValue);
    return new Value_1.Value(result, lbl);
}
// ------------------------------------------------------------
// slice, 15.5.4.13
function slice(thisArg, args) {
    var c = monitor.context;
    var start = args[0] || new Value_1.Value(undefined, Label_1.bot);
    var end = args[1] || new Value_1.Value(undefined, Label_1.bot);
    CheckObjectCoercible_1.CheckObjectCoercible(thisArg);
    var S = ToString_1.ToString(thisArg);
    var len = S.value.length;
    var intStart = ToInteger_1.ToInteger(start);
    c.pushPC(end.label);
    var intEnd;
    if (end.value === undefined) {
        intEnd = new Value_1.Value(len, Label_1.lub(S.label, end.label));
    }
    else {
        intEnd = ToInteger_1.ToInteger(end);
    }
    c.popPC();
    var str = S.value.slice(intStart.value, intEnd.value);
    var lbl = Label_1.lub(S.label, intStart.label, intEnd.label);
    return new Value_1.Value(str, lbl);
}
// ------------------------------------------------------------
// split, 15.5.4.14
function split(thisArg, args) {
    var arg0 = args[0] || new Value_1.Value(undefined, Label_1.bot);
    var arg1 = args[1] || new Value_1.Value(undefined, Label_1.bot);
    CheckObjectCoercible_1.CheckObjectCoercible(thisArg);
    var S = ToString_1.ToString(thisArg);
    var limit;
    var lbl = Label_1.lub(S.label, arg0.label);
    if (arg1.value === undefined) {
        lbl = Label_1.lub(lbl, arg1.label);
        limit = 4294967295;
    }
    else {
        var intLimit = ToInt32_1.ToInt32(arg1);
        lbl = Label_1.lub(lbl, intLimit.label);
        limit = intLimit.value;
    }
    var separator;
    if (arg0.value === undefined) {
        separator = undefined;
    }
    else if (RegExpObject_1.IsRegExpObject(arg0)) {
        separator = arg0.value.PrimitiveValue;
        monitor.assert(Label_1.le(arg0.label, arg0.value.PrimitiveLabel), 'String.prototype.split: label of regular expression object not below label of regular expression');
        arg0.value.PrimitiveLabel = lbl;
    }
    else {
        var stringSeparator = ToString_1.ToString(arg0);
        separator = stringSeparator.value;
        lbl = Label_1.lub(lbl, stringSeparator.label);
    }
    var primitiveArray = S.value.split(separator, limit);
    var array = ArrayObject_1.ArrayObject.fromArray(primitiveArray, lbl, lbl);
    return new Value_1.Value(array, Label_1.bot);
}
// ------------------------------------------------------------
// substring, 15.5.4.15
function substring(thisArg, args) {
    var arg0 = args[0] || new Value_1.Value(undefined, Label_1.bot);
    var arg1 = args[1] || new Value_1.Value(undefined, Label_1.bot);
    CheckObjectCoercible_1.CheckObjectCoercible(thisArg);
    var S = ToString_1.ToString(thisArg);
    var start = ToInteger_1.ToInteger(arg0);
    var len = S.value.length;
    var end;
    if (arg1.value === undefined) {
        end = new Value_1.Value(len, arg1.label);
    }
    else {
        end = ToInteger_1.ToInteger(arg1);
    }
    var lbl = Label_1.lub(S.label, start.label, end.label);
    var str = S.value.substring(start.value, end.value);
    return new Value_1.Value(str, lbl);
}
// ------------------------------------------------------------
function substr(thisArg, args) {
    var arg0 = args[0] || new Value_1.Value(undefined, Label_1.bot);
    var arg1 = args[1] || new Value_1.Value(undefined, Label_1.bot);
    CheckObjectCoercible_1.CheckObjectCoercible(thisArg);
    var S = ToString_1.ToString(thisArg);
    var start = ToInteger_1.ToInteger(arg0);
    var len = S.value.length;
    var end;
    if (arg1.value === undefined) {
        end = new Value_1.Value(len, arg1.label);
    }
    else {
        end = ToInteger_1.ToInteger(arg1);
    }
    var lbl = Label_1.lub(S.label, start.label, end.label);
    var str = S.value.substr(start.value, end.value);
    return new Value_1.Value(str, lbl);
}
// ------------------------------------------------------------
// toLowerCase, 15.5.4.16
function toLowerCase(thisArg, args) {
    CheckObjectCoercible_1.CheckObjectCoercible(thisArg);
    var S = ToString_1.ToString(thisArg);
    var L = S.value.toLowerCase();
    return new Value_1.Value(L, S.label);
}
// ------------------------------------------------------------
// toLocaleLowerCase, 15.5.4.17
function toLocaleLowerCase(thisArg, args) {
    CheckObjectCoercible_1.CheckObjectCoercible(thisArg);
    var S = ToString_1.ToString(thisArg);
    var L = S.value.toLocaleLowerCase();
    return new Value_1.Value(L, S.label);
}
// ------------------------------------------------------------
// toUpperCase, 15.5.4.18
function toUpperCase(thisArg, args) {
    CheckObjectCoercible_1.CheckObjectCoercible(thisArg);
    var S = ToString_1.ToString(thisArg);
    var L = S.value.toUpperCase();
    return new Value_1.Value(L, S.label);
}
// ------------------------------------------------------------
// toLocaleUpperCase, 15.5.4.19
function toLocaleUpperCase(thisArg, args) {
    CheckObjectCoercible_1.CheckObjectCoercible(thisArg);
    var S = ToString_1.ToString(thisArg);
    var L = S.value.toLocaleUpperCase();
    return new Value_1.Value(L, S.label);
}
// ------------------------------------------------------------
// trim, 15.5.4.20
function trim(thisArg, args) {
    CheckObjectCoercible_1.CheckObjectCoercible(thisArg);
    var S = ToString_1.ToString(thisArg);
    var T = S.value.trim();
    return new Value_1.Value(T, S.label);
}

},{"../Constants":64,"../Conversion/ToInt32":82,"../Conversion/ToInteger":83,"../Conversion/ToNumber":84,"../Conversion/ToString":87,"../Define":91,"../Label":123,"../Objects/ArrayObject":132,"../Objects/BuiltinFunctionObject":134,"../Objects/EcmaObject":137,"../Objects/RegExpObject":149,"../Objects/StringObject":150,"../Utility/CheckObjectCoercible":181,"../Utility/IsCallable":182,"../Value":184}],169:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ErrorPrototype_1 = require("./ErrorPrototype");
var SyntaxErrorPrototype = /** @class */ (function (_super) {
    __extends(SyntaxErrorPrototype, _super);
    function SyntaxErrorPrototype(host) {
        return _super.call(this, host) || this;
    }
    SyntaxErrorPrototype.prototype.Setup = function () {
        this.SetupBase(monitor.instances.ErrorConstructor, 'SyntaxError');
    };
    return SyntaxErrorPrototype;
}(ErrorPrototype_1.ErrorPrototype));
exports.SyntaxErrorPrototype = SyntaxErrorPrototype;

},{"./ErrorPrototype":160}],170:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ErrorPrototype_1 = require("./ErrorPrototype");
var TypeErrorPrototype = /** @class */ (function (_super) {
    __extends(TypeErrorPrototype, _super);
    function TypeErrorPrototype(host) {
        return _super.call(this, host) || this;
    }
    TypeErrorPrototype.prototype.Setup = function () {
        this.SetupBase(monitor.instances.ErrorConstructor, 'TypeError');
    };
    return TypeErrorPrototype;
}(ErrorPrototype_1.ErrorPrototype));
exports.TypeErrorPrototype = TypeErrorPrototype;

},{"./ErrorPrototype":160}],171:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ErrorPrototype_1 = require("./ErrorPrototype");
var URIErrorPrototype = /** @class */ (function (_super) {
    __extends(URIErrorPrototype, _super);
    function URIErrorPrototype(host) {
        return _super.call(this, host) || this;
    }
    URIErrorPrototype.prototype.Setup = function () {
        this.SetupBase(monitor.instances.ErrorConstructor, 'URIError');
    };
    return URIErrorPrototype;
}(ErrorPrototype_1.ErrorPrototype));
exports.URIErrorPrototype = URIErrorPrototype;

},{"./ErrorPrototype":160}],172:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
var Reference_1 = require("./Reference");
var ToObject_1 = require("./Conversion/ToObject");
var Label_1 = require("./Label");
var PropertyDescriptor_1 = require("./PropertyDescriptor");
// ------------------------------------------------------------
// PutValue
function PutValue(r, v) {
    if (!(r instanceof Reference_1.Reference)) {
        monitor.Throw("ReferenceError", 'PutValue: target is not a reference', 
        //@ts-ignore TYPES
        r.label);
        throw "TS doesn't know monitor.Throw throws";
    }
    var p = r.base;
    var s = r.propertyName;
    if (r.IsUnresolvableReference()) {
        p.value = monitor.GlobalObject;
        p.Put(s, v);
    }
    else if (r.IsPropertyReference()) {
        if (r.HasPrimitiveBase()) {
            var o = ToObject_1.ToObject(p);
            if (!o.CanPut(s).value) {
                return;
            }
            var ownDesc = o.GetOwnProperty(s);
            if (ownDesc.value && PropertyDescriptor_1.IsDataDescriptor(ownDesc.value)) {
                return;
            }
            // TODO: this must be wrong; part of old handling of getter/setters?
            var desc = o.GetProperty(s);
            if (desc.value && PropertyDescriptor_1.IsAccessorDescriptor(desc.value)) {
                monitor.context.pushPC(Label_1.lub(ownDesc.label, desc.label)); // contains o.label
                //@ts-ignore TYPES
                desc.value.Set.Call(p, [v]);
                monitor.context.popPC();
            }
        }
        else {
            p.Put(s, v);
        }
    }
    else {
        p.SetMutableBinding(s, v);
    }
}
exports.PutValue = PutValue;

},{"./Conversion/ToObject":85,"./Label":123,"./PropertyDescriptor":156,"./Reference":173}],173:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
var Reference = /** @class */ (function () {
    function Reference(base, propertyName) {
        this.base = base;
        this.propertyName = propertyName;
    }
    Reference.prototype.GetBase = function () {
        return this.base;
    };
    Reference.prototype.GetReferencedName = function () {
        return this.propertyName;
    };
    Reference.prototype.HasPrimitiveBase = function () {
        return (typeof this.base.value === 'boolean' ||
            typeof this.base.value === 'string' ||
            typeof this.base.value === 'number');
    };
    Reference.prototype.IsPropertyReference = function () {
        return (typeof this.base.value === 'boolean' ||
            typeof this.base.value === 'string' ||
            typeof this.base.value === 'number' ||
            this.base.value !== undefined && "Class" in this.base.value);
    };
    Reference.prototype.IsUnresolvableReference = function () {
        return (this.base.value === undefined);
    };
    Reference.prototype.toString = function () {
        return ('@(' + this.base + ',' + this.propertyName + ')');
    };
    return Reference;
}());
exports.Reference = Reference;

},{}],174:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
var Result = /** @class */ (function () {
    function Result(value) {
        this.type = 'normal';
        this.target = null;
        this.value = value || null;
    }
    return Result;
}());
exports.Result = Result;

},{}],175:[function(require,module,exports){
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
var Stack = /** @class */ (function () {
    function Stack() {
        this.content = [];
    }
    Stack.prototype.push = function (v) {
        this.content.push(v);
    };
    Stack.prototype.pop = function () {
        if (this.content.length === 0) {
            throw new Error('Empty Stack');
        }
        //@ts-ignore
        return this.content.pop();
    };
    Stack.prototype.peek = function () {
        if (this.content.length === 0) {
            throw new Error('Empty Stack');
        }
        return this.content[this.content.length - 1];
    };
    Stack.prototype.dup = function () {
        this.push(this.peek());
    };
    Stack.prototype.marker = function () {
        return { length: this.content.length };
    };
    Stack.prototype.reset = function (m) {
        this.content.length = m.length;
    };
    Stack.prototype.iter = function (f) {
        for (var i = 0, len = this.content.length; i < len; i++) {
            f(this.content[i]);
        }
    };
    Stack.prototype.map = function (f, m) {
        for (var i = m.length, len = this.content.length; i < len; i++) {
            this.content[i] = f(this.content[i]);
        }
    };
    Stack.prototype.size = function () {
        return this.content.length;
    };
    Stack.prototype.empty = function () {
        return this.content.length === 0;
    };
    Stack.prototype.toArray = function () {
        return this.content.slice(0);
    };
    return Stack;
}());
exports.Stack = Stack;

},{}],176:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
var escodegen = require("escodegen");
// --------------------------------------------------------------------------- 
var StackTrace = /** @class */ (function () {
    function StackTrace(stack) {
        this.trace = [];
        for (var i = 0, len = stack.length; i < len; i++) {
            var context = stack[i];
            var stmt = context.codeStack.size() > 0 ? context.codeStack.peek() : undefined;
            if (stmt === undefined) {
                break;
            }
            var loc = stmt.loc;
            var source = loc.source;
            this.trace.push({ owner: context.owner, source: source, loc: loc.start, stmt: stmt });
        }
    }
    StackTrace.prototype.toString = function () {
        if (this.trace.length === 0) {
            return '';
        }
        var result;
        var len = this.trace.length;
        // last entry contains offending command
        var last = this.trace[len - 1];
        result = last.source + ':' + last.loc.line + ':' + last.loc.column + '\n';
        result = result + '    ' + escodegen.generate(last.stmt) + '\n\n';
        for (var i = len - 2; i >= 0; i--) {
            var tr = this.trace[i];
            if (tr.owner) {
                result = result + 'at ' + tr.owner + ' ';
            }
            result = result + '(' + tr.source + ':' + tr.loc.line + ':' + tr.loc.column + ')\n';
        }
        return result;
    };
    return StackTrace;
}());
exports.StackTrace = StackTrace;

},{"escodegen":5}],177:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var FunctionObject_1 = require("./Objects/FunctionObject");
var Value_1 = require("./Value");
var Label_1 = require("./Label");
var Define_1 = require("./Define");
var esprima = require("esprima");
var constants = require("./Constants");
// 13.2.3
var ThrowTypeError = /** @class */ (function (_super) {
    __extends(ThrowTypeError, _super);
    function ThrowTypeError() {
        var _this = _super.call(this, [], 
        //@ts-ignore
        esprima.parse("(function() { throw new TypeError(); })").body[0].expression, new Value_1.Value(monitor.GlobalEnvironment, Label_1.bot)) || this;
        Define_1.DefineFFF(_this, constants.length, 0);
        _this.Extensible = false;
        return _this;
    }
    Object.defineProperty(ThrowTypeError, "Instance", {
        get: function () {
            if (ThrowTypeError.instance === undefined) {
                ThrowTypeError.instance = new ThrowTypeError();
            }
            return ThrowTypeError.instance;
        },
        enumerable: true,
        configurable: true
    });
    return ThrowTypeError;
}(FunctionObject_1.FunctionObject));
exports.ThrowTypeError = ThrowTypeError;

},{"./Constants":64,"./Define":91,"./Label":123,"./Objects/FunctionObject":140,"./Value":184,"esprima":18}],178:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
function IsCrawler(monitor) {
    //@ts-ignore monitor.crawler is a boolean option
    return monitor.options.get("monitor.crawler");
}
exports.IsCrawler = IsCrawler;

},{}],179:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
var JSFlowMonitor_1 = require("./JSFlowMonitor");
var sms = require('source-map-support');
sms.install();
//@ts-ignore TYPES
jsflow.monitor = new JSFlowMonitor_1.JSFlowMonitor(window);
//@ts-ignore TYPES
jsflow.version = "1.2";

},{"./JSFlowMonitor":180,"source-map-support":63}],180:[function(require,module,exports){
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var MonitorBase_1 = require("../../MonitorBase");
var GlobalObject_1 = require("../../Objects/GlobalObject");
var Instances_1 = require("../../Instances");
var Value_1 = require("../../Value");
var Label_1 = require("../../Label");
var ObjectEnvironmentRecord_1 = require("../../ObjectEnvironmentRecord");
var Module_1 = require("../../Module/CommonJS/Module");
// --------------------------------------------------------------------------
var JSFlowMonitor = /** @class */ (function (_super) {
    __extends(JSFlowMonitor, _super);
    function JSFlowMonitor(global, print, log, info, warn, error) {
        var _this = _super.call(this, global, print, log, info, warn, error) || this;
        _this.instances = new Instances_1.Instances(global);
        _this.instances.Setup();
        _this.GlobalObject = new GlobalObject_1.GlobalObject(global);
        _this.GlobalEnvironment = ObjectEnvironmentRecord_1.NewObjectEnvironment(new Value_1.Value(_this.GlobalObject, Label_1.bot), new Value_1.Value(null, Label_1.bot));
        _this.context.thisValue = new Value_1.Value(_this.GlobalObject, Label_1.bot);
        _this.context.variableEnv = new Value_1.Value(_this.GlobalEnvironment, Label_1.bot);
        _this.context.lexicalEnv = new Value_1.Value(_this.GlobalEnvironment, Label_1.bot);
        _this.module = new Module_1.CommonJSModule();
        _this.GlobalObject.Put(new Value_1.Value('module', Label_1.bot), new Value_1.Value(_this.module, Label_1.bot), false);
        _this.GlobalObject.Put(new Value_1.Value('require', Label_1.bot), new Value_1.Value(_this.module.require, Label_1.bot), false);
        _this.labelBot = Label_1.bot;
        return _this;
    }
    JSFlowMonitor.prototype.ExecuteModule = function (path) {
        Module_1.CommonJSModule.LoadModule(new Value_1.Value(path, Label_1.bot));
    };
    return JSFlowMonitor;
}(MonitorBase_1.MonitorBase));
exports.JSFlowMonitor = JSFlowMonitor;

},{"../../Instances":121,"../../Label":123,"../../Module/CommonJS/Module":125,"../../MonitorBase":129,"../../ObjectEnvironmentRecord":130,"../../Objects/GlobalObject":141,"../../Value":184}],181:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
// -------------------------------------------------------------
// CheckObjectCoercible, 9.10
function CheckObjectCoercible(x) {
    if (x.value === null || x.value === undefined) {
        monitor.context.raisePC(x.label);
        monitor.Throw("TypeError", String(x.value) + ' is not coercible', x.label);
        throw 'TypeScript';
    }
    return true;
}
exports.CheckObjectCoercible = CheckObjectCoercible;

},{}],182:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
// -------------------------------------------------------------
// IsCallable, 9.11
function IsCallable(x) {
    var b = false;
    if (x.value !== null && typeof x.value === 'object') {
        b = 'Call' in x.value;
    }
    return b;
}
exports.IsCallable = IsCallable;

},{}],183:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
// -------------------------------------------------------------
// ES6: IsConstructor, 7.2.4
function IsConstructor(argument) {
    if (typeof argument.value !== 'object') {
        return false;
    }
    return argument.value.Construct !== undefined;
}
exports.IsConstructor = IsConstructor;

},{}],184:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", { value: true });
var Label_1 = require("./Label");
// ------------------------------------------------------------
// Value - labeled values
var Value = /** @class */ (function () {
    function Value(value, label) {
        this.value = value;
        this.label = label;
        if (label === undefined) {
            throw new Error("Value with undefined label");
        }
    }
    // ------------------------------------------------------------
    Value.prototype.raise = function (l) {
        this.label = Label_1.lub(this.label, l);
    };
    // ------------------------------------------------------------
    Value.prototype.clone = function () {
        return new Value(this.value, this.label);
    };
    // ------------------------------------------------------------
    Value.prototype.toString = function () {
        if (typeof this.value === 'string') {
            return "'" + this.value + "'_" + this.label;
        }
        else {
            return this.value + "_" + this.label;
        }
    };
    // ------------------------------------------------------------
    // Ecma
    Value.prototype.GetOwnProperty = function (s) {
        var value = this.value;
        return InContext(this.label, function () { return value.GetOwnProperty(s); });
    };
    Value.prototype.GetProperty = function (s) {
        var value = this.value;
        return InContext(this.label, function () { return value.GetProperty(s); });
    };
    Value.prototype.Get = function (s) {
        var value = this.value;
        return InContext(this.label, function () { return value.Get(s); });
    };
    Value.prototype.CanPut = function (p) {
        var value = this.value;
        return InContext(this.label, function () { return value.CanPut(p); });
    };
    Value.prototype.Put = function (s, v, Throw) {
        var value = this.value;
        return InContext(this.label, function () { return value.Put(s, v, Throw); });
    };
    Value.prototype.HasProperty = function (s) {
        var value = this.value;
        return InContext(this.label, function () { return value.HasProperty(s); });
    };
    Value.prototype.Delete = function (s, Throw) {
        var value = this.value;
        return InContext(this.label, function () { return value.Delete(s, Throw); });
    };
    Value.prototype.DefaultValue = function (hint) {
        var value = this.value;
        return InContext(this.label, function () { return value.DefaultValue(hint); });
    };
    Value.prototype.DefineOwnProperty = function (s, desc, Throw) {
        var value = this.value;
        return InContext(this.label, function () { return value.DefineOwnProperty(s, desc, Throw); });
    };
    // ---
    // Function
    Value.prototype.HasInstance = function (V) {
        var value = this.value;
        return InContext(this.label, function () { return value.HasInstance(V); });
    };
    Value.prototype.Call = function (thisArg, args) {
        var value = this.value;
        return InContext(this.label, function () { return value.Call(thisArg, args); });
    };
    Value.prototype.Construct = function (args) {
        var value = this.value;
        return InContext(this.label, function () { return value.Construct(args); });
    };
    // ---
    // ObjectEnvironmentRecord, DeclarativeEnvironmentRecord
    Value.prototype.HasBinding = function (p) {
        var value = this.value;
        return InContext(this.label, function () { return value.HasBinding(p); });
    };
    Value.prototype.CreateMutableBinding = function (p, d) {
        var value = this.value;
        return InContext(this.label, function () { return value.CreateMutableBinding(p, d); });
    };
    Value.prototype.GetBindingValue = function (p, s) {
        var value = this.value;
        return InContext(this.label, function () { return value.GetBindingValue(p, s); });
    };
    Value.prototype.SetMutableBinding = function (p, v, s) {
        var value = this.value;
        return InContext(this.label, function () { return value.SetMutableBinding(p, v, s); });
    };
    Value.prototype.DeleteBinding = function (p) {
        var value = this.value;
        return InContext(this.label, function () { return value.DeleteBinding(p); });
    };
    Value.prototype.ImplicitThisValue = function () {
        var value = this.value;
        return InContext(this.label, function () { return value.ImplicitThisValue(); });
    };
    // DeclarativeEnvironmentRecord
    Value.prototype.CreateImmutableBinding = function (p) {
        var value = this.value;
        return InContext(this.label, function () { return value.CreateImmutableBinding(p); });
    };
    Value.prototype.InitializeImmutableBinding = function (p, v) {
        var value = this.value;
        return InContext(this.label, function () { return value.InitializeImmutableBinding(p, v); });
    };
    return Value;
}());
exports.Value = Value;
function InContext(l, f) {
    monitor.context.pushPC(l);
    var res = f();
    monitor.context.popPC();
    if (res instanceof Value) {
        res.raise(l);
    }
    return res;
}

},{"./Label":123}]},{},[179])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbGliL19lbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXItZnJvbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXNjb2RlZ2VuL2VzY29kZWdlbi5qcyIsIm5vZGVfbW9kdWxlcy9lc2NvZGVnZW4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL2FycmF5LXNldC5qcyIsIm5vZGVfbW9kdWxlcy9lc2NvZGVnZW4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL2Jhc2U2NC12bHEuanMiLCJub2RlX21vZHVsZXMvZXNjb2RlZ2VuL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9iYXNlNjQuanMiLCJub2RlX21vZHVsZXMvZXNjb2RlZ2VuL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9iaW5hcnktc2VhcmNoLmpzIiwibm9kZV9tb2R1bGVzL2VzY29kZWdlbi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvbWFwcGluZy1saXN0LmpzIiwibm9kZV9tb2R1bGVzL2VzY29kZWdlbi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvcXVpY2stc29ydC5qcyIsIm5vZGVfbW9kdWxlcy9lc2NvZGVnZW4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAtY29uc3VtZXIuanMiLCJub2RlX21vZHVsZXMvZXNjb2RlZ2VuL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwLWdlbmVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9lc2NvZGVnZW4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1ub2RlLmpzIiwibm9kZV9tb2R1bGVzL2VzY29kZWdlbi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9lc2NvZGVnZW4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvc291cmNlLW1hcC5qcyIsIm5vZGVfbW9kdWxlcy9lc2NvZGVnZW4vcGFja2FnZS5qc29uIiwibm9kZV9tb2R1bGVzL2VzcHJpbWEvZXNwcmltYS5qcyIsIm5vZGVfbW9kdWxlcy9lc3RyYXZlcnNlL2VzdHJhdmVyc2UuanMiLCJub2RlX21vZHVsZXMvZXN0cmF2ZXJzZS9wYWNrYWdlLmpzb24iLCJub2RlX21vZHVsZXMvZXN1dGlscy9saWIvYXN0LmpzIiwibm9kZV9tb2R1bGVzL2VzdXRpbHMvbGliL2NvZGUuanMiLCJub2RlX21vZHVsZXMvZXN1dGlscy9saWIva2V5d29yZC5qcyIsIm5vZGVfbW9kdWxlcy9lc3V0aWxzL2xpYi91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzLWJlYXV0aWZ5L2pzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzLWJlYXV0aWZ5L2pzL3NyYy9jb3JlL2RpcmVjdGl2ZXMuanMiLCJub2RlX21vZHVsZXMvanMtYmVhdXRpZnkvanMvc3JjL2NvcmUvaW5wdXRzY2FubmVyLmpzIiwibm9kZV9tb2R1bGVzL2pzLWJlYXV0aWZ5L2pzL3NyYy9jb3JlL29wdGlvbnMuanMiLCJub2RlX21vZHVsZXMvanMtYmVhdXRpZnkvanMvc3JjL2NvcmUvb3V0cHV0LmpzIiwibm9kZV9tb2R1bGVzL2pzLWJlYXV0aWZ5L2pzL3NyYy9jb3JlL3BhdHRlcm4uanMiLCJub2RlX21vZHVsZXMvanMtYmVhdXRpZnkvanMvc3JjL2NvcmUvdGVtcGxhdGFibGVwYXR0ZXJuLmpzIiwibm9kZV9tb2R1bGVzL2pzLWJlYXV0aWZ5L2pzL3NyYy9jb3JlL3Rva2VuLmpzIiwibm9kZV9tb2R1bGVzL2pzLWJlYXV0aWZ5L2pzL3NyYy9jb3JlL3Rva2VuaXplci5qcyIsIm5vZGVfbW9kdWxlcy9qcy1iZWF1dGlmeS9qcy9zcmMvY29yZS90b2tlbnN0cmVhbS5qcyIsIm5vZGVfbW9kdWxlcy9qcy1iZWF1dGlmeS9qcy9zcmMvY29yZS93aGl0ZXNwYWNlcGF0dGVybi5qcyIsIm5vZGVfbW9kdWxlcy9qcy1iZWF1dGlmeS9qcy9zcmMvY3NzL2JlYXV0aWZpZXIuanMiLCJub2RlX21vZHVsZXMvanMtYmVhdXRpZnkvanMvc3JjL2Nzcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qcy1iZWF1dGlmeS9qcy9zcmMvY3NzL29wdGlvbnMuanMiLCJub2RlX21vZHVsZXMvanMtYmVhdXRpZnkvanMvc3JjL2h0bWwvYmVhdXRpZmllci5qcyIsIm5vZGVfbW9kdWxlcy9qcy1iZWF1dGlmeS9qcy9zcmMvaHRtbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qcy1iZWF1dGlmeS9qcy9zcmMvaHRtbC9vcHRpb25zLmpzIiwibm9kZV9tb2R1bGVzL2pzLWJlYXV0aWZ5L2pzL3NyYy9odG1sL3Rva2VuaXplci5qcyIsIm5vZGVfbW9kdWxlcy9qcy1iZWF1dGlmeS9qcy9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanMtYmVhdXRpZnkvanMvc3JjL2phdmFzY3JpcHQvYWNvcm4uanMiLCJub2RlX21vZHVsZXMvanMtYmVhdXRpZnkvanMvc3JjL2phdmFzY3JpcHQvYmVhdXRpZmllci5qcyIsIm5vZGVfbW9kdWxlcy9qcy1iZWF1dGlmeS9qcy9zcmMvamF2YXNjcmlwdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qcy1iZWF1dGlmeS9qcy9zcmMvamF2YXNjcmlwdC9vcHRpb25zLmpzIiwibm9kZV9tb2R1bGVzL2pzLWJlYXV0aWZ5L2pzL3NyYy9qYXZhc2NyaXB0L3Rva2VuaXplci5qcyIsIm5vZGVfbW9kdWxlcy9wYXRoLWJyb3dzZXJpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAtc3VwcG9ydC9zb3VyY2UtbWFwLXN1cHBvcnQuanMiLCJzcmMvQ29uc3RhbnRzLnRzIiwic3JjL0NvbnN0cnVjdG9ycy9BcnJheUNvbnN0cnVjdG9yLnRzIiwic3JjL0NvbnN0cnVjdG9ycy9Cb29sZWFuQ29uc3RydWN0b3IudHMiLCJzcmMvQ29uc3RydWN0b3JzL0RhdGVDb25zdHJ1Y3Rvci50cyIsInNyYy9Db25zdHJ1Y3RvcnMvRXJyb3JDb25zdHJ1Y3Rvci50cyIsInNyYy9Db25zdHJ1Y3RvcnMvRXZhbEVycm9yQ29uc3RydWN0b3IudHMiLCJzcmMvQ29uc3RydWN0b3JzL0Z1bmN0aW9uQ29uc3RydWN0b3IudHMiLCJzcmMvQ29uc3RydWN0b3JzL051bWJlckNvbnN0cnVjdG9yLnRzIiwic3JjL0NvbnN0cnVjdG9ycy9PYmplY3RDb25zdHJ1Y3Rvci50cyIsInNyYy9Db25zdHJ1Y3RvcnMvUmFuZ2VFcnJvckNvbnN0cnVjdG9yLnRzIiwic3JjL0NvbnN0cnVjdG9ycy9SZWZlcmVuY2VFcnJvckNvbnN0cnVjdG9yLnRzIiwic3JjL0NvbnN0cnVjdG9ycy9SZWdFeHBDb25zdHJ1Y3Rvci50cyIsInNyYy9Db25zdHJ1Y3RvcnMvU3RyaW5nQ29uc3RydWN0b3IudHMiLCJzcmMvQ29uc3RydWN0b3JzL1N5bnRheEVycm9yQ29uc3RydWN0b3IudHMiLCJzcmMvQ29uc3RydWN0b3JzL1R5cGVFcnJvckNvbnN0cnVjdG9yLnRzIiwic3JjL0NvbnN0cnVjdG9ycy9VUklFcnJvckNvbnN0cnVjdG9yLnRzIiwic3JjL0NvbnRleHQudHMiLCJzcmMvQ29udmVyc2lvbi9Ub0Jvb2xlYW4udHMiLCJzcmMvQ29udmVyc2lvbi9Ub0ludDMyLnRzIiwic3JjL0NvbnZlcnNpb24vVG9JbnRlZ2VyLnRzIiwic3JjL0NvbnZlcnNpb24vVG9OdW1iZXIudHMiLCJzcmMvQ29udmVyc2lvbi9Ub09iamVjdC50cyIsInNyYy9Db252ZXJzaW9uL1RvUHJpbWl0aXZlLnRzIiwic3JjL0NvbnZlcnNpb24vVG9TdHJpbmcudHMiLCJzcmMvQ29udmVyc2lvbi9Ub1VJbnQxNi50cyIsInNyYy9Db252ZXJzaW9uL1RvVUludDMyLnRzIiwic3JjL0RlY2xhcmF0aXZlRW52aXJvbm1lbnRSZWNvcmQudHMiLCJzcmMvRGVmaW5lLnRzIiwic3JjL0VuZ2luZS9CaW5hcnlPcGVyYXRvcnMudHMiLCJzcmMvRW5naW5lL0JpbmRpbmcudHMiLCJzcmMvRW5naW5lL0RlYnVnLnRzIiwic3JjL0VuZ2luZS9FeGVjdXRlLnRzIiwic3JjL0VuZ2luZS9FeHByZXNzaW9uLnRzIiwic3JjL0VuZ2luZS9TdGF0ZW1lbnQudHMiLCJzcmMvRW5naW5lL1Rhc2sudHMiLCJzcmMvRW5naW5lL1RyYWNpbmcvQmxvY2tTdGF0ZW1lbnQudHMiLCJzcmMvRW5naW5lL1RyYWNpbmcvQnJlYWtTdGF0ZW1lbnQudHMiLCJzcmMvRW5naW5lL1RyYWNpbmcvQ29udGludWVTdGF0ZW1lbnQudHMiLCJzcmMvRW5naW5lL1RyYWNpbmcvRGVidWdnZXJTdGF0ZW1lbnQudHMiLCJzcmMvRW5naW5lL1RyYWNpbmcvRW1wdHlTdGF0ZW1lbnQudHMiLCJzcmMvRW5naW5lL1RyYWNpbmcvRXhwcmVzc2lvblN0YXRlbWVudC50cyIsInNyYy9FbmdpbmUvVHJhY2luZy9Gb3JJblN0YXRlbWVudC50cyIsInNyYy9FbmdpbmUvVHJhY2luZy9Gb3JTdGF0ZW1lbnQudHMiLCJzcmMvRW5naW5lL1RyYWNpbmcvSWZTdGF0ZW1lbnQudHMiLCJzcmMvRW5naW5lL1RyYWNpbmcvTGFiZWxlZFN0YXRlbWVudC50cyIsInNyYy9FbmdpbmUvVHJhY2luZy9SZXR1cm5TdGF0ZW1lbnQudHMiLCJzcmMvRW5naW5lL1RyYWNpbmcvU3dpdGNoU3RhdGVtZW50LnRzIiwic3JjL0VuZ2luZS9UcmFjaW5nL1Rocm93U3RhdGVtZW50LnRzIiwic3JjL0VuZ2luZS9UcmFjaW5nL1RyeUNhdGNoU3RhdGVtZW50LnRzIiwic3JjL0VuZ2luZS9UcmFjaW5nL1ZhcmlhYmxlRGVjbGFyYXRpb24udHMiLCJzcmMvRW5naW5lL1RyYWNpbmcvV2hpbGVTdGF0ZW1lbnQudHMiLCJzcmMvRW5naW5lL1RyYWNpbmcvV2l0aFN0YXRlbWVudC50cyIsInNyYy9FbmdpbmUvVW5hcnlPcGVyYXRvcnMudHMiLCJzcmMvRXJyb3IudHMiLCJzcmMvR2V0SWRlbnRpZmllclJlZmVyZW5jZS50cyIsInNyYy9HZXRWYWx1ZS50cyIsInNyYy9IYXNJbnN0YW5jZS50cyIsInNyYy9JbnN0YW5jZXMudHMiLCJzcmMvSW50ZXJmYWNlcy50cyIsInNyYy9MYWJlbC50cyIsInNyYy9MZXhpY2FsRW52aXJvbm1lbnQudHMiLCJzcmMvTW9kdWxlL0NvbW1vbkpTL01vZHVsZS50cyIsInNyYy9Nb2R1bGUvQ29tbW9uSlMvUmVxdWlyZS50cyIsInNyYy9Nb2R1bGUvTW9kdWxlLnRzIiwic3JjL01vZHVsZS9SZXF1aXJlLnRzIiwic3JjL01vbml0b3JCYXNlLnRzIiwic3JjL09iamVjdEVudmlyb25tZW50UmVjb3JkLnRzIiwic3JjL09iamVjdHMvQXJndW1lbnRzT2JqZWN0LnRzIiwic3JjL09iamVjdHMvQXJyYXlPYmplY3QudHMiLCJzcmMvT2JqZWN0cy9Cb29sZWFuT2JqZWN0LnRzIiwic3JjL09iamVjdHMvQnVpbHRpbkZ1bmN0aW9uT2JqZWN0LnRzIiwic3JjL09iamVjdHMvQnVpbHRpbk1ldGhvZE9iamVjdC50cyIsInNyYy9PYmplY3RzL0RhdGVPYmplY3QudHMiLCJzcmMvT2JqZWN0cy9FY21hT2JqZWN0LnRzIiwic3JjL09iamVjdHMvRXJyb3JPYmplY3QudHMiLCJzcmMvT2JqZWN0cy9FdmFsRXJyb3JPYmplY3QudHMiLCJzcmMvT2JqZWN0cy9GdW5jdGlvbk9iamVjdC50cyIsInNyYy9PYmplY3RzL0dsb2JhbE9iamVjdC50cyIsInNyYy9PYmplY3RzL0pTT05PYmplY3QudHMiLCJzcmMvT2JqZWN0cy9NYXRoT2JqZWN0LnRzIiwic3JjL09iamVjdHMvTmF0aXZlRXJyb3JPYmplY3QudHMiLCJzcmMvT2JqZWN0cy9OdW1iZXJPYmplY3QudHMiLCJzcmMvT2JqZWN0cy9PYmplY3RPYmplY3QudHMiLCJzcmMvT2JqZWN0cy9SYW5nZUVycm9yT2JqZWN0LnRzIiwic3JjL09iamVjdHMvUmVmZXJlbmNlRXJyb3JPYmplY3QudHMiLCJzcmMvT2JqZWN0cy9SZWdFeHBPYmplY3QudHMiLCJzcmMvT2JqZWN0cy9TdHJpbmdPYmplY3QudHMiLCJzcmMvT2JqZWN0cy9TeW50YXhFcnJvck9iamVjdC50cyIsInNyYy9PYmplY3RzL1R5cGVFcnJvck9iamVjdC50cyIsInNyYy9PYmplY3RzL1VSSUVycm9yT2JqZWN0LnRzIiwic3JjL09wdGlvbnMudHMiLCJzcmMvUFAudHMiLCJzcmMvUHJvcGVydHlEZXNjcmlwdG9yLnRzIiwic3JjL1Byb3RvdHlwZXMvQXJyYXlQcm90b3R5cGUudHMiLCJzcmMvUHJvdG90eXBlcy9Cb29sZWFuUHJvdG90eXBlLnRzIiwic3JjL1Byb3RvdHlwZXMvRGF0ZVByb3RvdHlwZS50cyIsInNyYy9Qcm90b3R5cGVzL0Vycm9yUHJvdG90eXBlLnRzIiwic3JjL1Byb3RvdHlwZXMvRXZhbEVycm9yUHJvdG90eXBlLnRzIiwic3JjL1Byb3RvdHlwZXMvRnVuY3Rpb25Qcm90b3R5cGUudHMiLCJzcmMvUHJvdG90eXBlcy9OdW1iZXJQcm90b3R5cGUudHMiLCJzcmMvUHJvdG90eXBlcy9PYmplY3RQcm90b3R5cGUudHMiLCJzcmMvUHJvdG90eXBlcy9SYW5nZUVycm9yUHJvdG90eXBlLnRzIiwic3JjL1Byb3RvdHlwZXMvUmVmZXJlbmNlRXJyb3JQcm90b3R5cGUudHMiLCJzcmMvUHJvdG90eXBlcy9SZWdFeHBQcm90b3R5cGUudHMiLCJzcmMvUHJvdG90eXBlcy9TdHJpbmdQcm90b3R5cGUudHMiLCJzcmMvUHJvdG90eXBlcy9TeW50YXhFcnJvclByb3RvdHlwZS50cyIsInNyYy9Qcm90b3R5cGVzL1R5cGVFcnJvclByb3RvdHlwZS50cyIsInNyYy9Qcm90b3R5cGVzL1VSSUVycm9yUHJvdG90eXBlLnRzIiwic3JjL1B1dFZhbHVlLnRzIiwic3JjL1JlZmVyZW5jZS50cyIsInNyYy9SZXN1bHQudHMiLCJzcmMvU3RhY2sudHMiLCJzcmMvU3RhY2tUcmFjZS50cyIsInNyYy9UaHJvd1R5cGVFcnJvci50cyIsInNyYy9Ub3BsZXZlbC9jcmF3bGVyL0NyYXdsZXJVdGlsLnRzIiwic3JjL1RvcGxldmVsL2pzZmxvdy9KU0Zsb3dDaGFsbGVuZ2VCYXNlLnRzIiwic3JjL1RvcGxldmVsL2pzZmxvdy9KU0Zsb3dNb25pdG9yLnRzIiwic3JjL1V0aWxpdHkvQ2hlY2tPYmplY3RDb2VyY2libGUudHMiLCJzcmMvVXRpbGl0eS9Jc0NhbGxhYmxlLnRzIiwic3JjL1V0aWxpdHkvSXNDb25zdHJ1Y3Rvci50cyIsInNyYy9WYWx1ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SkE7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdndEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNWpGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3puQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3phQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4ZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVtTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzl3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDak1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9MQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0ZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3gwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDLzZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzFrQkEsaUNBQThCO0FBQzlCLGlDQUFnQztBQUVyQixRQUFBLEtBQUssR0FBRyxJQUFJLGFBQUssQ0FBQyxPQUFPLEVBQUUs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QyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7QUFDekUsQ0FBQztBQUVELCtEQUErRDtBQUMvRCxvQkFBb0I7QUFDcEIsU0FBUyxNQUFNLENBQTRCLE9BQTBCLEVBQUUsSUFBeUI7SUFDNUYsT0FBTyxJQUFJLGFBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLEVBQUUsV0FBRyxDQUFDLENBQUM7QUFDdkMsQ0FBQztBQUVELCtEQUErRDtBQUMvRCxtQkFBbUI7QUFDbkIsU0FBUyxLQUFLLENBQXFDLE9BQTBCLEVBQUUsSUFBeUI7SUFDcEcsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxtQkFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLGFBQUssQ0FBQyxHQUFHLEVBQUUsV0FBRyxDQUFDLENBQUM7SUFDMUQsT0FBTyxJQUFJLGFBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDbEQsQ0FBQztBQUVELCtEQUErRDtBQUMvRCxpQkFBaUI7QUFDakIsU0FBUyxHQUFHLENBQXFDLE9BQTBCLEVBQUUsSUFBeUI7SUFDbEcsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxtQkFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLGFBQUssQ0FBQyxHQUFHLEVBQUUsV0FBRyxDQUFDLENBQUM7SUFDMUQsT0FBTyxJQUFJLGFBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDbEQsQ0FBQztBQUVELCtEQUErRDtBQUMvRCxrQkFBa0I7QUFDbEIsU0FBUyxJQUFJLENBQXFDLE9BQTBCLEVBQUUsSUFBeUI7SUFDbkcsSUFBSSxDQUFDLEdBQUcs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QUFTLENBQUksQ0FBUSxFQUFFLENBQVU7SUFDeEMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDMUIsSUFBSSxHQUFHLEdBQUcsQ0FBQyxFQUFFLENBQUM7SUFDZCxPQUFPLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxDQUFDO0lBRXhCLElBQUksR0FBRyxZQUFZLEtBQUssRUFBRTtRQUN4QixHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ2Q7SUFFRCxPQUFPLEdBQUcsQ0FBQztBQUNiLENBQUMiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsoXG4gICAgICB1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpXG4gICAgKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiIiwidmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xuXG52YXIgaXNNb2Rlcm4gPSAoXG4gIHR5cGVvZiBCdWZmZXIuYWxsb2MgPT09ICdmdW5jdGlvbicgJiZcbiAgdHlwZW9mIEJ1ZmZlci5hbGxvY1Vuc2FmZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICB0eXBlb2YgQnVmZmVyLmZyb20gPT09ICdmdW5jdGlvbidcbilcblxuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlciAoaW5wdXQpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaW5wdXQpLnNsaWNlKDgsIC0xKSA9PT0gJ0FycmF5QnVmZmVyJ1xufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKG9iaiwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGJ5dGVPZmZzZXQgPj4+PSAwXG5cbiAgdmFyIG1heExlbmd0aCA9IG9iai5ieXRlTGVuZ3RoIC0gYnl0ZU9mZnNldFxuXG4gIGlmIChtYXhMZW5ndGggPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCInb2Zmc2V0JyBpcyBvdXQgb2YgYm91bmRzXCIpXG4gIH1cblxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSBtYXhMZW5ndGhcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPj4+PSAwXG5cbiAgICBpZiAobGVuZ3RoID4gbWF4TGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIidsZW5ndGgnIGlzIG91dCBvZiBib3VuZHNcIilcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaXNNb2Rlcm5cbiAgICA/IEJ1ZmZlci5mcm9tKG9iai5zbGljZShieXRlT2Zmc2V0LCBieXRlT2Zmc2V0ICsgbGVuZ3RoKSlcbiAgICA6IG5ldyBCdWZmZXIobmV3IFVpbnQ4QXJyYXkob2JqLnNsaWNlKGJ5dGVPZmZzZXQsIGJ5dGVPZmZzZXQgKyBsZW5ndGgpKSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICByZXR1cm4gaXNNb2Rlcm5cbiAgICA/IEJ1ZmZlci5mcm9tKHN0cmluZywgZW5jb2RpbmcpXG4gICAgOiBuZXcgQnVmZmVyKHN0cmluZywgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGJ1ZmZlckZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKGlzQXJyYXlCdWZmZXIodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBpc01vZGVyblxuICAgID8gQnVmZmVyLmZyb20odmFsdWUpXG4gICAgOiBuZXcgQnVmZmVyKHZhbHVlKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlckZyb21cbiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBjdXN0b21JbnNwZWN0U3ltYm9sID1cbiAgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5mb3IgPT09ICdmdW5jdGlvbicpXG4gICAgPyBTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXG4gICAgOiBudWxsXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxudmFyIEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmZcbmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBQcmludCB3YXJuaW5nIGFuZCByZWNvbW1lbmQgdXNpbmcgYGJ1ZmZlcmAgdjQueCB3aGljaCBoYXMgYW4gT2JqZWN0XG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBXZSByZXBvcnQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBpZiB0aGUgYXJlIG5vdCBzdWJjbGFzc2FibGVcbiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWBcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcbiAqIGZvciBfX3Byb3RvX18gYW5kIGhhcyBhIGJ1Z2d5IHR5cGVkIGFycmF5IGltcGxlbWVudGF0aW9uLlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBjb25zb2xlLmVycm9yKFxuICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xuICApXG59XG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkP1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIHZhciBwcm90byA9IHsgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9IH1cbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YocHJvdG8sIFVpbnQ4QXJyYXkucHJvdG90eXBlKVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihhcnIsIHByb3RvKVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ3BhcmVudCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5idWZmZXJcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdvZmZzZXQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldFxuICB9XG59KVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBsZW5ndGggKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXIucHJvdG90eXBlKVxuICByZXR1cm4gYnVmXG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICE9IG51bGwgJiZcbiAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG5mdW5jdGlvbiBmcm9tICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHZhbHVlKVxuICB9XG5cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICAgIClcbiAgfVxuXG4gIGlmIChpc0luc3RhbmNlKHZhbHVlLCBBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgQXJyYXlCdWZmZXIpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICApXG4gIH1cblxuICB2YXIgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YgJiYgdmFsdWUudmFsdWVPZigpXG4gIGlmICh2YWx1ZU9mICE9IG51bGwgJiYgdmFsdWVPZiAhPT0gdmFsdWUpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWVPZiwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgdmFyIGIgPSBmcm9tT2JqZWN0KHZhbHVlKVxuICBpZiAoYikgcmV0dXJuIGJcblxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvUHJpbWl0aXZlICE9IG51bGwgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKFxuICAgICAgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSgnc3RyaW5nJyksIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aFxuICAgIClcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIE5vdGU6IENoYW5nZSBwcm90b3R5cGUgKmFmdGVyKiBCdWZmZXIuZnJvbSBpcyBkZWZpbmVkIHRvIHdvcmthcm91bmQgQ2hyb21lIGJ1Zzpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvMTQ4XG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLnByb3RvdHlwZSwgVWludDhBcnJheS5wcm90b3R5cGUpXG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLCBVaW50OEFycmF5KVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgc2l6ZSArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSBidWYud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIGJ1ZiA9IGJ1Zi5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICBidWZbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyIChhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcIm9mZnNldFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wibGVuZ3RoXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIHZhciBidWZcbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpXG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0IChvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pXG5cbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZlxuICAgIH1cblxuICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKVxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApXG4gICAgfVxuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iailcbiAgfVxuXG4gIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWUgJiZcbiAgICBiICE9PSBCdWZmZXIucHJvdG90eXBlIC8vIHNvIEJ1ZmZlci5pc0J1ZmZlcihCdWZmZXIucHJvdG90eXBlKSB3aWxsIGJlIGZhbHNlXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoaXNJbnN0YW5jZShhLCBVaW50OEFycmF5KSkgYSA9IEJ1ZmZlci5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpXG4gIGlmIChpc0luc3RhbmNlKGIsIFVpbnQ4QXJyYXkpKSBiID0gQnVmZmVyLmZyb20oYiwgYi5vZmZzZXQsIGIuYnl0ZUxlbmd0aClcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheSdcbiAgICApXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoaXNJbnN0YW5jZShidWYsIFVpbnQ4QXJyYXkpKSB7XG4gICAgICBidWYgPSBCdWZmZXIuZnJvbShidWYpXG4gICAgfVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IGlzSW5zdGFuY2Uoc3RyaW5nLCBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2Ygc3RyaW5nXG4gICAgKVxuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIG11c3RNYXRjaCA9IChhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gPT09IHRydWUpXG4gIGlmICghbXVzdE1hdGNoICYmIGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkge1xuICAgICAgICAgIHJldHVybiBtdXN0TWF0Y2ggPyAtMSA6IHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpXG4vLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgXG4vLyByZWxpYWJseSBpbiBhIGJyb3dzZXJpZnkgY29udGV4dCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudFxuLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyXG4vLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNTRcbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nXG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkucmVwbGFjZSgvKC57Mn0pL2csICckMSAnKS50cmltKClcbiAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuaWYgKGN1c3RvbUluc3BlY3RTeW1ib2wpIHtcbiAgQnVmZmVyLnByb3RvdHlwZVtjdXN0b21JbnNwZWN0U3ltYm9sXSA9IEJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoaXNJbnN0YW5jZSh0YXJnZXQsIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGFyZ2V0ID0gQnVmZmVyLmZyb20odGFyZ2V0LCB0YXJnZXQub2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aClcbiAgfVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHRhcmdldClcbiAgICApXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0IC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFt2YWxdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAobnVtYmVySXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPj4+IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gaGV4U2xpY2VMb29rdXBUYWJsZVtidWZbaV1dXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIChieXRlc1tpICsgMV0gKiAyNTYpKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihuZXdCdWYsIEJ1ZmZlci5wcm90b3R5cGUpXG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlcicpXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVXNlIGJ1aWx0LWluIHdoZW4gYXZhaWxhYmxlLCBtaXNzaW5nIGZyb20gSUUxMVxuICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZClcbiAgfSBlbHNlIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKChlbmNvZGluZyA9PT0gJ3V0ZjgnICYmIGNvZGUgPCAxMjgpIHx8XG4gICAgICAgICAgZW5jb2RpbmcgPT09ICdsYXRpbjEnKSB7XG4gICAgICAgIC8vIEZhc3QgcGF0aDogSWYgYHZhbGAgZml0cyBpbnRvIGEgc2luZ2xlIGJ5dGUsIHVzZSB0aGF0IG51bWVyaWMgdmFsdWUuXG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnYm9vbGVhbicpIHtcbiAgICB2YWwgPSBOdW1iZXIodmFsKVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyB2YWwgK1xuICAgICAgICAnXCIgaXMgaW52YWxpZCBmb3IgYXJndW1lbnQgXCJ2YWx1ZVwiJylcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSB0YWtlcyBlcXVhbCBzaWducyBhcyBlbmQgb2YgdGhlIEJhc2U2NCBlbmNvZGluZ1xuICBzdHIgPSBzdHIuc3BsaXQoJz0nKVswXVxuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG4vLyBBcnJheUJ1ZmZlciBvciBVaW50OEFycmF5IG9iamVjdHMgZnJvbSBvdGhlciBjb250ZXh0cyAoaS5lLiBpZnJhbWVzKSBkbyBub3QgcGFzc1xuLy8gdGhlIGBpbnN0YW5jZW9mYCBjaGVjayBidXQgdGhleSBzaG91bGQgYmUgdHJlYXRlZCBhcyBvZiB0aGF0IHR5cGUuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNjZcbmZ1bmN0aW9uIGlzSW5zdGFuY2UgKG9iaiwgdHlwZSkge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgdHlwZSB8fFxuICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSAhPSBudWxsICYmXG4gICAgICBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gdHlwZS5uYW1lKVxufVxuZnVuY3Rpb24gbnVtYmVySXNOYU4gKG9iaikge1xuICAvLyBGb3IgSUUxMSBzdXBwb3J0XG4gIHJldHVybiBvYmogIT09IG9iaiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuXG4vLyBDcmVhdGUgbG9va3VwIHRhYmxlIGZvciBgdG9TdHJpbmcoJ2hleCcpYFxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMjE5XG52YXIgaGV4U2xpY2VMb29rdXBUYWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBhbHBoYWJldCA9ICcwMTIzNDU2Nzg5YWJjZGVmJ1xuICB2YXIgdGFibGUgPSBuZXcgQXJyYXkoMjU2KVxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICB2YXIgaTE2ID0gaSAqIDE2XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCAxNjsgKytqKSB7XG4gICAgICB0YWJsZVtpMTYgKyBqXSA9IGFscGhhYmV0W2ldICsgYWxwaGFiZXRbal1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhYmxlXG59KSgpXG4iLCIvKlxuICBDb3B5cmlnaHQgKEMpIDIwMTItMjAxNCBZdXN1a2UgU3V6dWtpIDx1dGF0YW5lLnRlYUBnbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxNSBJbmd2YXIgU3RlcGFueWFuIDxtZUBycmV2ZXJzZXIuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTQgSXZhbiBOaWt1bGluIDxpZmFhYW5AZ21haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTItMjAxMyBNaWNoYWVsIEZpY2FycmEgPGVzY29kZWdlbi5jb3B5cmlnaHRAbWljaGFlbC5maWNhcnJhLm1lPlxuICBDb3B5cmlnaHQgKEMpIDIwMTItMjAxMyBNYXRoaWFzIEJ5bmVucyA8bWF0aGlhc0BxaXdpLmJlPlxuICBDb3B5cmlnaHQgKEMpIDIwMTMgSXJha2xpIEdvemFsaXNodmlsaSA8cmZvYmljQGdtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIFJvYmVydCBHdXN0LUJhcmRvbiA8ZG9uYXRlQHJvYmVydC5ndXN0LWJhcmRvbi5vcmc+XG4gIENvcHlyaWdodCAoQykgMjAxMiBKb2huIEZyZWVtYW4gPGpmcmVlbWFuMDhAZ21haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTEtMjAxMiBBcml5YSBIaWRheWF0IDxhcml5YS5oaWRheWF0QGdtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEpvb3N0LVdpbSBCb2VrZXN0ZWlqbiA8am9vc3Qtd2ltQGJvZWtlc3RlaWpuLm5sPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgS3JpcyBLb3dhbCA8a3Jpcy5rb3dhbEBjaXhhci5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMiBBcnBhZCBCb3Jzb3MgPGFycGFkLmJvcnNvc0Bnb29nbGVtYWlsLmNvbT5cblxuICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuICBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCA8Q09QWVJJR0hUIEhPTERFUj4gQkUgTElBQkxFIEZPUiBBTllcbiAgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbiAgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuICBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkRcbiAgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GXG4gIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xuXG4vKmdsb2JhbCBleHBvcnRzOnRydWUsIHJlcXVpcmU6dHJ1ZSwgZ2xvYmFsOnRydWUqL1xuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgU3ludGF4LFxuICAgICAgICBQcmVjZWRlbmNlLFxuICAgICAgICBCaW5hcnlQcmVjZWRlbmNlLFxuICAgICAgICBTb3VyY2VOb2RlLFxuICAgICAgICBlc3RyYXZlcnNlLFxuICAgICAgICBlc3V0aWxzLFxuICAgICAgICBiYXNlLFxuICAgICAgICBpbmRlbnQsXG4gICAgICAgIGpzb24sXG4gICAgICAgIHJlbnVtYmVyLFxuICAgICAgICBoZXhhZGVjaW1hbCxcbiAgICAgICAgcXVvdGVzLFxuICAgICAgICBlc2NhcGVsZXNzLFxuICAgICAgICBuZXdsaW5lLFxuICAgICAgICBzcGFjZSxcbiAgICAgICAgcGFyZW50aGVzZXMsXG4gICAgICAgIHNlbWljb2xvbnMsXG4gICAgICAgIHNhZmVDb25jYXRlbmF0aW9uLFxuICAgICAgICBkaXJlY3RpdmUsXG4gICAgICAgIGV4dHJhLFxuICAgICAgICBwYXJzZSxcbiAgICAgICAgc291cmNlTWFwLFxuICAgICAgICBzb3VyY2VDb2RlLFxuICAgICAgICBwcmVzZXJ2ZUJsYW5rTGluZXMsXG4gICAgICAgIEZPUk1BVF9NSU5JRlksXG4gICAgICAgIEZPUk1BVF9ERUZBVUxUUztcblxuICAgIGVzdHJhdmVyc2UgPSByZXF1aXJlKCdlc3RyYXZlcnNlJyk7XG4gICAgZXN1dGlscyA9IHJlcXVpcmUoJ2VzdXRpbHMnKTtcblxuICAgIFN5bnRheCA9IGVzdHJhdmVyc2UuU3ludGF4O1xuXG4gICAgLy8gR2VuZXJhdGlvbiBpcyBkb25lIGJ5IGdlbmVyYXRlRXhwcmVzc2lvbi5cbiAgICBmdW5jdGlvbiBpc0V4cHJlc3Npb24obm9kZSkge1xuICAgICAgICByZXR1cm4gQ29kZUdlbmVyYXRvci5FeHByZXNzaW9uLmhhc093blByb3BlcnR5KG5vZGUudHlwZSk7XG4gICAgfVxuXG4gICAgLy8gR2VuZXJhdGlvbiBpcyBkb25lIGJ5IGdlbmVyYXRlU3RhdGVtZW50LlxuICAgIGZ1bmN0aW9uIGlzU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIENvZGVHZW5lcmF0b3IuU3RhdGVtZW50Lmhhc093blByb3BlcnR5KG5vZGUudHlwZSk7XG4gICAgfVxuXG4gICAgUHJlY2VkZW5jZSA9IHtcbiAgICAgICAgU2VxdWVuY2U6IDAsXG4gICAgICAgIFlpZWxkOiAxLFxuICAgICAgICBBc3NpZ25tZW50OiAxLFxuICAgICAgICBDb25kaXRpb25hbDogMixcbiAgICAgICAgQXJyb3dGdW5jdGlvbjogMixcbiAgICAgICAgTG9naWNhbE9SOiAzLFxuICAgICAgICBMb2dpY2FsQU5EOiA0LFxuICAgICAgICBCaXR3aXNlT1I6IDUsXG4gICAgICAgIEJpdHdpc2VYT1I6IDYsXG4gICAgICAgIEJpdHdpc2VBTkQ6IDcsXG4gICAgICAgIEVxdWFsaXR5OiA4LFxuICAgICAgICBSZWxhdGlvbmFsOiA5LFxuICAgICAgICBCaXR3aXNlU0hJRlQ6IDEwLFxuICAgICAgICBBZGRpdGl2ZTogMTEsXG4gICAgICAgIE11bHRpcGxpY2F0aXZlOiAxMixcbiAgICAgICAgRXhwb25lbnRpYXRpb246IDEzLFxuICAgICAgICBBd2FpdDogMTQsXG4gICAgICAgIFVuYXJ5OiAxNCxcbiAgICAgICAgUG9zdGZpeDogMTUsXG4gICAgICAgIENhbGw6IDE2LFxuICAgICAgICBOZXc6IDE3LFxuICAgICAgICBUYWdnZWRUZW1wbGF0ZTogMTgsXG4gICAgICAgIE1lbWJlcjogMTksXG4gICAgICAgIFByaW1hcnk6IDIwXG4gICAgfTtcblxuICAgIEJpbmFyeVByZWNlZGVuY2UgPSB7XG4gICAgICAgICd8fCc6IFByZWNlZGVuY2UuTG9naWNhbE9SLFxuICAgICAgICAnJiYnOiBQcmVjZWRlbmNlLkxvZ2ljYWxBTkQsXG4gICAgICAgICd8JzogUHJlY2VkZW5jZS5CaXR3aXNlT1IsXG4gICAgICAgICdeJzogUHJlY2VkZW5jZS5CaXR3aXNlWE9SLFxuICAgICAgICAnJic6IFByZWNlZGVuY2UuQml0d2lzZUFORCxcbiAgICAgICAgJz09JzogUHJlY2VkZW5jZS5FcXVhbGl0eSxcbiAgICAgICAgJyE9JzogUHJlY2VkZW5jZS5FcXVhbGl0eSxcbiAgICAgICAgJz09PSc6IFByZWNlZGVuY2UuRXF1YWxpdHksXG4gICAgICAgICchPT0nOiBQcmVjZWRlbmNlLkVxdWFsaXR5LFxuICAgICAgICAnaXMnOiBQcmVjZWRlbmNlLkVxdWFsaXR5LFxuICAgICAgICAnaXNudCc6IFByZWNlZGVuY2UuRXF1YWxpdHksXG4gICAgICAgICc8JzogUHJlY2VkZW5jZS5SZWxhdGlvbmFsLFxuICAgICAgICAnPic6IFByZWNlZGVuY2UuUmVsYXRpb25hbCxcbiAgICAgICAgJzw9JzogUHJlY2VkZW5jZS5SZWxhdGlvbmFsLFxuICAgICAgICAnPj0nOiBQcmVjZWRlbmNlLlJlbGF0aW9uYWwsXG4gICAgICAgICdpbic6IFByZWNlZGVuY2UuUmVsYXRpb25hbCxcbiAgICAgICAgJ2luc3RhbmNlb2YnOiBQcmVjZWRlbmNlLlJlbGF0aW9uYWwsXG4gICAgICAgICc8PCc6IFByZWNlZGVuY2UuQml0d2lzZVNISUZULFxuICAgICAgICAnPj4nOiBQcmVjZWRlbmNlLkJpdHdpc2VTSElGVCxcbiAgICAgICAgJz4+Pic6IFByZWNlZGVuY2UuQml0d2lzZVNISUZULFxuICAgICAgICAnKyc6IFByZWNlZGVuY2UuQWRkaXRpdmUsXG4gICAgICAgICctJzogUHJlY2VkZW5jZS5BZGRpdGl2ZSxcbiAgICAgICAgJyonOiBQcmVjZWRlbmNlLk11bHRpcGxpY2F0aXZlLFxuICAgICAgICAnJSc6IFByZWNlZGVuY2UuTXVsdGlwbGljYXRpdmUsXG4gICAgICAgICcvJzogUHJlY2VkZW5jZS5NdWx0aXBsaWNhdGl2ZSxcbiAgICAgICAgJyoqJzogUHJlY2VkZW5jZS5FeHBvbmVudGlhdGlvblxuICAgIH07XG5cbiAgICAvL0ZsYWdzXG4gICAgdmFyIEZfQUxMT1dfSU4gPSAxLFxuICAgICAgICBGX0FMTE9XX0NBTEwgPSAxIDw8IDEsXG4gICAgICAgIEZfQUxMT1dfVU5QQVJBVEhfTkVXID0gMSA8PCAyLFxuICAgICAgICBGX0ZVTkNfQk9EWSA9IDEgPDwgMyxcbiAgICAgICAgRl9ESVJFQ1RJVkVfQ1RYID0gMSA8PCA0LFxuICAgICAgICBGX1NFTUlDT0xPTl9PUFQgPSAxIDw8IDU7XG5cbiAgICAvL0V4cHJlc3Npb24gZmxhZyBzZXRzXG4gICAgLy9OT1RFOiBGbGFnIG9yZGVyOlxuICAgIC8vIEZfQUxMT1dfSU5cbiAgICAvLyBGX0FMTE9XX0NBTExcbiAgICAvLyBGX0FMTE9XX1VOUEFSQVRIX05FV1xuICAgIHZhciBFX0ZUVCA9IEZfQUxMT1dfQ0FMTCB8IEZfQUxMT1dfVU5QQVJBVEhfTkVXLFxuICAgICAgICBFX1RURiA9IEZfQUxMT1dfSU4gfCBGX0FMTE9XX0NBTEwsXG4gICAgICAgIEVfVFRUID0gRl9BTExPV19JTiB8IEZfQUxMT1dfQ0FMTCB8IEZfQUxMT1dfVU5QQVJBVEhfTkVXLFxuICAgICAgICBFX1RGRiA9IEZfQUxMT1dfSU4sXG4gICAgICAgIEVfRkZUID0gRl9BTExPV19VTlBBUkFUSF9ORVcsXG4gICAgICAgIEVfVEZUID0gRl9BTExPV19JTiB8IEZfQUxMT1dfVU5QQVJBVEhfTkVXO1xuXG4gICAgLy9TdGF0ZW1lbnQgZmxhZyBzZXRzXG4gICAgLy9OT1RFOiBGbGFnIG9yZGVyOlxuICAgIC8vIEZfQUxMT1dfSU5cbiAgICAvLyBGX0ZVTkNfQk9EWVxuICAgIC8vIEZfRElSRUNUSVZFX0NUWFxuICAgIC8vIEZfU0VNSUNPTE9OX09QVFxuICAgIHZhciBTX1RGRkYgPSBGX0FMTE9XX0lOLFxuICAgICAgICBTX1RGRlQgPSBGX0FMTE9XX0lOIHwgRl9TRU1JQ09MT05fT1BULFxuICAgICAgICBTX0ZGRkYgPSAweDAwLFxuICAgICAgICBTX1RGVEYgPSBGX0FMTE9XX0lOIHwgRl9ESVJFQ1RJVkVfQ1RYLFxuICAgICAgICBTX1RURkYgPSBGX0FMTE9XX0lOIHwgRl9GVU5DX0JPRFk7XG5cbiAgICBmdW5jdGlvbiBnZXREZWZhdWx0T3B0aW9ucygpIHtcbiAgICAgICAgLy8gZGVmYXVsdCBvcHRpb25zXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbmRlbnQ6IG51bGwsXG4gICAgICAgICAgICBiYXNlOiBudWxsLFxuICAgICAgICAgICAgcGFyc2U6IG51bGwsXG4gICAgICAgICAgICBjb21tZW50OiBmYWxzZSxcbiAgICAgICAgICAgIGZvcm1hdDoge1xuICAgICAgICAgICAgICAgIGluZGVudDoge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZTogJyAgICAnLFxuICAgICAgICAgICAgICAgICAgICBiYXNlOiAwLFxuICAgICAgICAgICAgICAgICAgICBhZGp1c3RNdWx0aWxpbmVDb21tZW50OiBmYWxzZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbmV3bGluZTogJ1xcbicsXG4gICAgICAgICAgICAgICAgc3BhY2U6ICcgJyxcbiAgICAgICAgICAgICAgICBqc29uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICByZW51bWJlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgaGV4YWRlY2ltYWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHF1b3RlczogJ3NpbmdsZScsXG4gICAgICAgICAgICAgICAgZXNjYXBlbGVzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29tcGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcGFyZW50aGVzZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgc2VtaWNvbG9uczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzYWZlQ29uY2F0ZW5hdGlvbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgcHJlc2VydmVCbGFua0xpbmVzOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1vejoge1xuICAgICAgICAgICAgICAgIGNvbXByZWhlbnNpb25FeHByZXNzaW9uU3RhcnRzV2l0aEFzc2lnbm1lbnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHN0YXJsZXNzR2VuZXJhdG9yOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNvdXJjZU1hcDogbnVsbCxcbiAgICAgICAgICAgIHNvdXJjZU1hcFJvb3Q6IG51bGwsXG4gICAgICAgICAgICBzb3VyY2VNYXBXaXRoQ29kZTogZmFsc2UsXG4gICAgICAgICAgICBkaXJlY3RpdmU6IGZhbHNlLFxuICAgICAgICAgICAgcmF3OiB0cnVlLFxuICAgICAgICAgICAgdmVyYmF0aW06IG51bGwsXG4gICAgICAgICAgICBzb3VyY2VDb2RlOiBudWxsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RyaW5nUmVwZWF0KHN0ciwgbnVtKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAnJztcblxuICAgICAgICBmb3IgKG51bSB8PSAwOyBudW0gPiAwOyBudW0gPj4+PSAxLCBzdHIgKz0gc3RyKSB7XG4gICAgICAgICAgICBpZiAobnVtICYgMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzdHI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc0xpbmVUZXJtaW5hdG9yKHN0cikge1xuICAgICAgICByZXR1cm4gKC9bXFxyXFxuXS9nKS50ZXN0KHN0cik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5kc1dpdGhMaW5lVGVybWluYXRvcihzdHIpIHtcbiAgICAgICAgdmFyIGxlbiA9IHN0ci5sZW5ndGg7XG4gICAgICAgIHJldHVybiBsZW4gJiYgZXN1dGlscy5jb2RlLmlzTGluZVRlcm1pbmF0b3Ioc3RyLmNoYXJDb2RlQXQobGVuIC0gMSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1lcmdlKHRhcmdldCwgb3ZlcnJpZGUpIHtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChrZXkgaW4gb3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIGlmIChvdmVycmlkZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBvdmVycmlkZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlRGVlcGx5KHRhcmdldCwgb3ZlcnJpZGUpIHtcbiAgICAgICAgdmFyIGtleSwgdmFsO1xuXG4gICAgICAgIGZ1bmN0aW9uIGlzSGFzaE9iamVjdCh0YXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdGFyZ2V0ID09PSAnb2JqZWN0JyAmJiB0YXJnZXQgaW5zdGFuY2VvZiBPYmplY3QgJiYgISh0YXJnZXQgaW5zdGFuY2VvZiBSZWdFeHApO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChrZXkgaW4gb3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIGlmIChvdmVycmlkZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gb3ZlcnJpZGVba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoaXNIYXNoT2JqZWN0KHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSGFzaE9iamVjdCh0YXJnZXRba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZURlZXBseSh0YXJnZXRba2V5XSwgdmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gdXBkYXRlRGVlcGx5KHt9LCB2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVOdW1iZXIodmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCwgcG9pbnQsIHRlbXAsIGV4cG9uZW50LCBwb3M7XG5cbiAgICAgICAgaWYgKHZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOdW1lcmljIGxpdGVyYWwgd2hvc2UgdmFsdWUgaXMgTmFOJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTnVtZXJpYyBsaXRlcmFsIHdob3NlIHZhbHVlIGlzIG5lZ2F0aXZlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgPT09IDEgLyAwKSB7XG4gICAgICAgICAgICByZXR1cm4ganNvbiA/ICdudWxsJyA6IHJlbnVtYmVyID8gJzFlNDAwJyA6ICcxZSs0MDAnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gJycgKyB2YWx1ZTtcbiAgICAgICAgaWYgKCFyZW51bWJlciB8fCByZXN1bHQubGVuZ3RoIDwgMykge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHBvaW50ID0gcmVzdWx0LmluZGV4T2YoJy4nKTtcbiAgICAgICAgaWYgKCFqc29uICYmIHJlc3VsdC5jaGFyQ29kZUF0KDApID09PSAweDMwICAvKiAwICovICYmIHBvaW50ID09PSAxKSB7XG4gICAgICAgICAgICBwb2ludCA9IDA7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGVtcCA9IHJlc3VsdDtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoJ2UrJywgJ2UnKTtcbiAgICAgICAgZXhwb25lbnQgPSAwO1xuICAgICAgICBpZiAoKHBvcyA9IHRlbXAuaW5kZXhPZignZScpKSA+IDApIHtcbiAgICAgICAgICAgIGV4cG9uZW50ID0gK3RlbXAuc2xpY2UocG9zICsgMSk7XG4gICAgICAgICAgICB0ZW1wID0gdGVtcC5zbGljZSgwLCBwb3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb2ludCA+PSAwKSB7XG4gICAgICAgICAgICBleHBvbmVudCAtPSB0ZW1wLmxlbmd0aCAtIHBvaW50IC0gMTtcbiAgICAgICAgICAgIHRlbXAgPSArKHRlbXAuc2xpY2UoMCwgcG9pbnQpICsgdGVtcC5zbGljZShwb2ludCArIDEpKSArICcnO1xuICAgICAgICB9XG4gICAgICAgIHBvcyA9IDA7XG4gICAgICAgIHdoaWxlICh0ZW1wLmNoYXJDb2RlQXQodGVtcC5sZW5ndGggKyBwb3MgLSAxKSA9PT0gMHgzMCAgLyogMCAqLykge1xuICAgICAgICAgICAgLS1wb3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyAhPT0gMCkge1xuICAgICAgICAgICAgZXhwb25lbnQgLT0gcG9zO1xuICAgICAgICAgICAgdGVtcCA9IHRlbXAuc2xpY2UoMCwgcG9zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhwb25lbnQgIT09IDApIHtcbiAgICAgICAgICAgIHRlbXAgKz0gJ2UnICsgZXhwb25lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh0ZW1wLmxlbmd0aCA8IHJlc3VsdC5sZW5ndGggfHxcbiAgICAgICAgICAgICAgICAgICAgKGhleGFkZWNpbWFsICYmIHZhbHVlID4gMWUxMiAmJiBNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUgJiYgKHRlbXAgPSAnMHgnICsgdmFsdWUudG9TdHJpbmcoMTYpKS5sZW5ndGggPCByZXN1bHQubGVuZ3RoKSkgJiZcbiAgICAgICAgICAgICAgICArdGVtcCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRlbXA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIEdlbmVyYXRlIHZhbGlkIFJlZ0V4cCBleHByZXNzaW9uLlxuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL0NvbnN0ZWxsYXRpb24vaXYgRW5naW5lXG5cbiAgICBmdW5jdGlvbiBlc2NhcGVSZWdFeHBDaGFyYWN0ZXIoY2gsIHByZXZpb3VzSXNCYWNrc2xhc2gpIHtcbiAgICAgICAgLy8gbm90IGhhbmRsaW5nICdcXCcgYW5kIGhhbmRsaW5nIFxcdTIwMjggb3IgXFx1MjAyOSB0byB1bmljb2RlIGVzY2FwZSBzZXF1ZW5jZVxuICAgICAgICBpZiAoKGNoICYgfjEpID09PSAweDIwMjgpIHtcbiAgICAgICAgICAgIHJldHVybiAocHJldmlvdXNJc0JhY2tzbGFzaCA/ICd1JyA6ICdcXFxcdScpICsgKChjaCA9PT0gMHgyMDI4KSA/ICcyMDI4JyA6ICcyMDI5Jyk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDEwIHx8IGNoID09PSAxMykgeyAgLy8gXFxuLCBcXHJcbiAgICAgICAgICAgIHJldHVybiAocHJldmlvdXNJc0JhY2tzbGFzaCA/ICcnIDogJ1xcXFwnKSArICgoY2ggPT09IDEwKSA/ICduJyA6ICdyJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlUmVnRXhwKHJlZykge1xuICAgICAgICB2YXIgbWF0Y2gsIHJlc3VsdCwgZmxhZ3MsIGksIGl6LCBjaCwgY2hhcmFjdGVySW5CcmFjaywgcHJldmlvdXNJc0JhY2tzbGFzaDtcblxuICAgICAgICByZXN1bHQgPSByZWcudG9TdHJpbmcoKTtcblxuICAgICAgICBpZiAocmVnLnNvdXJjZSkge1xuICAgICAgICAgICAgLy8gZXh0cmFjdCBmbGFnIGZyb20gdG9TdHJpbmcgcmVzdWx0XG4gICAgICAgICAgICBtYXRjaCA9IHJlc3VsdC5tYXRjaCgvXFwvKFteL10qKSQvKTtcbiAgICAgICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmbGFncyA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgcmVzdWx0ID0gJyc7XG5cbiAgICAgICAgICAgIGNoYXJhY3RlckluQnJhY2sgPSBmYWxzZTtcbiAgICAgICAgICAgIHByZXZpb3VzSXNCYWNrc2xhc2ggPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGl6ID0gcmVnLnNvdXJjZS5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICAgICAgY2ggPSByZWcuc291cmNlLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXByZXZpb3VzSXNCYWNrc2xhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJhY3RlckluQnJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gOTMpIHsgIC8vIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFyYWN0ZXJJbkJyYWNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09IDQ3KSB7ICAvLyAvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdcXFxcJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDkxKSB7ICAvLyBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhcmFjdGVySW5CcmFjayA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGVzY2FwZVJlZ0V4cENoYXJhY3RlcihjaCwgcHJldmlvdXNJc0JhY2tzbGFzaCk7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzSXNCYWNrc2xhc2ggPSBjaCA9PT0gOTI7ICAvLyBcXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIG5ldyBSZWdFeHAoXCJcXFxcXFxuJykgaXMgcHJvdmlkZWQsIGNyZWF0ZSAvXFxuL1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gZXNjYXBlUmVnRXhwQ2hhcmFjdGVyKGNoLCBwcmV2aW91c0lzQmFja3NsYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJldmVudCBsaWtlIC9cXFxcWy9dL1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0lzQmFja3NsYXNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gJy8nICsgcmVzdWx0ICsgJy8nICsgZmxhZ3M7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVzY2FwZUFsbG93ZWRDaGFyYWN0ZXIoY29kZSwgbmV4dCkge1xuICAgICAgICB2YXIgaGV4O1xuXG4gICAgICAgIGlmIChjb2RlID09PSAweDA4ICAvKiBcXGIgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiAnXFxcXGInO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvZGUgPT09IDB4MEMgIC8qIFxcZiAqLykge1xuICAgICAgICAgICAgcmV0dXJuICdcXFxcZic7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29kZSA9PT0gMHgwOSAgLyogXFx0ICovKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1xcXFx0JztcbiAgICAgICAgfVxuXG4gICAgICAgIGhleCA9IGNvZGUudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGlmIChqc29uIHx8IGNvZGUgPiAweEZGKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1xcXFx1JyArICcwMDAwJy5zbGljZShoZXgubGVuZ3RoKSArIGhleDtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwMDAgJiYgIWVzdXRpbHMuY29kZS5pc0RlY2ltYWxEaWdpdChuZXh0KSkge1xuICAgICAgICAgICAgcmV0dXJuICdcXFxcMCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgwMDBCICAvKiBcXHYgKi8pIHsgLy8gJ1xcdidcbiAgICAgICAgICAgIHJldHVybiAnXFxcXHgwQic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJ1xcXFx4JyArICcwMCcuc2xpY2UoaGV4Lmxlbmd0aCkgKyBoZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlc2NhcGVEaXNhbGxvd2VkQ2hhcmFjdGVyKGNvZGUpIHtcbiAgICAgICAgaWYgKGNvZGUgPT09IDB4NUMgIC8qIFxcICovKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1xcXFxcXFxcJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb2RlID09PSAweDBBICAvKiBcXG4gKi8pIHtcbiAgICAgICAgICAgIHJldHVybiAnXFxcXG4nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvZGUgPT09IDB4MEQgIC8qIFxcciAqLykge1xuICAgICAgICAgICAgcmV0dXJuICdcXFxccic7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29kZSA9PT0gMHgyMDI4KSB7XG4gICAgICAgICAgICByZXR1cm4gJ1xcXFx1MjAyOCc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29kZSA9PT0gMHgyMDI5KSB7XG4gICAgICAgICAgICByZXR1cm4gJ1xcXFx1MjAyOSc7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29ycmVjdGx5IGNsYXNzaWZpZWQgY2hhcmFjdGVyJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXNjYXBlRGlyZWN0aXZlKHN0cikge1xuICAgICAgICB2YXIgaSwgaXosIGNvZGUsIHF1b3RlO1xuXG4gICAgICAgIHF1b3RlID0gcXVvdGVzID09PSAnZG91YmxlJyA/ICdcIicgOiAnXFwnJztcbiAgICAgICAgZm9yIChpID0gMCwgaXogPSBzdHIubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgaWYgKGNvZGUgPT09IDB4MjcgIC8qICcgKi8pIHtcbiAgICAgICAgICAgICAgICBxdW90ZSA9ICdcIic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MjIgIC8qIFwiICovKSB7XG4gICAgICAgICAgICAgICAgcXVvdGUgPSAnXFwnJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHg1QyAgLyogXFwgKi8pIHtcbiAgICAgICAgICAgICAgICArK2k7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcXVvdGUgKyBzdHIgKyBxdW90ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlc2NhcGVTdHJpbmcoc3RyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAnJywgaSwgbGVuLCBjb2RlLCBzaW5nbGVRdW90ZXMgPSAwLCBkb3VibGVRdW90ZXMgPSAwLCBzaW5nbGUsIHF1b3RlO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHN0ci5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgaWYgKGNvZGUgPT09IDB4MjcgIC8qICcgKi8pIHtcbiAgICAgICAgICAgICAgICArK3NpbmdsZVF1b3RlcztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyMiAgLyogXCIgKi8pIHtcbiAgICAgICAgICAgICAgICArK2RvdWJsZVF1b3RlcztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyRiAgLyogLyAqLyAmJiBqc29uKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdcXFxcJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXN1dGlscy5jb2RlLmlzTGluZVRlcm1pbmF0b3IoY29kZSkgfHwgY29kZSA9PT0gMHg1QyAgLyogXFwgKi8pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gZXNjYXBlRGlzYWxsb3dlZENoYXJhY3Rlcihjb2RlKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWVzdXRpbHMuY29kZS5pc0lkZW50aWZpZXJQYXJ0RVM1KGNvZGUpICYmIChqc29uICYmIGNvZGUgPCAweDIwICAvKiBTUCAqLyB8fCAhanNvbiAmJiAhZXNjYXBlbGVzcyAmJiAoY29kZSA8IDB4MjAgIC8qIFNQICovIHx8IGNvZGUgPiAweDdFICAvKiB+ICovKSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gZXNjYXBlQWxsb3dlZENoYXJhY3Rlcihjb2RlLCBzdHIuY2hhckNvZGVBdChpICsgMSkpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzaW5nbGUgPSAhKHF1b3RlcyA9PT0gJ2RvdWJsZScgfHwgKHF1b3RlcyA9PT0gJ2F1dG8nICYmIGRvdWJsZVF1b3RlcyA8IHNpbmdsZVF1b3RlcykpO1xuICAgICAgICBxdW90ZSA9IHNpbmdsZSA/ICdcXCcnIDogJ1wiJztcblxuICAgICAgICBpZiAoIShzaW5nbGUgPyBzaW5nbGVRdW90ZXMgOiBkb3VibGVRdW90ZXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gcXVvdGUgKyByZXN1bHQgKyBxdW90ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0ciA9IHJlc3VsdDtcbiAgICAgICAgcmVzdWx0ID0gcXVvdGU7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gc3RyLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBpZiAoKGNvZGUgPT09IDB4MjcgIC8qICcgKi8gJiYgc2luZ2xlKSB8fCAoY29kZSA9PT0gMHgyMiAgLyogXCIgKi8gJiYgIXNpbmdsZSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ1xcXFwnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0ICsgcXVvdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZmxhdHRlbiBhbiBhcnJheSB0byBhIHN0cmluZywgd2hlcmUgdGhlIGFycmF5IGNhbiBjb250YWluXG4gICAgICogZWl0aGVyIHN0cmluZ3Mgb3IgbmVzdGVkIGFycmF5c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW5Ub1N0cmluZyhhcnIpIHtcbiAgICAgICAgdmFyIGksIGl6LCBlbGVtLCByZXN1bHQgPSAnJztcbiAgICAgICAgZm9yIChpID0gMCwgaXogPSBhcnIubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgZWxlbSA9IGFycltpXTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBBcnJheS5pc0FycmF5KGVsZW0pID8gZmxhdHRlblRvU3RyaW5nKGVsZW0pIDogZWxlbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNvbnZlcnQgZ2VuZXJhdGVkIHRvIGEgU291cmNlTm9kZSB3aGVuIHNvdXJjZSBtYXBzIGFyZSBlbmFibGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvU291cmNlTm9kZVdoZW5OZWVkZWQoZ2VuZXJhdGVkLCBub2RlKSB7XG4gICAgICAgIGlmICghc291cmNlTWFwKSB7XG4gICAgICAgICAgICAvLyB3aXRoIG5vIHNvdXJjZSBtYXBzLCBnZW5lcmF0ZWQgaXMgZWl0aGVyIGFuXG4gICAgICAgICAgICAvLyBhcnJheSBvciBhIHN0cmluZy4gIGlmIGFuIGFycmF5LCBmbGF0dGVuIGl0LlxuICAgICAgICAgICAgLy8gaWYgYSBzdHJpbmcsIGp1c3QgcmV0dXJuIGl0XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShnZW5lcmF0ZWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZsYXR0ZW5Ub1N0cmluZyhnZW5lcmF0ZWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChnZW5lcmF0ZWQgaW5zdGFuY2VvZiBTb3VyY2VOb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLmxvYyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNvdXJjZU5vZGUobnVsbCwgbnVsbCwgc291cmNlTWFwLCBnZW5lcmF0ZWQsIG5vZGUubmFtZSB8fCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNvdXJjZU5vZGUobm9kZS5sb2Muc3RhcnQubGluZSwgbm9kZS5sb2Muc3RhcnQuY29sdW1uLCAoc291cmNlTWFwID09PSB0cnVlID8gbm9kZS5sb2Muc291cmNlIHx8IG51bGwgOiBzb3VyY2VNYXApLCBnZW5lcmF0ZWQsIG5vZGUubmFtZSB8fCBudWxsKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub0VtcHR5U3BhY2UoKSB7XG4gICAgICAgIHJldHVybiAoc3BhY2UpID8gc3BhY2UgOiAnICc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gam9pbihsZWZ0LCByaWdodCkge1xuICAgICAgICB2YXIgbGVmdFNvdXJjZSxcbiAgICAgICAgICAgIHJpZ2h0U291cmNlLFxuICAgICAgICAgICAgbGVmdENoYXJDb2RlLFxuICAgICAgICAgICAgcmlnaHRDaGFyQ29kZTtcblxuICAgICAgICBsZWZ0U291cmNlID0gdG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChsZWZ0KS50b1N0cmluZygpO1xuICAgICAgICBpZiAobGVmdFNvdXJjZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbcmlnaHRdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmlnaHRTb3VyY2UgPSB0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKHJpZ2h0KS50b1N0cmluZygpO1xuICAgICAgICBpZiAocmlnaHRTb3VyY2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW2xlZnRdO1xuICAgICAgICB9XG5cbiAgICAgICAgbGVmdENoYXJDb2RlID0gbGVmdFNvdXJjZS5jaGFyQ29kZUF0KGxlZnRTb3VyY2UubGVuZ3RoIC0gMSk7XG4gICAgICAgIHJpZ2h0Q2hhckNvZGUgPSByaWdodFNvdXJjZS5jaGFyQ29kZUF0KDApO1xuXG4gICAgICAgIGlmICgobGVmdENoYXJDb2RlID09PSAweDJCICAvKiArICovIHx8IGxlZnRDaGFyQ29kZSA9PT0gMHgyRCAgLyogLSAqLykgJiYgbGVmdENoYXJDb2RlID09PSByaWdodENoYXJDb2RlIHx8XG4gICAgICAgICAgICBlc3V0aWxzLmNvZGUuaXNJZGVudGlmaWVyUGFydEVTNShsZWZ0Q2hhckNvZGUpICYmIGVzdXRpbHMuY29kZS5pc0lkZW50aWZpZXJQYXJ0RVM1KHJpZ2h0Q2hhckNvZGUpIHx8XG4gICAgICAgICAgICBsZWZ0Q2hhckNvZGUgPT09IDB4MkYgIC8qIC8gKi8gJiYgcmlnaHRDaGFyQ29kZSA9PT0gMHg2OSAgLyogaSAqLykgeyAvLyBpbmZpeCB3b3JkIG9wZXJhdG9ycyBhbGwgc3RhcnQgd2l0aCBgaWBcbiAgICAgICAgICAgIHJldHVybiBbbGVmdCwgbm9FbXB0eVNwYWNlKCksIHJpZ2h0XTtcbiAgICAgICAgfSBlbHNlIGlmIChlc3V0aWxzLmNvZGUuaXNXaGl0ZVNwYWNlKGxlZnRDaGFyQ29kZSkgfHwgZXN1dGlscy5jb2RlLmlzTGluZVRlcm1pbmF0b3IobGVmdENoYXJDb2RlKSB8fFxuICAgICAgICAgICAgICAgIGVzdXRpbHMuY29kZS5pc1doaXRlU3BhY2UocmlnaHRDaGFyQ29kZSkgfHwgZXN1dGlscy5jb2RlLmlzTGluZVRlcm1pbmF0b3IocmlnaHRDaGFyQ29kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbbGVmdCwgcmlnaHRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbGVmdCwgc3BhY2UsIHJpZ2h0XTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRJbmRlbnQoc3RtdCkge1xuICAgICAgICByZXR1cm4gW2Jhc2UsIHN0bXRdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdpdGhJbmRlbnQoZm4pIHtcbiAgICAgICAgdmFyIHByZXZpb3VzQmFzZTtcbiAgICAgICAgcHJldmlvdXNCYXNlID0gYmFzZTtcbiAgICAgICAgYmFzZSArPSBpbmRlbnQ7XG4gICAgICAgIGZuKGJhc2UpO1xuICAgICAgICBiYXNlID0gcHJldmlvdXNCYXNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZVNwYWNlcyhzdHIpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGZvciAoaSA9IHN0ci5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgaWYgKGVzdXRpbHMuY29kZS5pc0xpbmVUZXJtaW5hdG9yKHN0ci5jaGFyQ29kZUF0KGkpKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoc3RyLmxlbmd0aCAtIDEpIC0gaTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGp1c3RNdWx0aWxpbmVDb21tZW50KHZhbHVlLCBzcGVjaWFsQmFzZSkge1xuICAgICAgICB2YXIgYXJyYXksIGksIGxlbiwgbGluZSwgaiwgc3BhY2VzLCBwcmV2aW91c0Jhc2UsIHNuO1xuXG4gICAgICAgIGFycmF5ID0gdmFsdWUuc3BsaXQoL1xcclxcbnxbXFxyXFxuXS8pO1xuICAgICAgICBzcGFjZXMgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXG4gICAgICAgIC8vIGZpcnN0IGxpbmUgZG9lc24ndCBoYXZlIGluZGVudGF0aW9uXG4gICAgICAgIGZvciAoaSA9IDEsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBsaW5lID0gYXJyYXlbaV07XG4gICAgICAgICAgICBqID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChqIDwgbGluZS5sZW5ndGggJiYgZXN1dGlscy5jb2RlLmlzV2hpdGVTcGFjZShsaW5lLmNoYXJDb2RlQXQoaikpKSB7XG4gICAgICAgICAgICAgICAgKytqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNwYWNlcyA+IGopIHtcbiAgICAgICAgICAgICAgICBzcGFjZXMgPSBqO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzcGVjaWFsQmFzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIHBhdHRlcm4gbGlrZVxuICAgICAgICAgICAgLy8ge1xuICAgICAgICAgICAgLy8gICB2YXIgdCA9IDIwOyAgLypcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAqIHRoaXMgaXMgY29tbWVudFxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICBwcmV2aW91c0Jhc2UgPSBiYXNlO1xuICAgICAgICAgICAgaWYgKGFycmF5WzFdW3NwYWNlc10gPT09ICcqJykge1xuICAgICAgICAgICAgICAgIHNwZWNpYWxCYXNlICs9ICcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJhc2UgPSBzcGVjaWFsQmFzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzcGFjZXMgJiAxKSB7XG4gICAgICAgICAgICAgICAgLy8gLypcbiAgICAgICAgICAgICAgICAvLyAgKlxuICAgICAgICAgICAgICAgIC8vICAqL1xuICAgICAgICAgICAgICAgIC8vIElmIHNwYWNlcyBhcmUgb2RkIG51bWJlciwgYWJvdmUgcGF0dGVybiBpcyBjb25zaWRlcmVkLlxuICAgICAgICAgICAgICAgIC8vIFdlIHdhc3RlIDEgc3BhY2UuXG4gICAgICAgICAgICAgICAgLS1zcGFjZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2aW91c0Jhc2UgPSBiYXNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMSwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIHNuID0gdG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChhZGRJbmRlbnQoYXJyYXlbaV0uc2xpY2Uoc3BhY2VzKSkpO1xuICAgICAgICAgICAgYXJyYXlbaV0gPSBzb3VyY2VNYXAgPyBzbi5qb2luKCcnKSA6IHNuO1xuICAgICAgICB9XG5cbiAgICAgICAgYmFzZSA9IHByZXZpb3VzQmFzZTtcblxuICAgICAgICByZXR1cm4gYXJyYXkuam9pbignXFxuJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVDb21tZW50KGNvbW1lbnQsIHNwZWNpYWxCYXNlKSB7XG4gICAgICAgIGlmIChjb21tZW50LnR5cGUgPT09ICdMaW5lJykge1xuICAgICAgICAgICAgaWYgKGVuZHNXaXRoTGluZVRlcm1pbmF0b3IoY29tbWVudC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJy8vJyArIGNvbW1lbnQudmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEFsd2F5cyB1c2UgTGluZVRlcm1pbmF0b3JcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gJy8vJyArIGNvbW1lbnQudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmVzZXJ2ZUJsYW5rTGluZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdcXG4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleHRyYS5mb3JtYXQuaW5kZW50LmFkanVzdE11bHRpbGluZUNvbW1lbnQgJiYgL1tcXG5cXHJdLy50ZXN0KGNvbW1lbnQudmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gYWRqdXN0TXVsdGlsaW5lQ29tbWVudCgnLyonICsgY29tbWVudC52YWx1ZSArICcqLycsIHNwZWNpYWxCYXNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJy8qJyArIGNvbW1lbnQudmFsdWUgKyAnKi8nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZENvbW1lbnRzKHN0bXQsIHJlc3VsdCkge1xuICAgICAgICB2YXIgaSwgbGVuLCBjb21tZW50LCBzYXZlLCB0YWlsaW5nVG9TdGF0ZW1lbnQsIHNwZWNpYWxCYXNlLCBmcmFnbWVudCxcbiAgICAgICAgICAgIGV4dFJhbmdlLCByYW5nZSwgcHJldlJhbmdlLCBwcmVmaXgsIGluZml4LCBzdWZmaXgsIGNvdW50O1xuXG4gICAgICAgIGlmIChzdG10LmxlYWRpbmdDb21tZW50cyAmJiBzdG10LmxlYWRpbmdDb21tZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBzYXZlID0gcmVzdWx0O1xuXG4gICAgICAgICAgICBpZiAocHJlc2VydmVCbGFua0xpbmVzKSB7XG4gICAgICAgICAgICAgICAgY29tbWVudCA9IHN0bXQubGVhZGluZ0NvbW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgICAgICAgICAgZXh0UmFuZ2UgPSBjb21tZW50LmV4dGVuZGVkUmFuZ2U7XG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBjb21tZW50LnJhbmdlO1xuXG4gICAgICAgICAgICAgICAgcHJlZml4ID0gc291cmNlQ29kZS5zdWJzdHJpbmcoZXh0UmFuZ2VbMF0sIHJhbmdlWzBdKTtcbiAgICAgICAgICAgICAgICBjb3VudCA9IChwcmVmaXgubWF0Y2goL1xcbi9nKSB8fCBbXSkubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChjb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3RyaW5nUmVwZWF0KCdcXG4nLCBjb3VudCkpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhZGRJbmRlbnQoZ2VuZXJhdGVDb21tZW50KGNvbW1lbnQpKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocHJlZml4KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZ2VuZXJhdGVDb21tZW50KGNvbW1lbnQpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwcmV2UmFuZ2UgPSByYW5nZTtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDEsIGxlbiA9IHN0bXQubGVhZGluZ0NvbW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBzdG10LmxlYWRpbmdDb21tZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSBjb21tZW50LnJhbmdlO1xuXG4gICAgICAgICAgICAgICAgICAgIGluZml4ID0gc291cmNlQ29kZS5zdWJzdHJpbmcocHJldlJhbmdlWzFdLCByYW5nZVswXSk7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ID0gKGluZml4Lm1hdGNoKC9cXG4vZykgfHwgW10pLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3RyaW5nUmVwZWF0KCdcXG4nLCBjb3VudCkpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhZGRJbmRlbnQoZ2VuZXJhdGVDb21tZW50KGNvbW1lbnQpKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcHJldlJhbmdlID0gcmFuZ2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3VmZml4ID0gc291cmNlQ29kZS5zdWJzdHJpbmcocmFuZ2VbMV0sIGV4dFJhbmdlWzFdKTtcbiAgICAgICAgICAgICAgICBjb3VudCA9IChzdWZmaXgubWF0Y2goL1xcbi9nKSB8fCBbXSkubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHN0cmluZ1JlcGVhdCgnXFxuJywgY291bnQpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29tbWVudCA9IHN0bXQubGVhZGluZ0NvbW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICAgIGlmIChzYWZlQ29uY2F0ZW5hdGlvbiAmJiBzdG10LnR5cGUgPT09IFN5bnRheC5Qcm9ncmFtICYmIHN0bXQuYm9keS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJ1xcbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChnZW5lcmF0ZUNvbW1lbnQoY29tbWVudCkpO1xuICAgICAgICAgICAgICAgIGlmICghZW5kc1dpdGhMaW5lVGVybWluYXRvcih0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKHJlc3VsdCkudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJ1xcbicpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDEsIGxlbiA9IHN0bXQubGVhZGluZ0NvbW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBzdG10LmxlYWRpbmdDb21tZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBbZ2VuZXJhdGVDb21tZW50KGNvbW1lbnQpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlbmRzV2l0aExpbmVUZXJtaW5hdG9yKHRvU291cmNlTm9kZVdoZW5OZWVkZWQoZnJhZ21lbnQpLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnbWVudC5wdXNoKCdcXG4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhZGRJbmRlbnQoZnJhZ21lbnQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFkZEluZGVudChzYXZlKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RtdC50cmFpbGluZ0NvbW1lbnRzKSB7XG5cbiAgICAgICAgICAgIGlmIChwcmVzZXJ2ZUJsYW5rTGluZXMpIHtcbiAgICAgICAgICAgICAgICBjb21tZW50ID0gc3RtdC50cmFpbGluZ0NvbW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgIGV4dFJhbmdlID0gY29tbWVudC5leHRlbmRlZFJhbmdlO1xuICAgICAgICAgICAgICAgIHJhbmdlID0gY29tbWVudC5yYW5nZTtcblxuICAgICAgICAgICAgICAgIHByZWZpeCA9IHNvdXJjZUNvZGUuc3Vic3RyaW5nKGV4dFJhbmdlWzBdLCByYW5nZVswXSk7XG4gICAgICAgICAgICAgICAgY291bnQgPSAocHJlZml4Lm1hdGNoKC9cXG4vZykgfHwgW10pLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIGlmIChjb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3RyaW5nUmVwZWF0KCdcXG4nLCBjb3VudCkpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhZGRJbmRlbnQoZ2VuZXJhdGVDb21tZW50KGNvbW1lbnQpKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocHJlZml4KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZ2VuZXJhdGVDb21tZW50KGNvbW1lbnQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhaWxpbmdUb1N0YXRlbWVudCA9ICFlbmRzV2l0aExpbmVUZXJtaW5hdG9yKHRvU291cmNlTm9kZVdoZW5OZWVkZWQocmVzdWx0KS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICBzcGVjaWFsQmFzZSA9IHN0cmluZ1JlcGVhdCgnICcsIGNhbGN1bGF0ZVNwYWNlcyh0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKFtiYXNlLCByZXN1bHQsIGluZGVudF0pLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBzdG10LnRyYWlsaW5nQ29tbWVudHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IHN0bXQudHJhaWxpbmdDb21tZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhaWxpbmdUb1N0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgYXNzdW1lIHRhcmdldCBsaWtlIGZvbGxvd2luZyBzY3JpcHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB2YXIgdCA9IDIwOyAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICogVGhpcyBpcyBjb21tZW50IG9mIHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmlyc3QgY2FzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtyZXN1bHQsIGluZGVudF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtyZXN1bHQsIHNwZWNpYWxCYXNlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGdlbmVyYXRlQ29tbWVudChjb21tZW50LCBzcGVjaWFsQmFzZSkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gW3Jlc3VsdCwgYWRkSW5kZW50KGdlbmVyYXRlQ29tbWVudChjb21tZW50KSldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICE9PSBsZW4gLSAxICYmICFlbmRzV2l0aExpbmVUZXJtaW5hdG9yKHRvU291cmNlTm9kZVdoZW5OZWVkZWQocmVzdWx0KS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gW3Jlc3VsdCwgJ1xcbiddO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUJsYW5rTGluZXMoc3RhcnQsIGVuZCwgcmVzdWx0KSB7XG4gICAgICAgIHZhciBqLCBuZXdsaW5lQ291bnQgPSAwO1xuXG4gICAgICAgIGZvciAoaiA9IHN0YXJ0OyBqIDwgZW5kOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2VDb2RlW2pdID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgIG5ld2xpbmVDb3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChqID0gMTsgaiA8IG5ld2xpbmVDb3VudDsgaisrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcmVudGhlc2l6ZSh0ZXh0LCBjdXJyZW50LCBzaG91bGQpIHtcbiAgICAgICAgaWYgKGN1cnJlbnQgPCBzaG91bGQpIHtcbiAgICAgICAgICAgIHJldHVybiBbJygnLCB0ZXh0LCAnKSddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlVmVyYmF0aW1TdHJpbmcoc3RyaW5nKSB7XG4gICAgICAgIHZhciBpLCBpeiwgcmVzdWx0O1xuICAgICAgICByZXN1bHQgPSBzdHJpbmcuc3BsaXQoL1xcclxcbnxcXG4vKTtcbiAgICAgICAgZm9yIChpID0gMSwgaXogPSByZXN1bHQubGVuZ3RoOyBpIDwgaXo7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0W2ldID0gbmV3bGluZSArIGJhc2UgKyByZXN1bHRbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZVZlcmJhdGltKGV4cHIsIHByZWNlZGVuY2UpIHtcbiAgICAgICAgdmFyIHZlcmJhdGltLCByZXN1bHQsIHByZWM7XG4gICAgICAgIHZlcmJhdGltID0gZXhwcltleHRyYS52ZXJiYXRpbV07XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2ZXJiYXRpbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHBhcmVudGhlc2l6ZShnZW5lcmF0ZVZlcmJhdGltU3RyaW5nKHZlcmJhdGltKSwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgcHJlY2VkZW5jZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB2ZXJiYXRpbSBpcyBvYmplY3RcbiAgICAgICAgICAgIHJlc3VsdCA9IGdlbmVyYXRlVmVyYmF0aW1TdHJpbmcodmVyYmF0aW0uY29udGVudCk7XG4gICAgICAgICAgICBwcmVjID0gKHZlcmJhdGltLnByZWNlZGVuY2UgIT0gbnVsbCkgPyB2ZXJiYXRpbS5wcmVjZWRlbmNlIDogUHJlY2VkZW5jZS5TZXF1ZW5jZTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHBhcmVudGhlc2l6ZShyZXN1bHQsIHByZWMsIHByZWNlZGVuY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRvU291cmNlTm9kZVdoZW5OZWVkZWQocmVzdWx0LCBleHByKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBDb2RlR2VuZXJhdG9yKCkge1xuICAgIH1cblxuICAgIC8vIEhlbHBlcnMuXG5cbiAgICBDb2RlR2VuZXJhdG9yLnByb3RvdHlwZS5tYXliZUJsb2NrID0gZnVuY3Rpb24oc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgdmFyIHJlc3VsdCwgbm9MZWFkaW5nQ29tbWVudCwgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgbm9MZWFkaW5nQ29tbWVudCA9ICFleHRyYS5jb21tZW50IHx8ICFzdG10LmxlYWRpbmdDb21tZW50cztcblxuICAgICAgICBpZiAoc3RtdC50eXBlID09PSBTeW50YXguQmxvY2tTdGF0ZW1lbnQgJiYgbm9MZWFkaW5nQ29tbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIFtzcGFjZSwgdGhpcy5nZW5lcmF0ZVN0YXRlbWVudChzdG10LCBmbGFncyldO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0bXQudHlwZSA9PT0gU3ludGF4LkVtcHR5U3RhdGVtZW50ICYmIG5vTGVhZGluZ0NvbW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiAnOyc7XG4gICAgICAgIH1cblxuICAgICAgICB3aXRoSW5kZW50KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFtcbiAgICAgICAgICAgICAgICBuZXdsaW5lLFxuICAgICAgICAgICAgICAgIGFkZEluZGVudCh0aGF0LmdlbmVyYXRlU3RhdGVtZW50KHN0bXQsIGZsYWdzKSlcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIENvZGVHZW5lcmF0b3IucHJvdG90eXBlLm1heWJlQmxvY2tTdWZmaXggPSBmdW5jdGlvbiAoc3RtdCwgcmVzdWx0KSB7XG4gICAgICAgIHZhciBlbmRzID0gZW5kc1dpdGhMaW5lVGVybWluYXRvcih0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKHJlc3VsdCkudG9TdHJpbmcoKSk7XG4gICAgICAgIGlmIChzdG10LnR5cGUgPT09IFN5bnRheC5CbG9ja1N0YXRlbWVudCAmJiAoIWV4dHJhLmNvbW1lbnQgfHwgIXN0bXQubGVhZGluZ0NvbW1lbnRzKSAmJiAhZW5kcykge1xuICAgICAgICAgICAgcmV0dXJuIFtyZXN1bHQsIHNwYWNlXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kcykge1xuICAgICAgICAgICAgcmV0dXJuIFtyZXN1bHQsIGJhc2VdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbcmVzdWx0LCBuZXdsaW5lLCBiYXNlXTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVJZGVudGlmaWVyKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRvU291cmNlTm9kZVdoZW5OZWVkZWQobm9kZS5uYW1lLCBub2RlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUFzeW5jUHJlZml4KG5vZGUsIHNwYWNlUmVxdWlyZWQpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuYXN5bmMgPyAnYXN5bmMnICsgKHNwYWNlUmVxdWlyZWQgPyBub0VtcHR5U3BhY2UoKSA6IHNwYWNlKSA6ICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlU3RhclN1ZmZpeChub2RlKSB7XG4gICAgICAgIHZhciBpc0dlbmVyYXRvciA9IG5vZGUuZ2VuZXJhdG9yICYmICFleHRyYS5tb3ouc3Rhcmxlc3NHZW5lcmF0b3I7XG4gICAgICAgIHJldHVybiBpc0dlbmVyYXRvciA/ICcqJyArIHNwYWNlIDogJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVNZXRob2RQcmVmaXgocHJvcCkge1xuICAgICAgICB2YXIgZnVuYyA9IHByb3AudmFsdWUsIHByZWZpeCA9ICcnO1xuICAgICAgICBpZiAoZnVuYy5hc3luYykge1xuICAgICAgICAgICAgcHJlZml4ICs9IGdlbmVyYXRlQXN5bmNQcmVmaXgoZnVuYywgIXByb3AuY29tcHV0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmdW5jLmdlbmVyYXRvcikge1xuICAgICAgICAgICAgLy8gYXZvaWQgc3BhY2UgYmVmb3JlIG1ldGhvZCBuYW1lXG4gICAgICAgICAgICBwcmVmaXggKz0gZ2VuZXJhdGVTdGFyU3VmZml4KGZ1bmMpID8gJyonIDogJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByZWZpeDtcbiAgICB9XG5cbiAgICBDb2RlR2VuZXJhdG9yLnByb3RvdHlwZS5nZW5lcmF0ZVBhdHRlcm4gPSBmdW5jdGlvbiAobm9kZSwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZUlkZW50aWZpZXIobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKG5vZGUsIHByZWNlZGVuY2UsIGZsYWdzKTtcbiAgICB9O1xuXG4gICAgQ29kZUdlbmVyYXRvci5wcm90b3R5cGUuZ2VuZXJhdGVGdW5jdGlvblBhcmFtcyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBpLCBpeiwgcmVzdWx0LCBoYXNEZWZhdWx0O1xuXG4gICAgICAgIGhhc0RlZmF1bHQgPSBmYWxzZTtcblxuICAgICAgICBpZiAobm9kZS50eXBlID09PSBTeW50YXguQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24gJiZcbiAgICAgICAgICAgICAgICAhbm9kZS5yZXN0ICYmICghbm9kZS5kZWZhdWx0cyB8fCBub2RlLmRlZmF1bHRzLmxlbmd0aCA9PT0gMCkgJiZcbiAgICAgICAgICAgICAgICBub2RlLnBhcmFtcy5sZW5ndGggPT09IDEgJiYgbm9kZS5wYXJhbXNbMF0udHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIC8vIGFyZyA9PiB7IH0gY2FzZVxuICAgICAgICAgICAgcmVzdWx0ID0gW2dlbmVyYXRlQXN5bmNQcmVmaXgobm9kZSwgdHJ1ZSksIGdlbmVyYXRlSWRlbnRpZmllcihub2RlLnBhcmFtc1swXSldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gbm9kZS50eXBlID09PSBTeW50YXguQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24gPyBbZ2VuZXJhdGVBc3luY1ByZWZpeChub2RlLCBmYWxzZSldIDogW107XG4gICAgICAgICAgICByZXN1bHQucHVzaCgnKCcpO1xuICAgICAgICAgICAgaWYgKG5vZGUuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgICBoYXNEZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGl6ID0gbm9kZS5wYXJhbXMubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmIChoYXNEZWZhdWx0ICYmIG5vZGUuZGVmYXVsdHNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIGRlZmF1bHQgdmFsdWVzLlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmdlbmVyYXRlQXNzaWdubWVudChub2RlLnBhcmFtc1tpXSwgbm9kZS5kZWZhdWx0c1tpXSwgJz0nLCBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsIEVfVFRUKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5nZW5lcmF0ZVBhdHRlcm4obm9kZS5wYXJhbXNbaV0sIFByZWNlZGVuY2UuQXNzaWdubWVudCwgRV9UVFQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGkgKyAxIDwgaXopIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJywnICsgc3BhY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5vZGUucmVzdCkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLnBhcmFtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJywnICsgc3BhY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLi4uJyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZ2VuZXJhdGVJZGVudGlmaWVyKG5vZGUucmVzdCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHQucHVzaCgnKScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgQ29kZUdlbmVyYXRvci5wcm90b3R5cGUuZ2VuZXJhdGVGdW5jdGlvbkJvZHkgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgcmVzdWx0LCBleHByO1xuXG4gICAgICAgIHJlc3VsdCA9IHRoaXMuZ2VuZXJhdGVGdW5jdGlvblBhcmFtcyhub2RlKTtcblxuICAgICAgICBpZiAobm9kZS50eXBlID09PSBTeW50YXguQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNwYWNlKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCc9PicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vZGUuZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goc3BhY2UpO1xuICAgICAgICAgICAgZXhwciA9IHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKG5vZGUuYm9keSwgUHJlY2VkZW5jZS5Bc3NpZ25tZW50LCBFX1RUVCk7XG4gICAgICAgICAgICBpZiAoZXhwci50b1N0cmluZygpLmNoYXJBdCgwKSA9PT0gJ3snKSB7XG4gICAgICAgICAgICAgICAgZXhwciA9IFsnKCcsIGV4cHIsICcpJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChleHByKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMubWF5YmVCbG9jayhub2RlLmJvZHksIFNfVFRGRikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgQ29kZUdlbmVyYXRvci5wcm90b3R5cGUuZ2VuZXJhdGVJdGVyYXRpb25Gb3JTdGF0ZW1lbnQgPSBmdW5jdGlvbiAob3BlcmF0b3IsIHN0bXQsIGZsYWdzKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbJ2ZvcicgKyAoc3RtdC5hd2FpdCA/IG5vRW1wdHlTcGFjZSgpICsgJ2F3YWl0JyA6ICcnKSArIHNwYWNlICsgJygnXSwgdGhhdCA9IHRoaXM7XG4gICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHN0bXQubGVmdC50eXBlID09PSBTeW50YXguVmFyaWFibGVEZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzdG10LmxlZnQua2luZCArIG5vRW1wdHlTcGFjZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhhdC5nZW5lcmF0ZVN0YXRlbWVudChzdG10LmxlZnQuZGVjbGFyYXRpb25zWzBdLCBTX0ZGRkYpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhhdC5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5sZWZ0LCBQcmVjZWRlbmNlLkNhbGwsIEVfVFRUKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCBvcGVyYXRvcik7XG4gICAgICAgICAgICByZXN1bHQgPSBbam9pbihcbiAgICAgICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICAgICAgdGhhdC5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5yaWdodCwgUHJlY2VkZW5jZS5Bc3NpZ25tZW50LCBFX1RUVClcbiAgICAgICAgICAgICksICcpJ107XG4gICAgICAgIH0pO1xuICAgICAgICByZXN1bHQucHVzaCh0aGlzLm1heWJlQmxvY2soc3RtdC5ib2R5LCBmbGFncykpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICBDb2RlR2VuZXJhdG9yLnByb3RvdHlwZS5nZW5lcmF0ZVByb3BlcnR5S2V5ID0gZnVuY3Rpb24gKGV4cHIsIGNvbXB1dGVkKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICBpZiAoY29tcHV0ZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCdbJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQucHVzaCh0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCkpO1xuXG4gICAgICAgIGlmIChjb21wdXRlZCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goJ10nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIENvZGVHZW5lcmF0b3IucHJvdG90eXBlLmdlbmVyYXRlQXNzaWdubWVudCA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCwgb3BlcmF0b3IsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgIGlmIChQcmVjZWRlbmNlLkFzc2lnbm1lbnQgPCBwcmVjZWRlbmNlKSB7XG4gICAgICAgICAgICBmbGFncyB8PSBGX0FMTE9XX0lOO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcmVudGhlc2l6ZShcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihsZWZ0LCBQcmVjZWRlbmNlLkNhbGwsIGZsYWdzKSxcbiAgICAgICAgICAgICAgICBzcGFjZSArIG9wZXJhdG9yICsgc3BhY2UsXG4gICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24ocmlnaHQsIFByZWNlZGVuY2UuQXNzaWdubWVudCwgZmxhZ3MpXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgUHJlY2VkZW5jZS5Bc3NpZ25tZW50LFxuICAgICAgICAgICAgcHJlY2VkZW5jZVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICBDb2RlR2VuZXJhdG9yLnByb3RvdHlwZS5zZW1pY29sb24gPSBmdW5jdGlvbiAoZmxhZ3MpIHtcbiAgICAgICAgaWYgKCFzZW1pY29sb25zICYmIGZsYWdzICYgRl9TRU1JQ09MT05fT1BUKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICc7JztcbiAgICB9O1xuXG4gICAgLy8gU3RhdGVtZW50cy5cblxuICAgIENvZGVHZW5lcmF0b3IuU3RhdGVtZW50ID0ge1xuXG4gICAgICAgIEJsb2NrU3RhdGVtZW50OiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByYW5nZSwgY29udGVudCwgcmVzdWx0ID0gWyd7JywgbmV3bGluZV0sIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICB3aXRoSW5kZW50KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgZnVuY3Rpb25zIHdpdGhvdXQgYW55IGNvZGVcbiAgICAgICAgICAgICAgICBpZiAoc3RtdC5ib2R5Lmxlbmd0aCA9PT0gMCAmJiBwcmVzZXJ2ZUJsYW5rTGluZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSBzdG10LnJhbmdlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2VbMV0gLSByYW5nZVswXSA+IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBzb3VyY2VDb2RlLnN1YnN0cmluZyhyYW5nZVswXSArIDEsIHJhbmdlWzFdIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudFswXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBbJ3snXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGksIGl6LCBmcmFnbWVudCwgYm9keUZsYWdzO1xuICAgICAgICAgICAgICAgIGJvZHlGbGFncyA9IFNfVEZGRjtcbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MgJiBGX0ZVTkNfQk9EWSkge1xuICAgICAgICAgICAgICAgICAgICBib2R5RmxhZ3MgfD0gRl9ESVJFQ1RJVkVfQ1RYO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGl6ID0gc3RtdC5ib2R5Lmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXNlcnZlQmxhbmtMaW5lcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlIHNwYWNlcyBiZWZvcmUgdGhlIGZpcnN0IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0bXQuYm9keVswXS5sZWFkaW5nQ29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSBzdG10LmJvZHlbMF0ubGVhZGluZ0NvbW1lbnRzWzBdLmV4dGVuZGVkUmFuZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBzb3VyY2VDb2RlLnN1YnN0cmluZyhyYW5nZVswXSwgcmFuZ2VbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudFswXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFsneyddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3RtdC5ib2R5WzBdLmxlYWRpbmdDb21tZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUJsYW5rTGluZXMoc3RtdC5yYW5nZVswXSwgc3RtdC5ib2R5WzBdLnJhbmdlWzBdLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlIHNwYWNlcyBiZXR3ZWVuIGxpbmVzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0bXQuYm9keVtpIC0gMV0udHJhaWxpbmdDb21tZW50cyAgJiYgIXN0bXQuYm9keVtpXS5sZWFkaW5nQ29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVCbGFua0xpbmVzKHN0bXQuYm9keVtpIC0gMV0ucmFuZ2VbMV0sIHN0bXQuYm9keVtpXS5yYW5nZVswXSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gaXogLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5RmxhZ3MgfD0gRl9TRU1JQ09MT05fT1BUO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0bXQuYm9keVtpXS5sZWFkaW5nQ29tbWVudHMgJiYgcHJlc2VydmVCbGFua0xpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnbWVudCA9IHRoYXQuZ2VuZXJhdGVTdGF0ZW1lbnQoc3RtdC5ib2R5W2ldLCBib2R5RmxhZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBhZGRJbmRlbnQodGhhdC5nZW5lcmF0ZVN0YXRlbWVudChzdG10LmJvZHlbaV0sIGJvZHlGbGFncykpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVuZHNXaXRoTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChmcmFnbWVudCkudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVzZXJ2ZUJsYW5rTGluZXMgJiYgaSA8IGl6IC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IGFkZCBhIG5ldyBsaW5lIGlmIHRoZXJlIGFyZSBsZWFkaW5nIGNvbWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGUgbmV4dCBzdGF0ZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0bXQuYm9keVtpICsgMV0ubGVhZGluZ0NvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld2xpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAocHJlc2VydmVCbGFua0xpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGUgc3BhY2VzIGFmdGVyIHRoZSBsYXN0IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBpeiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0bXQuYm9keVtpXS50cmFpbGluZ0NvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlQmxhbmtMaW5lcyhzdG10LmJvZHlbaV0ucmFuZ2VbMV0sIHN0bXQucmFuZ2VbMV0sIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFkZEluZGVudCgnfScpKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQnJlYWtTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgaWYgKHN0bXQubGFiZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2JyZWFrICcgKyBzdG10LmxhYmVsLm5hbWUgKyB0aGlzLnNlbWljb2xvbihmbGFncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ2JyZWFrJyArIHRoaXMuc2VtaWNvbG9uKGZsYWdzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBDb250aW51ZVN0YXRlbWVudDogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICBpZiAoc3RtdC5sYWJlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnY29udGludWUgJyArIHN0bXQubGFiZWwubmFtZSArIHRoaXMuc2VtaWNvbG9uKGZsYWdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnY29udGludWUnICsgdGhpcy5zZW1pY29sb24oZmxhZ3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIENsYXNzQm9keTogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gWyAneycsIG5ld2xpbmVdLCB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoaW5kZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGksIGl6O1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaXogPSBzdG10LmJvZHkubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpbmRlbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGF0LmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LmJvZHlbaV0sIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICsgMSA8IGl6KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIWVuZHNXaXRoTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChyZXN1bHQpLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChiYXNlKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCd9Jyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIENsYXNzRGVjbGFyYXRpb246IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgZnJhZ21lbnQ7XG4gICAgICAgICAgICByZXN1bHQgID0gWydjbGFzcyddO1xuICAgICAgICAgICAgaWYgKHN0bXQuaWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5pZCwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdG10LnN1cGVyQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudCA9IGpvaW4oJ2V4dGVuZHMnLCB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LnN1cGVyQ2xhc3MsIFByZWNlZGVuY2UuVW5hcnksIEVfVFRUKSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNwYWNlKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuZ2VuZXJhdGVTdGF0ZW1lbnQoc3RtdC5ib2R5LCBTX1RGRlQpKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRGlyZWN0aXZlU3RhdGVtZW50OiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIGlmIChleHRyYS5yYXcgJiYgc3RtdC5yYXcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RtdC5yYXcgKyB0aGlzLnNlbWljb2xvbihmbGFncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXNjYXBlRGlyZWN0aXZlKHN0bXQuZGlyZWN0aXZlKSArIHRoaXMuc2VtaWNvbG9uKGZsYWdzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBEb1doaWxlU3RhdGVtZW50OiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIC8vIEJlY2F1c2UgYGRvIDQyIHdoaWxlIChjb25kKWAgaXMgU3ludGF4IEVycm9yLiBXZSBuZWVkIHNlbWljb2xvbi5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBqb2luKCdkbycsIHRoaXMubWF5YmVCbG9jayhzdG10LmJvZHksIFNfVEZGRikpO1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5tYXliZUJsb2NrU3VmZml4KHN0bXQuYm9keSwgcmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybiBqb2luKHJlc3VsdCwgW1xuICAgICAgICAgICAgICAgICd3aGlsZScgKyBzcGFjZSArICcoJyxcbiAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LnRlc3QsIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSxcbiAgICAgICAgICAgICAgICAnKScgKyB0aGlzLnNlbWljb2xvbihmbGFncylcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIENhdGNoQ2xhdXNlOiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGd1YXJkO1xuXG4gICAgICAgICAgICAgICAgaWYgKHN0bXQucGFyYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NhdGNoJyArIHNwYWNlICsgJygnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5wYXJhbSwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgJyknXG4gICAgICAgICAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0bXQuZ3VhcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGd1YXJkID0gdGhhdC5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5ndWFyZCwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNwbGljZSgyLCAwLCAnIGlmICcsIGd1YXJkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFsnY2F0Y2gnXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMubWF5YmVCbG9jayhzdG10LmJvZHksIFNfVEZGRikpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBEZWJ1Z2dlclN0YXRlbWVudDogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2RlYnVnZ2VyJyArIHRoaXMuc2VtaWNvbG9uKGZsYWdzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBFbXB0eVN0YXRlbWVudDogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gJzsnO1xuICAgICAgICB9LFxuXG4gICAgICAgIEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbjogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gWyAnZXhwb3J0JyBdLCBib2R5RmxhZ3M7XG5cbiAgICAgICAgICAgIGJvZHlGbGFncyA9IChmbGFncyAmIEZfU0VNSUNPTE9OX09QVCkgPyBTX1RGRlQgOiBTX1RGRkY7XG5cbiAgICAgICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0IEhvaXN0YWJsZURlY2xhcmF0aW9uW0RlZmF1bHRdXG4gICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCBBc3NpZ25tZW50RXhwcmVzc2lvbltJbl0gO1xuICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsICdkZWZhdWx0Jyk7XG4gICAgICAgICAgICBpZiAoaXNTdGF0ZW1lbnQoc3RtdC5kZWNsYXJhdGlvbikpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgdGhpcy5nZW5lcmF0ZVN0YXRlbWVudChzdG10LmRlY2xhcmF0aW9uLCBib2R5RmxhZ3MpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQuZGVjbGFyYXRpb24sIFByZWNlZGVuY2UuQXNzaWdubWVudCwgRV9UVFQpICsgdGhpcy5zZW1pY29sb24oZmxhZ3MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRXhwb3J0TmFtZWREZWNsYXJhdGlvbjogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gWyAnZXhwb3J0JyBdLCBib2R5RmxhZ3MsIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICBib2R5RmxhZ3MgPSAoZmxhZ3MgJiBGX1NFTUlDT0xPTl9PUFQpID8gU19URkZUIDogU19URkZGO1xuXG4gICAgICAgICAgICAvLyBleHBvcnQgVmFyaWFibGVTdGF0ZW1lbnRcbiAgICAgICAgICAgIC8vIGV4cG9ydCBEZWNsYXJhdGlvbltEZWZhdWx0XVxuICAgICAgICAgICAgaWYgKHN0bXQuZGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gam9pbihyZXN1bHQsIHRoaXMuZ2VuZXJhdGVTdGF0ZW1lbnQoc3RtdC5kZWNsYXJhdGlvbiwgYm9keUZsYWdzKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGV4cG9ydCBFeHBvcnRDbGF1c2VbTm9SZWZlcmVuY2VdIEZyb21DbGF1c2UgO1xuICAgICAgICAgICAgLy8gZXhwb3J0IEV4cG9ydENsYXVzZSA7XG4gICAgICAgICAgICBpZiAoc3RtdC5zcGVjaWZpZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0bXQuc3BlY2lmaWVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsICd7JyArIHNwYWNlICsgJ30nKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0bXQuc3BlY2lmaWVyc1swXS50eXBlID09PSBTeW50YXguRXhwb3J0QmF0Y2hTcGVjaWZpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQuc3BlY2lmaWVyc1swXSwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgJ3snKTtcbiAgICAgICAgICAgICAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoaW5kZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSwgaXo7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGl6ID0gc3RtdC5zcGVjaWZpZXJzLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpbmRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoYXQuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQuc3BlY2lmaWVyc1tpXSwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSArIDEgPCBpeikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcgKyBuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVuZHNXaXRoTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChyZXN1bHQpLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChiYXNlICsgJ30nKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc3RtdC5zb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdmcm9tJyArIHNwYWNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTW9kdWxlU3BlY2lmaWVyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LnNvdXJjZSwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW1pY29sb24oZmxhZ3MpXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuc2VtaWNvbG9uKGZsYWdzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBFeHBvcnRBbGxEZWNsYXJhdGlvbjogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICAvLyBleHBvcnQgKiBGcm9tQ2xhdXNlIDtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgJ2V4cG9ydCcgKyBzcGFjZSxcbiAgICAgICAgICAgICAgICAnKicgKyBzcGFjZSxcbiAgICAgICAgICAgICAgICAnZnJvbScgKyBzcGFjZSxcbiAgICAgICAgICAgICAgICAvLyBNb2R1bGVTcGVjaWZpZXJcbiAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LnNvdXJjZSwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpLFxuICAgICAgICAgICAgICAgIHRoaXMuc2VtaWNvbG9uKGZsYWdzKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSxcblxuICAgICAgICBFeHByZXNzaW9uU3RhdGVtZW50OiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIGZyYWdtZW50O1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBpc0NsYXNzUHJlZml4ZWQoZnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29kZTtcbiAgICAgICAgICAgICAgICBpZiAoZnJhZ21lbnQuc2xpY2UoMCwgNSkgIT09ICdjbGFzcycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb2RlID0gZnJhZ21lbnQuY2hhckNvZGVBdCg1KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29kZSA9PT0gMHg3QiAgLyogJ3snICovIHx8IGVzdXRpbHMuY29kZS5pc1doaXRlU3BhY2UoY29kZSkgfHwgZXN1dGlscy5jb2RlLmlzTGluZVRlcm1pbmF0b3IoY29kZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb25QcmVmaXhlZChmcmFnbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBjb2RlO1xuICAgICAgICAgICAgICAgIGlmIChmcmFnbWVudC5zbGljZSgwLCA4KSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvZGUgPSBmcmFnbWVudC5jaGFyQ29kZUF0KDgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2RlID09PSAweDI4IC8qICcoJyAqLyB8fCBlc3V0aWxzLmNvZGUuaXNXaGl0ZVNwYWNlKGNvZGUpIHx8IGNvZGUgPT09IDB4MkEgIC8qICcqJyAqLyB8fCBlc3V0aWxzLmNvZGUuaXNMaW5lVGVybWluYXRvcihjb2RlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gaXNBc3luY1ByZWZpeGVkKGZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvZGUsIGksIGl6O1xuICAgICAgICAgICAgICAgIGlmIChmcmFnbWVudC5zbGljZSgwLCA1KSAhPT0gJ2FzeW5jJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZXN1dGlscy5jb2RlLmlzV2hpdGVTcGFjZShmcmFnbWVudC5jaGFyQ29kZUF0KDUpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDYsIGl6ID0gZnJhZ21lbnQubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVzdXRpbHMuY29kZS5pc1doaXRlU3BhY2UoZnJhZ21lbnQuY2hhckNvZGVBdChpKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpID09PSBpeikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmcmFnbWVudC5zbGljZShpLCBpICsgOCkgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb2RlID0gZnJhZ21lbnQuY2hhckNvZGVBdChpICsgOCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvZGUgPT09IDB4MjggLyogJygnICovIHx8IGVzdXRpbHMuY29kZS5pc1doaXRlU3BhY2UoY29kZSkgfHwgY29kZSA9PT0gMHgyQSAgLyogJyonICovIHx8IGVzdXRpbHMuY29kZS5pc0xpbmVUZXJtaW5hdG9yKGNvZGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHQgPSBbdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5leHByZXNzaW9uLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCldO1xuICAgICAgICAgICAgLy8gMTIuNCAneycsICdmdW5jdGlvbicsICdjbGFzcycgaXMgbm90IGFsbG93ZWQgaW4gdGhpcyBwb3NpdGlvbi5cbiAgICAgICAgICAgIC8vIHdyYXAgZXhwcmVzc2lvbiB3aXRoIHBhcmVudGhlc2VzXG4gICAgICAgICAgICBmcmFnbWVudCA9IHRvU291cmNlTm9kZVdoZW5OZWVkZWQocmVzdWx0KS50b1N0cmluZygpO1xuICAgICAgICAgICAgaWYgKGZyYWdtZW50LmNoYXJDb2RlQXQoMCkgPT09IDB4N0IgIC8qICd7JyAqLyB8fCAgLy8gT2JqZWN0RXhwcmVzc2lvblxuICAgICAgICAgICAgICAgICAgICBpc0NsYXNzUHJlZml4ZWQoZnJhZ21lbnQpIHx8XG4gICAgICAgICAgICAgICAgICAgIGlzRnVuY3Rpb25QcmVmaXhlZChmcmFnbWVudCkgfHxcbiAgICAgICAgICAgICAgICAgICAgaXNBc3luY1ByZWZpeGVkKGZyYWdtZW50KSB8fFxuICAgICAgICAgICAgICAgICAgICAoZGlyZWN0aXZlICYmIChmbGFncyAmIEZfRElSRUNUSVZFX0NUWCkgJiYgc3RtdC5leHByZXNzaW9uLnR5cGUgPT09IFN5bnRheC5MaXRlcmFsICYmIHR5cGVvZiBzdG10LmV4cHJlc3Npb24udmFsdWUgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFsnKCcsIHJlc3VsdCwgJyknICsgdGhpcy5zZW1pY29sb24oZmxhZ3MpXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5zZW1pY29sb24oZmxhZ3MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgSW1wb3J0RGVjbGFyYXRpb246IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgLy8gRVM2OiAxNS4yLjEgdmFsaWQgaW1wb3J0IGRlY2xhcmF0aW9uczpcbiAgICAgICAgICAgIC8vICAgICAtIGltcG9ydCBJbXBvcnRDbGF1c2UgRnJvbUNsYXVzZSA7XG4gICAgICAgICAgICAvLyAgICAgLSBpbXBvcnQgTW9kdWxlU3BlY2lmaWVyIDtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIGN1cnNvciwgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vIElmIG5vIEltcG9ydENsYXVzZSBpcyBwcmVzZW50LFxuICAgICAgICAgICAgLy8gdGhpcyBzaG91bGQgYmUgYGltcG9ydCBNb2R1bGVTcGVjaWZpZXJgIHNvIHNraXAgYGZyb21gXG4gICAgICAgICAgICAvLyBNb2R1bGVTcGVjaWZpZXIgaXMgU3RyaW5nTGl0ZXJhbC5cbiAgICAgICAgICAgIGlmIChzdG10LnNwZWNpZmllcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gaW1wb3J0IE1vZHVsZVNwZWNpZmllciA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgJ2ltcG9ydCcsXG4gICAgICAgICAgICAgICAgICAgIHNwYWNlLFxuICAgICAgICAgICAgICAgICAgICAvLyBNb2R1bGVTcGVjaWZpZXJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5zb3VyY2UsIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW1pY29sb24oZmxhZ3MpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaW1wb3J0IEltcG9ydENsYXVzZSBGcm9tQ2xhdXNlIDtcbiAgICAgICAgICAgIHJlc3VsdCA9IFtcbiAgICAgICAgICAgICAgICAnaW1wb3J0J1xuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGN1cnNvciA9IDA7XG5cbiAgICAgICAgICAgIC8vIEltcG9ydGVkQmluZGluZ1xuICAgICAgICAgICAgaWYgKHN0bXQuc3BlY2lmaWVyc1tjdXJzb3JdLnR5cGUgPT09IFN5bnRheC5JbXBvcnREZWZhdWx0U3BlY2lmaWVyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQuc3BlY2lmaWVyc1tjdXJzb3JdLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVClcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICArK2N1cnNvcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN0bXQuc3BlY2lmaWVyc1tjdXJzb3JdKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnNvciAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzdG10LnNwZWNpZmllcnNbY3Vyc29yXS50eXBlID09PSBTeW50YXguSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5hbWVTcGFjZUltcG9ydFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwYWNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQuc3BlY2lmaWVyc1tjdXJzb3JdLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVClcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTmFtZWRJbXBvcnRzXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNwYWNlICsgJ3snKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoKHN0bXQuc3BlY2lmaWVycy5sZW5ndGggLSBjdXJzb3IpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbXBvcnQgeyAuLi4gfSBmcm9tIFwiLi4uXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzcGFjZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LnNwZWNpZmllcnNbY3Vyc29yXSwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNwYWNlICsgJ30nICsgc3BhY2UpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW1wb3J0IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgIC4uLixcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgIC4uLixcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIH0gZnJvbSBcIi4uLlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoaW5kZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGksIGl6O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld2xpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IGN1cnNvciwgaXogPSBzdG10LnNwZWNpZmllcnMubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpbmRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGF0LmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LnNwZWNpZmllcnNbaV0sIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpICsgMSA8IGl6KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcgKyBuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlbmRzV2l0aExpbmVUZXJtaW5hdG9yKHRvU291cmNlTm9kZVdoZW5OZWVkZWQocmVzdWx0KS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld2xpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYmFzZSArICd9JyArIHNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIFtcbiAgICAgICAgICAgICAgICAnZnJvbScgKyBzcGFjZSxcbiAgICAgICAgICAgICAgICAvLyBNb2R1bGVTcGVjaWZpZXJcbiAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LnNvdXJjZSwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpLFxuICAgICAgICAgICAgICAgIHRoaXMuc2VtaWNvbG9uKGZsYWdzKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIFZhcmlhYmxlRGVjbGFyYXRvcjogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgaXRlbUZsYWdzID0gKGZsYWdzICYgRl9BTExPV19JTikgPyBFX1RUVCA6IEVfRlRUO1xuICAgICAgICAgICAgaWYgKHN0bXQuaW5pdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQuaWQsIFByZWNlZGVuY2UuQXNzaWdubWVudCwgaXRlbUZsYWdzKSxcbiAgICAgICAgICAgICAgICAgICAgc3BhY2UsXG4gICAgICAgICAgICAgICAgICAgICc9JyxcbiAgICAgICAgICAgICAgICAgICAgc3BhY2UsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQuaW5pdCwgUHJlY2VkZW5jZS5Bc3NpZ25tZW50LCBpdGVtRmxhZ3MpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlUGF0dGVybihzdG10LmlkLCBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsIGl0ZW1GbGFncyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgVmFyaWFibGVEZWNsYXJhdGlvbjogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICAvLyBWYXJpYWJsZURlY2xhcmF0b3IgaXMgdHlwZWQgYXMgU3RhdGVtZW50LFxuICAgICAgICAgICAgLy8gYnV0IGpvaW5lZCB3aXRoIGNvbW1hIChub3QgTGluZVRlcm1pbmF0b3IpLlxuICAgICAgICAgICAgLy8gU28gaWYgY29tbWVudCBpcyBhdHRhY2hlZCB0byB0YXJnZXQgbm9kZSwgd2Ugc2hvdWxkIHNwZWNpYWxpemUuXG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBpLCBpeiwgbm9kZSwgYm9keUZsYWdzLCB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgcmVzdWx0ID0gWyBzdG10LmtpbmQgXTtcblxuICAgICAgICAgICAgYm9keUZsYWdzID0gKGZsYWdzICYgRl9BTExPV19JTikgPyBTX1RGRkYgOiBTX0ZGRkY7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGJsb2NrKCkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBzdG10LmRlY2xhcmF0aW9uc1swXTtcbiAgICAgICAgICAgICAgICBpZiAoZXh0cmEuY29tbWVudCAmJiBub2RlLmxlYWRpbmdDb21tZW50cykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFkZEluZGVudCh0aGF0LmdlbmVyYXRlU3RhdGVtZW50KG5vZGUsIGJvZHlGbGFncykpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChub0VtcHR5U3BhY2UoKSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoYXQuZ2VuZXJhdGVTdGF0ZW1lbnQobm9kZSwgYm9keUZsYWdzKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMSwgaXogPSBzdG10LmRlY2xhcmF0aW9ucy5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBzdG10LmRlY2xhcmF0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4dHJhLmNvbW1lbnQgJiYgbm9kZS5sZWFkaW5nQ29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcsJyArIG5ld2xpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYWRkSW5kZW50KHRoYXQuZ2VuZXJhdGVTdGF0ZW1lbnQobm9kZSwgYm9keUZsYWdzKSkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJywnICsgc3BhY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhhdC5nZW5lcmF0ZVN0YXRlbWVudChub2RlLCBib2R5RmxhZ3MpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN0bXQuZGVjbGFyYXRpb25zLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB3aXRoSW5kZW50KGJsb2NrKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYmxvY2soKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5zZW1pY29sb24oZmxhZ3MpKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBUaHJvd1N0YXRlbWVudDogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gW2pvaW4oXG4gICAgICAgICAgICAgICAgJ3Rocm93JyxcbiAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LmFyZ3VtZW50LCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVClcbiAgICAgICAgICAgICksIHRoaXMuc2VtaWNvbG9uKGZsYWdzKV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgVHJ5U3RhdGVtZW50OiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIGksIGl6LCBndWFyZGVkSGFuZGxlcnM7XG5cbiAgICAgICAgICAgIHJlc3VsdCA9IFsndHJ5JywgdGhpcy5tYXliZUJsb2NrKHN0bXQuYmxvY2ssIFNfVEZGRildO1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5tYXliZUJsb2NrU3VmZml4KHN0bXQuYmxvY2ssIHJlc3VsdCk7XG5cbiAgICAgICAgICAgIGlmIChzdG10LmhhbmRsZXJzKSB7XG4gICAgICAgICAgICAgICAgLy8gb2xkIGludGVyZmFjZVxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGl6ID0gc3RtdC5oYW5kbGVycy5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCB0aGlzLmdlbmVyYXRlU3RhdGVtZW50KHN0bXQuaGFuZGxlcnNbaV0sIFNfVEZGRikpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RtdC5maW5hbGl6ZXIgfHwgaSArIDEgIT09IGl6KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLm1heWJlQmxvY2tTdWZmaXgoc3RtdC5oYW5kbGVyc1tpXS5ib2R5LCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBndWFyZGVkSGFuZGxlcnMgPSBzdG10Lmd1YXJkZWRIYW5kbGVycyB8fCBbXTtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGl6ID0gZ3VhcmRlZEhhbmRsZXJzLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIHRoaXMuZ2VuZXJhdGVTdGF0ZW1lbnQoZ3VhcmRlZEhhbmRsZXJzW2ldLCBTX1RGRkYpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0bXQuZmluYWxpemVyIHx8IGkgKyAxICE9PSBpeikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5tYXliZUJsb2NrU3VmZml4KGd1YXJkZWRIYW5kbGVyc1tpXS5ib2R5LCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gbmV3IGludGVyZmFjZVxuICAgICAgICAgICAgICAgIGlmIChzdG10LmhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc3RtdC5oYW5kbGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaXogPSBzdG10LmhhbmRsZXIubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCB0aGlzLmdlbmVyYXRlU3RhdGVtZW50KHN0bXQuaGFuZGxlcltpXSwgU19URkZGKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0bXQuZmluYWxpemVyIHx8IGkgKyAxICE9PSBpeikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLm1heWJlQmxvY2tTdWZmaXgoc3RtdC5oYW5kbGVyW2ldLmJvZHksIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIHRoaXMuZ2VuZXJhdGVTdGF0ZW1lbnQoc3RtdC5oYW5kbGVyLCBTX1RGRkYpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdG10LmZpbmFsaXplcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMubWF5YmVCbG9ja1N1ZmZpeChzdG10LmhhbmRsZXIuYm9keSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdG10LmZpbmFsaXplcikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCBbJ2ZpbmFsbHknLCB0aGlzLm1heWJlQmxvY2soc3RtdC5maW5hbGl6ZXIsIFNfVEZGRildKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgU3dpdGNoU3RhdGVtZW50OiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIGZyYWdtZW50LCBpLCBpeiwgYm9keUZsYWdzLCB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtcbiAgICAgICAgICAgICAgICAgICAgJ3N3aXRjaCcgKyBzcGFjZSArICcoJyxcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5kaXNjcmltaW5hbnQsIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSxcbiAgICAgICAgICAgICAgICAgICAgJyknICsgc3BhY2UgKyAneycgKyBuZXdsaW5lXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHN0bXQuY2FzZXMpIHtcbiAgICAgICAgICAgICAgICBib2R5RmxhZ3MgPSBTX1RGRkY7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaXogPSBzdG10LmNhc2VzLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IGl6IC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keUZsYWdzIHw9IEZfU0VNSUNPTE9OX09QVDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudCA9IGFkZEluZGVudCh0aGlzLmdlbmVyYXRlU3RhdGVtZW50KHN0bXQuY2FzZXNbaV0sIGJvZHlGbGFncykpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZW5kc1dpdGhMaW5lVGVybWluYXRvcih0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKGZyYWdtZW50KS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChhZGRJbmRlbnQoJ30nKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIFN3aXRjaENhc2U6IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgZnJhZ21lbnQsIGksIGl6LCBib2R5RmxhZ3MsIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0bXQudGVzdCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBqb2luKCdjYXNlJywgdGhhdC5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC50ZXN0LCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgJzonXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gWydkZWZhdWx0OiddO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgIGl6ID0gc3RtdC5jb25zZXF1ZW50Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoaXogJiYgc3RtdC5jb25zZXF1ZW50WzBdLnR5cGUgPT09IFN5bnRheC5CbG9ja1N0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudCA9IHRoYXQubWF5YmVCbG9jayhzdG10LmNvbnNlcXVlbnRbMF0sIFNfVEZGRik7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGkgIT09IGl6ICYmICFlbmRzV2l0aExpbmVUZXJtaW5hdG9yKHRvU291cmNlTm9kZVdoZW5OZWVkZWQocmVzdWx0KS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBib2R5RmxhZ3MgPSBTX1RGRkY7XG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBpeiAtIDEgJiYgZmxhZ3MgJiBGX1NFTUlDT0xPTl9PUFQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlGbGFncyB8PSBGX1NFTUlDT0xPTl9PUFQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBhZGRJbmRlbnQodGhhdC5nZW5lcmF0ZVN0YXRlbWVudChzdG10LmNvbnNlcXVlbnRbaV0sIGJvZHlGbGFncykpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICsgMSAhPT0gaXogJiYgIWVuZHNXaXRoTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChmcmFnbWVudCkudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld2xpbmUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIElmU3RhdGVtZW50OiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIGJvZHlGbGFncywgc2VtaWNvbG9uT3B0aW9uYWwsIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW1xuICAgICAgICAgICAgICAgICAgICAnaWYnICsgc3BhY2UgKyAnKCcsXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQudGVzdCwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpLFxuICAgICAgICAgICAgICAgICAgICAnKSdcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZW1pY29sb25PcHRpb25hbCA9IGZsYWdzICYgRl9TRU1JQ09MT05fT1BUO1xuICAgICAgICAgICAgYm9keUZsYWdzID0gU19URkZGO1xuICAgICAgICAgICAgaWYgKHNlbWljb2xvbk9wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgYm9keUZsYWdzIHw9IEZfU0VNSUNPTE9OX09QVDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdG10LmFsdGVybmF0ZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMubWF5YmVCbG9jayhzdG10LmNvbnNlcXVlbnQsIFNfVEZGRikpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMubWF5YmVCbG9ja1N1ZmZpeChzdG10LmNvbnNlcXVlbnQsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0bXQuYWx0ZXJuYXRlLnR5cGUgPT09IFN5bnRheC5JZlN0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgWydlbHNlICcsIHRoaXMuZ2VuZXJhdGVTdGF0ZW1lbnQoc3RtdC5hbHRlcm5hdGUsIGJvZHlGbGFncyldKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgam9pbignZWxzZScsIHRoaXMubWF5YmVCbG9jayhzdG10LmFsdGVybmF0ZSwgYm9keUZsYWdzKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5tYXliZUJsb2NrKHN0bXQuY29uc2VxdWVudCwgYm9keUZsYWdzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIEZvclN0YXRlbWVudDogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFsnZm9yJyArIHNwYWNlICsgJygnXTtcbiAgICAgICAgICAgICAgICBpZiAoc3RtdC5pbml0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdG10LmluaXQudHlwZSA9PT0gU3ludGF4LlZhcmlhYmxlRGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoYXQuZ2VuZXJhdGVTdGF0ZW1lbnQoc3RtdC5pbml0LCBTX0ZGRkYpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZfQUxMT1dfSU4gYmVjb21lcyBmYWxzZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoYXQuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQuaW5pdCwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9GVFQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCc7Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnOycpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzdG10LnRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3BhY2UpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGF0LmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LnRlc3QsIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCc7Jyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJzsnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc3RtdC51cGRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3BhY2UpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGF0LmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LnVwZGF0ZSwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJyknKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnKScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLm1heWJlQmxvY2soc3RtdC5ib2R5LCBmbGFncyAmIEZfU0VNSUNPTE9OX09QVCA/IFNfVEZGVCA6IFNfVEZGRikpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBGb3JJblN0YXRlbWVudDogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZUl0ZXJhdGlvbkZvclN0YXRlbWVudCgnaW4nLCBzdG10LCBmbGFncyAmIEZfU0VNSUNPTE9OX09QVCA/IFNfVEZGVCA6IFNfVEZGRik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRm9yT2ZTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVJdGVyYXRpb25Gb3JTdGF0ZW1lbnQoJ29mJywgc3RtdCwgZmxhZ3MgJiBGX1NFTUlDT0xPTl9PUFQgPyBTX1RGRlQgOiBTX1RGRkYpO1xuICAgICAgICB9LFxuXG4gICAgICAgIExhYmVsZWRTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgcmV0dXJuIFtzdG10LmxhYmVsLm5hbWUgKyAnOicsIHRoaXMubWF5YmVCbG9jayhzdG10LmJvZHksIGZsYWdzICYgRl9TRU1JQ09MT05fT1BUID8gU19URkZUIDogU19URkZGKV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgUHJvZ3JhbTogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBmcmFnbWVudCwgaSwgaXosIGJvZHlGbGFncztcbiAgICAgICAgICAgIGl6ID0gc3RtdC5ib2R5Lmxlbmd0aDtcbiAgICAgICAgICAgIHJlc3VsdCA9IFtzYWZlQ29uY2F0ZW5hdGlvbiAmJiBpeiA+IDAgPyAnXFxuJyA6ICcnXTtcbiAgICAgICAgICAgIGJvZHlGbGFncyA9IFNfVEZURjtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzYWZlQ29uY2F0ZW5hdGlvbiAmJiBpID09PSBpeiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keUZsYWdzIHw9IEZfU0VNSUNPTE9OX09QVDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocHJlc2VydmVCbGFua0xpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBzcGFjZXMgYmVmb3JlIHRoZSBmaXJzdCBsaW5lXG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0bXQuYm9keVswXS5sZWFkaW5nQ29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUJsYW5rTGluZXMoc3RtdC5yYW5nZVswXSwgc3RtdC5ib2R5W2ldLnJhbmdlWzBdLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlIHNwYWNlcyBiZXR3ZWVuIGxpbmVzXG4gICAgICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdG10LmJvZHlbaSAtIDFdLnRyYWlsaW5nQ29tbWVudHMgJiYgIXN0bXQuYm9keVtpXS5sZWFkaW5nQ29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUJsYW5rTGluZXMoc3RtdC5ib2R5W2kgLSAxXS5yYW5nZVsxXSwgc3RtdC5ib2R5W2ldLnJhbmdlWzBdLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBhZGRJbmRlbnQodGhpcy5nZW5lcmF0ZVN0YXRlbWVudChzdG10LmJvZHlbaV0sIGJvZHlGbGFncykpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoaSArIDEgPCBpeiAmJiAhZW5kc1dpdGhMaW5lVGVybWluYXRvcih0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKGZyYWdtZW50KS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJlc2VydmVCbGFua0xpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0bXQuYm9keVtpICsgMV0ubGVhZGluZ0NvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwcmVzZXJ2ZUJsYW5rTGluZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlIHNwYWNlcyBhZnRlciB0aGUgbGFzdCBsaW5lXG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBpeiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3RtdC5ib2R5W2ldLnRyYWlsaW5nQ29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUJsYW5rTGluZXMoc3RtdC5ib2R5W2ldLnJhbmdlWzFdLCBzdG10LnJhbmdlWzFdLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBGdW5jdGlvbkRlY2xhcmF0aW9uOiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVBc3luY1ByZWZpeChzdG10LCB0cnVlKSxcbiAgICAgICAgICAgICAgICAnZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgIGdlbmVyYXRlU3RhclN1ZmZpeChzdG10KSB8fCBub0VtcHR5U3BhY2UoKSxcbiAgICAgICAgICAgICAgICBzdG10LmlkID8gZ2VuZXJhdGVJZGVudGlmaWVyKHN0bXQuaWQpIDogJycsXG4gICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUZ1bmN0aW9uQm9keShzdG10KVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSxcblxuICAgICAgICBSZXR1cm5TdGF0ZW1lbnQ6IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgaWYgKHN0bXQuYXJndW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2pvaW4oXG4gICAgICAgICAgICAgICAgICAgICdyZXR1cm4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LmFyZ3VtZW50LCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVClcbiAgICAgICAgICAgICAgICApLCB0aGlzLnNlbWljb2xvbihmbGFncyldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFsncmV0dXJuJyArIHRoaXMuc2VtaWNvbG9uKGZsYWdzKV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgV2hpbGVTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB3aXRoSW5kZW50KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbXG4gICAgICAgICAgICAgICAgICAgICd3aGlsZScgKyBzcGFjZSArICcoJyxcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC50ZXN0LCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCksXG4gICAgICAgICAgICAgICAgICAgICcpJ1xuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMubWF5YmVCbG9jayhzdG10LmJvZHksIGZsYWdzICYgRl9TRU1JQ09MT05fT1BUID8gU19URkZUIDogU19URkZGKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIFdpdGhTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB3aXRoSW5kZW50KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbXG4gICAgICAgICAgICAgICAgICAgICd3aXRoJyArIHNwYWNlICsgJygnLFxuICAgICAgICAgICAgICAgICAgICB0aGF0LmdlbmVyYXRlRXhwcmVzc2lvbihzdG10Lm9iamVjdCwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpLFxuICAgICAgICAgICAgICAgICAgICAnKSdcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLm1heWJlQmxvY2soc3RtdC5ib2R5LCBmbGFncyAmIEZfU0VNSUNPTE9OX09QVCA/IFNfVEZGVCA6IFNfVEZGRikpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIG1lcmdlKENvZGVHZW5lcmF0b3IucHJvdG90eXBlLCBDb2RlR2VuZXJhdG9yLlN0YXRlbWVudCk7XG5cbiAgICAvLyBFeHByZXNzaW9ucy5cblxuICAgIENvZGVHZW5lcmF0b3IuRXhwcmVzc2lvbiA9IHtcblxuICAgICAgICBTZXF1ZW5jZUV4cHJlc3Npb246IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgaSwgaXo7XG4gICAgICAgICAgICBpZiAoUHJlY2VkZW5jZS5TZXF1ZW5jZSA8IHByZWNlZGVuY2UpIHtcbiAgICAgICAgICAgICAgICBmbGFncyB8PSBGX0FMTE9XX0lOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IGV4cHIuZXhwcmVzc2lvbnMubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuZXhwcmVzc2lvbnNbaV0sIFByZWNlZGVuY2UuQXNzaWdubWVudCwgZmxhZ3MpKTtcbiAgICAgICAgICAgICAgICBpZiAoaSArIDEgPCBpeikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcgKyBzcGFjZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudGhlc2l6ZShyZXN1bHQsIFByZWNlZGVuY2UuU2VxdWVuY2UsIHByZWNlZGVuY2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIEFzc2lnbm1lbnRFeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlQXNzaWdubWVudChleHByLmxlZnQsIGV4cHIucmlnaHQsIGV4cHIub3BlcmF0b3IsIHByZWNlZGVuY2UsIGZsYWdzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50aGVzaXplKHRoaXMuZ2VuZXJhdGVGdW5jdGlvbkJvZHkoZXhwciksIFByZWNlZGVuY2UuQXJyb3dGdW5jdGlvbiwgcHJlY2VkZW5jZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQ29uZGl0aW9uYWxFeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIGlmIChQcmVjZWRlbmNlLkNvbmRpdGlvbmFsIDwgcHJlY2VkZW5jZSkge1xuICAgICAgICAgICAgICAgIGZsYWdzIHw9IEZfQUxMT1dfSU47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50aGVzaXplKFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci50ZXN0LCBQcmVjZWRlbmNlLkxvZ2ljYWxPUiwgZmxhZ3MpLFxuICAgICAgICAgICAgICAgICAgICBzcGFjZSArICc/JyArIHNwYWNlLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLmNvbnNlcXVlbnQsIFByZWNlZGVuY2UuQXNzaWdubWVudCwgZmxhZ3MpLFxuICAgICAgICAgICAgICAgICAgICBzcGFjZSArICc6JyArIHNwYWNlLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLmFsdGVybmF0ZSwgUHJlY2VkZW5jZS5Bc3NpZ25tZW50LCBmbGFncylcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFByZWNlZGVuY2UuQ29uZGl0aW9uYWwsXG4gICAgICAgICAgICAgICAgcHJlY2VkZW5jZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICBMb2dpY2FsRXhwcmVzc2lvbjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5CaW5hcnlFeHByZXNzaW9uKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBCaW5hcnlFeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIGxlZnRQcmVjZWRlbmNlLCByaWdodFByZWNlZGVuY2UsIGN1cnJlbnRQcmVjZWRlbmNlLCBmcmFnbWVudCwgbGVmdFNvdXJjZTtcbiAgICAgICAgICAgIGN1cnJlbnRQcmVjZWRlbmNlID0gQmluYXJ5UHJlY2VkZW5jZVtleHByLm9wZXJhdG9yXTtcbiAgICAgICAgICAgIGxlZnRQcmVjZWRlbmNlID0gZXhwci5vcGVyYXRvciA9PT0gJyoqJyA/IFByZWNlZGVuY2UuUG9zdGZpeCA6IGN1cnJlbnRQcmVjZWRlbmNlO1xuICAgICAgICAgICAgcmlnaHRQcmVjZWRlbmNlID0gZXhwci5vcGVyYXRvciA9PT0gJyoqJyA/IGN1cnJlbnRQcmVjZWRlbmNlIDogY3VycmVudFByZWNlZGVuY2UgKyAxO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudFByZWNlZGVuY2UgPCBwcmVjZWRlbmNlKSB7XG4gICAgICAgICAgICAgICAgZmxhZ3MgfD0gRl9BTExPV19JTjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLmxlZnQsIGxlZnRQcmVjZWRlbmNlLCBmbGFncyk7XG5cbiAgICAgICAgICAgIGxlZnRTb3VyY2UgPSBmcmFnbWVudC50b1N0cmluZygpO1xuXG4gICAgICAgICAgICBpZiAobGVmdFNvdXJjZS5jaGFyQ29kZUF0KGxlZnRTb3VyY2UubGVuZ3RoIC0gMSkgPT09IDB4MkYgLyogLyAqLyAmJiBlc3V0aWxzLmNvZGUuaXNJZGVudGlmaWVyUGFydEVTNShleHByLm9wZXJhdG9yLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW2ZyYWdtZW50LCBub0VtcHR5U3BhY2UoKSwgZXhwci5vcGVyYXRvcl07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4oZnJhZ21lbnQsIGV4cHIub3BlcmF0b3IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmcmFnbWVudCA9IHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIucmlnaHQsIHJpZ2h0UHJlY2VkZW5jZSwgZmxhZ3MpO1xuXG4gICAgICAgICAgICBpZiAoZXhwci5vcGVyYXRvciA9PT0gJy8nICYmIGZyYWdtZW50LnRvU3RyaW5nKCkuY2hhckF0KDApID09PSAnLycgfHxcbiAgICAgICAgICAgIGV4cHIub3BlcmF0b3Iuc2xpY2UoLTEpID09PSAnPCcgJiYgZnJhZ21lbnQudG9TdHJpbmcoKS5zbGljZSgwLCAzKSA9PT0gJyEtLScpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiAnLycgY29uY2F0cyB3aXRoICcvJyBvciBgPGAgY29uY2F0cyB3aXRoIGAhLS1gLCBpdCBpcyBpbnRlcnByZXRlZCBhcyBjb21tZW50IHN0YXJ0XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobm9FbXB0eVNwYWNlKCkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZyYWdtZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGV4cHIub3BlcmF0b3IgPT09ICdpbicgJiYgIShmbGFncyAmIEZfQUxMT1dfSU4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnKCcsIHJlc3VsdCwgJyknXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRoZXNpemUocmVzdWx0LCBjdXJyZW50UHJlY2VkZW5jZSwgcHJlY2VkZW5jZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQ2FsbEV4cHJlc3Npb246IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgaSwgaXo7XG4gICAgICAgICAgICAvLyBGX0FMTE9XX1VOUEFSQVRIX05FVyBiZWNvbWVzIGZhbHNlLlxuICAgICAgICAgICAgcmVzdWx0ID0gW3RoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuY2FsbGVlLCBQcmVjZWRlbmNlLkNhbGwsIEVfVFRGKV07XG4gICAgICAgICAgICByZXN1bHQucHVzaCgnKCcpO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgaXogPSBleHByWydhcmd1bWVudHMnXS5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwclsnYXJndW1lbnRzJ11baV0sIFByZWNlZGVuY2UuQXNzaWdubWVudCwgRV9UVFQpKTtcbiAgICAgICAgICAgICAgICBpZiAoaSArIDEgPCBpeikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcgKyBzcGFjZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goJyknKTtcblxuICAgICAgICAgICAgaWYgKCEoZmxhZ3MgJiBGX0FMTE9XX0NBTEwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnKCcsIHJlc3VsdCwgJyknXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRoZXNpemUocmVzdWx0LCBQcmVjZWRlbmNlLkNhbGwsIHByZWNlZGVuY2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIE5ld0V4cHJlc3Npb246IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgbGVuZ3RoLCBpLCBpeiwgaXRlbUZsYWdzO1xuICAgICAgICAgICAgbGVuZ3RoID0gZXhwclsnYXJndW1lbnRzJ10ubGVuZ3RoO1xuXG4gICAgICAgICAgICAvLyBGX0FMTE9XX0NBTEwgYmVjb21lcyBmYWxzZS5cbiAgICAgICAgICAgIC8vIEZfQUxMT1dfVU5QQVJBVEhfTkVXIG1heSBiZWNvbWUgZmFsc2UuXG4gICAgICAgICAgICBpdGVtRmxhZ3MgPSAoZmxhZ3MgJiBGX0FMTE9XX1VOUEFSQVRIX05FVyAmJiAhcGFyZW50aGVzZXMgJiYgbGVuZ3RoID09PSAwKSA/IEVfVEZUIDogRV9URkY7XG5cbiAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4oXG4gICAgICAgICAgICAgICAgJ25ldycsXG4gICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5jYWxsZWUsIFByZWNlZGVuY2UuTmV3LCBpdGVtRmxhZ3MpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiAoIShmbGFncyAmIEZfQUxMT1dfVU5QQVJBVEhfTkVXKSB8fCBwYXJlbnRoZXNlcyB8fCBsZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJygnKTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IGxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwclsnYXJndW1lbnRzJ11baV0sIFByZWNlZGVuY2UuQXNzaWdubWVudCwgRV9UVFQpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgKyAxIDwgaXopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcsJyArIHNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnKScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcGFyZW50aGVzaXplKHJlc3VsdCwgUHJlY2VkZW5jZS5OZXcsIHByZWNlZGVuY2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIE1lbWJlckV4cHJlc3Npb246IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgZnJhZ21lbnQ7XG5cbiAgICAgICAgICAgIC8vIEZfQUxMT1dfVU5QQVJBVEhfTkVXIGJlY29tZXMgZmFsc2UuXG4gICAgICAgICAgICByZXN1bHQgPSBbdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5vYmplY3QsIFByZWNlZGVuY2UuQ2FsbCwgKGZsYWdzICYgRl9BTExPV19DQUxMKSA/IEVfVFRGIDogRV9URkYpXTtcblxuICAgICAgICAgICAgaWYgKGV4cHIuY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnWycpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIucHJvcGVydHksIFByZWNlZGVuY2UuU2VxdWVuY2UsIGZsYWdzICYgRl9BTExPV19DQUxMID8gRV9UVFQgOiBFX1RGVCkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCddJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChleHByLm9iamVjdC50eXBlID09PSBTeW50YXguTGl0ZXJhbCAmJiB0eXBlb2YgZXhwci5vYmplY3QudmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gdG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChyZXN1bHQpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBhbGwgdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gICAxLiBObyBmbG9hdGluZyBwb2ludFxuICAgICAgICAgICAgICAgICAgICAvLyAgIDIuIERvbid0IGhhdmUgZXhwb25lbnRzXG4gICAgICAgICAgICAgICAgICAgIC8vICAgMy4gVGhlIGxhc3QgY2hhcmFjdGVyIGlzIGEgZGVjaW1hbCBkaWdpdFxuICAgICAgICAgICAgICAgICAgICAvLyAgIDQuIE5vdCBoZXhhZGVjaW1hbCBPUiBvY3RhbCBudW1iZXIgbGl0ZXJhbFxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBzaG91bGQgYWRkIGEgZmxvYXRpbmcgcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFnbWVudC5pbmRleE9mKCcuJykgPCAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIS9bZUV4WF0vLnRlc3QoZnJhZ21lbnQpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXN1dGlscy5jb2RlLmlzRGVjaW1hbERpZ2l0KGZyYWdtZW50LmNoYXJDb2RlQXQoZnJhZ21lbnQubGVuZ3RoIC0gMSkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIShmcmFnbWVudC5sZW5ndGggPj0gMiAmJiBmcmFnbWVudC5jaGFyQ29kZUF0KDApID09PSA0OCkgIC8vICcwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJyAnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLicpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGdlbmVyYXRlSWRlbnRpZmllcihleHByLnByb3BlcnR5KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRoZXNpemUocmVzdWx0LCBQcmVjZWRlbmNlLk1lbWJlciwgcHJlY2VkZW5jZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgTWV0YVByb3BlcnR5OiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHR5cGVvZiBleHByLm1ldGEgPT09IFwic3RyaW5nXCIgPyBleHByLm1ldGEgOiBnZW5lcmF0ZUlkZW50aWZpZXIoZXhwci5tZXRhKSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgnLicpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godHlwZW9mIGV4cHIucHJvcGVydHkgPT09IFwic3RyaW5nXCIgPyBleHByLnByb3BlcnR5IDogZ2VuZXJhdGVJZGVudGlmaWVyKGV4cHIucHJvcGVydHkpKTtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRoZXNpemUocmVzdWx0LCBQcmVjZWRlbmNlLk1lbWJlciwgcHJlY2VkZW5jZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgVW5hcnlFeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIGZyYWdtZW50LCByaWdodENoYXJDb2RlLCBsZWZ0U291cmNlLCBsZWZ0Q2hhckNvZGU7XG4gICAgICAgICAgICBmcmFnbWVudCA9IHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuYXJndW1lbnQsIFByZWNlZGVuY2UuVW5hcnksIEVfVFRUKTtcblxuICAgICAgICAgICAgaWYgKHNwYWNlID09PSAnJykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4oZXhwci5vcGVyYXRvciwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbZXhwci5vcGVyYXRvcl07XG4gICAgICAgICAgICAgICAgaWYgKGV4cHIub3BlcmF0b3IubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBkZWxldGUsIHZvaWQsIHR5cGVvZlxuICAgICAgICAgICAgICAgICAgICAvLyBnZXQgYHR5cGVvZiBbXWAsIG5vdCBgdHlwZW9mW11gXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCBmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCBpbnNlcnRpbmcgc3BhY2VzIGJldHdlZW4gb3BlcmF0b3IgYW5kIGFyZ3VtZW50IGlmIGl0IGlzIHVubmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgICAgIC8vIGxpa2UsIGAhY29uZGBcbiAgICAgICAgICAgICAgICAgICAgbGVmdFNvdXJjZSA9IHRvU291cmNlTm9kZVdoZW5OZWVkZWQocmVzdWx0KS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBsZWZ0Q2hhckNvZGUgPSBsZWZ0U291cmNlLmNoYXJDb2RlQXQobGVmdFNvdXJjZS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRDaGFyQ29kZSA9IGZyYWdtZW50LnRvU3RyaW5nKCkuY2hhckNvZGVBdCgwKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoKChsZWZ0Q2hhckNvZGUgPT09IDB4MkIgIC8qICsgKi8gfHwgbGVmdENoYXJDb2RlID09PSAweDJEICAvKiAtICovKSAmJiBsZWZ0Q2hhckNvZGUgPT09IHJpZ2h0Q2hhckNvZGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGVzdXRpbHMuY29kZS5pc0lkZW50aWZpZXJQYXJ0RVM1KGxlZnRDaGFyQ29kZSkgJiYgZXN1dGlscy5jb2RlLmlzSWRlbnRpZmllclBhcnRFUzUocmlnaHRDaGFyQ29kZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChub0VtcHR5U3BhY2UoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50aGVzaXplKHJlc3VsdCwgUHJlY2VkZW5jZS5VbmFyeSwgcHJlY2VkZW5jZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgWWllbGRFeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICBpZiAoZXhwci5kZWxlZ2F0ZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICd5aWVsZConO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAneWllbGQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4cHIuYXJndW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuYXJndW1lbnQsIFByZWNlZGVuY2UuWWllbGQsIEVfVFRUKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50aGVzaXplKHJlc3VsdCwgUHJlY2VkZW5jZS5ZaWVsZCwgcHJlY2VkZW5jZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQXdhaXRFeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBqb2luKFxuICAgICAgICAgICAgICAgIGV4cHIuYWxsID8gJ2F3YWl0KicgOiAnYXdhaXQnLFxuICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuYXJndW1lbnQsIFByZWNlZGVuY2UuQXdhaXQsIEVfVFRUKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRoZXNpemUocmVzdWx0LCBQcmVjZWRlbmNlLkF3YWl0LCBwcmVjZWRlbmNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBVcGRhdGVFeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIGlmIChleHByLnByZWZpeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnRoZXNpemUoXG4gICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIub3BlcmF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLmFyZ3VtZW50LCBQcmVjZWRlbmNlLlVuYXJ5LCBFX1RUVClcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgUHJlY2VkZW5jZS5VbmFyeSxcbiAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50aGVzaXplKFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5hcmd1bWVudCwgUHJlY2VkZW5jZS5Qb3N0Zml4LCBFX1RUVCksXG4gICAgICAgICAgICAgICAgICAgIGV4cHIub3BlcmF0b3JcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFByZWNlZGVuY2UuUG9zdGZpeCxcbiAgICAgICAgICAgICAgICBwcmVjZWRlbmNlXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIEZ1bmN0aW9uRXhwcmVzc2lvbjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW1xuICAgICAgICAgICAgICAgIGdlbmVyYXRlQXN5bmNQcmVmaXgoZXhwciwgdHJ1ZSksXG4gICAgICAgICAgICAgICAgJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGlmIChleHByLmlkKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZ2VuZXJhdGVTdGFyU3VmZml4KGV4cHIpIHx8IG5vRW1wdHlTcGFjZSgpKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChnZW5lcmF0ZUlkZW50aWZpZXIoZXhwci5pZCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChnZW5lcmF0ZVN0YXJTdWZmaXgoZXhwcikgfHwgc3BhY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5nZW5lcmF0ZUZ1bmN0aW9uQm9keShleHByKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIEFycmF5UGF0dGVybjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5BcnJheUV4cHJlc3Npb24oZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MsIHRydWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIEFycmF5RXhwcmVzc2lvbjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzLCBpc1BhdHRlcm4pIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIG11bHRpbGluZSwgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoIWV4cHIuZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdbXSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtdWx0aWxpbmUgPSBpc1BhdHRlcm4gPyBmYWxzZSA6IGV4cHIuZWxlbWVudHMubGVuZ3RoID4gMTtcbiAgICAgICAgICAgIHJlc3VsdCA9IFsnWycsIG11bHRpbGluZSA/IG5ld2xpbmUgOiAnJ107XG4gICAgICAgICAgICB3aXRoSW5kZW50KGZ1bmN0aW9uIChpbmRlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSwgaXo7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaXogPSBleHByLmVsZW1lbnRzLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFleHByLmVsZW1lbnRzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobXVsdGlsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaW5kZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpICsgMSA9PT0gaXopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobXVsdGlsaW5lID8gaW5kZW50IDogJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhhdC5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5lbGVtZW50c1tpXSwgUHJlY2VkZW5jZS5Bc3NpZ25tZW50LCBFX1RUVCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICsgMSA8IGl6KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcgKyAobXVsdGlsaW5lID8gbmV3bGluZSA6IHNwYWNlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChtdWx0aWxpbmUgJiYgIWVuZHNXaXRoTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChyZXN1bHQpLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChtdWx0aWxpbmUgPyBiYXNlIDogJycpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goJ10nKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgUmVzdEVsZW1lbnQ6IGZ1bmN0aW9uKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gJy4uLicgKyB0aGlzLmdlbmVyYXRlUGF0dGVybihleHByLmFyZ3VtZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICBDbGFzc0V4cHJlc3Npb246IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgZnJhZ21lbnQ7XG4gICAgICAgICAgICByZXN1bHQgPSBbJ2NsYXNzJ107XG4gICAgICAgICAgICBpZiAoZXhwci5pZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLmlkLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4cHIuc3VwZXJDbGFzcykge1xuICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gam9pbignZXh0ZW5kcycsIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuc3VwZXJDbGFzcywgUHJlY2VkZW5jZS5VbmFyeSwgRV9UVFQpKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goc3BhY2UpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5nZW5lcmF0ZVN0YXRlbWVudChleHByLmJvZHksIFNfVEZGVCkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBNZXRob2REZWZpbml0aW9uOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIGZyYWdtZW50O1xuICAgICAgICAgICAgaWYgKGV4cHJbJ3N0YXRpYyddKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gWydzdGF0aWMnICsgc3BhY2VdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHByLmtpbmQgPT09ICdnZXQnIHx8IGV4cHIua2luZCA9PT0gJ3NldCcpIHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudCA9IFtcbiAgICAgICAgICAgICAgICAgICAgam9pbihleHByLmtpbmQsIHRoaXMuZ2VuZXJhdGVQcm9wZXJ0eUtleShleHByLmtleSwgZXhwci5jb21wdXRlZCkpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRnVuY3Rpb25Cb2R5KGV4cHIudmFsdWUpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBbXG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlTWV0aG9kUHJlZml4KGV4cHIpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlUHJvcGVydHlLZXkoZXhwci5rZXksIGV4cHIuY29tcHV0ZWQpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRnVuY3Rpb25Cb2R5KGV4cHIudmFsdWUpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBqb2luKHJlc3VsdCwgZnJhZ21lbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIFByb3BlcnR5OiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIGlmIChleHByLmtpbmQgPT09ICdnZXQnIHx8IGV4cHIua2luZCA9PT0gJ3NldCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBleHByLmtpbmQsIG5vRW1wdHlTcGFjZSgpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlUHJvcGVydHlLZXkoZXhwci5rZXksIGV4cHIuY29tcHV0ZWQpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRnVuY3Rpb25Cb2R5KGV4cHIudmFsdWUpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGV4cHIuc2hvcnRoYW5kKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4cHIudmFsdWUudHlwZSA9PT0gXCJBc3NpZ25tZW50UGF0dGVyblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLkFzc2lnbm1lbnRQYXR0ZXJuKGV4cHIudmFsdWUsIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVQcm9wZXJ0eUtleShleHByLmtleSwgZXhwci5jb21wdXRlZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChleHByLm1ldGhvZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlTWV0aG9kUHJlZml4KGV4cHIpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlUHJvcGVydHlLZXkoZXhwci5rZXksIGV4cHIuY29tcHV0ZWQpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRnVuY3Rpb25Cb2R5KGV4cHIudmFsdWUpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlUHJvcGVydHlLZXkoZXhwci5rZXksIGV4cHIuY29tcHV0ZWQpLFxuICAgICAgICAgICAgICAgICc6JyArIHNwYWNlLFxuICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIudmFsdWUsIFByZWNlZGVuY2UuQXNzaWdubWVudCwgRV9UVFQpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9LFxuXG4gICAgICAgIE9iamVjdEV4cHJlc3Npb246IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIG11bHRpbGluZSwgcmVzdWx0LCBmcmFnbWVudCwgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIGlmICghZXhwci5wcm9wZXJ0aWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAne30nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbXVsdGlsaW5lID0gZXhwci5wcm9wZXJ0aWVzLmxlbmd0aCA+IDE7XG5cbiAgICAgICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gdGhhdC5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5wcm9wZXJ0aWVzWzBdLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFtdWx0aWxpbmUpIHtcbiAgICAgICAgICAgICAgICAvLyBpc3N1ZXMgNFxuICAgICAgICAgICAgICAgIC8vIERvIG5vdCB0cmFuc2Zvcm0gZnJvbVxuICAgICAgICAgICAgICAgIC8vICAgZGVqYXZ1LkNsYXNzLmRlY2xhcmUoe1xuICAgICAgICAgICAgICAgIC8vICAgICAgIG1ldGhvZDI6IGZ1bmN0aW9uICgpIHt9XG4gICAgICAgICAgICAgICAgLy8gICB9KTtcbiAgICAgICAgICAgICAgICAvLyB0b1xuICAgICAgICAgICAgICAgIC8vICAgZGVqYXZ1LkNsYXNzLmRlY2xhcmUoe21ldGhvZDI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICB9fSk7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNMaW5lVGVybWluYXRvcih0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKGZyYWdtZW50KS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyAneycsIHNwYWNlLCBmcmFnbWVudCwgc3BhY2UsICd9JyBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoaW5kZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGksIGl6O1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFsgJ3snLCBuZXdsaW5lLCBpbmRlbnQsIGZyYWdtZW50IF07XG5cbiAgICAgICAgICAgICAgICBpZiAobXVsdGlsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcsJyArIG5ld2xpbmUpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAxLCBpeiA9IGV4cHIucHJvcGVydGllcy5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpbmRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhhdC5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5wcm9wZXJ0aWVzW2ldLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgKyAxIDwgaXopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcgKyBuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIWVuZHNXaXRoTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChyZXN1bHQpLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChiYXNlKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCd9Jyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIEFzc2lnbm1lbnRQYXR0ZXJuOiBmdW5jdGlvbihleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVBc3NpZ25tZW50KGV4cHIubGVmdCwgZXhwci5yaWdodCwgJz0nLCBwcmVjZWRlbmNlLCBmbGFncyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgT2JqZWN0UGF0dGVybjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBpLCBpeiwgbXVsdGlsaW5lLCBwcm9wZXJ0eSwgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoIWV4cHIucHJvcGVydGllcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3t9JztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbXVsdGlsaW5lID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZXhwci5wcm9wZXJ0aWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHByb3BlcnR5ID0gZXhwci5wcm9wZXJ0aWVzWzBdO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eS52YWx1ZS50eXBlICE9PSBTeW50YXguSWRlbnRpZmllcikge1xuICAgICAgICAgICAgICAgICAgICBtdWx0aWxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaXogPSBleHByLnByb3BlcnRpZXMubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9IGV4cHIucHJvcGVydGllc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9wZXJ0eS5zaG9ydGhhbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpbGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCA9IFsneycsIG11bHRpbGluZSA/IG5ld2xpbmUgOiAnJyBdO1xuXG4gICAgICAgICAgICB3aXRoSW5kZW50KGZ1bmN0aW9uIChpbmRlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSwgaXo7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaXogPSBleHByLnByb3BlcnRpZXMubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChtdWx0aWxpbmUgPyBpbmRlbnQgOiAnJyk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoYXQuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIucHJvcGVydGllc1tpXSwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgKyAxIDwgaXopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcsJyArIChtdWx0aWxpbmUgPyBuZXdsaW5lIDogc3BhY2UpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAobXVsdGlsaW5lICYmICFlbmRzV2l0aExpbmVUZXJtaW5hdG9yKHRvU291cmNlTm9kZVdoZW5OZWVkZWQocmVzdWx0KS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld2xpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobXVsdGlsaW5lID8gYmFzZSA6ICcnKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCd9Jyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIFRoaXNFeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiAndGhpcyc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgU3VwZXI6IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgcmV0dXJuICdzdXBlcic7XG4gICAgICAgIH0sXG5cbiAgICAgICAgSWRlbnRpZmllcjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVJZGVudGlmaWVyKGV4cHIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIEltcG9ydERlZmF1bHRTcGVjaWZpZXI6IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlSWRlbnRpZmllcihleHByLmlkIHx8IGV4cHIubG9jYWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIEltcG9ydE5hbWVzcGFjZVNwZWNpZmllcjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gWycqJ107XG4gICAgICAgICAgICB2YXIgaWQgPSBleHByLmlkIHx8IGV4cHIubG9jYWw7XG4gICAgICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzcGFjZSArICdhcycgKyBub0VtcHR5U3BhY2UoKSArIGdlbmVyYXRlSWRlbnRpZmllcihpZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBJbXBvcnRTcGVjaWZpZXI6IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIGltcG9ydGVkID0gZXhwci5pbXBvcnRlZDtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbIGltcG9ydGVkLm5hbWUgXTtcbiAgICAgICAgICAgIHZhciBsb2NhbCA9IGV4cHIubG9jYWw7XG4gICAgICAgICAgICBpZiAobG9jYWwgJiYgbG9jYWwubmFtZSAhPT0gaW1wb3J0ZWQubmFtZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5vRW1wdHlTcGFjZSgpICsgJ2FzJyArIG5vRW1wdHlTcGFjZSgpICsgZ2VuZXJhdGVJZGVudGlmaWVyKGxvY2FsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIEV4cG9ydFNwZWNpZmllcjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgbG9jYWwgPSBleHByLmxvY2FsO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFsgbG9jYWwubmFtZSBdO1xuICAgICAgICAgICAgdmFyIGV4cG9ydGVkID0gZXhwci5leHBvcnRlZDtcbiAgICAgICAgICAgIGlmIChleHBvcnRlZCAmJiBleHBvcnRlZC5uYW1lICE9PSBsb2NhbC5uYW1lKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobm9FbXB0eVNwYWNlKCkgKyAnYXMnICsgbm9FbXB0eVNwYWNlKCkgKyBnZW5lcmF0ZUlkZW50aWZpZXIoZXhwb3J0ZWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgTGl0ZXJhbDogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmF3O1xuICAgICAgICAgICAgaWYgKGV4cHIuaGFzT3duUHJvcGVydHkoJ3JhdycpICYmIHBhcnNlICYmIGV4dHJhLnJhdykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJhdyA9IHBhcnNlKGV4cHIucmF3KS5ib2R5WzBdLmV4cHJlc3Npb247XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYXcudHlwZSA9PT0gU3ludGF4LkxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyYXcudmFsdWUgPT09IGV4cHIudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhwci5yYXc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdCB1c2UgcmF3IHByb3BlcnR5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXhwci5yZWdleCkge1xuICAgICAgICAgICAgICByZXR1cm4gJy8nICsgZXhwci5yZWdleC5wYXR0ZXJuICsgJy8nICsgZXhwci5yZWdleC5mbGFncztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGV4cHIudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4cHIudmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVzY2FwZVN0cmluZyhleHByLnZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHByLnZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZU51bWJlcihleHByLnZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHByLnZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwci52YWx1ZSA/ICd0cnVlJyA6ICdmYWxzZSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZVJlZ0V4cChleHByLnZhbHVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBHZW5lcmF0b3JFeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNvbXByZWhlbnNpb25FeHByZXNzaW9uKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBDb21wcmVoZW5zaW9uRXhwcmVzc2lvbjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICAvLyBHZW5lcmF0b3JFeHByZXNzaW9uIHNob3VsZCBiZSBwYXJlbnRoZXNpemVkIHdpdGggKC4uLiksIENvbXByZWhlbnNpb25FeHByZXNzaW9uIHdpdGggWy4uLl1cbiAgICAgICAgICAgIC8vIER1ZSB0byBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD04ODM0NjggcG9zaXRpb24gb2YgZXhwci5ib2R5IGNhbiBkaWZmZXIgaW4gU3BpZGVybW9ua2V5IGFuZCBFUzZcblxuICAgICAgICAgICAgdmFyIHJlc3VsdCwgaSwgaXosIGZyYWdtZW50LCB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHJlc3VsdCA9IChleHByLnR5cGUgPT09IFN5bnRheC5HZW5lcmF0b3JFeHByZXNzaW9uKSA/IFsnKCddIDogWydbJ107XG5cbiAgICAgICAgICAgIGlmIChleHRyYS5tb3ouY29tcHJlaGVuc2lvbkV4cHJlc3Npb25TdGFydHNXaXRoQXNzaWdubWVudCkge1xuICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5ib2R5LCBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsIEVfVFRUKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmcmFnbWVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChleHByLmJsb2Nrcykge1xuICAgICAgICAgICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IGV4cHIuYmxvY2tzLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gdGhhdC5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5ibG9ja3NbaV0sIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID4gMCB8fCBleHRyYS5tb3ouY29tcHJlaGVuc2lvbkV4cHJlc3Npb25TdGFydHNXaXRoQXNzaWdubWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCBmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXhwci5maWx0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgJ2lmJyArIHNwYWNlKTtcbiAgICAgICAgICAgICAgICBmcmFnbWVudCA9IHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuZmlsdGVyLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIFsgJygnLCBmcmFnbWVudCwgJyknIF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWV4dHJhLm1vei5jb21wcmVoZW5zaW9uRXhwcmVzc2lvblN0YXJ0c1dpdGhBc3NpZ25tZW50KSB7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLmJvZHksIFByZWNlZGVuY2UuQXNzaWdubWVudCwgRV9UVFQpO1xuXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0LnB1c2goKGV4cHIudHlwZSA9PT0gU3ludGF4LkdlbmVyYXRvckV4cHJlc3Npb24pID8gJyknIDogJ10nKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQ29tcHJlaGVuc2lvbkJsb2NrOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciBmcmFnbWVudDtcbiAgICAgICAgICAgIGlmIChleHByLmxlZnQudHlwZSA9PT0gU3ludGF4LlZhcmlhYmxlRGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudCA9IFtcbiAgICAgICAgICAgICAgICAgICAgZXhwci5sZWZ0LmtpbmQsIG5vRW1wdHlTcGFjZSgpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlU3RhdGVtZW50KGV4cHIubGVmdC5kZWNsYXJhdGlvbnNbMF0sIFNfRkZGRilcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudCA9IHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIubGVmdCwgUHJlY2VkZW5jZS5DYWxsLCBFX1RUVCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZyYWdtZW50ID0gam9pbihmcmFnbWVudCwgZXhwci5vZiA/ICdvZicgOiAnaW4nKTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gam9pbihmcmFnbWVudCwgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5yaWdodCwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpKTtcblxuICAgICAgICAgICAgcmV0dXJuIFsgJ2ZvcicgKyBzcGFjZSArICcoJywgZnJhZ21lbnQsICcpJyBdO1xuICAgICAgICB9LFxuXG4gICAgICAgIFNwcmVhZEVsZW1lbnQ6IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAnLi4uJyxcbiAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLmFyZ3VtZW50LCBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsIEVfVFRUKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSxcblxuICAgICAgICBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb246IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIGl0ZW1GbGFncyA9IEVfVFRGO1xuICAgICAgICAgICAgaWYgKCEoZmxhZ3MgJiBGX0FMTE9XX0NBTEwpKSB7XG4gICAgICAgICAgICAgICAgaXRlbUZsYWdzID0gRV9URkY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW1xuICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIudGFnLCBQcmVjZWRlbmNlLkNhbGwsIGl0ZW1GbGFncyksXG4gICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5xdWFzaSwgUHJlY2VkZW5jZS5QcmltYXJ5LCBFX0ZGVClcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50aGVzaXplKHJlc3VsdCwgUHJlY2VkZW5jZS5UYWdnZWRUZW1wbGF0ZSwgcHJlY2VkZW5jZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgVGVtcGxhdGVFbGVtZW50OiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIC8vIERvbid0IHVzZSBcImNvb2tlZFwiLiBTaW5jZSB0YWdnZWQgdGVtcGxhdGUgY2FuIHVzZSByYXcgdGVtcGxhdGVcbiAgICAgICAgICAgIC8vIHJlcHJlc2VudGF0aW9uLiBTbyBpZiB3ZSBkbyBzbywgaXQgYnJlYWtzIHRoZSBzY3JpcHQgc2VtYW50aWNzLlxuICAgICAgICAgICAgcmV0dXJuIGV4cHIudmFsdWUucmF3O1xuICAgICAgICB9LFxuXG4gICAgICAgIFRlbXBsYXRlTGl0ZXJhbDogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBpLCBpejtcbiAgICAgICAgICAgIHJlc3VsdCA9IFsgJ2AnIF07XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IGV4cHIucXVhc2lzLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLnF1YXNpc1tpXSwgUHJlY2VkZW5jZS5QcmltYXJ5LCBFX1RUVCkpO1xuICAgICAgICAgICAgICAgIGlmIChpICsgMSA8IGl6KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCckeycgKyBzcGFjZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuZXhwcmVzc2lvbnNbaV0sIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNwYWNlICsgJ30nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaCgnYCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBNb2R1bGVTcGVjaWZpZXI6IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuTGl0ZXJhbChleHByLCBwcmVjZWRlbmNlLCBmbGFncyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgSW1wb3J0RXhwcmVzc2lvbjogZnVuY3Rpb24oZXhwciwgcHJlY2VkZW5jZSwgZmxhZykge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudGhlc2l6ZShbXG4gICAgICAgICAgICAgICAgJ2ltcG9ydCgnLFxuICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuc291cmNlLCBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsIEVfVFRUKSxcbiAgICAgICAgICAgICAgICAnKSdcbiAgICAgICAgICAgIF0sIFByZWNlZGVuY2UuQ2FsbCwgcHJlY2VkZW5jZSk7XG4gICAgICAgIH0sXG5cbiAgICB9O1xuXG4gICAgbWVyZ2UoQ29kZUdlbmVyYXRvci5wcm90b3R5cGUsIENvZGVHZW5lcmF0b3IuRXhwcmVzc2lvbik7XG5cbiAgICBDb2RlR2VuZXJhdG9yLnByb3RvdHlwZS5nZW5lcmF0ZUV4cHJlc3Npb24gPSBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgdmFyIHJlc3VsdCwgdHlwZTtcblxuICAgICAgICB0eXBlID0gZXhwci50eXBlIHx8IFN5bnRheC5Qcm9wZXJ0eTtcblxuICAgICAgICBpZiAoZXh0cmEudmVyYmF0aW0gJiYgZXhwci5oYXNPd25Qcm9wZXJ0eShleHRyYS52ZXJiYXRpbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZVZlcmJhdGltKGV4cHIsIHByZWNlZGVuY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gdGhpc1t0eXBlXShleHByLCBwcmVjZWRlbmNlLCBmbGFncyk7XG5cblxuICAgICAgICBpZiAoZXh0cmEuY29tbWVudCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gYWRkQ29tbWVudHMoZXhwciwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChyZXN1bHQsIGV4cHIpO1xuICAgIH07XG5cbiAgICBDb2RlR2VuZXJhdG9yLnByb3RvdHlwZS5nZW5lcmF0ZVN0YXRlbWVudCA9IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgICAgZnJhZ21lbnQ7XG5cbiAgICAgICAgcmVzdWx0ID0gdGhpc1tzdG10LnR5cGVdKHN0bXQsIGZsYWdzKTtcblxuICAgICAgICAvLyBBdHRhY2ggY29tbWVudHNcblxuICAgICAgICBpZiAoZXh0cmEuY29tbWVudCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gYWRkQ29tbWVudHMoc3RtdCwgcmVzdWx0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZyYWdtZW50ID0gdG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChyZXN1bHQpLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChzdG10LnR5cGUgPT09IFN5bnRheC5Qcm9ncmFtICYmICFzYWZlQ29uY2F0ZW5hdGlvbiAmJiBuZXdsaW5lID09PSAnJyAmJiAgZnJhZ21lbnQuY2hhckF0KGZyYWdtZW50Lmxlbmd0aCAtIDEpID09PSAnXFxuJykge1xuICAgICAgICAgICAgcmVzdWx0ID0gc291cmNlTWFwID8gdG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChyZXN1bHQpLnJlcGxhY2VSaWdodCgvXFxzKyQvLCAnJykgOiBmcmFnbWVudC5yZXBsYWNlKC9cXHMrJC8sICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKHJlc3VsdCwgc3RtdCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlSW50ZXJuYWwobm9kZSkge1xuICAgICAgICB2YXIgY29kZWdlbjtcblxuICAgICAgICBjb2RlZ2VuID0gbmV3IENvZGVHZW5lcmF0b3IoKTtcbiAgICAgICAgaWYgKGlzU3RhdGVtZW50KG5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29kZWdlbi5nZW5lcmF0ZVN0YXRlbWVudChub2RlLCBTX1RGRkYpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRXhwcmVzc2lvbihub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvZGVnZW4uZ2VuZXJhdGVFeHByZXNzaW9uKG5vZGUsIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBub2RlIHR5cGU6ICcgKyBub2RlLnR5cGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlKG5vZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRPcHRpb25zID0gZ2V0RGVmYXVsdE9wdGlvbnMoKSwgcmVzdWx0LCBwYWlyO1xuXG4gICAgICAgIGlmIChvcHRpb25zICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIE9ic29sZXRlIG9wdGlvbnNcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAgIGBvcHRpb25zLmluZGVudGBcbiAgICAgICAgICAgIC8vICAgYG9wdGlvbnMuYmFzZWBcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBJbnN0ZWFkIG9mIHRoZW0sIHdlIGNhbiB1c2UgYG9wdGlvbi5mb3JtYXQuaW5kZW50YC5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5pbmRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdE9wdGlvbnMuZm9ybWF0LmluZGVudC5zdHlsZSA9IG9wdGlvbnMuaW5kZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmJhc2UgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdE9wdGlvbnMuZm9ybWF0LmluZGVudC5iYXNlID0gb3B0aW9ucy5iYXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW9ucyA9IHVwZGF0ZURlZXBseShkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgICAgICBpbmRlbnQgPSBvcHRpb25zLmZvcm1hdC5pbmRlbnQuc3R5bGU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuYmFzZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBiYXNlID0gb3B0aW9ucy5iYXNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBiYXNlID0gc3RyaW5nUmVwZWF0KGluZGVudCwgb3B0aW9ucy5mb3JtYXQuaW5kZW50LmJhc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xuICAgICAgICAgICAgaW5kZW50ID0gb3B0aW9ucy5mb3JtYXQuaW5kZW50LnN0eWxlO1xuICAgICAgICAgICAgYmFzZSA9IHN0cmluZ1JlcGVhdChpbmRlbnQsIG9wdGlvbnMuZm9ybWF0LmluZGVudC5iYXNlKTtcbiAgICAgICAgfVxuICAgICAgICBqc29uID0gb3B0aW9ucy5mb3JtYXQuanNvbjtcbiAgICAgICAgcmVudW1iZXIgPSBvcHRpb25zLmZvcm1hdC5yZW51bWJlcjtcbiAgICAgICAgaGV4YWRlY2ltYWwgPSBqc29uID8gZmFsc2UgOiBvcHRpb25zLmZvcm1hdC5oZXhhZGVjaW1hbDtcbiAgICAgICAgcXVvdGVzID0ganNvbiA/ICdkb3VibGUnIDogb3B0aW9ucy5mb3JtYXQucXVvdGVzO1xuICAgICAgICBlc2NhcGVsZXNzID0gb3B0aW9ucy5mb3JtYXQuZXNjYXBlbGVzcztcbiAgICAgICAgbmV3bGluZSA9IG9wdGlvbnMuZm9ybWF0Lm5ld2xpbmU7XG4gICAgICAgIHNwYWNlID0gb3B0aW9ucy5mb3JtYXQuc3BhY2U7XG4gICAgICAgIGlmIChvcHRpb25zLmZvcm1hdC5jb21wYWN0KSB7XG4gICAgICAgICAgICBuZXdsaW5lID0gc3BhY2UgPSBpbmRlbnQgPSBiYXNlID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50aGVzZXMgPSBvcHRpb25zLmZvcm1hdC5wYXJlbnRoZXNlcztcbiAgICAgICAgc2VtaWNvbG9ucyA9IG9wdGlvbnMuZm9ybWF0LnNlbWljb2xvbnM7XG4gICAgICAgIHNhZmVDb25jYXRlbmF0aW9uID0gb3B0aW9ucy5mb3JtYXQuc2FmZUNvbmNhdGVuYXRpb247XG4gICAgICAgIGRpcmVjdGl2ZSA9IG9wdGlvbnMuZGlyZWN0aXZlO1xuICAgICAgICBwYXJzZSA9IGpzb24gPyBudWxsIDogb3B0aW9ucy5wYXJzZTtcbiAgICAgICAgc291cmNlTWFwID0gb3B0aW9ucy5zb3VyY2VNYXA7XG4gICAgICAgIHNvdXJjZUNvZGUgPSBvcHRpb25zLnNvdXJjZUNvZGU7XG4gICAgICAgIHByZXNlcnZlQmxhbmtMaW5lcyA9IG9wdGlvbnMuZm9ybWF0LnByZXNlcnZlQmxhbmtMaW5lcyAmJiBzb3VyY2VDb2RlICE9PSBudWxsO1xuICAgICAgICBleHRyYSA9IG9wdGlvbnM7XG5cbiAgICAgICAgaWYgKHNvdXJjZU1hcCkge1xuICAgICAgICAgICAgaWYgKCFleHBvcnRzLmJyb3dzZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBhc3N1bWUgZW52aXJvbm1lbnQgaXMgbm9kZS5qc1xuICAgICAgICAgICAgICAgIC8vIEFuZCBwcmV2ZW50IGZyb20gaW5jbHVkaW5nIHNvdXJjZS1tYXAgYnkgYnJvd3NlcmlmeVxuICAgICAgICAgICAgICAgIFNvdXJjZU5vZGUgPSByZXF1aXJlKCdzb3VyY2UtbWFwJykuU291cmNlTm9kZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgU291cmNlTm9kZSA9IGdsb2JhbC5zb3VyY2VNYXAuU291cmNlTm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IGdlbmVyYXRlSW50ZXJuYWwobm9kZSk7XG5cbiAgICAgICAgaWYgKCFzb3VyY2VNYXApIHtcbiAgICAgICAgICAgIHBhaXIgPSB7Y29kZTogcmVzdWx0LnRvU3RyaW5nKCksIG1hcDogbnVsbH07XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5zb3VyY2VNYXBXaXRoQ29kZSA/IHBhaXIgOiBwYWlyLmNvZGU7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHBhaXIgPSByZXN1bHQudG9TdHJpbmdXaXRoU291cmNlTWFwKHtcbiAgICAgICAgICAgIGZpbGU6IG9wdGlvbnMuZmlsZSxcbiAgICAgICAgICAgIHNvdXJjZVJvb3Q6IG9wdGlvbnMuc291cmNlTWFwUm9vdFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAob3B0aW9ucy5zb3VyY2VDb250ZW50KSB7XG4gICAgICAgICAgICBwYWlyLm1hcC5zZXRTb3VyY2VDb250ZW50KG9wdGlvbnMuc291cmNlTWFwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnNvdXJjZUNvbnRlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc291cmNlTWFwV2l0aENvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBwYWlyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhaXIubWFwLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgRk9STUFUX01JTklGWSA9IHtcbiAgICAgICAgaW5kZW50OiB7XG4gICAgICAgICAgICBzdHlsZTogJycsXG4gICAgICAgICAgICBiYXNlOiAwXG4gICAgICAgIH0sXG4gICAgICAgIHJlbnVtYmVyOiB0cnVlLFxuICAgICAgICBoZXhhZGVjaW1hbDogdHJ1ZSxcbiAgICAgICAgcXVvdGVzOiAnYXV0bycsXG4gICAgICAgIGVzY2FwZWxlc3M6IHRydWUsXG4gICAgICAgIGNvbXBhY3Q6IHRydWUsXG4gICAgICAgIHBhcmVudGhlc2VzOiBmYWxzZSxcbiAgICAgICAgc2VtaWNvbG9uczogZmFsc2VcbiAgICB9O1xuXG4gICAgRk9STUFUX0RFRkFVTFRTID0gZ2V0RGVmYXVsdE9wdGlvbnMoKS5mb3JtYXQ7XG5cbiAgICBleHBvcnRzLnZlcnNpb24gPSByZXF1aXJlKCcuL3BhY2thZ2UuanNvbicpLnZlcnNpb247XG4gICAgZXhwb3J0cy5nZW5lcmF0ZSA9IGdlbmVyYXRlO1xuICAgIGV4cG9ydHMuYXR0YWNoQ29tbWVudHMgPSBlc3RyYXZlcnNlLmF0dGFjaENvbW1lbnRzO1xuICAgIGV4cG9ydHMuUHJlY2VkZW5jZSA9IHVwZGF0ZURlZXBseSh7fSwgUHJlY2VkZW5jZSk7XG4gICAgZXhwb3J0cy5icm93c2VyID0gZmFsc2U7XG4gICAgZXhwb3J0cy5GT1JNQVRfTUlOSUZZID0gRk9STUFUX01JTklGWTtcbiAgICBleHBvcnRzLkZPUk1BVF9ERUZBVUxUUyA9IEZPUk1BVF9ERUZBVUxUUztcbn0oKSk7XG4vKiB2aW06IHNldCBzdz00IHRzPTQgZXQgdHc9ODAgOiAqL1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgaGFzTmF0aXZlTWFwID0gdHlwZW9mIE1hcCAhPT0gXCJ1bmRlZmluZWRcIjtcblxuLyoqXG4gKiBBIGRhdGEgc3RydWN0dXJlIHdoaWNoIGlzIGEgY29tYmluYXRpb24gb2YgYW4gYXJyYXkgYW5kIGEgc2V0LiBBZGRpbmcgYSBuZXdcbiAqIG1lbWJlciBpcyBPKDEpLCB0ZXN0aW5nIGZvciBtZW1iZXJzaGlwIGlzIE8oMSksIGFuZCBmaW5kaW5nIHRoZSBpbmRleCBvZiBhblxuICogZWxlbWVudCBpcyBPKDEpLiBSZW1vdmluZyBlbGVtZW50cyBmcm9tIHRoZSBzZXQgaXMgbm90IHN1cHBvcnRlZC4gT25seVxuICogc3RyaW5ncyBhcmUgc3VwcG9ydGVkIGZvciBtZW1iZXJzaGlwLlxuICovXG5mdW5jdGlvbiBBcnJheVNldCgpIHtcbiAgdGhpcy5fYXJyYXkgPSBbXTtcbiAgdGhpcy5fc2V0ID0gaGFzTmF0aXZlTWFwID8gbmV3IE1hcCgpIDogT2JqZWN0LmNyZWF0ZShudWxsKTtcbn1cblxuLyoqXG4gKiBTdGF0aWMgbWV0aG9kIGZvciBjcmVhdGluZyBBcnJheVNldCBpbnN0YW5jZXMgZnJvbSBhbiBleGlzdGluZyBhcnJheS5cbiAqL1xuQXJyYXlTZXQuZnJvbUFycmF5ID0gZnVuY3Rpb24gQXJyYXlTZXRfZnJvbUFycmF5KGFBcnJheSwgYUFsbG93RHVwbGljYXRlcykge1xuICB2YXIgc2V0ID0gbmV3IEFycmF5U2V0KCk7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhQXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBzZXQuYWRkKGFBcnJheVtpXSwgYUFsbG93RHVwbGljYXRlcyk7XG4gIH1cbiAgcmV0dXJuIHNldDtcbn07XG5cbi8qKlxuICogUmV0dXJuIGhvdyBtYW55IHVuaXF1ZSBpdGVtcyBhcmUgaW4gdGhpcyBBcnJheVNldC4gSWYgZHVwbGljYXRlcyBoYXZlIGJlZW5cbiAqIGFkZGVkLCB0aGFuIHRob3NlIGRvIG5vdCBjb3VudCB0b3dhcmRzIHRoZSBzaXplLlxuICpcbiAqIEByZXR1cm5zIE51bWJlclxuICovXG5BcnJheVNldC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uIEFycmF5U2V0X3NpemUoKSB7XG4gIHJldHVybiBoYXNOYXRpdmVNYXAgPyB0aGlzLl9zZXQuc2l6ZSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMuX3NldCkubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBBZGQgdGhlIGdpdmVuIHN0cmluZyB0byB0aGlzIHNldC5cbiAqXG4gKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIEFycmF5U2V0X2FkZChhU3RyLCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gIHZhciBzU3RyID0gaGFzTmF0aXZlTWFwID8gYVN0ciA6IHV0aWwudG9TZXRTdHJpbmcoYVN0cik7XG4gIHZhciBpc0R1cGxpY2F0ZSA9IGhhc05hdGl2ZU1hcCA/IHRoaXMuaGFzKGFTdHIpIDogaGFzLmNhbGwodGhpcy5fc2V0LCBzU3RyKTtcbiAgdmFyIGlkeCA9IHRoaXMuX2FycmF5Lmxlbmd0aDtcbiAgaWYgKCFpc0R1cGxpY2F0ZSB8fCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gICAgdGhpcy5fYXJyYXkucHVzaChhU3RyKTtcbiAgfVxuICBpZiAoIWlzRHVwbGljYXRlKSB7XG4gICAgaWYgKGhhc05hdGl2ZU1hcCkge1xuICAgICAgdGhpcy5fc2V0LnNldChhU3RyLCBpZHgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zZXRbc1N0cl0gPSBpZHg7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIElzIHRoZSBnaXZlbiBzdHJpbmcgYSBtZW1iZXIgb2YgdGhpcyBzZXQ/XG4gKlxuICogQHBhcmFtIFN0cmluZyBhU3RyXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBBcnJheVNldF9oYXMoYVN0cikge1xuICBpZiAoaGFzTmF0aXZlTWFwKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NldC5oYXMoYVN0cik7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNTdHIgPSB1dGlsLnRvU2V0U3RyaW5nKGFTdHIpO1xuICAgIHJldHVybiBoYXMuY2FsbCh0aGlzLl9zZXQsIHNTdHIpO1xuICB9XG59O1xuXG4vKipcbiAqIFdoYXQgaXMgdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBzdHJpbmcgaW4gdGhlIGFycmF5P1xuICpcbiAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICovXG5BcnJheVNldC5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIEFycmF5U2V0X2luZGV4T2YoYVN0cikge1xuICBpZiAoaGFzTmF0aXZlTWFwKSB7XG4gICAgdmFyIGlkeCA9IHRoaXMuX3NldC5nZXQoYVN0cik7XG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIHJldHVybiBpZHg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBzU3RyID0gdXRpbC50b1NldFN0cmluZyhhU3RyKTtcbiAgICBpZiAoaGFzLmNhbGwodGhpcy5fc2V0LCBzU3RyKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NldFtzU3RyXTtcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTdHIgKyAnXCIgaXMgbm90IGluIHRoZSBzZXQuJyk7XG59O1xuXG4vKipcbiAqIFdoYXQgaXMgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4P1xuICpcbiAqIEBwYXJhbSBOdW1iZXIgYUlkeFxuICovXG5BcnJheVNldC5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiBBcnJheVNldF9hdChhSWR4KSB7XG4gIGlmIChhSWR4ID49IDAgJiYgYUlkeCA8IHRoaXMuX2FycmF5Lmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLl9hcnJheVthSWR4XTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ05vIGVsZW1lbnQgaW5kZXhlZCBieSAnICsgYUlkeCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc2V0ICh3aGljaCBoYXMgdGhlIHByb3BlciBpbmRpY2VzXG4gKiBpbmRpY2F0ZWQgYnkgaW5kZXhPZikuIE5vdGUgdGhhdCB0aGlzIGlzIGEgY29weSBvZiB0aGUgaW50ZXJuYWwgYXJyYXkgdXNlZFxuICogZm9yIHN0b3JpbmcgdGhlIG1lbWJlcnMgc28gdGhhdCBubyBvbmUgY2FuIG1lc3Mgd2l0aCBpbnRlcm5hbCBzdGF0ZS5cbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiBBcnJheVNldF90b0FycmF5KCkge1xuICByZXR1cm4gdGhpcy5fYXJyYXkuc2xpY2UoKTtcbn07XG5cbmV4cG9ydHMuQXJyYXlTZXQgPSBBcnJheVNldDtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKlxuICogQmFzZWQgb24gdGhlIEJhc2UgNjQgVkxRIGltcGxlbWVudGF0aW9uIGluIENsb3N1cmUgQ29tcGlsZXI6XG4gKiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nsb3N1cmUtY29tcGlsZXIvc291cmNlL2Jyb3dzZS90cnVuay9zcmMvY29tL2dvb2dsZS9kZWJ1Z2dpbmcvc291cmNlbWFwL0Jhc2U2NFZMUS5qYXZhXG4gKlxuICogQ29weXJpZ2h0IDIwMTEgVGhlIENsb3N1cmUgQ29tcGlsZXIgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gKiAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICogICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkXG4gKiAgICB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKiAgKiBOZWl0aGVyIHRoZSBuYW1lIG9mIEdvb2dsZSBJbmMuIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWRcbiAqICAgIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4gKiBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbiAqIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxuICogREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4gKiBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gKiAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0VcbiAqIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJy4vYmFzZTY0Jyk7XG5cbi8vIEEgc2luZ2xlIGJhc2UgNjQgZGlnaXQgY2FuIGNvbnRhaW4gNiBiaXRzIG9mIGRhdGEuIEZvciB0aGUgYmFzZSA2NCB2YXJpYWJsZVxuLy8gbGVuZ3RoIHF1YW50aXRpZXMgd2UgdXNlIGluIHRoZSBzb3VyY2UgbWFwIHNwZWMsIHRoZSBmaXJzdCBiaXQgaXMgdGhlIHNpZ24sXG4vLyB0aGUgbmV4dCBmb3VyIGJpdHMgYXJlIHRoZSBhY3R1YWwgdmFsdWUsIGFuZCB0aGUgNnRoIGJpdCBpcyB0aGVcbi8vIGNvbnRpbnVhdGlvbiBiaXQuIFRoZSBjb250aW51YXRpb24gYml0IHRlbGxzIHVzIHdoZXRoZXIgdGhlcmUgYXJlIG1vcmVcbi8vIGRpZ2l0cyBpbiB0aGlzIHZhbHVlIGZvbGxvd2luZyB0aGlzIGRpZ2l0LlxuLy9cbi8vICAgQ29udGludWF0aW9uXG4vLyAgIHwgICAgU2lnblxuLy8gICB8ICAgIHxcbi8vICAgViAgICBWXG4vLyAgIDEwMTAxMVxuXG52YXIgVkxRX0JBU0VfU0hJRlQgPSA1O1xuXG4vLyBiaW5hcnk6IDEwMDAwMFxudmFyIFZMUV9CQVNFID0gMSA8PCBWTFFfQkFTRV9TSElGVDtcblxuLy8gYmluYXJ5OiAwMTExMTFcbnZhciBWTFFfQkFTRV9NQVNLID0gVkxRX0JBU0UgLSAxO1xuXG4vLyBiaW5hcnk6IDEwMDAwMFxudmFyIFZMUV9DT05USU5VQVRJT05fQklUID0gVkxRX0JBU0U7XG5cbi8qKlxuICogQ29udmVydHMgZnJvbSBhIHR3by1jb21wbGVtZW50IHZhbHVlIHRvIGEgdmFsdWUgd2hlcmUgdGhlIHNpZ24gYml0IGlzXG4gKiBwbGFjZWQgaW4gdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdC4gIEZvciBleGFtcGxlLCBhcyBkZWNpbWFsczpcbiAqICAgMSBiZWNvbWVzIDIgKDEwIGJpbmFyeSksIC0xIGJlY29tZXMgMyAoMTEgYmluYXJ5KVxuICogICAyIGJlY29tZXMgNCAoMTAwIGJpbmFyeSksIC0yIGJlY29tZXMgNSAoMTAxIGJpbmFyeSlcbiAqL1xuZnVuY3Rpb24gdG9WTFFTaWduZWQoYVZhbHVlKSB7XG4gIHJldHVybiBhVmFsdWUgPCAwXG4gICAgPyAoKC1hVmFsdWUpIDw8IDEpICsgMVxuICAgIDogKGFWYWx1ZSA8PCAxKSArIDA7XG59XG5cbi8qKlxuICogQ29udmVydHMgdG8gYSB0d28tY29tcGxlbWVudCB2YWx1ZSBmcm9tIGEgdmFsdWUgd2hlcmUgdGhlIHNpZ24gYml0IGlzXG4gKiBwbGFjZWQgaW4gdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdC4gIEZvciBleGFtcGxlLCBhcyBkZWNpbWFsczpcbiAqICAgMiAoMTAgYmluYXJ5KSBiZWNvbWVzIDEsIDMgKDExIGJpbmFyeSkgYmVjb21lcyAtMVxuICogICA0ICgxMDAgYmluYXJ5KSBiZWNvbWVzIDIsIDUgKDEwMSBiaW5hcnkpIGJlY29tZXMgLTJcbiAqL1xuZnVuY3Rpb24gZnJvbVZMUVNpZ25lZChhVmFsdWUpIHtcbiAgdmFyIGlzTmVnYXRpdmUgPSAoYVZhbHVlICYgMSkgPT09IDE7XG4gIHZhciBzaGlmdGVkID0gYVZhbHVlID4+IDE7XG4gIHJldHVybiBpc05lZ2F0aXZlXG4gICAgPyAtc2hpZnRlZFxuICAgIDogc2hpZnRlZDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBiYXNlIDY0IFZMUSBlbmNvZGVkIHZhbHVlLlxuICovXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIGJhc2U2NFZMUV9lbmNvZGUoYVZhbHVlKSB7XG4gIHZhciBlbmNvZGVkID0gXCJcIjtcbiAgdmFyIGRpZ2l0O1xuXG4gIHZhciB2bHEgPSB0b1ZMUVNpZ25lZChhVmFsdWUpO1xuXG4gIGRvIHtcbiAgICBkaWdpdCA9IHZscSAmIFZMUV9CQVNFX01BU0s7XG4gICAgdmxxID4+Pj0gVkxRX0JBU0VfU0hJRlQ7XG4gICAgaWYgKHZscSA+IDApIHtcbiAgICAgIC8vIFRoZXJlIGFyZSBzdGlsbCBtb3JlIGRpZ2l0cyBpbiB0aGlzIHZhbHVlLCBzbyB3ZSBtdXN0IG1ha2Ugc3VyZSB0aGVcbiAgICAgIC8vIGNvbnRpbnVhdGlvbiBiaXQgaXMgbWFya2VkLlxuICAgICAgZGlnaXQgfD0gVkxRX0NPTlRJTlVBVElPTl9CSVQ7XG4gICAgfVxuICAgIGVuY29kZWQgKz0gYmFzZTY0LmVuY29kZShkaWdpdCk7XG4gIH0gd2hpbGUgKHZscSA+IDApO1xuXG4gIHJldHVybiBlbmNvZGVkO1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIHRoZSBuZXh0IGJhc2UgNjQgVkxRIHZhbHVlIGZyb20gdGhlIGdpdmVuIHN0cmluZyBhbmQgcmV0dXJucyB0aGVcbiAqIHZhbHVlIGFuZCB0aGUgcmVzdCBvZiB0aGUgc3RyaW5nIHZpYSB0aGUgb3V0IHBhcmFtZXRlci5cbiAqL1xuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiBiYXNlNjRWTFFfZGVjb2RlKGFTdHIsIGFJbmRleCwgYU91dFBhcmFtKSB7XG4gIHZhciBzdHJMZW4gPSBhU3RyLmxlbmd0aDtcbiAgdmFyIHJlc3VsdCA9IDA7XG4gIHZhciBzaGlmdCA9IDA7XG4gIHZhciBjb250aW51YXRpb24sIGRpZ2l0O1xuXG4gIGRvIHtcbiAgICBpZiAoYUluZGV4ID49IHN0ckxlbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgbW9yZSBkaWdpdHMgaW4gYmFzZSA2NCBWTFEgdmFsdWUuXCIpO1xuICAgIH1cblxuICAgIGRpZ2l0ID0gYmFzZTY0LmRlY29kZShhU3RyLmNoYXJDb2RlQXQoYUluZGV4KyspKTtcbiAgICBpZiAoZGlnaXQgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGJhc2U2NCBkaWdpdDogXCIgKyBhU3RyLmNoYXJBdChhSW5kZXggLSAxKSk7XG4gICAgfVxuXG4gICAgY29udGludWF0aW9uID0gISEoZGlnaXQgJiBWTFFfQ09OVElOVUFUSU9OX0JJVCk7XG4gICAgZGlnaXQgJj0gVkxRX0JBU0VfTUFTSztcbiAgICByZXN1bHQgPSByZXN1bHQgKyAoZGlnaXQgPDwgc2hpZnQpO1xuICAgIHNoaWZ0ICs9IFZMUV9CQVNFX1NISUZUO1xuICB9IHdoaWxlIChjb250aW51YXRpb24pO1xuXG4gIGFPdXRQYXJhbS52YWx1ZSA9IGZyb21WTFFTaWduZWQocmVzdWx0KTtcbiAgYU91dFBhcmFtLnJlc3QgPSBhSW5kZXg7XG59O1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgaW50VG9DaGFyTWFwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nLnNwbGl0KCcnKTtcblxuLyoqXG4gKiBFbmNvZGUgYW4gaW50ZWdlciBpbiB0aGUgcmFuZ2Ugb2YgMCB0byA2MyB0byBhIHNpbmdsZSBiYXNlIDY0IGRpZ2l0LlxuICovXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgaWYgKDAgPD0gbnVtYmVyICYmIG51bWJlciA8IGludFRvQ2hhck1hcC5sZW5ndGgpIHtcbiAgICByZXR1cm4gaW50VG9DaGFyTWFwW251bWJlcl07XG4gIH1cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk11c3QgYmUgYmV0d2VlbiAwIGFuZCA2MzogXCIgKyBudW1iZXIpO1xufTtcblxuLyoqXG4gKiBEZWNvZGUgYSBzaW5nbGUgYmFzZSA2NCBjaGFyYWN0ZXIgY29kZSBkaWdpdCB0byBhbiBpbnRlZ2VyLiBSZXR1cm5zIC0xIG9uXG4gKiBmYWlsdXJlLlxuICovXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIChjaGFyQ29kZSkge1xuICB2YXIgYmlnQSA9IDY1OyAgICAgLy8gJ0EnXG4gIHZhciBiaWdaID0gOTA7ICAgICAvLyAnWidcblxuICB2YXIgbGl0dGxlQSA9IDk3OyAgLy8gJ2EnXG4gIHZhciBsaXR0bGVaID0gMTIyOyAvLyAneidcblxuICB2YXIgemVybyA9IDQ4OyAgICAgLy8gJzAnXG4gIHZhciBuaW5lID0gNTc7ICAgICAvLyAnOSdcblxuICB2YXIgcGx1cyA9IDQzOyAgICAgLy8gJysnXG4gIHZhciBzbGFzaCA9IDQ3OyAgICAvLyAnLydcblxuICB2YXIgbGl0dGxlT2Zmc2V0ID0gMjY7XG4gIHZhciBudW1iZXJPZmZzZXQgPSA1MjtcblxuICAvLyAwIC0gMjU6IEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXG4gIGlmIChiaWdBIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IGJpZ1opIHtcbiAgICByZXR1cm4gKGNoYXJDb2RlIC0gYmlnQSk7XG4gIH1cblxuICAvLyAyNiAtIDUxOiBhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elxuICBpZiAobGl0dGxlQSA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSBsaXR0bGVaKSB7XG4gICAgcmV0dXJuIChjaGFyQ29kZSAtIGxpdHRsZUEgKyBsaXR0bGVPZmZzZXQpO1xuICB9XG5cbiAgLy8gNTIgLSA2MTogMDEyMzQ1Njc4OVxuICBpZiAoemVybyA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSBuaW5lKSB7XG4gICAgcmV0dXJuIChjaGFyQ29kZSAtIHplcm8gKyBudW1iZXJPZmZzZXQpO1xuICB9XG5cbiAgLy8gNjI6ICtcbiAgaWYgKGNoYXJDb2RlID09IHBsdXMpIHtcbiAgICByZXR1cm4gNjI7XG4gIH1cblxuICAvLyA2MzogL1xuICBpZiAoY2hhckNvZGUgPT0gc2xhc2gpIHtcbiAgICByZXR1cm4gNjM7XG4gIH1cblxuICAvLyBJbnZhbGlkIGJhc2U2NCBkaWdpdC5cbiAgcmV0dXJuIC0xO1xufTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxuZXhwb3J0cy5HUkVBVEVTVF9MT1dFUl9CT1VORCA9IDE7XG5leHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EID0gMjtcblxuLyoqXG4gKiBSZWN1cnNpdmUgaW1wbGVtZW50YXRpb24gb2YgYmluYXJ5IHNlYXJjaC5cbiAqXG4gKiBAcGFyYW0gYUxvdyBJbmRpY2VzIGhlcmUgYW5kIGxvd2VyIGRvIG5vdCBjb250YWluIHRoZSBuZWVkbGUuXG4gKiBAcGFyYW0gYUhpZ2ggSW5kaWNlcyBoZXJlIGFuZCBoaWdoZXIgZG8gbm90IGNvbnRhaW4gdGhlIG5lZWRsZS5cbiAqIEBwYXJhbSBhTmVlZGxlIFRoZSBlbGVtZW50IGJlaW5nIHNlYXJjaGVkIGZvci5cbiAqIEBwYXJhbSBhSGF5c3RhY2sgVGhlIG5vbi1lbXB0eSBhcnJheSBiZWluZyBzZWFyY2hlZC5cbiAqIEBwYXJhbSBhQ29tcGFyZSBGdW5jdGlvbiB3aGljaCB0YWtlcyB0d28gZWxlbWVudHMgYW5kIHJldHVybnMgLTEsIDAsIG9yIDEuXG4gKiBAcGFyYW0gYUJpYXMgRWl0aGVyICdiaW5hcnlTZWFyY2guR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gKiAgICAgJ2JpbmFyeVNlYXJjaC5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGVcbiAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gKi9cbmZ1bmN0aW9uIHJlY3Vyc2l2ZVNlYXJjaChhTG93LCBhSGlnaCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpIHtcbiAgLy8gVGhpcyBmdW5jdGlvbiB0ZXJtaW5hdGVzIHdoZW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgaXMgdHJ1ZTpcbiAgLy9cbiAgLy8gICAxLiBXZSBmaW5kIHRoZSBleGFjdCBlbGVtZW50IHdlIGFyZSBsb29raW5nIGZvci5cbiAgLy9cbiAgLy8gICAyLiBXZSBkaWQgbm90IGZpbmQgdGhlIGV4YWN0IGVsZW1lbnQsIGJ1dCB3ZSBjYW4gcmV0dXJuIHRoZSBpbmRleCBvZlxuICAvLyAgICAgIHRoZSBuZXh0LWNsb3Nlc3QgZWxlbWVudC5cbiAgLy9cbiAgLy8gICAzLiBXZSBkaWQgbm90IGZpbmQgdGhlIGV4YWN0IGVsZW1lbnQsIGFuZCB0aGVyZSBpcyBubyBuZXh0LWNsb3Nlc3RcbiAgLy8gICAgICBlbGVtZW50IHRoYW4gdGhlIG9uZSB3ZSBhcmUgc2VhcmNoaW5nIGZvciwgc28gd2UgcmV0dXJuIC0xLlxuICB2YXIgbWlkID0gTWF0aC5mbG9vcigoYUhpZ2ggLSBhTG93KSAvIDIpICsgYUxvdztcbiAgdmFyIGNtcCA9IGFDb21wYXJlKGFOZWVkbGUsIGFIYXlzdGFja1ttaWRdLCB0cnVlKTtcbiAgaWYgKGNtcCA9PT0gMCkge1xuICAgIC8vIEZvdW5kIHRoZSBlbGVtZW50IHdlIGFyZSBsb29raW5nIGZvci5cbiAgICByZXR1cm4gbWlkO1xuICB9XG4gIGVsc2UgaWYgKGNtcCA+IDApIHtcbiAgICAvLyBPdXIgbmVlZGxlIGlzIGdyZWF0ZXIgdGhhbiBhSGF5c3RhY2tbbWlkXS5cbiAgICBpZiAoYUhpZ2ggLSBtaWQgPiAxKSB7XG4gICAgICAvLyBUaGUgZWxlbWVudCBpcyBpbiB0aGUgdXBwZXIgaGFsZi5cbiAgICAgIHJldHVybiByZWN1cnNpdmVTZWFyY2gobWlkLCBhSGlnaCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpO1xuICAgIH1cblxuICAgIC8vIFRoZSBleGFjdCBuZWVkbGUgZWxlbWVudCB3YXMgbm90IGZvdW5kIGluIHRoaXMgaGF5c3RhY2suIERldGVybWluZSBpZlxuICAgIC8vIHdlIGFyZSBpbiB0ZXJtaW5hdGlvbiBjYXNlICgzKSBvciAoMikgYW5kIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgdGhpbmcuXG4gICAgaWYgKGFCaWFzID09IGV4cG9ydHMuTEVBU1RfVVBQRVJfQk9VTkQpIHtcbiAgICAgIHJldHVybiBhSGlnaCA8IGFIYXlzdGFjay5sZW5ndGggPyBhSGlnaCA6IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWlkO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvLyBPdXIgbmVlZGxlIGlzIGxlc3MgdGhhbiBhSGF5c3RhY2tbbWlkXS5cbiAgICBpZiAobWlkIC0gYUxvdyA+IDEpIHtcbiAgICAgIC8vIFRoZSBlbGVtZW50IGlzIGluIHRoZSBsb3dlciBoYWxmLlxuICAgICAgcmV0dXJuIHJlY3Vyc2l2ZVNlYXJjaChhTG93LCBtaWQsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKTtcbiAgICB9XG5cbiAgICAvLyB3ZSBhcmUgaW4gdGVybWluYXRpb24gY2FzZSAoMykgb3IgKDIpIGFuZCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIHRoaW5nLlxuICAgIGlmIChhQmlhcyA9PSBleHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EKSB7XG4gICAgICByZXR1cm4gbWlkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYUxvdyA8IDAgPyAtMSA6IGFMb3c7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiBiaW5hcnkgc2VhcmNoIHdoaWNoIHdpbGwgYWx3YXlzIHRyeSBhbmQgcmV0dXJuXG4gKiB0aGUgaW5kZXggb2YgdGhlIGNsb3Nlc3QgZWxlbWVudCBpZiB0aGVyZSBpcyBubyBleGFjdCBoaXQuIFRoaXMgaXMgYmVjYXVzZVxuICogbWFwcGluZ3MgYmV0d2VlbiBvcmlnaW5hbCBhbmQgZ2VuZXJhdGVkIGxpbmUvY29sIHBhaXJzIGFyZSBzaW5nbGUgcG9pbnRzLFxuICogYW5kIHRoZXJlIGlzIGFuIGltcGxpY2l0IHJlZ2lvbiBiZXR3ZWVuIGVhY2ggb2YgdGhlbSwgc28gYSBtaXNzIGp1c3QgbWVhbnNcbiAqIHRoYXQgeW91IGFyZW4ndCBvbiB0aGUgdmVyeSBzdGFydCBvZiBhIHJlZ2lvbi5cbiAqXG4gKiBAcGFyYW0gYU5lZWRsZSBUaGUgZWxlbWVudCB5b3UgYXJlIGxvb2tpbmcgZm9yLlxuICogQHBhcmFtIGFIYXlzdGFjayBUaGUgYXJyYXkgdGhhdCBpcyBiZWluZyBzZWFyY2hlZC5cbiAqIEBwYXJhbSBhQ29tcGFyZSBBIGZ1bmN0aW9uIHdoaWNoIHRha2VzIHRoZSBuZWVkbGUgYW5kIGFuIGVsZW1lbnQgaW4gdGhlXG4gKiAgICAgYXJyYXkgYW5kIHJldHVybnMgLTEsIDAsIG9yIDEgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIG5lZWRsZSBpcyBsZXNzXG4gKiAgICAgdGhhbiwgZXF1YWwgdG8sIG9yIGdyZWF0ZXIgdGhhbiB0aGUgZWxlbWVudCwgcmVzcGVjdGl2ZWx5LlxuICogQHBhcmFtIGFCaWFzIEVpdGhlciAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICogICAgICdiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICogICAgIERlZmF1bHRzIHRvICdiaW5hcnlTZWFyY2guR1JFQVRFU1RfTE9XRVJfQk9VTkQnLlxuICovXG5leHBvcnRzLnNlYXJjaCA9IGZ1bmN0aW9uIHNlYXJjaChhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlLCBhQmlhcykge1xuICBpZiAoYUhheXN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIHZhciBpbmRleCA9IHJlY3Vyc2l2ZVNlYXJjaCgtMSwgYUhheXN0YWNrLmxlbmd0aCwgYU5lZWRsZSwgYUhheXN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYUNvbXBhcmUsIGFCaWFzIHx8IGV4cG9ydHMuR1JFQVRFU1RfTE9XRVJfQk9VTkQpO1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLy8gV2UgaGF2ZSBmb3VuZCBlaXRoZXIgdGhlIGV4YWN0IGVsZW1lbnQsIG9yIHRoZSBuZXh0LWNsb3Nlc3QgZWxlbWVudCB0aGFuXG4gIC8vIHRoZSBvbmUgd2UgYXJlIHNlYXJjaGluZyBmb3IuIEhvd2V2ZXIsIHRoZXJlIG1heSBiZSBtb3JlIHRoYW4gb25lIHN1Y2hcbiAgLy8gZWxlbWVudC4gTWFrZSBzdXJlIHdlIGFsd2F5cyByZXR1cm4gdGhlIHNtYWxsZXN0IG9mIHRoZXNlLlxuICB3aGlsZSAoaW5kZXggLSAxID49IDApIHtcbiAgICBpZiAoYUNvbXBhcmUoYUhheXN0YWNrW2luZGV4XSwgYUhheXN0YWNrW2luZGV4IC0gMV0sIHRydWUpICE9PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgLS1pbmRleDtcbiAgfVxuXG4gIHJldHVybiBpbmRleDtcbn07XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTQgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgbWFwcGluZ0IgaXMgYWZ0ZXIgbWFwcGluZ0Egd2l0aCByZXNwZWN0IHRvIGdlbmVyYXRlZFxuICogcG9zaXRpb24uXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlZFBvc2l0aW9uQWZ0ZXIobWFwcGluZ0EsIG1hcHBpbmdCKSB7XG4gIC8vIE9wdGltaXplZCBmb3IgbW9zdCBjb21tb24gY2FzZVxuICB2YXIgbGluZUEgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lO1xuICB2YXIgbGluZUIgPSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICB2YXIgY29sdW1uQSA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbjtcbiAgdmFyIGNvbHVtbkIgPSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIHJldHVybiBsaW5lQiA+IGxpbmVBIHx8IGxpbmVCID09IGxpbmVBICYmIGNvbHVtbkIgPj0gY29sdW1uQSB8fFxuICAgICAgICAgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZChtYXBwaW5nQSwgbWFwcGluZ0IpIDw9IDA7XG59XG5cbi8qKlxuICogQSBkYXRhIHN0cnVjdHVyZSB0byBwcm92aWRlIGEgc29ydGVkIHZpZXcgb2YgYWNjdW11bGF0ZWQgbWFwcGluZ3MgaW4gYVxuICogcGVyZm9ybWFuY2UgY29uc2Npb3VzIG1hbm5lci4gSXQgdHJhZGVzIGEgbmVnbGliYWJsZSBvdmVyaGVhZCBpbiBnZW5lcmFsXG4gKiBjYXNlIGZvciBhIGxhcmdlIHNwZWVkdXAgaW4gY2FzZSBvZiBtYXBwaW5ncyBiZWluZyBhZGRlZCBpbiBvcmRlci5cbiAqL1xuZnVuY3Rpb24gTWFwcGluZ0xpc3QoKSB7XG4gIHRoaXMuX2FycmF5ID0gW107XG4gIHRoaXMuX3NvcnRlZCA9IHRydWU7XG4gIC8vIFNlcnZlcyBhcyBpbmZpbXVtXG4gIHRoaXMuX2xhc3QgPSB7Z2VuZXJhdGVkTGluZTogLTEsIGdlbmVyYXRlZENvbHVtbjogMH07XG59XG5cbi8qKlxuICogSXRlcmF0ZSB0aHJvdWdoIGludGVybmFsIGl0ZW1zLiBUaGlzIG1ldGhvZCB0YWtlcyB0aGUgc2FtZSBhcmd1bWVudHMgdGhhdFxuICogYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCB0YWtlcy5cbiAqXG4gKiBOT1RFOiBUaGUgb3JkZXIgb2YgdGhlIG1hcHBpbmdzIGlzIE5PVCBndWFyYW50ZWVkLlxuICovXG5NYXBwaW5nTGlzdC5wcm90b3R5cGUudW5zb3J0ZWRGb3JFYWNoID1cbiAgZnVuY3Rpb24gTWFwcGluZ0xpc3RfZm9yRWFjaChhQ2FsbGJhY2ssIGFUaGlzQXJnKSB7XG4gICAgdGhpcy5fYXJyYXkuZm9yRWFjaChhQ2FsbGJhY2ssIGFUaGlzQXJnKTtcbiAgfTtcblxuLyoqXG4gKiBBZGQgdGhlIGdpdmVuIHNvdXJjZSBtYXBwaW5nLlxuICpcbiAqIEBwYXJhbSBPYmplY3QgYU1hcHBpbmdcbiAqL1xuTWFwcGluZ0xpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIE1hcHBpbmdMaXN0X2FkZChhTWFwcGluZykge1xuICBpZiAoZ2VuZXJhdGVkUG9zaXRpb25BZnRlcih0aGlzLl9sYXN0LCBhTWFwcGluZykpIHtcbiAgICB0aGlzLl9sYXN0ID0gYU1hcHBpbmc7XG4gICAgdGhpcy5fYXJyYXkucHVzaChhTWFwcGluZyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fc29ydGVkID0gZmFsc2U7XG4gICAgdGhpcy5fYXJyYXkucHVzaChhTWFwcGluZyk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmxhdCwgc29ydGVkIGFycmF5IG9mIG1hcHBpbmdzLiBUaGUgbWFwcGluZ3MgYXJlIHNvcnRlZCBieVxuICogZ2VuZXJhdGVkIHBvc2l0aW9uLlxuICpcbiAqIFdBUk5JTkc6IFRoaXMgbWV0aG9kIHJldHVybnMgaW50ZXJuYWwgZGF0YSB3aXRob3V0IGNvcHlpbmcsIGZvclxuICogcGVyZm9ybWFuY2UuIFRoZSByZXR1cm4gdmFsdWUgbXVzdCBOT1QgYmUgbXV0YXRlZCwgYW5kIHNob3VsZCBiZSB0cmVhdGVkIGFzXG4gKiBhbiBpbW11dGFibGUgYm9ycm93LiBJZiB5b3Ugd2FudCB0byB0YWtlIG93bmVyc2hpcCwgeW91IG11c3QgbWFrZSB5b3VyIG93blxuICogY29weS5cbiAqL1xuTWFwcGluZ0xpc3QucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiBNYXBwaW5nTGlzdF90b0FycmF5KCkge1xuICBpZiAoIXRoaXMuX3NvcnRlZCkge1xuICAgIHRoaXMuX2FycmF5LnNvcnQodXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZCk7XG4gICAgdGhpcy5fc29ydGVkID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gdGhpcy5fYXJyYXk7XG59O1xuXG5leHBvcnRzLk1hcHBpbmdMaXN0ID0gTWFwcGluZ0xpc3Q7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbi8vIEl0IHR1cm5zIG91dCB0aGF0IHNvbWUgKG1vc3Q/KSBKYXZhU2NyaXB0IGVuZ2luZXMgZG9uJ3Qgc2VsZi1ob3N0XG4vLyBgQXJyYXkucHJvdG90eXBlLnNvcnRgLiBUaGlzIG1ha2VzIHNlbnNlIGJlY2F1c2UgQysrIHdpbGwgbGlrZWx5IHJlbWFpblxuLy8gZmFzdGVyIHRoYW4gSlMgd2hlbiBkb2luZyByYXcgQ1BVLWludGVuc2l2ZSBzb3J0aW5nLiBIb3dldmVyLCB3aGVuIHVzaW5nIGFcbi8vIGN1c3RvbSBjb21wYXJhdG9yIGZ1bmN0aW9uLCBjYWxsaW5nIGJhY2sgYW5kIGZvcnRoIGJldHdlZW4gdGhlIFZNJ3MgQysrIGFuZFxuLy8gSklUJ2QgSlMgaXMgcmF0aGVyIHNsb3cgKmFuZCogbG9zZXMgSklUIHR5cGUgaW5mb3JtYXRpb24sIHJlc3VsdGluZyBpblxuLy8gd29yc2UgZ2VuZXJhdGVkIGNvZGUgZm9yIHRoZSBjb21wYXJhdG9yIGZ1bmN0aW9uIHRoYW4gd291bGQgYmUgb3B0aW1hbC4gSW5cbi8vIGZhY3QsIHdoZW4gc29ydGluZyB3aXRoIGEgY29tcGFyYXRvciwgdGhlc2UgY29zdHMgb3V0d2VpZ2ggdGhlIGJlbmVmaXRzIG9mXG4vLyBzb3J0aW5nIGluIEMrKy4gQnkgdXNpbmcgb3VyIG93biBKUy1pbXBsZW1lbnRlZCBRdWljayBTb3J0IChiZWxvdyksIHdlIGdldFxuLy8gYSB+MzUwMG1zIG1lYW4gc3BlZWQtdXAgaW4gYGJlbmNoL2JlbmNoLmh0bWxgLlxuXG4vKipcbiAqIFN3YXAgdGhlIGVsZW1lbnRzIGluZGV4ZWQgYnkgYHhgIGFuZCBgeWAgaW4gdGhlIGFycmF5IGBhcnlgLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyeVxuICogICAgICAgIFRoZSBhcnJheS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiAgICAgICAgVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBpdGVtLlxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqICAgICAgICBUaGUgaW5kZXggb2YgdGhlIHNlY29uZCBpdGVtLlxuICovXG5mdW5jdGlvbiBzd2FwKGFyeSwgeCwgeSkge1xuICB2YXIgdGVtcCA9IGFyeVt4XTtcbiAgYXJ5W3hdID0gYXJ5W3ldO1xuICBhcnlbeV0gPSB0ZW1wO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSByYW5kb20gaW50ZWdlciB3aXRoaW4gdGhlIHJhbmdlIGBsb3cgLi4gaGlnaGAgaW5jbHVzaXZlLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBsb3dcbiAqICAgICAgICBUaGUgbG93ZXIgYm91bmQgb24gdGhlIHJhbmdlLlxuICogQHBhcmFtIHtOdW1iZXJ9IGhpZ2hcbiAqICAgICAgICBUaGUgdXBwZXIgYm91bmQgb24gdGhlIHJhbmdlLlxuICovXG5mdW5jdGlvbiByYW5kb21JbnRJblJhbmdlKGxvdywgaGlnaCkge1xuICByZXR1cm4gTWF0aC5yb3VuZChsb3cgKyAoTWF0aC5yYW5kb20oKSAqIChoaWdoIC0gbG93KSkpO1xufVxuXG4vKipcbiAqIFRoZSBRdWljayBTb3J0IGFsZ29yaXRobS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnlcbiAqICAgICAgICBBbiBhcnJheSB0byBzb3J0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY29tcGFyYXRvclxuICogICAgICAgIEZ1bmN0aW9uIHRvIHVzZSB0byBjb21wYXJlIHR3byBpdGVtcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBwXG4gKiAgICAgICAgU3RhcnQgaW5kZXggb2YgdGhlIGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gclxuICogICAgICAgIEVuZCBpbmRleCBvZiB0aGUgYXJyYXlcbiAqL1xuZnVuY3Rpb24gZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCBwLCByKSB7XG4gIC8vIElmIG91ciBsb3dlciBib3VuZCBpcyBsZXNzIHRoYW4gb3VyIHVwcGVyIGJvdW5kLCB3ZSAoMSkgcGFydGl0aW9uIHRoZVxuICAvLyBhcnJheSBpbnRvIHR3byBwaWVjZXMgYW5kICgyKSByZWN1cnNlIG9uIGVhY2ggaGFsZi4gSWYgaXQgaXMgbm90LCB0aGlzIGlzXG4gIC8vIHRoZSBlbXB0eSBhcnJheSBhbmQgb3VyIGJhc2UgY2FzZS5cblxuICBpZiAocCA8IHIpIHtcbiAgICAvLyAoMSkgUGFydGl0aW9uaW5nLlxuICAgIC8vXG4gICAgLy8gVGhlIHBhcnRpdGlvbmluZyBjaG9vc2VzIGEgcGl2b3QgYmV0d2VlbiBgcGAgYW5kIGByYCBhbmQgbW92ZXMgYWxsXG4gICAgLy8gZWxlbWVudHMgdGhhdCBhcmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBwaXZvdCB0byB0aGUgYmVmb3JlIGl0LCBhbmRcbiAgICAvLyBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgYXJlIGdyZWF0ZXIgdGhhbiBpdCBhZnRlciBpdC4gVGhlIGVmZmVjdCBpcyB0aGF0XG4gICAgLy8gb25jZSBwYXJ0aXRpb24gaXMgZG9uZSwgdGhlIHBpdm90IGlzIGluIHRoZSBleGFjdCBwbGFjZSBpdCB3aWxsIGJlIHdoZW5cbiAgICAvLyB0aGUgYXJyYXkgaXMgcHV0IGluIHNvcnRlZCBvcmRlciwgYW5kIGl0IHdpbGwgbm90IG5lZWQgdG8gYmUgbW92ZWRcbiAgICAvLyBhZ2Fpbi4gVGhpcyBydW5zIGluIE8obikgdGltZS5cblxuICAgIC8vIEFsd2F5cyBjaG9vc2UgYSByYW5kb20gcGl2b3Qgc28gdGhhdCBhbiBpbnB1dCBhcnJheSB3aGljaCBpcyByZXZlcnNlXG4gICAgLy8gc29ydGVkIGRvZXMgbm90IGNhdXNlIE8obl4yKSBydW5uaW5nIHRpbWUuXG4gICAgdmFyIHBpdm90SW5kZXggPSByYW5kb21JbnRJblJhbmdlKHAsIHIpO1xuICAgIHZhciBpID0gcCAtIDE7XG5cbiAgICBzd2FwKGFyeSwgcGl2b3RJbmRleCwgcik7XG4gICAgdmFyIHBpdm90ID0gYXJ5W3JdO1xuXG4gICAgLy8gSW1tZWRpYXRlbHkgYWZ0ZXIgYGpgIGlzIGluY3JlbWVudGVkIGluIHRoaXMgbG9vcCwgdGhlIGZvbGxvd2luZyBob2xkXG4gICAgLy8gdHJ1ZTpcbiAgICAvL1xuICAgIC8vICAgKiBFdmVyeSBlbGVtZW50IGluIGBhcnlbcCAuLiBpXWAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBwaXZvdC5cbiAgICAvL1xuICAgIC8vICAgKiBFdmVyeSBlbGVtZW50IGluIGBhcnlbaSsxIC4uIGotMV1gIGlzIGdyZWF0ZXIgdGhhbiB0aGUgcGl2b3QuXG4gICAgZm9yICh2YXIgaiA9IHA7IGogPCByOyBqKyspIHtcbiAgICAgIGlmIChjb21wYXJhdG9yKGFyeVtqXSwgcGl2b3QpIDw9IDApIHtcbiAgICAgICAgaSArPSAxO1xuICAgICAgICBzd2FwKGFyeSwgaSwgaik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3dhcChhcnksIGkgKyAxLCBqKTtcbiAgICB2YXIgcSA9IGkgKyAxO1xuXG4gICAgLy8gKDIpIFJlY3Vyc2Ugb24gZWFjaCBoYWxmLlxuXG4gICAgZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCBwLCBxIC0gMSk7XG4gICAgZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCBxICsgMSwgcik7XG4gIH1cbn1cblxuLyoqXG4gKiBTb3J0IHRoZSBnaXZlbiBhcnJheSBpbi1wbGFjZSB3aXRoIHRoZSBnaXZlbiBjb21wYXJhdG9yIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyeVxuICogICAgICAgIEFuIGFycmF5IHRvIHNvcnQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb21wYXJhdG9yXG4gKiAgICAgICAgRnVuY3Rpb24gdG8gdXNlIHRvIGNvbXBhcmUgdHdvIGl0ZW1zLlxuICovXG5leHBvcnRzLnF1aWNrU29ydCA9IGZ1bmN0aW9uIChhcnksIGNvbXBhcmF0b3IpIHtcbiAgZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCAwLCBhcnkubGVuZ3RoIC0gMSk7XG59O1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIGJpbmFyeVNlYXJjaCA9IHJlcXVpcmUoJy4vYmluYXJ5LXNlYXJjaCcpO1xudmFyIEFycmF5U2V0ID0gcmVxdWlyZSgnLi9hcnJheS1zZXQnKS5BcnJheVNldDtcbnZhciBiYXNlNjRWTFEgPSByZXF1aXJlKCcuL2Jhc2U2NC12bHEnKTtcbnZhciBxdWlja1NvcnQgPSByZXF1aXJlKCcuL3F1aWNrLXNvcnQnKS5xdWlja1NvcnQ7XG5cbmZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyKGFTb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpIHtcbiAgdmFyIHNvdXJjZU1hcCA9IGFTb3VyY2VNYXA7XG4gIGlmICh0eXBlb2YgYVNvdXJjZU1hcCA9PT0gJ3N0cmluZycpIHtcbiAgICBzb3VyY2VNYXAgPSB1dGlsLnBhcnNlU291cmNlTWFwSW5wdXQoYVNvdXJjZU1hcCk7XG4gIH1cblxuICByZXR1cm4gc291cmNlTWFwLnNlY3Rpb25zICE9IG51bGxcbiAgICA/IG5ldyBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIoc291cmNlTWFwLCBhU291cmNlTWFwVVJMKVxuICAgIDogbmV3IEJhc2ljU291cmNlTWFwQ29uc3VtZXIoc291cmNlTWFwLCBhU291cmNlTWFwVVJMKTtcbn1cblxuU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcCA9IGZ1bmN0aW9uKGFTb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpIHtcbiAgcmV0dXJuIEJhc2ljU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcChhU291cmNlTWFwLCBhU291cmNlTWFwVVJMKTtcbn1cblxuLyoqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbi8vIGBfX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmQgYF9fb3JpZ2luYWxNYXBwaW5nc2AgYXJlIGFycmF5cyB0aGF0IGhvbGQgdGhlXG4vLyBwYXJzZWQgbWFwcGluZyBjb29yZGluYXRlcyBmcm9tIHRoZSBzb3VyY2UgbWFwJ3MgXCJtYXBwaW5nc1wiIGF0dHJpYnV0ZS4gVGhleVxuLy8gYXJlIGxhemlseSBpbnN0YW50aWF0ZWQsIGFjY2Vzc2VkIHZpYSB0aGUgYF9nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4vLyBgX29yaWdpbmFsTWFwcGluZ3NgIGdldHRlcnMgcmVzcGVjdGl2ZWx5LCBhbmQgd2Ugb25seSBwYXJzZSB0aGUgbWFwcGluZ3Ncbi8vIGFuZCBjcmVhdGUgdGhlc2UgYXJyYXlzIG9uY2UgcXVlcmllZCBmb3IgYSBzb3VyY2UgbG9jYXRpb24uIFdlIGp1bXAgdGhyb3VnaFxuLy8gdGhlc2UgaG9vcHMgYmVjYXVzZSB0aGVyZSBjYW4gYmUgbWFueSB0aG91c2FuZHMgb2YgbWFwcGluZ3MsIGFuZCBwYXJzaW5nXG4vLyB0aGVtIGlzIGV4cGVuc2l2ZSwgc28gd2Ugb25seSB3YW50IHRvIGRvIGl0IGlmIHdlIG11c3QuXG4vL1xuLy8gRWFjaCBvYmplY3QgaW4gdGhlIGFycmF5cyBpcyBvZiB0aGUgZm9ybTpcbi8vXG4vLyAgICAge1xuLy8gICAgICAgZ2VuZXJhdGVkTGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIGdlbmVyYXRlZENvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLFxuLy8gICAgICAgc291cmNlOiBUaGUgcGF0aCB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGUgdGhhdCBnZW5lcmF0ZWQgdGhpc1xuLy8gICAgICAgICAgICAgICBjaHVuayBvZiBjb2RlLFxuLy8gICAgICAgb3JpZ2luYWxMaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSB0aGF0XG4vLyAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRzIHRvIHRoaXMgY2h1bmsgb2YgZ2VuZXJhdGVkIGNvZGUsXG4vLyAgICAgICBvcmlnaW5hbENvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSB0aGF0XG4vLyAgICAgICAgICAgICAgICAgICAgICAgY29ycmVzcG9uZHMgdG8gdGhpcyBjaHVuayBvZiBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIG5hbWU6IFRoZSBuYW1lIG9mIHRoZSBvcmlnaW5hbCBzeW1ib2wgd2hpY2ggZ2VuZXJhdGVkIHRoaXMgY2h1bmsgb2Zcbi8vICAgICAgICAgICAgIGNvZGUuXG4vLyAgICAgfVxuLy9cbi8vIEFsbCBwcm9wZXJ0aWVzIGV4Y2VwdCBmb3IgYGdlbmVyYXRlZExpbmVgIGFuZCBgZ2VuZXJhdGVkQ29sdW1uYCBjYW4gYmVcbi8vIGBudWxsYC5cbi8vXG4vLyBgX2dlbmVyYXRlZE1hcHBpbmdzYCBpcyBvcmRlcmVkIGJ5IHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zLlxuLy9cbi8vIGBfb3JpZ2luYWxNYXBwaW5nc2AgaXMgb3JkZXJlZCBieSB0aGUgb3JpZ2luYWwgcG9zaXRpb25zLlxuXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IG51bGw7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnX2dlbmVyYXRlZE1hcHBpbmdzJywge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzKSB7XG4gICAgICB0aGlzLl9wYXJzZU1hcHBpbmdzKHRoaXMuX21hcHBpbmdzLCB0aGlzLnNvdXJjZVJvb3QpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3M7XG4gIH1cbn0pO1xuXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX19vcmlnaW5hbE1hcHBpbmdzID0gbnVsbDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdfb3JpZ2luYWxNYXBwaW5ncycsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuX19vcmlnaW5hbE1hcHBpbmdzKSB7XG4gICAgICB0aGlzLl9wYXJzZU1hcHBpbmdzKHRoaXMuX21hcHBpbmdzLCB0aGlzLnNvdXJjZVJvb3QpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncztcbiAgfVxufSk7XG5cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fY2hhcklzTWFwcGluZ1NlcGFyYXRvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2NoYXJJc01hcHBpbmdTZXBhcmF0b3IoYVN0ciwgaW5kZXgpIHtcbiAgICB2YXIgYyA9IGFTdHIuY2hhckF0KGluZGV4KTtcbiAgICByZXR1cm4gYyA9PT0gXCI7XCIgfHwgYyA9PT0gXCIsXCI7XG4gIH07XG5cbi8qKlxuICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICovXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3BhcnNlTWFwcGluZ3MgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudCBfcGFyc2VNYXBwaW5nc1wiKTtcbiAgfTtcblxuU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSID0gMTtcblNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSID0gMjtcblxuU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQgPSAxO1xuU291cmNlTWFwQ29uc3VtZXIuTEVBU1RfVVBQRVJfQk9VTkQgPSAyO1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBlYWNoIG1hcHBpbmcgYmV0d2VlbiBhbiBvcmlnaW5hbCBzb3VyY2UvbGluZS9jb2x1bW4gYW5kIGFcbiAqIGdlbmVyYXRlZCBsaW5lL2NvbHVtbiBpbiB0aGlzIHNvdXJjZSBtYXAuXG4gKlxuICogQHBhcmFtIEZ1bmN0aW9uIGFDYWxsYmFja1xuICogICAgICAgIFRoZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIGVhY2ggbWFwcGluZy5cbiAqIEBwYXJhbSBPYmplY3QgYUNvbnRleHRcbiAqICAgICAgICBPcHRpb25hbC4gSWYgc3BlY2lmaWVkLCB0aGlzIG9iamVjdCB3aWxsIGJlIHRoZSB2YWx1ZSBvZiBgdGhpc2AgZXZlcnlcbiAqICAgICAgICB0aW1lIHRoYXQgYGFDYWxsYmFja2AgaXMgY2FsbGVkLlxuICogQHBhcmFtIGFPcmRlclxuICogICAgICAgIEVpdGhlciBgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSYCBvclxuICogICAgICAgIGBTb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUmAuIFNwZWNpZmllcyB3aGV0aGVyIHlvdSB3YW50IHRvXG4gKiAgICAgICAgaXRlcmF0ZSBvdmVyIHRoZSBtYXBwaW5ncyBzb3J0ZWQgYnkgdGhlIGdlbmVyYXRlZCBmaWxlJ3MgbGluZS9jb2x1bW5cbiAqICAgICAgICBvcmRlciBvciB0aGUgb3JpZ2luYWwncyBzb3VyY2UvbGluZS9jb2x1bW4gb3JkZXIsIHJlc3BlY3RpdmVseS4gRGVmYXVsdHMgdG9cbiAqICAgICAgICBgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSYC5cbiAqL1xuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmVhY2hNYXBwaW5nID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZWFjaE1hcHBpbmcoYUNhbGxiYWNrLCBhQ29udGV4dCwgYU9yZGVyKSB7XG4gICAgdmFyIGNvbnRleHQgPSBhQ29udGV4dCB8fCBudWxsO1xuICAgIHZhciBvcmRlciA9IGFPcmRlciB8fCBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVI7XG5cbiAgICB2YXIgbWFwcGluZ3M7XG4gICAgc3dpdGNoIChvcmRlcikge1xuICAgIGNhc2UgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSOlxuICAgICAgbWFwcGluZ3MgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVI6XG4gICAgICBtYXBwaW5ncyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3M7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvcmRlciBvZiBpdGVyYXRpb24uXCIpO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2VSb290ID0gdGhpcy5zb3VyY2VSb290O1xuICAgIG1hcHBpbmdzLm1hcChmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgdmFyIHNvdXJjZSA9IG1hcHBpbmcuc291cmNlID09PSBudWxsID8gbnVsbCA6IHRoaXMuX3NvdXJjZXMuYXQobWFwcGluZy5zb3VyY2UpO1xuICAgICAgc291cmNlID0gdXRpbC5jb21wdXRlU291cmNlVVJMKHNvdXJjZVJvb3QsIHNvdXJjZSwgdGhpcy5fc291cmNlTWFwVVJMKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICBnZW5lcmF0ZWRMaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUsXG4gICAgICAgIGdlbmVyYXRlZENvbHVtbjogbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4sXG4gICAgICAgIG9yaWdpbmFsTGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgIG9yaWdpbmFsQ29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICBuYW1lOiBtYXBwaW5nLm5hbWUgPT09IG51bGwgPyBudWxsIDogdGhpcy5fbmFtZXMuYXQobWFwcGluZy5uYW1lKVxuICAgICAgfTtcbiAgICB9LCB0aGlzKS5mb3JFYWNoKGFDYWxsYmFjaywgY29udGV4dCk7XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyBhbGwgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIG9yaWdpbmFsIHNvdXJjZSxcbiAqIGxpbmUsIGFuZCBjb2x1bW4gcHJvdmlkZWQuIElmIG5vIGNvbHVtbiBpcyBwcm92aWRlZCwgcmV0dXJucyBhbGwgbWFwcGluZ3NcbiAqIGNvcnJlc3BvbmRpbmcgdG8gYSBlaXRoZXIgdGhlIGxpbmUgd2UgYXJlIHNlYXJjaGluZyBmb3Igb3IgdGhlIG5leHRcbiAqIGNsb3Nlc3QgbGluZSB0aGF0IGhhcyBhbnkgbWFwcGluZ3MuIE90aGVyd2lzZSwgcmV0dXJucyBhbGwgbWFwcGluZ3NcbiAqIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGxpbmUgYW5kIGVpdGhlciB0aGUgY29sdW1uIHdlIGFyZSBzZWFyY2hpbmcgZm9yXG4gKiBvciB0aGUgbmV4dCBjbG9zZXN0IGNvbHVtbiB0aGF0IGhhcyBhbnkgb2Zmc2V0cy5cbiAqXG4gKiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIHNvdXJjZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuICBUaGUgbGluZSBudW1iZXIgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IE9wdGlvbmFsLiB0aGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAgVGhlIGNvbHVtbiBudW1iZXIgaXMgMC1iYXNlZC5cbiAqXG4gKiBhbmQgYW4gYXJyYXkgb2Ygb2JqZWN0cyBpcyByZXR1cm5lZCwgZWFjaCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLiAgVGhlXG4gKiAgICBsaW5lIG51bWJlciBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgICBUaGUgY29sdW1uIG51bWJlciBpcyAwLWJhc2VkLlxuICovXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuYWxsR2VuZXJhdGVkUG9zaXRpb25zRm9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfYWxsR2VuZXJhdGVkUG9zaXRpb25zRm9yKGFBcmdzKSB7XG4gICAgdmFyIGxpbmUgPSB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKTtcblxuICAgIC8vIFdoZW4gdGhlcmUgaXMgbm8gZXhhY3QgbWF0Y2gsIEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9maW5kTWFwcGluZ1xuICAgIC8vIHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBjbG9zZXN0IG1hcHBpbmcgbGVzcyB0aGFuIHRoZSBuZWVkbGUuIEJ5XG4gICAgLy8gc2V0dGluZyBuZWVkbGUub3JpZ2luYWxDb2x1bW4gdG8gMCwgd2UgdGh1cyBmaW5kIHRoZSBsYXN0IG1hcHBpbmcgZm9yXG4gICAgLy8gdGhlIGdpdmVuIGxpbmUsIHByb3ZpZGVkIHN1Y2ggYSBtYXBwaW5nIGV4aXN0cy5cbiAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgc291cmNlOiB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScpLFxuICAgICAgb3JpZ2luYWxMaW5lOiBsaW5lLFxuICAgICAgb3JpZ2luYWxDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJywgMClcbiAgICB9O1xuXG4gICAgbmVlZGxlLnNvdXJjZSA9IHRoaXMuX2ZpbmRTb3VyY2VJbmRleChuZWVkbGUuc291cmNlKTtcbiAgICBpZiAobmVlZGxlLnNvdXJjZSA8IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICB2YXIgbWFwcGluZ3MgPSBbXTtcblxuICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRNYXBwaW5nKG5lZWRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3JpZ2luYWxMaW5lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvcmlnaW5hbENvbHVtblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmluYXJ5U2VhcmNoLkxFQVNUX1VQUEVSX0JPVU5EKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgaWYgKGFBcmdzLmNvbHVtbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBvcmlnaW5hbExpbmUgPSBtYXBwaW5nLm9yaWdpbmFsTGluZTtcblxuICAgICAgICAvLyBJdGVyYXRlIHVudGlsIGVpdGhlciB3ZSBydW4gb3V0IG9mIG1hcHBpbmdzLCBvciB3ZSBydW4gaW50b1xuICAgICAgICAvLyBhIG1hcHBpbmcgZm9yIGEgZGlmZmVyZW50IGxpbmUgdGhhbiB0aGUgb25lIHdlIGZvdW5kLiBTaW5jZVxuICAgICAgICAvLyBtYXBwaW5ncyBhcmUgc29ydGVkLCB0aGlzIGlzIGd1YXJhbnRlZWQgdG8gZmluZCBhbGwgbWFwcGluZ3MgZm9yXG4gICAgICAgIC8vIHRoZSBsaW5lIHdlIGZvdW5kLlxuICAgICAgICB3aGlsZSAobWFwcGluZyAmJiBtYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gb3JpZ2luYWxMaW5lKSB7XG4gICAgICAgICAgbWFwcGluZ3MucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkTGluZScsIG51bGwpLFxuICAgICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgICBsYXN0Q29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbGFzdEdlbmVyYXRlZENvbHVtbicsIG51bGwpXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1srK2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsQ29sdW1uID0gbWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICAvLyBJdGVyYXRlIHVudGlsIGVpdGhlciB3ZSBydW4gb3V0IG9mIG1hcHBpbmdzLCBvciB3ZSBydW4gaW50b1xuICAgICAgICAvLyBhIG1hcHBpbmcgZm9yIGEgZGlmZmVyZW50IGxpbmUgdGhhbiB0aGUgb25lIHdlIHdlcmUgc2VhcmNoaW5nIGZvci5cbiAgICAgICAgLy8gU2luY2UgbWFwcGluZ3MgYXJlIHNvcnRlZCwgdGhpcyBpcyBndWFyYW50ZWVkIHRvIGZpbmQgYWxsIG1hcHBpbmdzIGZvclxuICAgICAgICAvLyB0aGUgbGluZSB3ZSBhcmUgc2VhcmNoaW5nIGZvci5cbiAgICAgICAgd2hpbGUgKG1hcHBpbmcgJiZcbiAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID09PSBsaW5lICYmXG4gICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uID09IG9yaWdpbmFsQ29sdW1uKSB7XG4gICAgICAgICAgbWFwcGluZ3MucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkTGluZScsIG51bGwpLFxuICAgICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgICBsYXN0Q29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbGFzdEdlbmVyYXRlZENvbHVtbicsIG51bGwpXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1srK2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXBwaW5ncztcbiAgfTtcblxuZXhwb3J0cy5Tb3VyY2VNYXBDb25zdW1lciA9IFNvdXJjZU1hcENvbnN1bWVyO1xuXG4vKipcbiAqIEEgQmFzaWNTb3VyY2VNYXBDb25zdW1lciBpbnN0YW5jZSByZXByZXNlbnRzIGEgcGFyc2VkIHNvdXJjZSBtYXAgd2hpY2ggd2UgY2FuXG4gKiBxdWVyeSBmb3IgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9yaWdpbmFsIGZpbGUgcG9zaXRpb25zIGJ5IGdpdmluZyBpdCBhIGZpbGVcbiAqIHBvc2l0aW9uIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICpcbiAqIFRoZSBmaXJzdCBwYXJhbWV0ZXIgaXMgdGhlIHJhdyBzb3VyY2UgbWFwIChlaXRoZXIgYXMgYSBKU09OIHN0cmluZywgb3JcbiAqIGFscmVhZHkgcGFyc2VkIHRvIGFuIG9iamVjdCkuIEFjY29yZGluZyB0byB0aGUgc3BlYywgc291cmNlIG1hcHMgaGF2ZSB0aGVcbiAqIGZvbGxvd2luZyBhdHRyaWJ1dGVzOlxuICpcbiAqICAgLSB2ZXJzaW9uOiBXaGljaCB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwIHNwZWMgdGhpcyBtYXAgaXMgZm9sbG93aW5nLlxuICogICAtIHNvdXJjZXM6IEFuIGFycmF5IG9mIFVSTHMgdG8gdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlcy5cbiAqICAgLSBuYW1lczogQW4gYXJyYXkgb2YgaWRlbnRpZmllcnMgd2hpY2ggY2FuIGJlIHJlZmVycmVuY2VkIGJ5IGluZGl2aWR1YWwgbWFwcGluZ3MuXG4gKiAgIC0gc291cmNlUm9vdDogT3B0aW9uYWwuIFRoZSBVUkwgcm9vdCBmcm9tIHdoaWNoIGFsbCBzb3VyY2VzIGFyZSByZWxhdGl2ZS5cbiAqICAgLSBzb3VyY2VzQ29udGVudDogT3B0aW9uYWwuIEFuIGFycmF5IG9mIGNvbnRlbnRzIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZXMuXG4gKiAgIC0gbWFwcGluZ3M6IEEgc3RyaW5nIG9mIGJhc2U2NCBWTFFzIHdoaWNoIGNvbnRhaW4gdGhlIGFjdHVhbCBtYXBwaW5ncy5cbiAqICAgLSBmaWxlOiBPcHRpb25hbC4gVGhlIGdlbmVyYXRlZCBmaWxlIHRoaXMgc291cmNlIG1hcCBpcyBhc3NvY2lhdGVkIHdpdGguXG4gKlxuICogSGVyZSBpcyBhbiBleGFtcGxlIHNvdXJjZSBtYXAsIHRha2VuIGZyb20gdGhlIHNvdXJjZSBtYXAgc3BlY1swXTpcbiAqXG4gKiAgICAge1xuICogICAgICAgdmVyc2lvbiA6IDMsXG4gKiAgICAgICBmaWxlOiBcIm91dC5qc1wiLFxuICogICAgICAgc291cmNlUm9vdCA6IFwiXCIsXG4gKiAgICAgICBzb3VyY2VzOiBbXCJmb28uanNcIiwgXCJiYXIuanNcIl0sXG4gKiAgICAgICBuYW1lczogW1wic3JjXCIsIFwibWFwc1wiLCBcImFyZVwiLCBcImZ1blwiXSxcbiAqICAgICAgIG1hcHBpbmdzOiBcIkFBLEFCOztBQkNERTtcIlxuICogICAgIH1cbiAqXG4gKiBUaGUgc2Vjb25kIHBhcmFtZXRlciwgaWYgZ2l2ZW4sIGlzIGEgc3RyaW5nIHdob3NlIHZhbHVlIGlzIHRoZSBVUkxcbiAqIGF0IHdoaWNoIHRoZSBzb3VyY2UgbWFwIHdhcyBmb3VuZC4gIFRoaXMgVVJMIGlzIHVzZWQgdG8gY29tcHV0ZSB0aGVcbiAqIHNvdXJjZXMgYXJyYXkuXG4gKlxuICogWzBdOiBodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9kb2N1bWVudC9kLzFVMVJHQWVoUXdSeXBVVG92RjFLUmxwaU9GemUwYi1fMmdjNmZBSDBLWTBrL2VkaXQ/cGxpPTEjXG4gKi9cbmZ1bmN0aW9uIEJhc2ljU291cmNlTWFwQ29uc3VtZXIoYVNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCkge1xuICB2YXIgc291cmNlTWFwID0gYVNvdXJjZU1hcDtcbiAgaWYgKHR5cGVvZiBhU291cmNlTWFwID09PSAnc3RyaW5nJykge1xuICAgIHNvdXJjZU1hcCA9IHV0aWwucGFyc2VTb3VyY2VNYXBJbnB1dChhU291cmNlTWFwKTtcbiAgfVxuXG4gIHZhciB2ZXJzaW9uID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAndmVyc2lvbicpO1xuICB2YXIgc291cmNlcyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZXMnKTtcbiAgLy8gU2FzcyAzLjMgbGVhdmVzIG91dCB0aGUgJ25hbWVzJyBhcnJheSwgc28gd2UgZGV2aWF0ZSBmcm9tIHRoZSBzcGVjICh3aGljaFxuICAvLyByZXF1aXJlcyB0aGUgYXJyYXkpIHRvIHBsYXkgbmljZSBoZXJlLlxuICB2YXIgbmFtZXMgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICduYW1lcycsIFtdKTtcbiAgdmFyIHNvdXJjZVJvb3QgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzb3VyY2VSb290JywgbnVsbCk7XG4gIHZhciBzb3VyY2VzQ29udGVudCA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZXNDb250ZW50JywgbnVsbCk7XG4gIHZhciBtYXBwaW5ncyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ21hcHBpbmdzJyk7XG4gIHZhciBmaWxlID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnZmlsZScsIG51bGwpO1xuXG4gIC8vIE9uY2UgYWdhaW4sIFNhc3MgZGV2aWF0ZXMgZnJvbSB0aGUgc3BlYyBhbmQgc3VwcGxpZXMgdGhlIHZlcnNpb24gYXMgYVxuICAvLyBzdHJpbmcgcmF0aGVyIHRoYW4gYSBudW1iZXIsIHNvIHdlIHVzZSBsb29zZSBlcXVhbGl0eSBjaGVja2luZyBoZXJlLlxuICBpZiAodmVyc2lvbiAhPSB0aGlzLl92ZXJzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB2ZXJzaW9uOiAnICsgdmVyc2lvbik7XG4gIH1cblxuICBpZiAoc291cmNlUm9vdCkge1xuICAgIHNvdXJjZVJvb3QgPSB1dGlsLm5vcm1hbGl6ZShzb3VyY2VSb290KTtcbiAgfVxuXG4gIHNvdXJjZXMgPSBzb3VyY2VzXG4gICAgLm1hcChTdHJpbmcpXG4gICAgLy8gU29tZSBzb3VyY2UgbWFwcyBwcm9kdWNlIHJlbGF0aXZlIHNvdXJjZSBwYXRocyBsaWtlIFwiLi9mb28uanNcIiBpbnN0ZWFkIG9mXG4gICAgLy8gXCJmb28uanNcIi4gIE5vcm1hbGl6ZSB0aGVzZSBmaXJzdCBzbyB0aGF0IGZ1dHVyZSBjb21wYXJpc29ucyB3aWxsIHN1Y2NlZWQuXG4gICAgLy8gU2VlIGJ1Z3ppbC5sYS8xMDkwNzY4LlxuICAgIC5tYXAodXRpbC5ub3JtYWxpemUpXG4gICAgLy8gQWx3YXlzIGVuc3VyZSB0aGF0IGFic29sdXRlIHNvdXJjZXMgYXJlIGludGVybmFsbHkgc3RvcmVkIHJlbGF0aXZlIHRvXG4gICAgLy8gdGhlIHNvdXJjZSByb290LCBpZiB0aGUgc291cmNlIHJvb3QgaXMgYWJzb2x1dGUuIE5vdCBkb2luZyB0aGlzIHdvdWxkXG4gICAgLy8gYmUgcGFydGljdWxhcmx5IHByb2JsZW1hdGljIHdoZW4gdGhlIHNvdXJjZSByb290IGlzIGEgcHJlZml4IG9mIHRoZVxuICAgIC8vIHNvdXJjZSAodmFsaWQsIGJ1dCB3aHk/PykuIFNlZSBnaXRodWIgaXNzdWUgIzE5OSBhbmQgYnVnemlsLmxhLzExODg5ODIuXG4gICAgLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gc291cmNlUm9vdCAmJiB1dGlsLmlzQWJzb2x1dGUoc291cmNlUm9vdCkgJiYgdXRpbC5pc0Fic29sdXRlKHNvdXJjZSlcbiAgICAgICAgPyB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZSlcbiAgICAgICAgOiBzb3VyY2U7XG4gICAgfSk7XG5cbiAgLy8gUGFzcyBgdHJ1ZWAgYmVsb3cgdG8gYWxsb3cgZHVwbGljYXRlIG5hbWVzIGFuZCBzb3VyY2VzLiBXaGlsZSBzb3VyY2UgbWFwc1xuICAvLyBhcmUgaW50ZW5kZWQgdG8gYmUgY29tcHJlc3NlZCBhbmQgZGVkdXBsaWNhdGVkLCB0aGUgVHlwZVNjcmlwdCBjb21waWxlclxuICAvLyBzb21ldGltZXMgZ2VuZXJhdGVzIHNvdXJjZSBtYXBzIHdpdGggZHVwbGljYXRlcyBpbiB0aGVtLiBTZWUgR2l0aHViIGlzc3VlXG4gIC8vICM3MiBhbmQgYnVnemlsLmxhLzg4OTQ5Mi5cbiAgdGhpcy5fbmFtZXMgPSBBcnJheVNldC5mcm9tQXJyYXkobmFtZXMubWFwKFN0cmluZyksIHRydWUpO1xuICB0aGlzLl9zb3VyY2VzID0gQXJyYXlTZXQuZnJvbUFycmF5KHNvdXJjZXMsIHRydWUpO1xuXG4gIHRoaXMuX2Fic29sdXRlU291cmNlcyA9IHRoaXMuX3NvdXJjZXMudG9BcnJheSgpLm1hcChmdW5jdGlvbiAocykge1xuICAgIHJldHVybiB1dGlsLmNvbXB1dGVTb3VyY2VVUkwoc291cmNlUm9vdCwgcywgYVNvdXJjZU1hcFVSTCk7XG4gIH0pO1xuXG4gIHRoaXMuc291cmNlUm9vdCA9IHNvdXJjZVJvb3Q7XG4gIHRoaXMuc291cmNlc0NvbnRlbnQgPSBzb3VyY2VzQ29udGVudDtcbiAgdGhpcy5fbWFwcGluZ3MgPSBtYXBwaW5ncztcbiAgdGhpcy5fc291cmNlTWFwVVJMID0gYVNvdXJjZU1hcFVSTDtcbiAgdGhpcy5maWxlID0gZmlsZTtcbn1cblxuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSk7XG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5jb25zdW1lciA9IFNvdXJjZU1hcENvbnN1bWVyO1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gZmluZCB0aGUgaW5kZXggb2YgYSBzb3VyY2UuICBSZXR1cm5zIC0xIGlmIG5vdFxuICogZm91bmQuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9maW5kU291cmNlSW5kZXggPSBmdW5jdGlvbihhU291cmNlKSB7XG4gIHZhciByZWxhdGl2ZVNvdXJjZSA9IGFTb3VyY2U7XG4gIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgIHJlbGF0aXZlU291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLnNvdXJjZVJvb3QsIHJlbGF0aXZlU291cmNlKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9zb3VyY2VzLmhhcyhyZWxhdGl2ZVNvdXJjZSkpIHtcbiAgICByZXR1cm4gdGhpcy5fc291cmNlcy5pbmRleE9mKHJlbGF0aXZlU291cmNlKTtcbiAgfVxuXG4gIC8vIE1heWJlIGFTb3VyY2UgaXMgYW4gYWJzb2x1dGUgVVJMIGFzIHJldHVybmVkIGJ5IHxzb3VyY2VzfC4gIEluXG4gIC8vIHRoaXMgY2FzZSB3ZSBjYW4ndCBzaW1wbHkgdW5kbyB0aGUgdHJhbnNmb3JtLlxuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IHRoaXMuX2Fic29sdXRlU291cmNlcy5sZW5ndGg7ICsraSkge1xuICAgIGlmICh0aGlzLl9hYnNvbHV0ZVNvdXJjZXNbaV0gPT0gYVNvdXJjZSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyIGZyb20gYSBTb3VyY2VNYXBHZW5lcmF0b3IuXG4gKlxuICogQHBhcmFtIFNvdXJjZU1hcEdlbmVyYXRvciBhU291cmNlTWFwXG4gKiAgICAgICAgVGhlIHNvdXJjZSBtYXAgdGhhdCB3aWxsIGJlIGNvbnN1bWVkLlxuICogQHBhcmFtIFN0cmluZyBhU291cmNlTWFwVVJMXG4gKiAgICAgICAgVGhlIFVSTCBhdCB3aGljaCB0aGUgc291cmNlIG1hcCBjYW4gYmUgZm91bmQgKG9wdGlvbmFsKVxuICogQHJldHVybnMgQmFzaWNTb3VyY2VNYXBDb25zdW1lclxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLmZyb21Tb3VyY2VNYXAgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9mcm9tU291cmNlTWFwKGFTb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpIHtcbiAgICB2YXIgc21jID0gT2JqZWN0LmNyZWF0ZShCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSk7XG5cbiAgICB2YXIgbmFtZXMgPSBzbWMuX25hbWVzID0gQXJyYXlTZXQuZnJvbUFycmF5KGFTb3VyY2VNYXAuX25hbWVzLnRvQXJyYXkoKSwgdHJ1ZSk7XG4gICAgdmFyIHNvdXJjZXMgPSBzbWMuX3NvdXJjZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoYVNvdXJjZU1hcC5fc291cmNlcy50b0FycmF5KCksIHRydWUpO1xuICAgIHNtYy5zb3VyY2VSb290ID0gYVNvdXJjZU1hcC5fc291cmNlUm9vdDtcbiAgICBzbWMuc291cmNlc0NvbnRlbnQgPSBhU291cmNlTWFwLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KHNtYy5fc291cmNlcy50b0FycmF5KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbWMuc291cmNlUm9vdCk7XG4gICAgc21jLmZpbGUgPSBhU291cmNlTWFwLl9maWxlO1xuICAgIHNtYy5fc291cmNlTWFwVVJMID0gYVNvdXJjZU1hcFVSTDtcbiAgICBzbWMuX2Fic29sdXRlU291cmNlcyA9IHNtYy5fc291cmNlcy50b0FycmF5KCkubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICByZXR1cm4gdXRpbC5jb21wdXRlU291cmNlVVJMKHNtYy5zb3VyY2VSb290LCBzLCBhU291cmNlTWFwVVJMKTtcbiAgICB9KTtcblxuICAgIC8vIEJlY2F1c2Ugd2UgYXJlIG1vZGlmeWluZyB0aGUgZW50cmllcyAoYnkgY29udmVydGluZyBzdHJpbmcgc291cmNlcyBhbmRcbiAgICAvLyBuYW1lcyB0byBpbmRpY2VzIGludG8gdGhlIHNvdXJjZXMgYW5kIG5hbWVzIEFycmF5U2V0cyksIHdlIGhhdmUgdG8gbWFrZVxuICAgIC8vIGEgY29weSBvZiB0aGUgZW50cnkgb3IgZWxzZSBiYWQgdGhpbmdzIGhhcHBlbi4gU2hhcmVkIG11dGFibGUgc3RhdGVcbiAgICAvLyBzdHJpa2VzIGFnYWluISBTZWUgZ2l0aHViIGlzc3VlICMxOTEuXG5cbiAgICB2YXIgZ2VuZXJhdGVkTWFwcGluZ3MgPSBhU291cmNlTWFwLl9tYXBwaW5ncy50b0FycmF5KCkuc2xpY2UoKTtcbiAgICB2YXIgZGVzdEdlbmVyYXRlZE1hcHBpbmdzID0gc21jLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBbXTtcbiAgICB2YXIgZGVzdE9yaWdpbmFsTWFwcGluZ3MgPSBzbWMuX19vcmlnaW5hbE1hcHBpbmdzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZ2VuZXJhdGVkTWFwcGluZ3MubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzcmNNYXBwaW5nID0gZ2VuZXJhdGVkTWFwcGluZ3NbaV07XG4gICAgICB2YXIgZGVzdE1hcHBpbmcgPSBuZXcgTWFwcGluZztcbiAgICAgIGRlc3RNYXBwaW5nLmdlbmVyYXRlZExpbmUgPSBzcmNNYXBwaW5nLmdlbmVyYXRlZExpbmU7XG4gICAgICBkZXN0TWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gPSBzcmNNYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcblxuICAgICAgaWYgKHNyY01hcHBpbmcuc291cmNlKSB7XG4gICAgICAgIGRlc3RNYXBwaW5nLnNvdXJjZSA9IHNvdXJjZXMuaW5kZXhPZihzcmNNYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgIGRlc3RNYXBwaW5nLm9yaWdpbmFsTGluZSA9IHNyY01hcHBpbmcub3JpZ2luYWxMaW5lO1xuICAgICAgICBkZXN0TWFwcGluZy5vcmlnaW5hbENvbHVtbiA9IHNyY01hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgaWYgKHNyY01hcHBpbmcubmFtZSkge1xuICAgICAgICAgIGRlc3RNYXBwaW5nLm5hbWUgPSBuYW1lcy5pbmRleE9mKHNyY01hcHBpbmcubmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBkZXN0T3JpZ2luYWxNYXBwaW5ncy5wdXNoKGRlc3RNYXBwaW5nKTtcbiAgICAgIH1cblxuICAgICAgZGVzdEdlbmVyYXRlZE1hcHBpbmdzLnB1c2goZGVzdE1hcHBpbmcpO1xuICAgIH1cblxuICAgIHF1aWNrU29ydChzbWMuX19vcmlnaW5hbE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcblxuICAgIHJldHVybiBzbWM7XG4gIH07XG5cbi8qKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXBwaW5nIHNwZWMgdGhhdCB3ZSBhcmUgY29uc3VtaW5nLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbi8qKlxuICogVGhlIGxpc3Qgb2Ygb3JpZ2luYWwgc291cmNlcy5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnc291cmNlcycsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Fic29sdXRlU291cmNlcy5zbGljZSgpO1xuICB9XG59KTtcblxuLyoqXG4gKiBQcm92aWRlIHRoZSBKSVQgd2l0aCBhIG5pY2Ugc2hhcGUgLyBoaWRkZW4gY2xhc3MuXG4gKi9cbmZ1bmN0aW9uIE1hcHBpbmcoKSB7XG4gIHRoaXMuZ2VuZXJhdGVkTGluZSA9IDA7XG4gIHRoaXMuZ2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgdGhpcy5zb3VyY2UgPSBudWxsO1xuICB0aGlzLm9yaWdpbmFsTGluZSA9IG51bGw7XG4gIHRoaXMub3JpZ2luYWxDb2x1bW4gPSBudWxsO1xuICB0aGlzLm5hbWUgPSBudWxsO1xufVxuXG4vKipcbiAqIFBhcnNlIHRoZSBtYXBwaW5ncyBpbiBhIHN0cmluZyBpbiB0byBhIGRhdGEgc3RydWN0dXJlIHdoaWNoIHdlIGNhbiBlYXNpbHlcbiAqIHF1ZXJ5ICh0aGUgb3JkZXJlZCBhcnJheXMgaW4gdGhlIGB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3BhcnNlTWFwcGluZ3MgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgdmFyIGdlbmVyYXRlZExpbmUgPSAxO1xuICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgdmFyIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gMDtcbiAgICB2YXIgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IDA7XG4gICAgdmFyIHByZXZpb3VzU291cmNlID0gMDtcbiAgICB2YXIgcHJldmlvdXNOYW1lID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gYVN0ci5sZW5ndGg7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgY2FjaGVkU2VnbWVudHMgPSB7fTtcbiAgICB2YXIgdGVtcCA9IHt9O1xuICAgIHZhciBvcmlnaW5hbE1hcHBpbmdzID0gW107XG4gICAgdmFyIGdlbmVyYXRlZE1hcHBpbmdzID0gW107XG4gICAgdmFyIG1hcHBpbmcsIHN0ciwgc2VnbWVudCwgZW5kLCB2YWx1ZTtcblxuICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGFTdHIuY2hhckF0KGluZGV4KSA9PT0gJzsnKSB7XG4gICAgICAgIGdlbmVyYXRlZExpbmUrKztcbiAgICAgICAgaW5kZXgrKztcbiAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYVN0ci5jaGFyQXQoaW5kZXgpID09PSAnLCcpIHtcbiAgICAgICAgaW5kZXgrKztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBtYXBwaW5nID0gbmV3IE1hcHBpbmcoKTtcbiAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWRMaW5lID0gZ2VuZXJhdGVkTGluZTtcblxuICAgICAgICAvLyBCZWNhdXNlIGVhY2ggb2Zmc2V0IGlzIGVuY29kZWQgcmVsYXRpdmUgdG8gdGhlIHByZXZpb3VzIG9uZSxcbiAgICAgICAgLy8gbWFueSBzZWdtZW50cyBvZnRlbiBoYXZlIHRoZSBzYW1lIGVuY29kaW5nLiBXZSBjYW4gZXhwbG9pdCB0aGlzXG4gICAgICAgIC8vIGZhY3QgYnkgY2FjaGluZyB0aGUgcGFyc2VkIHZhcmlhYmxlIGxlbmd0aCBmaWVsZHMgb2YgZWFjaCBzZWdtZW50LFxuICAgICAgICAvLyBhbGxvd2luZyB1cyB0byBhdm9pZCBhIHNlY29uZCBwYXJzZSBpZiB3ZSBlbmNvdW50ZXIgdGhlIHNhbWVcbiAgICAgICAgLy8gc2VnbWVudCBhZ2Fpbi5cbiAgICAgICAgZm9yIChlbmQgPSBpbmRleDsgZW5kIDwgbGVuZ3RoOyBlbmQrKykge1xuICAgICAgICAgIGlmICh0aGlzLl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yKGFTdHIsIGVuZCkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdHIgPSBhU3RyLnNsaWNlKGluZGV4LCBlbmQpO1xuXG4gICAgICAgIHNlZ21lbnQgPSBjYWNoZWRTZWdtZW50c1tzdHJdO1xuICAgICAgICBpZiAoc2VnbWVudCkge1xuICAgICAgICAgIGluZGV4ICs9IHN0ci5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VnbWVudCA9IFtdO1xuICAgICAgICAgIHdoaWxlIChpbmRleCA8IGVuZCkge1xuICAgICAgICAgICAgYmFzZTY0VkxRLmRlY29kZShhU3RyLCBpbmRleCwgdGVtcCk7XG4gICAgICAgICAgICB2YWx1ZSA9IHRlbXAudmFsdWU7XG4gICAgICAgICAgICBpbmRleCA9IHRlbXAucmVzdDtcbiAgICAgICAgICAgIHNlZ21lbnQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIGEgc291cmNlLCBidXQgbm8gbGluZSBhbmQgY29sdW1uJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIGEgc291cmNlIGFuZCBsaW5lLCBidXQgbm8gY29sdW1uJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FjaGVkU2VnbWVudHNbc3RyXSA9IHNlZ21lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZW5lcmF0ZWQgY29sdW1uLlxuICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiA9IHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uICsgc2VnbWVudFswXTtcbiAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcblxuICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgLy8gT3JpZ2luYWwgc291cmNlLlxuICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gcHJldmlvdXNTb3VyY2UgKyBzZWdtZW50WzFdO1xuICAgICAgICAgIHByZXZpb3VzU291cmNlICs9IHNlZ21lbnRbMV07XG5cbiAgICAgICAgICAvLyBPcmlnaW5hbCBsaW5lLlxuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID0gcHJldmlvdXNPcmlnaW5hbExpbmUgKyBzZWdtZW50WzJdO1xuICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gbWFwcGluZy5vcmlnaW5hbExpbmU7XG4gICAgICAgICAgLy8gTGluZXMgYXJlIHN0b3JlZCAwLWJhc2VkXG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgKz0gMTtcblxuICAgICAgICAgIC8vIE9yaWdpbmFsIGNvbHVtbi5cbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uID0gcHJldmlvdXNPcmlnaW5hbENvbHVtbiArIHNlZ21lbnRbM107XG4gICAgICAgICAgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IG1hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPiA0KSB7XG4gICAgICAgICAgICAvLyBPcmlnaW5hbCBuYW1lLlxuICAgICAgICAgICAgbWFwcGluZy5uYW1lID0gcHJldmlvdXNOYW1lICsgc2VnbWVudFs0XTtcbiAgICAgICAgICAgIHByZXZpb3VzTmFtZSArPSBzZWdtZW50WzRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdlbmVyYXRlZE1hcHBpbmdzLnB1c2gobWFwcGluZyk7XG4gICAgICAgIGlmICh0eXBlb2YgbWFwcGluZy5vcmlnaW5hbExpbmUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgb3JpZ2luYWxNYXBwaW5ncy5wdXNoKG1hcHBpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcXVpY2tTb3J0KGdlbmVyYXRlZE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkKTtcbiAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBnZW5lcmF0ZWRNYXBwaW5ncztcblxuICAgIHF1aWNrU29ydChvcmlnaW5hbE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncyA9IG9yaWdpbmFsTWFwcGluZ3M7XG4gIH07XG5cbi8qKlxuICogRmluZCB0aGUgbWFwcGluZyB0aGF0IGJlc3QgbWF0Y2hlcyB0aGUgaHlwb3RoZXRpY2FsIFwibmVlZGxlXCIgbWFwcGluZyB0aGF0XG4gKiB3ZSBhcmUgc2VhcmNoaW5nIGZvciBpbiB0aGUgZ2l2ZW4gXCJoYXlzdGFja1wiIG9mIG1hcHBpbmdzLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fZmluZE1hcHBpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9maW5kTWFwcGluZyhhTmVlZGxlLCBhTWFwcGluZ3MsIGFMaW5lTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYUNvbHVtbk5hbWUsIGFDb21wYXJhdG9yLCBhQmlhcykge1xuICAgIC8vIFRvIHJldHVybiB0aGUgcG9zaXRpb24gd2UgYXJlIHNlYXJjaGluZyBmb3IsIHdlIG11c3QgZmlyc3QgZmluZCB0aGVcbiAgICAvLyBtYXBwaW5nIGZvciB0aGUgZ2l2ZW4gcG9zaXRpb24gYW5kIHRoZW4gcmV0dXJuIHRoZSBvcHBvc2l0ZSBwb3NpdGlvbiBpdFxuICAgIC8vIHBvaW50cyB0by4gQmVjYXVzZSB0aGUgbWFwcGluZ3MgYXJlIHNvcnRlZCwgd2UgY2FuIHVzZSBiaW5hcnkgc2VhcmNoIHRvXG4gICAgLy8gZmluZCB0aGUgYmVzdCBtYXBwaW5nLlxuXG4gICAgaWYgKGFOZWVkbGVbYUxpbmVOYW1lXSA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdMaW5lIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEsIGdvdCAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICsgYU5lZWRsZVthTGluZU5hbWVdKTtcbiAgICB9XG4gICAgaWYgKGFOZWVkbGVbYUNvbHVtbk5hbWVdIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ29sdW1uIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDAsIGdvdCAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICsgYU5lZWRsZVthQ29sdW1uTmFtZV0pO1xuICAgIH1cblxuICAgIHJldHVybiBiaW5hcnlTZWFyY2guc2VhcmNoKGFOZWVkbGUsIGFNYXBwaW5ncywgYUNvbXBhcmF0b3IsIGFCaWFzKTtcbiAgfTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBsYXN0IGNvbHVtbiBmb3IgZWFjaCBnZW5lcmF0ZWQgbWFwcGluZy4gVGhlIGxhc3QgY29sdW1uIGlzXG4gKiBpbmNsdXNpdmUuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmNvbXB1dGVDb2x1bW5TcGFucyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2NvbXB1dGVDb2x1bW5TcGFucygpIHtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3MubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgLy8gTWFwcGluZ3MgZG8gbm90IGNvbnRhaW4gYSBmaWVsZCBmb3IgdGhlIGxhc3QgZ2VuZXJhdGVkIGNvbHVtbnQuIFdlXG4gICAgICAvLyBjYW4gY29tZSB1cCB3aXRoIGFuIG9wdGltaXN0aWMgZXN0aW1hdGUsIGhvd2V2ZXIsIGJ5IGFzc3VtaW5nIHRoYXRcbiAgICAgIC8vIG1hcHBpbmdzIGFyZSBjb250aWd1b3VzIChpLmUuIGdpdmVuIHR3byBjb25zZWN1dGl2ZSBtYXBwaW5ncywgdGhlXG4gICAgICAvLyBmaXJzdCBtYXBwaW5nIGVuZHMgd2hlcmUgdGhlIHNlY29uZCBvbmUgc3RhcnRzKS5cbiAgICAgIGlmIChpbmRleCArIDEgPCB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5leHRNYXBwaW5nID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXggKyAxXTtcblxuICAgICAgICBpZiAobWFwcGluZy5nZW5lcmF0ZWRMaW5lID09PSBuZXh0TWFwcGluZy5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgbWFwcGluZy5sYXN0R2VuZXJhdGVkQ29sdW1uID0gbmV4dE1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uIC0gMTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgbGFzdCBtYXBwaW5nIGZvciBlYWNoIGxpbmUgc3BhbnMgdGhlIGVudGlyZSBsaW5lLlxuICAgICAgbWFwcGluZy5sYXN0R2VuZXJhdGVkQ29sdW1uID0gSW5maW5pdHk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSwgbGluZSwgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIGdlbmVyYXRlZFxuICogc291cmNlJ3MgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0XG4gKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLiAgVGhlIGxpbmUgbnVtYmVyXG4gKiAgICAgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLiAgVGhlIGNvbHVtblxuICogICAgIG51bWJlciBpcyAwLWJhc2VkLlxuICogICAtIGJpYXM6IEVpdGhlciAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gKiAgICAgJ1NvdXJjZU1hcENvbnN1bWVyLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAqICAgICBEZWZhdWx0cyB0byAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnLlxuICpcbiAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIHNvdXJjZTogVGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlLCBvciBudWxsLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLiAgVGhlXG4gKiAgICAgbGluZSBudW1iZXIgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAqICAgICBjb2x1bW4gbnVtYmVyIGlzIDAtYmFzZWQuXG4gKiAgIC0gbmFtZTogVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIsIG9yIG51bGwuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLm9yaWdpbmFsUG9zaXRpb25Gb3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9vcmlnaW5hbFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgIGdlbmVyYXRlZExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgZ2VuZXJhdGVkQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicpXG4gICAgfTtcblxuICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRNYXBwaW5nKFxuICAgICAgbmVlZGxlLFxuICAgICAgdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3MsXG4gICAgICBcImdlbmVyYXRlZExpbmVcIixcbiAgICAgIFwiZ2VuZXJhdGVkQ29sdW1uXCIsXG4gICAgICB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkLFxuICAgICAgdXRpbC5nZXRBcmcoYUFyZ3MsICdiaWFzJywgU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQpXG4gICAgKTtcblxuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9PT0gbmVlZGxlLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdzb3VyY2UnLCBudWxsKTtcbiAgICAgICAgaWYgKHNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuYXQoc291cmNlKTtcbiAgICAgICAgICBzb3VyY2UgPSB1dGlsLmNvbXB1dGVTb3VyY2VVUkwodGhpcy5zb3VyY2VSb290LCBzb3VyY2UsIHRoaXMuX3NvdXJjZU1hcFVSTCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5hbWUgPSB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbmFtZScsIG51bGwpO1xuICAgICAgICBpZiAobmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIG5hbWUgPSB0aGlzLl9uYW1lcy5hdChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdvcmlnaW5hbExpbmUnLCBudWxsKSxcbiAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdvcmlnaW5hbENvbHVtbicsIG51bGwpLFxuICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc291cmNlOiBudWxsLFxuICAgICAgbGluZTogbnVsbCxcbiAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgIG5hbWU6IG51bGxcbiAgICB9O1xuICB9O1xuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHdlIGhhdmUgdGhlIHNvdXJjZSBjb250ZW50IGZvciBldmVyeSBzb3VyY2UgaW4gdGhlIHNvdXJjZVxuICogbWFwLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmhhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzID1cbiAgZnVuY3Rpb24gQmFzaWNTb3VyY2VNYXBDb25zdW1lcl9oYXNDb250ZW50c09mQWxsU291cmNlcygpIHtcbiAgICBpZiAoIXRoaXMuc291cmNlc0NvbnRlbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnQubGVuZ3RoID49IHRoaXMuX3NvdXJjZXMuc2l6ZSgpICYmXG4gICAgICAhdGhpcy5zb3VyY2VzQ29udGVudC5zb21lKGZ1bmN0aW9uIChzYykgeyByZXR1cm4gc2MgPT0gbnVsbDsgfSk7XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlIGNvbnRlbnQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIHRoZSB1cmwgb2YgdGhlXG4gKiBvcmlnaW5hbCBzb3VyY2UgZmlsZS4gUmV0dXJucyBudWxsIGlmIG5vIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50IGlzXG4gKiBhdmFpbGFibGUuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9zb3VyY2VDb250ZW50Rm9yKGFTb3VyY2UsIG51bGxPbk1pc3NpbmcpIHtcbiAgICBpZiAoIXRoaXMuc291cmNlc0NvbnRlbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRTb3VyY2VJbmRleChhU291cmNlKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbaW5kZXhdO1xuICAgIH1cblxuICAgIHZhciByZWxhdGl2ZVNvdXJjZSA9IGFTb3VyY2U7XG4gICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICByZWxhdGl2ZVNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LCByZWxhdGl2ZVNvdXJjZSk7XG4gICAgfVxuXG4gICAgdmFyIHVybDtcbiAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGxcbiAgICAgICAgJiYgKHVybCA9IHV0aWwudXJsUGFyc2UodGhpcy5zb3VyY2VSb290KSkpIHtcbiAgICAgIC8vIFhYWDogZmlsZTovLyBVUklzIGFuZCBhYnNvbHV0ZSBwYXRocyBsZWFkIHRvIHVuZXhwZWN0ZWQgYmVoYXZpb3IgZm9yXG4gICAgICAvLyBtYW55IHVzZXJzLiBXZSBjYW4gaGVscCB0aGVtIG91dCB3aGVuIHRoZXkgZXhwZWN0IGZpbGU6Ly8gVVJJcyB0b1xuICAgICAgLy8gYmVoYXZlIGxpa2UgaXQgd291bGQgaWYgdGhleSB3ZXJlIHJ1bm5pbmcgYSBsb2NhbCBIVFRQIHNlcnZlci4gU2VlXG4gICAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD04ODU1OTcuXG4gICAgICB2YXIgZmlsZVVyaUFic1BhdGggPSByZWxhdGl2ZVNvdXJjZS5yZXBsYWNlKC9eZmlsZTpcXC9cXC8vLCBcIlwiKTtcbiAgICAgIGlmICh1cmwuc2NoZW1lID09IFwiZmlsZVwiXG4gICAgICAgICAgJiYgdGhpcy5fc291cmNlcy5oYXMoZmlsZVVyaUFic1BhdGgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihmaWxlVXJpQWJzUGF0aCldXG4gICAgICB9XG5cbiAgICAgIGlmICgoIXVybC5wYXRoIHx8IHVybC5wYXRoID09IFwiL1wiKVxuICAgICAgICAgICYmIHRoaXMuX3NvdXJjZXMuaGFzKFwiL1wiICsgcmVsYXRpdmVTb3VyY2UpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihcIi9cIiArIHJlbGF0aXZlU291cmNlKV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHJlY3Vyc2l2ZWx5IGZyb21cbiAgICAvLyBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3IuIEluIHRoYXQgY2FzZSwgd2VcbiAgICAvLyBkb24ndCB3YW50IHRvIHRocm93IGlmIHdlIGNhbid0IGZpbmQgdGhlIHNvdXJjZSAtIHdlIGp1c3Qgd2FudCB0b1xuICAgIC8vIHJldHVybiBudWxsLCBzbyB3ZSBwcm92aWRlIGEgZmxhZyB0byBleGl0IGdyYWNlZnVsbHkuXG4gICAgaWYgKG51bGxPbk1pc3NpbmcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgcmVsYXRpdmVTb3VyY2UgKyAnXCIgaXMgbm90IGluIHRoZSBTb3VyY2VNYXAuJyk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsXG4gKiBsaW5lLCBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGhcbiAqIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS4gIFRoZSBsaW5lIG51bWJlclxuICogICAgIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLiAgVGhlIGNvbHVtblxuICogICAgIG51bWJlciBpcyAwLWJhc2VkLlxuICogICAtIGJpYXM6IEVpdGhlciAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gKiAgICAgJ1NvdXJjZU1hcENvbnN1bWVyLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAqICAgICBEZWZhdWx0cyB0byAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnLlxuICpcbiAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC4gIFRoZVxuICogICAgIGxpbmUgbnVtYmVyIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgICBUaGUgY29sdW1uIG51bWJlciBpcyAwLWJhc2VkLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5nZW5lcmF0ZWRQb3NpdGlvbkZvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2dlbmVyYXRlZFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgdmFyIHNvdXJjZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJyk7XG4gICAgc291cmNlID0gdGhpcy5fZmluZFNvdXJjZUluZGV4KHNvdXJjZSk7XG4gICAgaWYgKHNvdXJjZSA8IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgICAgbGFzdENvbHVtbjogbnVsbFxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICBvcmlnaW5hbExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgb3JpZ2luYWxDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJylcbiAgICB9O1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcoXG4gICAgICBuZWVkbGUsXG4gICAgICB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzLFxuICAgICAgXCJvcmlnaW5hbExpbmVcIixcbiAgICAgIFwib3JpZ2luYWxDb2x1bW5cIixcbiAgICAgIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMsXG4gICAgICB1dGlsLmdldEFyZyhhQXJncywgJ2JpYXMnLCBTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORClcbiAgICApO1xuXG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSA9PT0gbmVlZGxlLnNvdXJjZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgbGFzdENvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLCBudWxsKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBsaW5lOiBudWxsLFxuICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgbGFzdENvbHVtbjogbnVsbFxuICAgIH07XG4gIH07XG5cbmV4cG9ydHMuQmFzaWNTb3VyY2VNYXBDb25zdW1lciA9IEJhc2ljU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogQW4gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyIGluc3RhbmNlIHJlcHJlc2VudHMgYSBwYXJzZWQgc291cmNlIG1hcCB3aGljaFxuICogd2UgY2FuIHF1ZXJ5IGZvciBpbmZvcm1hdGlvbi4gSXQgZGlmZmVycyBmcm9tIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgaW5cbiAqIHRoYXQgaXQgdGFrZXMgXCJpbmRleGVkXCIgc291cmNlIG1hcHMgKGkuZS4gb25lcyB3aXRoIGEgXCJzZWN0aW9uc1wiIGZpZWxkKSBhc1xuICogaW5wdXQuXG4gKlxuICogVGhlIGZpcnN0IHBhcmFtZXRlciBpcyBhIHJhdyBzb3VyY2UgbWFwIChlaXRoZXIgYXMgYSBKU09OIHN0cmluZywgb3IgYWxyZWFkeVxuICogcGFyc2VkIHRvIGFuIG9iamVjdCkuIEFjY29yZGluZyB0byB0aGUgc3BlYyBmb3IgaW5kZXhlZCBzb3VyY2UgbWFwcywgdGhleVxuICogaGF2ZSB0aGUgZm9sbG93aW5nIGF0dHJpYnV0ZXM6XG4gKlxuICogICAtIHZlcnNpb246IFdoaWNoIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXAgc3BlYyB0aGlzIG1hcCBpcyBmb2xsb3dpbmcuXG4gKiAgIC0gZmlsZTogT3B0aW9uYWwuIFRoZSBnZW5lcmF0ZWQgZmlsZSB0aGlzIHNvdXJjZSBtYXAgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICogICAtIHNlY3Rpb25zOiBBIGxpc3Qgb2Ygc2VjdGlvbiBkZWZpbml0aW9ucy5cbiAqXG4gKiBFYWNoIHZhbHVlIHVuZGVyIHRoZSBcInNlY3Rpb25zXCIgZmllbGQgaGFzIHR3byBmaWVsZHM6XG4gKiAgIC0gb2Zmc2V0OiBUaGUgb2Zmc2V0IGludG8gdGhlIG9yaWdpbmFsIHNwZWNpZmllZCBhdCB3aGljaCB0aGlzIHNlY3Rpb25cbiAqICAgICAgIGJlZ2lucyB0byBhcHBseSwgZGVmaW5lZCBhcyBhbiBvYmplY3Qgd2l0aCBhIFwibGluZVwiIGFuZCBcImNvbHVtblwiXG4gKiAgICAgICBmaWVsZC5cbiAqICAgLSBtYXA6IEEgc291cmNlIG1hcCBkZWZpbml0aW9uLiBUaGlzIHNvdXJjZSBtYXAgY291bGQgYWxzbyBiZSBpbmRleGVkLFxuICogICAgICAgYnV0IGRvZXNuJ3QgaGF2ZSB0byBiZS5cbiAqXG4gKiBJbnN0ZWFkIG9mIHRoZSBcIm1hcFwiIGZpZWxkLCBpdCdzIGFsc28gcG9zc2libGUgdG8gaGF2ZSBhIFwidXJsXCIgZmllbGRcbiAqIHNwZWNpZnlpbmcgYSBVUkwgdG8gcmV0cmlldmUgYSBzb3VyY2UgbWFwIGZyb20sIGJ1dCB0aGF0J3MgY3VycmVudGx5XG4gKiB1bnN1cHBvcnRlZC5cbiAqXG4gKiBIZXJlJ3MgYW4gZXhhbXBsZSBzb3VyY2UgbWFwLCB0YWtlbiBmcm9tIHRoZSBzb3VyY2UgbWFwIHNwZWNbMF0sIGJ1dFxuICogbW9kaWZpZWQgdG8gb21pdCBhIHNlY3Rpb24gd2hpY2ggdXNlcyB0aGUgXCJ1cmxcIiBmaWVsZC5cbiAqXG4gKiAge1xuICogICAgdmVyc2lvbiA6IDMsXG4gKiAgICBmaWxlOiBcImFwcC5qc1wiLFxuICogICAgc2VjdGlvbnM6IFt7XG4gKiAgICAgIG9mZnNldDoge2xpbmU6MTAwLCBjb2x1bW46MTB9LFxuICogICAgICBtYXA6IHtcbiAqICAgICAgICB2ZXJzaW9uIDogMyxcbiAqICAgICAgICBmaWxlOiBcInNlY3Rpb24uanNcIixcbiAqICAgICAgICBzb3VyY2VzOiBbXCJmb28uanNcIiwgXCJiYXIuanNcIl0sXG4gKiAgICAgICAgbmFtZXM6IFtcInNyY1wiLCBcIm1hcHNcIiwgXCJhcmVcIiwgXCJmdW5cIl0sXG4gKiAgICAgICAgbWFwcGluZ3M6IFwiQUFBQSxFOztBQkNERTtcIlxuICogICAgICB9XG4gKiAgICB9XSxcbiAqICB9XG4gKlxuICogVGhlIHNlY29uZCBwYXJhbWV0ZXIsIGlmIGdpdmVuLCBpcyBhIHN0cmluZyB3aG9zZSB2YWx1ZSBpcyB0aGUgVVJMXG4gKiBhdCB3aGljaCB0aGUgc291cmNlIG1hcCB3YXMgZm91bmQuICBUaGlzIFVSTCBpcyB1c2VkIHRvIGNvbXB1dGUgdGhlXG4gKiBzb3VyY2VzIGFycmF5LlxuICpcbiAqIFswXTogaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZG9jdW1lbnQvZC8xVTFSR0FlaFF3UnlwVVRvdkYxS1JscGlPRnplMGItXzJnYzZmQUgwS1kway9lZGl0I2hlYWRpbmc9aC41MzVlczN4ZXByZ3RcbiAqL1xuZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyKGFTb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpIHtcbiAgdmFyIHNvdXJjZU1hcCA9IGFTb3VyY2VNYXA7XG4gIGlmICh0eXBlb2YgYVNvdXJjZU1hcCA9PT0gJ3N0cmluZycpIHtcbiAgICBzb3VyY2VNYXAgPSB1dGlsLnBhcnNlU291cmNlTWFwSW5wdXQoYVNvdXJjZU1hcCk7XG4gIH1cblxuICB2YXIgdmVyc2lvbiA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3ZlcnNpb24nKTtcbiAgdmFyIHNlY3Rpb25zID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc2VjdGlvbnMnKTtcblxuICBpZiAodmVyc2lvbiAhPSB0aGlzLl92ZXJzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB2ZXJzaW9uOiAnICsgdmVyc2lvbik7XG4gIH1cblxuICB0aGlzLl9zb3VyY2VzID0gbmV3IEFycmF5U2V0KCk7XG4gIHRoaXMuX25hbWVzID0gbmV3IEFycmF5U2V0KCk7XG5cbiAgdmFyIGxhc3RPZmZzZXQgPSB7XG4gICAgbGluZTogLTEsXG4gICAgY29sdW1uOiAwXG4gIH07XG4gIHRoaXMuX3NlY3Rpb25zID0gc2VjdGlvbnMubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgaWYgKHMudXJsKSB7XG4gICAgICAvLyBUaGUgdXJsIGZpZWxkIHdpbGwgcmVxdWlyZSBzdXBwb3J0IGZvciBhc3luY2hyb25pY2l0eS5cbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL2lzc3Vlcy8xNlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdXBwb3J0IGZvciB1cmwgZmllbGQgaW4gc2VjdGlvbnMgbm90IGltcGxlbWVudGVkLicpO1xuICAgIH1cbiAgICB2YXIgb2Zmc2V0ID0gdXRpbC5nZXRBcmcocywgJ29mZnNldCcpO1xuICAgIHZhciBvZmZzZXRMaW5lID0gdXRpbC5nZXRBcmcob2Zmc2V0LCAnbGluZScpO1xuICAgIHZhciBvZmZzZXRDb2x1bW4gPSB1dGlsLmdldEFyZyhvZmZzZXQsICdjb2x1bW4nKTtcblxuICAgIGlmIChvZmZzZXRMaW5lIDwgbGFzdE9mZnNldC5saW5lIHx8XG4gICAgICAgIChvZmZzZXRMaW5lID09PSBsYXN0T2Zmc2V0LmxpbmUgJiYgb2Zmc2V0Q29sdW1uIDwgbGFzdE9mZnNldC5jb2x1bW4pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlY3Rpb24gb2Zmc2V0cyBtdXN0IGJlIG9yZGVyZWQgYW5kIG5vbi1vdmVybGFwcGluZy4nKTtcbiAgICB9XG4gICAgbGFzdE9mZnNldCA9IG9mZnNldDtcblxuICAgIHJldHVybiB7XG4gICAgICBnZW5lcmF0ZWRPZmZzZXQ6IHtcbiAgICAgICAgLy8gVGhlIG9mZnNldCBmaWVsZHMgYXJlIDAtYmFzZWQsIGJ1dCB3ZSB1c2UgMS1iYXNlZCBpbmRpY2VzIHdoZW5cbiAgICAgICAgLy8gZW5jb2RpbmcvZGVjb2RpbmcgZnJvbSBWTFEuXG4gICAgICAgIGdlbmVyYXRlZExpbmU6IG9mZnNldExpbmUgKyAxLFxuICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IG9mZnNldENvbHVtbiArIDFcbiAgICAgIH0sXG4gICAgICBjb25zdW1lcjogbmV3IFNvdXJjZU1hcENvbnN1bWVyKHV0aWwuZ2V0QXJnKHMsICdtYXAnKSwgYVNvdXJjZU1hcFVSTClcbiAgICB9XG4gIH0pO1xufVxuXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUpO1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNvdXJjZU1hcENvbnN1bWVyO1xuXG4vKipcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwcGluZyBzcGVjIHRoYXQgd2UgYXJlIGNvbnN1bWluZy5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbi8qKlxuICogVGhlIGxpc3Qgb2Ygb3JpZ2luYWwgc291cmNlcy5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdzb3VyY2VzJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5fc2VjdGlvbnNbaV0uY29uc3VtZXIuc291cmNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBzb3VyY2VzLnB1c2godGhpcy5fc2VjdGlvbnNbaV0uY29uc3VtZXIuc291cmNlc1tqXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2VzO1xuICB9XG59KTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UsIGxpbmUsIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBnZW5lcmF0ZWRcbiAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdFxuICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS4gIFRoZSBsaW5lIG51bWJlclxuICogICAgIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS4gIFRoZSBjb2x1bW5cbiAqICAgICBudW1iZXIgaXMgMC1iYXNlZC5cbiAqXG4gKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSwgb3IgbnVsbC5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC4gIFRoZVxuICogICAgIGxpbmUgbnVtYmVyIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLiAgVGhlXG4gKiAgICAgY29sdW1uIG51bWJlciBpcyAwLWJhc2VkLlxuICogICAtIG5hbWU6IFRoZSBvcmlnaW5hbCBpZGVudGlmaWVyLCBvciBudWxsLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLm9yaWdpbmFsUG9zaXRpb25Gb3IgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfb3JpZ2luYWxQb3NpdGlvbkZvcihhQXJncykge1xuICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICBnZW5lcmF0ZWRMaW5lOiB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKSxcbiAgICAgIGdlbmVyYXRlZENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nKVxuICAgIH07XG5cbiAgICAvLyBGaW5kIHRoZSBzZWN0aW9uIGNvbnRhaW5pbmcgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbiB3ZSdyZSB0cnlpbmcgdG8gbWFwXG4gICAgLy8gdG8gYW4gb3JpZ2luYWwgcG9zaXRpb24uXG4gICAgdmFyIHNlY3Rpb25JbmRleCA9IGJpbmFyeVNlYXJjaC5zZWFyY2gobmVlZGxlLCB0aGlzLl9zZWN0aW9ucyxcbiAgICAgIGZ1bmN0aW9uKG5lZWRsZSwgc2VjdGlvbikge1xuICAgICAgICB2YXIgY21wID0gbmVlZGxlLmdlbmVyYXRlZExpbmUgLSBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lO1xuICAgICAgICBpZiAoY21wKSB7XG4gICAgICAgICAgcmV0dXJuIGNtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAobmVlZGxlLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgIH0pO1xuICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbc2VjdGlvbkluZGV4XTtcblxuICAgIGlmICghc2VjdGlvbikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICBsaW5lOiBudWxsLFxuICAgICAgICBjb2x1bW46IG51bGwsXG4gICAgICAgIG5hbWU6IG51bGxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlY3Rpb24uY29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICBsaW5lOiBuZWVkbGUuZ2VuZXJhdGVkTGluZSAtXG4gICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lIC0gMSksXG4gICAgICBjb2x1bW46IG5lZWRsZS5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSA9PT0gbmVlZGxlLmdlbmVyYXRlZExpbmVcbiAgICAgICAgID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMVxuICAgICAgICAgOiAwKSxcbiAgICAgIGJpYXM6IGFBcmdzLmJpYXNcbiAgICB9KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB3ZSBoYXZlIHRoZSBzb3VyY2UgY29udGVudCBmb3IgZXZlcnkgc291cmNlIGluIHRoZSBzb3VyY2VcbiAqIG1hcCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmhhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX2hhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWN0aW9ucy5ldmVyeShmdW5jdGlvbiAocykge1xuICAgICAgcmV0dXJuIHMuY29uc3VtZXIuaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKTtcbiAgICB9KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29udGVudC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgdGhlIHVybCBvZiB0aGVcbiAqIG9yaWdpbmFsIHNvdXJjZSBmaWxlLiBSZXR1cm5zIG51bGwgaWYgbm8gb3JpZ2luYWwgc291cmNlIGNvbnRlbnQgaXNcbiAqIGF2YWlsYWJsZS5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5zb3VyY2VDb250ZW50Rm9yID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX3NvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSwgbnVsbE9uTWlzc2luZykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07XG5cbiAgICAgIHZhciBjb250ZW50ID0gc2VjdGlvbi5jb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKGFTb3VyY2UsIHRydWUpO1xuICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChudWxsT25NaXNzaW5nKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTb3VyY2UgKyAnXCIgaXMgbm90IGluIHRoZSBTb3VyY2VNYXAuJyk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsXG4gKiBsaW5lLCBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGhcbiAqIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS4gIFRoZSBsaW5lIG51bWJlclxuICogICAgIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLiAgVGhlIGNvbHVtblxuICogICAgIG51bWJlciBpcyAwLWJhc2VkLlxuICpcbiAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC4gIFRoZVxuICogICAgIGxpbmUgbnVtYmVyIGlzIDEtYmFzZWQuIFxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgICAgVGhlIGNvbHVtbiBudW1iZXIgaXMgMC1iYXNlZC5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5nZW5lcmF0ZWRQb3NpdGlvbkZvciA9XG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9nZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07XG5cbiAgICAgIC8vIE9ubHkgY29uc2lkZXIgdGhpcyBzZWN0aW9uIGlmIHRoZSByZXF1ZXN0ZWQgc291cmNlIGlzIGluIHRoZSBsaXN0IG9mXG4gICAgICAvLyBzb3VyY2VzIG9mIHRoZSBjb25zdW1lci5cbiAgICAgIGlmIChzZWN0aW9uLmNvbnN1bWVyLl9maW5kU291cmNlSW5kZXgodXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKSkgPT09IC0xKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIGdlbmVyYXRlZFBvc2l0aW9uID0gc2VjdGlvbi5jb25zdW1lci5nZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncyk7XG4gICAgICBpZiAoZ2VuZXJhdGVkUG9zaXRpb24pIHtcbiAgICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWRQb3NpdGlvbi5saW5lICtcbiAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lIC0gMSksXG4gICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWRQb3NpdGlvbi5jb2x1bW4gK1xuICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgPT09IGdlbmVyYXRlZFBvc2l0aW9uLmxpbmVcbiAgICAgICAgICAgICA/IHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbiAtIDFcbiAgICAgICAgICAgICA6IDApXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmU6IG51bGwsXG4gICAgICBjb2x1bW46IG51bGxcbiAgICB9O1xuICB9O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBtYXBwaW5ncyBpbiBhIHN0cmluZyBpbiB0byBhIGRhdGEgc3RydWN0dXJlIHdoaWNoIHdlIGNhbiBlYXNpbHlcbiAqIHF1ZXJ5ICh0aGUgb3JkZXJlZCBhcnJheXMgaW4gdGhlIGB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzID0gW107XG4gICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW2ldO1xuICAgICAgdmFyIHNlY3Rpb25NYXBwaW5ncyA9IHNlY3Rpb24uY29uc3VtZXIuX2dlbmVyYXRlZE1hcHBpbmdzO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZWN0aW9uTWFwcGluZ3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIG1hcHBpbmcgPSBzZWN0aW9uTWFwcGluZ3Nbal07XG5cbiAgICAgICAgdmFyIHNvdXJjZSA9IHNlY3Rpb24uY29uc3VtZXIuX3NvdXJjZXMuYXQobWFwcGluZy5zb3VyY2UpO1xuICAgICAgICBzb3VyY2UgPSB1dGlsLmNvbXB1dGVTb3VyY2VVUkwoc2VjdGlvbi5jb25zdW1lci5zb3VyY2VSb290LCBzb3VyY2UsIHRoaXMuX3NvdXJjZU1hcFVSTCk7XG4gICAgICAgIHRoaXMuX3NvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICAgIHNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuaW5kZXhPZihzb3VyY2UpO1xuXG4gICAgICAgIHZhciBuYW1lID0gbnVsbDtcbiAgICAgICAgaWYgKG1hcHBpbmcubmFtZSkge1xuICAgICAgICAgIG5hbWUgPSBzZWN0aW9uLmNvbnN1bWVyLl9uYW1lcy5hdChtYXBwaW5nLm5hbWUpO1xuICAgICAgICAgIHRoaXMuX25hbWVzLmFkZChuYW1lKTtcbiAgICAgICAgICBuYW1lID0gdGhpcy5fbmFtZXMuaW5kZXhPZihuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBtYXBwaW5ncyBjb21pbmcgZnJvbSB0aGUgY29uc3VtZXIgZm9yIHRoZSBzZWN0aW9uIGhhdmVcbiAgICAgICAgLy8gZ2VuZXJhdGVkIHBvc2l0aW9ucyByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIHNlY3Rpb24sIHNvIHdlXG4gICAgICAgIC8vIG5lZWQgdG8gb2Zmc2V0IHRoZW0gdG8gYmUgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSBjb25jYXRlbmF0ZWRcbiAgICAgICAgLy8gZ2VuZXJhdGVkIGZpbGUuXG4gICAgICAgIHZhciBhZGp1c3RlZE1hcHBpbmcgPSB7XG4gICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgZ2VuZXJhdGVkTGluZTogbWFwcGluZy5nZW5lcmF0ZWRMaW5lICtcbiAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lIC0gMSksXG4gICAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiArXG4gICAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSA9PT0gbWFwcGluZy5nZW5lcmF0ZWRMaW5lXG4gICAgICAgICAgICA/IHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbiAtIDFcbiAgICAgICAgICAgIDogMCksXG4gICAgICAgICAgb3JpZ2luYWxMaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICBvcmlnaW5hbENvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtbixcbiAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzLnB1c2goYWRqdXN0ZWRNYXBwaW5nKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhZGp1c3RlZE1hcHBpbmcub3JpZ2luYWxMaW5lID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzLnB1c2goYWRqdXN0ZWRNYXBwaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHF1aWNrU29ydCh0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQpO1xuICAgIHF1aWNrU29ydCh0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7XG4gIH07XG5cbmV4cG9ydHMuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyID0gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyO1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgYmFzZTY0VkxRID0gcmVxdWlyZSgnLi9iYXNlNjQtdmxxJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIEFycmF5U2V0ID0gcmVxdWlyZSgnLi9hcnJheS1zZXQnKS5BcnJheVNldDtcbnZhciBNYXBwaW5nTGlzdCA9IHJlcXVpcmUoJy4vbWFwcGluZy1saXN0JykuTWFwcGluZ0xpc3Q7XG5cbi8qKlxuICogQW4gaW5zdGFuY2Ugb2YgdGhlIFNvdXJjZU1hcEdlbmVyYXRvciByZXByZXNlbnRzIGEgc291cmNlIG1hcCB3aGljaCBpc1xuICogYmVpbmcgYnVpbHQgaW5jcmVtZW50YWxseS4gWW91IG1heSBwYXNzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAqIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGZpbGU6IFRoZSBmaWxlbmFtZSBvZiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAqICAgLSBzb3VyY2VSb290OiBBIHJvb3QgZm9yIGFsbCByZWxhdGl2ZSBVUkxzIGluIHRoaXMgc291cmNlIG1hcC5cbiAqL1xuZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yKGFBcmdzKSB7XG4gIGlmICghYUFyZ3MpIHtcbiAgICBhQXJncyA9IHt9O1xuICB9XG4gIHRoaXMuX2ZpbGUgPSB1dGlsLmdldEFyZyhhQXJncywgJ2ZpbGUnLCBudWxsKTtcbiAgdGhpcy5fc291cmNlUm9vdCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlUm9vdCcsIG51bGwpO1xuICB0aGlzLl9za2lwVmFsaWRhdGlvbiA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc2tpcFZhbGlkYXRpb24nLCBmYWxzZSk7XG4gIHRoaXMuX3NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgdGhpcy5fbmFtZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgdGhpcy5fbWFwcGluZ3MgPSBuZXcgTWFwcGluZ0xpc3QoKTtcbiAgdGhpcy5fc291cmNlc0NvbnRlbnRzID0gbnVsbDtcbn1cblxuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBTb3VyY2VNYXBHZW5lcmF0b3IgYmFzZWQgb24gYSBTb3VyY2VNYXBDb25zdW1lclxuICpcbiAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIFNvdXJjZU1hcC5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLmZyb21Tb3VyY2VNYXAgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfZnJvbVNvdXJjZU1hcChhU291cmNlTWFwQ29uc3VtZXIpIHtcbiAgICB2YXIgc291cmNlUm9vdCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VSb290O1xuICAgIHZhciBnZW5lcmF0b3IgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yKHtcbiAgICAgIGZpbGU6IGFTb3VyY2VNYXBDb25zdW1lci5maWxlLFxuICAgICAgc291cmNlUm9vdDogc291cmNlUm9vdFxuICAgIH0pO1xuICAgIGFTb3VyY2VNYXBDb25zdW1lci5lYWNoTWFwcGluZyhmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgdmFyIG5ld01hcHBpbmcgPSB7XG4gICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgIGxpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSxcbiAgICAgICAgICBjb2x1bW46IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgIG5ld01hcHBpbmcuc291cmNlID0gbWFwcGluZy5zb3VyY2U7XG4gICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICBuZXdNYXBwaW5nLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgbmV3TWFwcGluZy5zb3VyY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3TWFwcGluZy5vcmlnaW5hbCA9IHtcbiAgICAgICAgICBsaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICBjb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW5cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAobWFwcGluZy5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICBuZXdNYXBwaW5nLm5hbWUgPSBtYXBwaW5nLm5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZ2VuZXJhdG9yLmFkZE1hcHBpbmcobmV3TWFwcGluZyk7XG4gICAgfSk7XG4gICAgYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlRmlsZSkge1xuICAgICAgdmFyIHNvdXJjZVJlbGF0aXZlID0gc291cmNlRmlsZTtcbiAgICAgIGlmIChzb3VyY2VSb290ICE9PSBudWxsKSB7XG4gICAgICAgIHNvdXJjZVJlbGF0aXZlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzb3VyY2VGaWxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFnZW5lcmF0b3IuX3NvdXJjZXMuaGFzKHNvdXJjZVJlbGF0aXZlKSkge1xuICAgICAgICBnZW5lcmF0b3IuX3NvdXJjZXMuYWRkKHNvdXJjZVJlbGF0aXZlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgZ2VuZXJhdG9yLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfTtcblxuLyoqXG4gKiBBZGQgYSBzaW5nbGUgbWFwcGluZyBmcm9tIG9yaWdpbmFsIHNvdXJjZSBsaW5lIGFuZCBjb2x1bW4gdG8gdGhlIGdlbmVyYXRlZFxuICogc291cmNlJ3MgbGluZSBhbmQgY29sdW1uIGZvciB0aGlzIHNvdXJjZSBtYXAgYmVpbmcgY3JlYXRlZC4gVGhlIG1hcHBpbmdcbiAqIG9iamVjdCBzaG91bGQgaGF2ZSB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGdlbmVyYXRlZDogQW4gb2JqZWN0IHdpdGggdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zLlxuICogICAtIG9yaWdpbmFsOiBBbiBvYmplY3Qgd2l0aCB0aGUgb3JpZ2luYWwgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucy5cbiAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSAocmVsYXRpdmUgdG8gdGhlIHNvdXJjZVJvb3QpLlxuICogICAtIG5hbWU6IEFuIG9wdGlvbmFsIG9yaWdpbmFsIHRva2VuIG5hbWUgZm9yIHRoaXMgbWFwcGluZy5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hZGRNYXBwaW5nID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2FkZE1hcHBpbmcoYUFyZ3MpIHtcbiAgICB2YXIgZ2VuZXJhdGVkID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdnZW5lcmF0ZWQnKTtcbiAgICB2YXIgb3JpZ2luYWwgPSB1dGlsLmdldEFyZyhhQXJncywgJ29yaWdpbmFsJywgbnVsbCk7XG4gICAgdmFyIHNvdXJjZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJywgbnVsbCk7XG4gICAgdmFyIG5hbWUgPSB1dGlsLmdldEFyZyhhQXJncywgJ25hbWUnLCBudWxsKTtcblxuICAgIGlmICghdGhpcy5fc2tpcFZhbGlkYXRpb24pIHtcbiAgICAgIHRoaXMuX3ZhbGlkYXRlTWFwcGluZyhnZW5lcmF0ZWQsIG9yaWdpbmFsLCBzb3VyY2UsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChzb3VyY2UgIT0gbnVsbCkge1xuICAgICAgc291cmNlID0gU3RyaW5nKHNvdXJjZSk7XG4gICAgICBpZiAoIXRoaXMuX3NvdXJjZXMuaGFzKHNvdXJjZSkpIHtcbiAgICAgICAgdGhpcy5fc291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobmFtZSAhPSBudWxsKSB7XG4gICAgICBuYW1lID0gU3RyaW5nKG5hbWUpO1xuICAgICAgaWYgKCF0aGlzLl9uYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgdGhpcy5fbmFtZXMuYWRkKG5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX21hcHBpbmdzLmFkZCh7XG4gICAgICBnZW5lcmF0ZWRMaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgIGdlbmVyYXRlZENvbHVtbjogZ2VuZXJhdGVkLmNvbHVtbixcbiAgICAgIG9yaWdpbmFsTGluZTogb3JpZ2luYWwgIT0gbnVsbCAmJiBvcmlnaW5hbC5saW5lLFxuICAgICAgb3JpZ2luYWxDb2x1bW46IG9yaWdpbmFsICE9IG51bGwgJiYgb3JpZ2luYWwuY29sdW1uLFxuICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICBuYW1lOiBuYW1lXG4gICAgfSk7XG4gIH07XG5cbi8qKlxuICogU2V0IHRoZSBzb3VyY2UgY29udGVudCBmb3IgYSBzb3VyY2UgZmlsZS5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5zZXRTb3VyY2VDb250ZW50ID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3NldFNvdXJjZUNvbnRlbnQoYVNvdXJjZUZpbGUsIGFTb3VyY2VDb250ZW50KSB7XG4gICAgdmFyIHNvdXJjZSA9IGFTb3VyY2VGaWxlO1xuICAgIGlmICh0aGlzLl9zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIHNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5fc291cmNlUm9vdCwgc291cmNlKTtcbiAgICB9XG5cbiAgICBpZiAoYVNvdXJjZUNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgLy8gQWRkIHRoZSBzb3VyY2UgY29udGVudCB0byB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAuXG4gICAgICAvLyBDcmVhdGUgYSBuZXcgX3NvdXJjZXNDb250ZW50cyBtYXAgaWYgdGhlIHByb3BlcnR5IGlzIG51bGwuXG4gICAgICBpZiAoIXRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc291cmNlc0NvbnRlbnRzW3V0aWwudG9TZXRTdHJpbmcoc291cmNlKV0gPSBhU291cmNlQ29udGVudDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgLy8gUmVtb3ZlIHRoZSBzb3VyY2UgZmlsZSBmcm9tIHRoZSBfc291cmNlc0NvbnRlbnRzIG1hcC5cbiAgICAgIC8vIElmIHRoZSBfc291cmNlc0NvbnRlbnRzIG1hcCBpcyBlbXB0eSwgc2V0IHRoZSBwcm9wZXJ0eSB0byBudWxsLlxuICAgICAgZGVsZXRlIHRoaXMuX3NvdXJjZXNDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSldO1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuX3NvdXJjZXNDb250ZW50cykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50cyA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIEFwcGxpZXMgdGhlIG1hcHBpbmdzIG9mIGEgc3ViLXNvdXJjZS1tYXAgZm9yIGEgc3BlY2lmaWMgc291cmNlIGZpbGUgdG8gdGhlXG4gKiBzb3VyY2UgbWFwIGJlaW5nIGdlbmVyYXRlZC4gRWFjaCBtYXBwaW5nIHRvIHRoZSBzdXBwbGllZCBzb3VyY2UgZmlsZSBpc1xuICogcmV3cml0dGVuIHVzaW5nIHRoZSBzdXBwbGllZCBzb3VyY2UgbWFwLiBOb3RlOiBUaGUgcmVzb2x1dGlvbiBmb3IgdGhlXG4gKiByZXN1bHRpbmcgbWFwcGluZ3MgaXMgdGhlIG1pbmltaXVtIG9mIHRoaXMgbWFwIGFuZCB0aGUgc3VwcGxpZWQgbWFwLlxuICpcbiAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIHNvdXJjZSBtYXAgdG8gYmUgYXBwbGllZC5cbiAqIEBwYXJhbSBhU291cmNlRmlsZSBPcHRpb25hbC4gVGhlIGZpbGVuYW1lIG9mIHRoZSBzb3VyY2UgZmlsZS5cbiAqICAgICAgICBJZiBvbWl0dGVkLCBTb3VyY2VNYXBDb25zdW1lcidzIGZpbGUgcHJvcGVydHkgd2lsbCBiZSB1c2VkLlxuICogQHBhcmFtIGFTb3VyY2VNYXBQYXRoIE9wdGlvbmFsLiBUaGUgZGlybmFtZSBvZiB0aGUgcGF0aCB0byB0aGUgc291cmNlIG1hcFxuICogICAgICAgIHRvIGJlIGFwcGxpZWQuIElmIHJlbGF0aXZlLCBpdCBpcyByZWxhdGl2ZSB0byB0aGUgU291cmNlTWFwQ29uc3VtZXIuXG4gKiAgICAgICAgVGhpcyBwYXJhbWV0ZXIgaXMgbmVlZGVkIHdoZW4gdGhlIHR3byBzb3VyY2UgbWFwcyBhcmVuJ3QgaW4gdGhlIHNhbWVcbiAqICAgICAgICBkaXJlY3RvcnksIGFuZCB0aGUgc291cmNlIG1hcCB0byBiZSBhcHBsaWVkIGNvbnRhaW5zIHJlbGF0aXZlIHNvdXJjZVxuICogICAgICAgIHBhdGhzLiBJZiBzbywgdGhvc2UgcmVsYXRpdmUgc291cmNlIHBhdGhzIG5lZWQgdG8gYmUgcmV3cml0dGVuXG4gKiAgICAgICAgcmVsYXRpdmUgdG8gdGhlIFNvdXJjZU1hcEdlbmVyYXRvci5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hcHBseVNvdXJjZU1hcCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9hcHBseVNvdXJjZU1hcChhU291cmNlTWFwQ29uc3VtZXIsIGFTb3VyY2VGaWxlLCBhU291cmNlTWFwUGF0aCkge1xuICAgIHZhciBzb3VyY2VGaWxlID0gYVNvdXJjZUZpbGU7XG4gICAgLy8gSWYgYVNvdXJjZUZpbGUgaXMgb21pdHRlZCwgd2Ugd2lsbCB1c2UgdGhlIGZpbGUgcHJvcGVydHkgb2YgdGhlIFNvdXJjZU1hcFxuICAgIGlmIChhU291cmNlRmlsZSA9PSBudWxsKSB7XG4gICAgICBpZiAoYVNvdXJjZU1hcENvbnN1bWVyLmZpbGUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ1NvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuYXBwbHlTb3VyY2VNYXAgcmVxdWlyZXMgZWl0aGVyIGFuIGV4cGxpY2l0IHNvdXJjZSBmaWxlLCAnICtcbiAgICAgICAgICAnb3IgdGhlIHNvdXJjZSBtYXBcXCdzIFwiZmlsZVwiIHByb3BlcnR5LiBCb3RoIHdlcmUgb21pdHRlZC4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBzb3VyY2VGaWxlID0gYVNvdXJjZU1hcENvbnN1bWVyLmZpbGU7XG4gICAgfVxuICAgIHZhciBzb3VyY2VSb290ID0gdGhpcy5fc291cmNlUm9vdDtcbiAgICAvLyBNYWtlIFwic291cmNlRmlsZVwiIHJlbGF0aXZlIGlmIGFuIGFic29sdXRlIFVybCBpcyBwYXNzZWQuXG4gICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgc291cmNlRmlsZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgc291cmNlRmlsZSk7XG4gICAgfVxuICAgIC8vIEFwcGx5aW5nIHRoZSBTb3VyY2VNYXAgY2FuIGFkZCBhbmQgcmVtb3ZlIGl0ZW1zIGZyb20gdGhlIHNvdXJjZXMgYW5kXG4gICAgLy8gdGhlIG5hbWVzIGFycmF5LlxuICAgIHZhciBuZXdTb3VyY2VzID0gbmV3IEFycmF5U2V0KCk7XG4gICAgdmFyIG5ld05hbWVzID0gbmV3IEFycmF5U2V0KCk7XG5cbiAgICAvLyBGaW5kIG1hcHBpbmdzIGZvciB0aGUgXCJzb3VyY2VGaWxlXCJcbiAgICB0aGlzLl9tYXBwaW5ncy51bnNvcnRlZEZvckVhY2goZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSA9PT0gc291cmNlRmlsZSAmJiBtYXBwaW5nLm9yaWdpbmFsTGluZSAhPSBudWxsKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIGl0IGNhbiBiZSBtYXBwZWQgYnkgdGhlIHNvdXJjZSBtYXAsIHRoZW4gdXBkYXRlIHRoZSBtYXBwaW5nLlxuICAgICAgICB2YXIgb3JpZ2luYWwgPSBhU291cmNlTWFwQ29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICAgICAgbGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgY29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob3JpZ2luYWwuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBDb3B5IG1hcHBpbmdcbiAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IG9yaWdpbmFsLnNvdXJjZTtcbiAgICAgICAgICBpZiAoYVNvdXJjZU1hcFBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSB1dGlsLmpvaW4oYVNvdXJjZU1hcFBhdGgsIG1hcHBpbmcuc291cmNlKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgbWFwcGluZy5zb3VyY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSA9IG9yaWdpbmFsLmxpbmU7XG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbiA9IG9yaWdpbmFsLmNvbHVtbjtcbiAgICAgICAgICBpZiAob3JpZ2luYWwubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBtYXBwaW5nLm5hbWUgPSBvcmlnaW5hbC5uYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgc291cmNlID0gbWFwcGluZy5zb3VyY2U7XG4gICAgICBpZiAoc291cmNlICE9IG51bGwgJiYgIW5ld1NvdXJjZXMuaGFzKHNvdXJjZSkpIHtcbiAgICAgICAgbmV3U291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5hbWUgPSBtYXBwaW5nLm5hbWU7XG4gICAgICBpZiAobmFtZSAhPSBudWxsICYmICFuZXdOYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgbmV3TmFtZXMuYWRkKG5hbWUpO1xuICAgICAgfVxuXG4gICAgfSwgdGhpcyk7XG4gICAgdGhpcy5fc291cmNlcyA9IG5ld1NvdXJjZXM7XG4gICAgdGhpcy5fbmFtZXMgPSBuZXdOYW1lcztcblxuICAgIC8vIENvcHkgc291cmNlc0NvbnRlbnRzIG9mIGFwcGxpZWQgbWFwLlxuICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGUpIHtcbiAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICBpZiAoY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChhU291cmNlTWFwUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgc291cmNlRmlsZSA9IHV0aWwuam9pbihhU291cmNlTWFwUGF0aCwgc291cmNlRmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZUZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgfTtcblxuLyoqXG4gKiBBIG1hcHBpbmcgY2FuIGhhdmUgb25lIG9mIHRoZSB0aHJlZSBsZXZlbHMgb2YgZGF0YTpcbiAqXG4gKiAgIDEuIEp1c3QgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbi5cbiAqICAgMi4gVGhlIEdlbmVyYXRlZCBwb3NpdGlvbiwgb3JpZ2luYWwgcG9zaXRpb24sIGFuZCBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIDMuIEdlbmVyYXRlZCBhbmQgb3JpZ2luYWwgcG9zaXRpb24sIG9yaWdpbmFsIHNvdXJjZSwgYXMgd2VsbCBhcyBhIG5hbWVcbiAqICAgICAgdG9rZW4uXG4gKlxuICogVG8gbWFpbnRhaW4gY29uc2lzdGVuY3ksIHdlIHZhbGlkYXRlIHRoYXQgYW55IG5ldyBtYXBwaW5nIGJlaW5nIGFkZGVkIGZhbGxzXG4gKiBpbiB0byBvbmUgb2YgdGhlc2UgY2F0ZWdvcmllcy5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fdmFsaWRhdGVNYXBwaW5nID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3ZhbGlkYXRlTWFwcGluZyhhR2VuZXJhdGVkLCBhT3JpZ2luYWwsIGFTb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYU5hbWUpIHtcbiAgICAvLyBXaGVuIGFPcmlnaW5hbCBpcyB0cnV0aHkgYnV0IGhhcyBlbXB0eSB2YWx1ZXMgZm9yIC5saW5lIGFuZCAuY29sdW1uLFxuICAgIC8vIGl0IGlzIG1vc3QgbGlrZWx5IGEgcHJvZ3JhbW1lciBlcnJvci4gSW4gdGhpcyBjYXNlIHdlIHRocm93IGEgdmVyeVxuICAgIC8vIHNwZWNpZmljIGVycm9yIG1lc3NhZ2UgdG8gdHJ5IHRvIGd1aWRlIHRoZW0gdGhlIHJpZ2h0IHdheS5cbiAgICAvLyBGb3IgZXhhbXBsZTogaHR0cHM6Ly9naXRodWIuY29tL1BvbHltZXIvcG9seW1lci1idW5kbGVyL3B1bGwvNTE5XG4gICAgaWYgKGFPcmlnaW5hbCAmJiB0eXBlb2YgYU9yaWdpbmFsLmxpbmUgIT09ICdudW1iZXInICYmIHR5cGVvZiBhT3JpZ2luYWwuY29sdW1uICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnb3JpZ2luYWwubGluZSBhbmQgb3JpZ2luYWwuY29sdW1uIGFyZSBub3QgbnVtYmVycyAtLSB5b3UgcHJvYmFibHkgbWVhbnQgdG8gb21pdCAnICtcbiAgICAgICAgICAgICd0aGUgb3JpZ2luYWwgbWFwcGluZyBlbnRpcmVseSBhbmQgb25seSBtYXAgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbi4gSWYgc28sIHBhc3MgJyArXG4gICAgICAgICAgICAnbnVsbCBmb3IgdGhlIG9yaWdpbmFsIG1hcHBpbmcgaW5zdGVhZCBvZiBhbiBvYmplY3Qgd2l0aCBlbXB0eSBvciBudWxsIHZhbHVlcy4nXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGFHZW5lcmF0ZWQgJiYgJ2xpbmUnIGluIGFHZW5lcmF0ZWQgJiYgJ2NvbHVtbicgaW4gYUdlbmVyYXRlZFxuICAgICAgICAmJiBhR2VuZXJhdGVkLmxpbmUgPiAwICYmIGFHZW5lcmF0ZWQuY29sdW1uID49IDBcbiAgICAgICAgJiYgIWFPcmlnaW5hbCAmJiAhYVNvdXJjZSAmJiAhYU5hbWUpIHtcbiAgICAgIC8vIENhc2UgMS5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSBpZiAoYUdlbmVyYXRlZCAmJiAnbGluZScgaW4gYUdlbmVyYXRlZCAmJiAnY29sdW1uJyBpbiBhR2VuZXJhdGVkXG4gICAgICAgICAgICAgJiYgYU9yaWdpbmFsICYmICdsaW5lJyBpbiBhT3JpZ2luYWwgJiYgJ2NvbHVtbicgaW4gYU9yaWdpbmFsXG4gICAgICAgICAgICAgJiYgYUdlbmVyYXRlZC5saW5lID4gMCAmJiBhR2VuZXJhdGVkLmNvbHVtbiA+PSAwXG4gICAgICAgICAgICAgJiYgYU9yaWdpbmFsLmxpbmUgPiAwICYmIGFPcmlnaW5hbC5jb2x1bW4gPj0gMFxuICAgICAgICAgICAgICYmIGFTb3VyY2UpIHtcbiAgICAgIC8vIENhc2VzIDIgYW5kIDMuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1hcHBpbmc6ICcgKyBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIGdlbmVyYXRlZDogYUdlbmVyYXRlZCxcbiAgICAgICAgc291cmNlOiBhU291cmNlLFxuICAgICAgICBvcmlnaW5hbDogYU9yaWdpbmFsLFxuICAgICAgICBuYW1lOiBhTmFtZVxuICAgICAgfSkpO1xuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBTZXJpYWxpemUgdGhlIGFjY3VtdWxhdGVkIG1hcHBpbmdzIGluIHRvIHRoZSBzdHJlYW0gb2YgYmFzZSA2NCBWTFFzXG4gKiBzcGVjaWZpZWQgYnkgdGhlIHNvdXJjZSBtYXAgZm9ybWF0LlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl9zZXJpYWxpemVNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9zZXJpYWxpemVNYXBwaW5ncygpIHtcbiAgICB2YXIgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZExpbmUgPSAxO1xuICAgIHZhciBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gMDtcbiAgICB2YXIgcHJldmlvdXNPcmlnaW5hbExpbmUgPSAwO1xuICAgIHZhciBwcmV2aW91c05hbWUgPSAwO1xuICAgIHZhciBwcmV2aW91c1NvdXJjZSA9IDA7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBuZXh0O1xuICAgIHZhciBtYXBwaW5nO1xuICAgIHZhciBuYW1lSWR4O1xuICAgIHZhciBzb3VyY2VJZHg7XG5cbiAgICB2YXIgbWFwcGluZ3MgPSB0aGlzLl9tYXBwaW5ncy50b0FycmF5KCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG1hcHBpbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBtYXBwaW5nID0gbWFwcGluZ3NbaV07XG4gICAgICBuZXh0ID0gJydcblxuICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSAhPT0gcHJldmlvdXNHZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgICAgd2hpbGUgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSAhPT0gcHJldmlvdXNHZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgbmV4dCArPSAnOyc7XG4gICAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICBpZiAoIXV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQobWFwcGluZywgbWFwcGluZ3NbaSAtIDFdKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5leHQgKz0gJywnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLmdlbmVyYXRlZENvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c0dlbmVyYXRlZENvbHVtbik7XG4gICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICBpZiAobWFwcGluZy5zb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICBzb3VyY2VJZHggPSB0aGlzLl9zb3VyY2VzLmluZGV4T2YobWFwcGluZy5zb3VyY2UpO1xuICAgICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUoc291cmNlSWR4IC0gcHJldmlvdXNTb3VyY2UpO1xuICAgICAgICBwcmV2aW91c1NvdXJjZSA9IHNvdXJjZUlkeDtcblxuICAgICAgICAvLyBsaW5lcyBhcmUgc3RvcmVkIDAtYmFzZWQgaW4gU291cmNlTWFwIHNwZWMgdmVyc2lvbiAzXG4gICAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLm9yaWdpbmFsTGluZSAtIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c09yaWdpbmFsTGluZSk7XG4gICAgICAgIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gbWFwcGluZy5vcmlnaW5hbExpbmUgLSAxO1xuXG4gICAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLm9yaWdpbmFsQ29sdW1uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNPcmlnaW5hbENvbHVtbik7XG4gICAgICAgIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgIGlmIChtYXBwaW5nLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgIG5hbWVJZHggPSB0aGlzLl9uYW1lcy5pbmRleE9mKG1hcHBpbmcubmFtZSk7XG4gICAgICAgICAgbmV4dCArPSBiYXNlNjRWTFEuZW5jb2RlKG5hbWVJZHggLSBwcmV2aW91c05hbWUpO1xuICAgICAgICAgIHByZXZpb3VzTmFtZSA9IG5hbWVJZHg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVzdWx0ICs9IG5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fZ2VuZXJhdGVTb3VyY2VzQ29udGVudCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KGFTb3VyY2VzLCBhU291cmNlUm9vdCkge1xuICAgIHJldHVybiBhU291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoYVNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICBzb3VyY2UgPSB1dGlsLnJlbGF0aXZlKGFTb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgfVxuICAgICAgdmFyIGtleSA9IHV0aWwudG9TZXRTdHJpbmcoc291cmNlKTtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5fc291cmNlc0NvbnRlbnRzLCBrZXkpXG4gICAgICAgID8gdGhpcy5fc291cmNlc0NvbnRlbnRzW2tleV1cbiAgICAgICAgOiBudWxsO1xuICAgIH0sIHRoaXMpO1xuICB9O1xuXG4vKipcbiAqIEV4dGVybmFsaXplIHRoZSBzb3VyY2UgbWFwLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnRvSlNPTiA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl90b0pTT04oKSB7XG4gICAgdmFyIG1hcCA9IHtcbiAgICAgIHZlcnNpb246IHRoaXMuX3ZlcnNpb24sXG4gICAgICBzb3VyY2VzOiB0aGlzLl9zb3VyY2VzLnRvQXJyYXkoKSxcbiAgICAgIG5hbWVzOiB0aGlzLl9uYW1lcy50b0FycmF5KCksXG4gICAgICBtYXBwaW5nczogdGhpcy5fc2VyaWFsaXplTWFwcGluZ3MoKVxuICAgIH07XG4gICAgaWYgKHRoaXMuX2ZpbGUgIT0gbnVsbCkge1xuICAgICAgbWFwLmZpbGUgPSB0aGlzLl9maWxlO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICBtYXAuc291cmNlUm9vdCA9IHRoaXMuX3NvdXJjZVJvb3Q7XG4gICAgfVxuICAgIGlmICh0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgIG1hcC5zb3VyY2VzQ29udGVudCA9IHRoaXMuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQobWFwLnNvdXJjZXMsIG1hcC5zb3VyY2VSb290KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFwO1xuICB9O1xuXG4vKipcbiAqIFJlbmRlciB0aGUgc291cmNlIG1hcCBiZWluZyBnZW5lcmF0ZWQgdG8gYSBzdHJpbmcuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUudG9TdHJpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMudG9KU09OKCkpO1xuICB9O1xuXG5leHBvcnRzLlNvdXJjZU1hcEdlbmVyYXRvciA9IFNvdXJjZU1hcEdlbmVyYXRvcjtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIFNvdXJjZU1hcEdlbmVyYXRvciA9IHJlcXVpcmUoJy4vc291cmNlLW1hcC1nZW5lcmF0b3InKS5Tb3VyY2VNYXBHZW5lcmF0b3I7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4vLyBNYXRjaGVzIGEgV2luZG93cy1zdHlsZSBgXFxyXFxuYCBuZXdsaW5lIG9yIGEgYFxcbmAgbmV3bGluZSB1c2VkIGJ5IGFsbCBvdGhlclxuLy8gb3BlcmF0aW5nIHN5c3RlbXMgdGhlc2UgZGF5cyAoY2FwdHVyaW5nIHRoZSByZXN1bHQpLlxudmFyIFJFR0VYX05FV0xJTkUgPSAvKFxccj9cXG4pLztcblxuLy8gTmV3bGluZSBjaGFyYWN0ZXIgY29kZSBmb3IgY2hhckNvZGVBdCgpIGNvbXBhcmlzb25zXG52YXIgTkVXTElORV9DT0RFID0gMTA7XG5cbi8vIFByaXZhdGUgc3ltYm9sIGZvciBpZGVudGlmeWluZyBgU291cmNlTm9kZWBzIHdoZW4gbXVsdGlwbGUgdmVyc2lvbnMgb2Zcbi8vIHRoZSBzb3VyY2UtbWFwIGxpYnJhcnkgYXJlIGxvYWRlZC4gVGhpcyBNVVNUIE5PVCBDSEFOR0UgYWNyb3NzXG4vLyB2ZXJzaW9ucyFcbnZhciBpc1NvdXJjZU5vZGUgPSBcIiQkJGlzU291cmNlTm9kZSQkJFwiO1xuXG4vKipcbiAqIFNvdXJjZU5vZGVzIHByb3ZpZGUgYSB3YXkgdG8gYWJzdHJhY3Qgb3ZlciBpbnRlcnBvbGF0aW5nL2NvbmNhdGVuYXRpbmdcbiAqIHNuaXBwZXRzIG9mIGdlbmVyYXRlZCBKYXZhU2NyaXB0IHNvdXJjZSBjb2RlIHdoaWxlIG1haW50YWluaW5nIHRoZSBsaW5lIGFuZFxuICogY29sdW1uIGluZm9ybWF0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgb3JpZ2luYWwgc291cmNlIGNvZGUuXG4gKlxuICogQHBhcmFtIGFMaW5lIFRoZSBvcmlnaW5hbCBsaW5lIG51bWJlci5cbiAqIEBwYXJhbSBhQ29sdW1uIFRoZSBvcmlnaW5hbCBjb2x1bW4gbnVtYmVyLlxuICogQHBhcmFtIGFTb3VyY2UgVGhlIG9yaWdpbmFsIHNvdXJjZSdzIGZpbGVuYW1lLlxuICogQHBhcmFtIGFDaHVua3MgT3B0aW9uYWwuIEFuIGFycmF5IG9mIHN0cmluZ3Mgd2hpY2ggYXJlIHNuaXBwZXRzIG9mXG4gKiAgICAgICAgZ2VuZXJhdGVkIEpTLCBvciBvdGhlciBTb3VyY2VOb2Rlcy5cbiAqIEBwYXJhbSBhTmFtZSBUaGUgb3JpZ2luYWwgaWRlbnRpZmllci5cbiAqL1xuZnVuY3Rpb24gU291cmNlTm9kZShhTGluZSwgYUNvbHVtbiwgYVNvdXJjZSwgYUNodW5rcywgYU5hbWUpIHtcbiAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICB0aGlzLnNvdXJjZUNvbnRlbnRzID0ge307XG4gIHRoaXMubGluZSA9IGFMaW5lID09IG51bGwgPyBudWxsIDogYUxpbmU7XG4gIHRoaXMuY29sdW1uID0gYUNvbHVtbiA9PSBudWxsID8gbnVsbCA6IGFDb2x1bW47XG4gIHRoaXMuc291cmNlID0gYVNvdXJjZSA9PSBudWxsID8gbnVsbCA6IGFTb3VyY2U7XG4gIHRoaXMubmFtZSA9IGFOYW1lID09IG51bGwgPyBudWxsIDogYU5hbWU7XG4gIHRoaXNbaXNTb3VyY2VOb2RlXSA9IHRydWU7XG4gIGlmIChhQ2h1bmtzICE9IG51bGwpIHRoaXMuYWRkKGFDaHVua3MpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBTb3VyY2VOb2RlIGZyb20gZ2VuZXJhdGVkIGNvZGUgYW5kIGEgU291cmNlTWFwQ29uc3VtZXIuXG4gKlxuICogQHBhcmFtIGFHZW5lcmF0ZWRDb2RlIFRoZSBnZW5lcmF0ZWQgY29kZVxuICogQHBhcmFtIGFTb3VyY2VNYXBDb25zdW1lciBUaGUgU291cmNlTWFwIGZvciB0aGUgZ2VuZXJhdGVkIGNvZGVcbiAqIEBwYXJhbSBhUmVsYXRpdmVQYXRoIE9wdGlvbmFsLiBUaGUgcGF0aCB0aGF0IHJlbGF0aXZlIHNvdXJjZXMgaW4gdGhlXG4gKiAgICAgICAgU291cmNlTWFwQ29uc3VtZXIgc2hvdWxkIGJlIHJlbGF0aXZlIHRvLlxuICovXG5Tb3VyY2VOb2RlLmZyb21TdHJpbmdXaXRoU291cmNlTWFwID1cbiAgZnVuY3Rpb24gU291cmNlTm9kZV9mcm9tU3RyaW5nV2l0aFNvdXJjZU1hcChhR2VuZXJhdGVkQ29kZSwgYVNvdXJjZU1hcENvbnN1bWVyLCBhUmVsYXRpdmVQYXRoKSB7XG4gICAgLy8gVGhlIFNvdXJjZU5vZGUgd2Ugd2FudCB0byBmaWxsIHdpdGggdGhlIGdlbmVyYXRlZCBjb2RlXG4gICAgLy8gYW5kIHRoZSBTb3VyY2VNYXBcbiAgICB2YXIgbm9kZSA9IG5ldyBTb3VyY2VOb2RlKCk7XG5cbiAgICAvLyBBbGwgZXZlbiBpbmRpY2VzIG9mIHRoaXMgYXJyYXkgYXJlIG9uZSBsaW5lIG9mIHRoZSBnZW5lcmF0ZWQgY29kZSxcbiAgICAvLyB3aGlsZSBhbGwgb2RkIGluZGljZXMgYXJlIHRoZSBuZXdsaW5lcyBiZXR3ZWVuIHR3byBhZGphY2VudCBsaW5lc1xuICAgIC8vIChzaW5jZSBgUkVHRVhfTkVXTElORWAgY2FwdHVyZXMgaXRzIG1hdGNoKS5cbiAgICAvLyBQcm9jZXNzZWQgZnJhZ21lbnRzIGFyZSBhY2Nlc3NlZCBieSBjYWxsaW5nIGBzaGlmdE5leHRMaW5lYC5cbiAgICB2YXIgcmVtYWluaW5nTGluZXMgPSBhR2VuZXJhdGVkQ29kZS5zcGxpdChSRUdFWF9ORVdMSU5FKTtcbiAgICB2YXIgcmVtYWluaW5nTGluZXNJbmRleCA9IDA7XG4gICAgdmFyIHNoaWZ0TmV4dExpbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsaW5lQ29udGVudHMgPSBnZXROZXh0TGluZSgpO1xuICAgICAgLy8gVGhlIGxhc3QgbGluZSBvZiBhIGZpbGUgbWlnaHQgbm90IGhhdmUgYSBuZXdsaW5lLlxuICAgICAgdmFyIG5ld0xpbmUgPSBnZXROZXh0TGluZSgpIHx8IFwiXCI7XG4gICAgICByZXR1cm4gbGluZUNvbnRlbnRzICsgbmV3TGluZTtcblxuICAgICAgZnVuY3Rpb24gZ2V0TmV4dExpbmUoKSB7XG4gICAgICAgIHJldHVybiByZW1haW5pbmdMaW5lc0luZGV4IDwgcmVtYWluaW5nTGluZXMubGVuZ3RoID9cbiAgICAgICAgICAgIHJlbWFpbmluZ0xpbmVzW3JlbWFpbmluZ0xpbmVzSW5kZXgrK10gOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIFdlIG5lZWQgdG8gcmVtZW1iZXIgdGhlIHBvc2l0aW9uIG9mIFwicmVtYWluaW5nTGluZXNcIlxuICAgIHZhciBsYXN0R2VuZXJhdGVkTGluZSA9IDEsIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuXG4gICAgLy8gVGhlIGdlbmVyYXRlIFNvdXJjZU5vZGVzIHdlIG5lZWQgYSBjb2RlIHJhbmdlLlxuICAgIC8vIFRvIGV4dHJhY3QgaXQgY3VycmVudCBhbmQgbGFzdCBtYXBwaW5nIGlzIHVzZWQuXG4gICAgLy8gSGVyZSB3ZSBzdG9yZSB0aGUgbGFzdCBtYXBwaW5nLlxuICAgIHZhciBsYXN0TWFwcGluZyA9IG51bGw7XG5cbiAgICBhU291cmNlTWFwQ29uc3VtZXIuZWFjaE1hcHBpbmcoZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgIGlmIChsYXN0TWFwcGluZyAhPT0gbnVsbCkge1xuICAgICAgICAvLyBXZSBhZGQgdGhlIGNvZGUgZnJvbSBcImxhc3RNYXBwaW5nXCIgdG8gXCJtYXBwaW5nXCI6XG4gICAgICAgIC8vIEZpcnN0IGNoZWNrIGlmIHRoZXJlIGlzIGEgbmV3IGxpbmUgaW4gYmV0d2Vlbi5cbiAgICAgICAgaWYgKGxhc3RHZW5lcmF0ZWRMaW5lIDwgbWFwcGluZy5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgLy8gQXNzb2NpYXRlIGZpcnN0IGxpbmUgd2l0aCBcImxhc3RNYXBwaW5nXCJcbiAgICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIHNoaWZ0TmV4dExpbmUoKSk7XG4gICAgICAgICAgbGFzdEdlbmVyYXRlZExpbmUrKztcbiAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgICAgICAvLyBUaGUgcmVtYWluaW5nIGNvZGUgaXMgYWRkZWQgd2l0aG91dCBtYXBwaW5nXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGhlcmUgaXMgbm8gbmV3IGxpbmUgaW4gYmV0d2Vlbi5cbiAgICAgICAgICAvLyBBc3NvY2lhdGUgdGhlIGNvZGUgYmV0d2VlbiBcImxhc3RHZW5lcmF0ZWRDb2x1bW5cIiBhbmRcbiAgICAgICAgICAvLyBcIm1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uXCIgd2l0aCBcImxhc3RNYXBwaW5nXCJcbiAgICAgICAgICB2YXIgbmV4dExpbmUgPSByZW1haW5pbmdMaW5lc1tyZW1haW5pbmdMaW5lc0luZGV4XSB8fCAnJztcbiAgICAgICAgICB2YXIgY29kZSA9IG5leHRMaW5lLnN1YnN0cigwLCBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgICAgcmVtYWluaW5nTGluZXNbcmVtYWluaW5nTGluZXNJbmRleF0gPSBuZXh0TGluZS5zdWJzdHIobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcbiAgICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIGNvZGUpO1xuICAgICAgICAgIC8vIE5vIG1vcmUgcmVtYWluaW5nIGNvZGUsIGNvbnRpbnVlXG4gICAgICAgICAgbGFzdE1hcHBpbmcgPSBtYXBwaW5nO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gV2UgYWRkIHRoZSBnZW5lcmF0ZWQgY29kZSB1bnRpbCB0aGUgZmlyc3QgbWFwcGluZ1xuICAgICAgLy8gdG8gdGhlIFNvdXJjZU5vZGUgd2l0aG91dCBhbnkgbWFwcGluZy5cbiAgICAgIC8vIEVhY2ggbGluZSBpcyBhZGRlZCBhcyBzZXBhcmF0ZSBzdHJpbmcuXG4gICAgICB3aGlsZSAobGFzdEdlbmVyYXRlZExpbmUgPCBtYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgbm9kZS5hZGQoc2hpZnROZXh0TGluZSgpKTtcbiAgICAgICAgbGFzdEdlbmVyYXRlZExpbmUrKztcbiAgICAgIH1cbiAgICAgIGlmIChsYXN0R2VuZXJhdGVkQ29sdW1uIDwgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4pIHtcbiAgICAgICAgdmFyIG5leHRMaW5lID0gcmVtYWluaW5nTGluZXNbcmVtYWluaW5nTGluZXNJbmRleF0gfHwgJyc7XG4gICAgICAgIG5vZGUuYWRkKG5leHRMaW5lLnN1YnN0cigwLCBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbikpO1xuICAgICAgICByZW1haW5pbmdMaW5lc1tyZW1haW5pbmdMaW5lc0luZGV4XSA9IG5leHRMaW5lLnN1YnN0cihtYXBwaW5nLmdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcbiAgICAgIH1cbiAgICAgIGxhc3RNYXBwaW5nID0gbWFwcGluZztcbiAgICB9LCB0aGlzKTtcbiAgICAvLyBXZSBoYXZlIHByb2Nlc3NlZCBhbGwgbWFwcGluZ3MuXG4gICAgaWYgKHJlbWFpbmluZ0xpbmVzSW5kZXggPCByZW1haW5pbmdMaW5lcy5sZW5ndGgpIHtcbiAgICAgIGlmIChsYXN0TWFwcGluZykge1xuICAgICAgICAvLyBBc3NvY2lhdGUgdGhlIHJlbWFpbmluZyBjb2RlIGluIHRoZSBjdXJyZW50IGxpbmUgd2l0aCBcImxhc3RNYXBwaW5nXCJcbiAgICAgICAgYWRkTWFwcGluZ1dpdGhDb2RlKGxhc3RNYXBwaW5nLCBzaGlmdE5leHRMaW5lKCkpO1xuICAgICAgfVxuICAgICAgLy8gYW5kIGFkZCB0aGUgcmVtYWluaW5nIGxpbmVzIHdpdGhvdXQgYW55IG1hcHBpbmdcbiAgICAgIG5vZGUuYWRkKHJlbWFpbmluZ0xpbmVzLnNwbGljZShyZW1haW5pbmdMaW5lc0luZGV4KS5qb2luKFwiXCIpKTtcbiAgICB9XG5cbiAgICAvLyBDb3B5IHNvdXJjZXNDb250ZW50IGludG8gU291cmNlTm9kZVxuICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGUpIHtcbiAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICBpZiAoY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChhUmVsYXRpdmVQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2VGaWxlID0gdXRpbC5qb2luKGFSZWxhdGl2ZVBhdGgsIHNvdXJjZUZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBub2RlO1xuXG4gICAgZnVuY3Rpb24gYWRkTWFwcGluZ1dpdGhDb2RlKG1hcHBpbmcsIGNvZGUpIHtcbiAgICAgIGlmIChtYXBwaW5nID09PSBudWxsIHx8IG1hcHBpbmcuc291cmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbm9kZS5hZGQoY29kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc291cmNlID0gYVJlbGF0aXZlUGF0aFxuICAgICAgICAgID8gdXRpbC5qb2luKGFSZWxhdGl2ZVBhdGgsIG1hcHBpbmcuc291cmNlKVxuICAgICAgICAgIDogbWFwcGluZy5zb3VyY2U7XG4gICAgICAgIG5vZGUuYWRkKG5ldyBTb3VyY2VOb2RlKG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcubmFtZSkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBBZGQgYSBjaHVuayBvZiBnZW5lcmF0ZWQgSlMgdG8gdGhpcyBzb3VyY2Ugbm9kZS5cbiAqXG4gKiBAcGFyYW0gYUNodW5rIEEgc3RyaW5nIHNuaXBwZXQgb2YgZ2VuZXJhdGVkIEpTIGNvZGUsIGFub3RoZXIgaW5zdGFuY2Ugb2ZcbiAqICAgICAgICBTb3VyY2VOb2RlLCBvciBhbiBhcnJheSB3aGVyZSBlYWNoIG1lbWJlciBpcyBvbmUgb2YgdGhvc2UgdGhpbmdzLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX2FkZChhQ2h1bmspIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYUNodW5rKSkge1xuICAgIGFDaHVuay5mb3JFYWNoKGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgdGhpcy5hZGQoY2h1bmspO1xuICAgIH0sIHRoaXMpO1xuICB9XG4gIGVsc2UgaWYgKGFDaHVua1tpc1NvdXJjZU5vZGVdIHx8IHR5cGVvZiBhQ2h1bmsgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAoYUNodW5rKSB7XG4gICAgICB0aGlzLmNoaWxkcmVuLnB1c2goYUNodW5rKTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgIFwiRXhwZWN0ZWQgYSBTb3VyY2VOb2RlLCBzdHJpbmcsIG9yIGFuIGFycmF5IG9mIFNvdXJjZU5vZGVzIGFuZCBzdHJpbmdzLiBHb3QgXCIgKyBhQ2h1bmtcbiAgICApO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGQgYSBjaHVuayBvZiBnZW5lcmF0ZWQgSlMgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGlzIHNvdXJjZSBub2RlLlxuICpcbiAqIEBwYXJhbSBhQ2h1bmsgQSBzdHJpbmcgc25pcHBldCBvZiBnZW5lcmF0ZWQgSlMgY29kZSwgYW5vdGhlciBpbnN0YW5jZSBvZlxuICogICAgICAgIFNvdXJjZU5vZGUsIG9yIGFuIGFycmF5IHdoZXJlIGVhY2ggbWVtYmVyIGlzIG9uZSBvZiB0aG9zZSB0aGluZ3MuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3ByZXBlbmQoYUNodW5rKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFDaHVuaykpIHtcbiAgICBmb3IgKHZhciBpID0gYUNodW5rLmxlbmd0aC0xOyBpID49IDA7IGktLSkge1xuICAgICAgdGhpcy5wcmVwZW5kKGFDaHVua1tpXSk7XG4gICAgfVxuICB9XG4gIGVsc2UgaWYgKGFDaHVua1tpc1NvdXJjZU5vZGVdIHx8IHR5cGVvZiBhQ2h1bmsgPT09IFwic3RyaW5nXCIpIHtcbiAgICB0aGlzLmNoaWxkcmVuLnVuc2hpZnQoYUNodW5rKTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgXCJFeHBlY3RlZCBhIFNvdXJjZU5vZGUsIHN0cmluZywgb3IgYW4gYXJyYXkgb2YgU291cmNlTm9kZXMgYW5kIHN0cmluZ3MuIEdvdCBcIiArIGFDaHVua1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFdhbGsgb3ZlciB0aGUgdHJlZSBvZiBKUyBzbmlwcGV0cyBpbiB0aGlzIG5vZGUgYW5kIGl0cyBjaGlsZHJlbi4gVGhlXG4gKiB3YWxraW5nIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmNlIGZvciBlYWNoIHNuaXBwZXQgb2YgSlMgYW5kIGlzIHBhc3NlZCB0aGF0XG4gKiBzbmlwcGV0IGFuZCB0aGUgaXRzIG9yaWdpbmFsIGFzc29jaWF0ZWQgc291cmNlJ3MgbGluZS9jb2x1bW4gbG9jYXRpb24uXG4gKlxuICogQHBhcmFtIGFGbiBUaGUgdHJhdmVyc2FsIGZ1bmN0aW9uLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gU291cmNlTm9kZV93YWxrKGFGbikge1xuICB2YXIgY2h1bms7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY2h1bmsgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgIGlmIChjaHVua1tpc1NvdXJjZU5vZGVdKSB7XG4gICAgICBjaHVuay53YWxrKGFGbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKGNodW5rICE9PSAnJykge1xuICAgICAgICBhRm4oY2h1bmssIHsgc291cmNlOiB0aGlzLnNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMubGluZSxcbiAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIExpa2UgYFN0cmluZy5wcm90b3R5cGUuam9pbmAgZXhjZXB0IGZvciBTb3VyY2VOb2Rlcy4gSW5zZXJ0cyBgYVN0cmAgYmV0d2VlblxuICogZWFjaCBvZiBgdGhpcy5jaGlsZHJlbmAuXG4gKlxuICogQHBhcmFtIGFTZXAgVGhlIHNlcGFyYXRvci5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfam9pbihhU2VwKSB7XG4gIHZhciBuZXdDaGlsZHJlbjtcbiAgdmFyIGk7XG4gIHZhciBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcbiAgaWYgKGxlbiA+IDApIHtcbiAgICBuZXdDaGlsZHJlbiA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW4tMTsgaSsrKSB7XG4gICAgICBuZXdDaGlsZHJlbi5wdXNoKHRoaXMuY2hpbGRyZW5baV0pO1xuICAgICAgbmV3Q2hpbGRyZW4ucHVzaChhU2VwKTtcbiAgICB9XG4gICAgbmV3Q2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkcmVuW2ldKTtcbiAgICB0aGlzLmNoaWxkcmVuID0gbmV3Q2hpbGRyZW47XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENhbGwgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlIG9uIHRoZSB2ZXJ5IHJpZ2h0LW1vc3Qgc291cmNlIHNuaXBwZXQuIFVzZWZ1bFxuICogZm9yIHRyaW1taW5nIHdoaXRlc3BhY2UgZnJvbSB0aGUgZW5kIG9mIGEgc291cmNlIG5vZGUsIGV0Yy5cbiAqXG4gKiBAcGFyYW0gYVBhdHRlcm4gVGhlIHBhdHRlcm4gdG8gcmVwbGFjZS5cbiAqIEBwYXJhbSBhUmVwbGFjZW1lbnQgVGhlIHRoaW5nIHRvIHJlcGxhY2UgdGhlIHBhdHRlcm4gd2l0aC5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUucmVwbGFjZVJpZ2h0ID0gZnVuY3Rpb24gU291cmNlTm9kZV9yZXBsYWNlUmlnaHQoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCkge1xuICB2YXIgbGFzdENoaWxkID0gdGhpcy5jaGlsZHJlblt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICBpZiAobGFzdENoaWxkW2lzU291cmNlTm9kZV0pIHtcbiAgICBsYXN0Q2hpbGQucmVwbGFjZVJpZ2h0KGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpO1xuICB9XG4gIGVsc2UgaWYgKHR5cGVvZiBsYXN0Q2hpbGQgPT09ICdzdHJpbmcnKSB7XG4gICAgdGhpcy5jaGlsZHJlblt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdID0gbGFzdENoaWxkLnJlcGxhY2UoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhpcy5jaGlsZHJlbi5wdXNoKCcnLnJlcGxhY2UoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCkpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHNvdXJjZSBjb250ZW50IGZvciBhIHNvdXJjZSBmaWxlLiBUaGlzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIFNvdXJjZU1hcEdlbmVyYXRvclxuICogaW4gdGhlIHNvdXJjZXNDb250ZW50IGZpZWxkLlxuICpcbiAqIEBwYXJhbSBhU291cmNlRmlsZSBUaGUgZmlsZW5hbWUgb2YgdGhlIHNvdXJjZSBmaWxlXG4gKiBAcGFyYW0gYVNvdXJjZUNvbnRlbnQgVGhlIGNvbnRlbnQgb2YgdGhlIHNvdXJjZSBmaWxlXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLnNldFNvdXJjZUNvbnRlbnQgPVxuICBmdW5jdGlvbiBTb3VyY2VOb2RlX3NldFNvdXJjZUNvbnRlbnQoYVNvdXJjZUZpbGUsIGFTb3VyY2VDb250ZW50KSB7XG4gICAgdGhpcy5zb3VyY2VDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKGFTb3VyY2VGaWxlKV0gPSBhU291cmNlQ29udGVudDtcbiAgfTtcblxuLyoqXG4gKiBXYWxrIG92ZXIgdGhlIHRyZWUgb2YgU291cmNlTm9kZXMuIFRoZSB3YWxraW5nIGZ1bmN0aW9uIGlzIGNhbGxlZCBmb3IgZWFjaFxuICogc291cmNlIGZpbGUgY29udGVudCBhbmQgaXMgcGFzc2VkIHRoZSBmaWxlbmFtZSBhbmQgc291cmNlIGNvbnRlbnQuXG4gKlxuICogQHBhcmFtIGFGbiBUaGUgdHJhdmVyc2FsIGZ1bmN0aW9uLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS53YWxrU291cmNlQ29udGVudHMgPVxuICBmdW5jdGlvbiBTb3VyY2VOb2RlX3dhbGtTb3VyY2VDb250ZW50cyhhRm4pIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV1baXNTb3VyY2VOb2RlXSkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLndhbGtTb3VyY2VDb250ZW50cyhhRm4pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzb3VyY2VzID0gT2JqZWN0LmtleXModGhpcy5zb3VyY2VDb250ZW50cyk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNvdXJjZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFGbih1dGlsLmZyb21TZXRTdHJpbmcoc291cmNlc1tpXSksIHRoaXMuc291cmNlQ29udGVudHNbc291cmNlc1tpXV0pO1xuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHNvdXJjZSBub2RlLiBXYWxrcyBvdmVyIHRoZSB0cmVlXG4gKiBhbmQgY29uY2F0ZW5hdGVzIGFsbCB0aGUgdmFyaW91cyBzbmlwcGV0cyB0b2dldGhlciB0byBvbmUgc3RyaW5nLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfdG9TdHJpbmcoKSB7XG4gIHZhciBzdHIgPSBcIlwiO1xuICB0aGlzLndhbGsoZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgc3RyICs9IGNodW5rO1xuICB9KTtcbiAgcmV0dXJuIHN0cjtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc291cmNlIG5vZGUgYWxvbmcgd2l0aCBhIHNvdXJjZVxuICogbWFwLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS50b1N0cmluZ1dpdGhTb3VyY2VNYXAgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3RvU3RyaW5nV2l0aFNvdXJjZU1hcChhQXJncykge1xuICB2YXIgZ2VuZXJhdGVkID0ge1xuICAgIGNvZGU6IFwiXCIsXG4gICAgbGluZTogMSxcbiAgICBjb2x1bW46IDBcbiAgfTtcbiAgdmFyIG1hcCA9IG5ldyBTb3VyY2VNYXBHZW5lcmF0b3IoYUFyZ3MpO1xuICB2YXIgc291cmNlTWFwcGluZ0FjdGl2ZSA9IGZhbHNlO1xuICB2YXIgbGFzdE9yaWdpbmFsU291cmNlID0gbnVsbDtcbiAgdmFyIGxhc3RPcmlnaW5hbExpbmUgPSBudWxsO1xuICB2YXIgbGFzdE9yaWdpbmFsQ29sdW1uID0gbnVsbDtcbiAgdmFyIGxhc3RPcmlnaW5hbE5hbWUgPSBudWxsO1xuICB0aGlzLndhbGsoZnVuY3Rpb24gKGNodW5rLCBvcmlnaW5hbCkge1xuICAgIGdlbmVyYXRlZC5jb2RlICs9IGNodW5rO1xuICAgIGlmIChvcmlnaW5hbC5zb3VyY2UgIT09IG51bGxcbiAgICAgICAgJiYgb3JpZ2luYWwubGluZSAhPT0gbnVsbFxuICAgICAgICAmJiBvcmlnaW5hbC5jb2x1bW4gIT09IG51bGwpIHtcbiAgICAgIGlmKGxhc3RPcmlnaW5hbFNvdXJjZSAhPT0gb3JpZ2luYWwuc291cmNlXG4gICAgICAgICB8fCBsYXN0T3JpZ2luYWxMaW5lICE9PSBvcmlnaW5hbC5saW5lXG4gICAgICAgICB8fCBsYXN0T3JpZ2luYWxDb2x1bW4gIT09IG9yaWdpbmFsLmNvbHVtblxuICAgICAgICAgfHwgbGFzdE9yaWdpbmFsTmFtZSAhPT0gb3JpZ2luYWwubmFtZSkge1xuICAgICAgICBtYXAuYWRkTWFwcGluZyh7XG4gICAgICAgICAgc291cmNlOiBvcmlnaW5hbC5zb3VyY2UsXG4gICAgICAgICAgb3JpZ2luYWw6IHtcbiAgICAgICAgICAgIGxpbmU6IG9yaWdpbmFsLmxpbmUsXG4gICAgICAgICAgICBjb2x1bW46IG9yaWdpbmFsLmNvbHVtblxuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkLmNvbHVtblxuICAgICAgICAgIH0sXG4gICAgICAgICAgbmFtZTogb3JpZ2luYWwubmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG9yaWdpbmFsLnNvdXJjZTtcbiAgICAgIGxhc3RPcmlnaW5hbExpbmUgPSBvcmlnaW5hbC5saW5lO1xuICAgICAgbGFzdE9yaWdpbmFsQ29sdW1uID0gb3JpZ2luYWwuY29sdW1uO1xuICAgICAgbGFzdE9yaWdpbmFsTmFtZSA9IG9yaWdpbmFsLm5hbWU7XG4gICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHNvdXJjZU1hcHBpbmdBY3RpdmUpIHtcbiAgICAgIG1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gbnVsbDtcbiAgICAgIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICB9XG4gICAgZm9yICh2YXIgaWR4ID0gMCwgbGVuZ3RoID0gY2h1bmsubGVuZ3RoOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICBpZiAoY2h1bmsuY2hhckNvZGVBdChpZHgpID09PSBORVdMSU5FX0NPREUpIHtcbiAgICAgICAgZ2VuZXJhdGVkLmxpbmUrKztcbiAgICAgICAgZ2VuZXJhdGVkLmNvbHVtbiA9IDA7XG4gICAgICAgIC8vIE1hcHBpbmdzIGVuZCBhdCBlb2xcbiAgICAgICAgaWYgKGlkeCArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgc291cmNlTWFwcGluZ0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZU1hcHBpbmdBY3RpdmUpIHtcbiAgICAgICAgICBtYXAuYWRkTWFwcGluZyh7XG4gICAgICAgICAgICBzb3VyY2U6IG9yaWdpbmFsLnNvdXJjZSxcbiAgICAgICAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgICAgICAgIGxpbmU6IG9yaWdpbmFsLmxpbmUsXG4gICAgICAgICAgICAgIGNvbHVtbjogb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuYW1lOiBvcmlnaW5hbC5uYW1lXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdlbmVyYXRlZC5jb2x1bW4rKztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICB0aGlzLndhbGtTb3VyY2VDb250ZW50cyhmdW5jdGlvbiAoc291cmNlRmlsZSwgc291cmNlQ29udGVudCkge1xuICAgIG1hcC5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIHNvdXJjZUNvbnRlbnQpO1xuICB9KTtcblxuICByZXR1cm4geyBjb2RlOiBnZW5lcmF0ZWQuY29kZSwgbWFwOiBtYXAgfTtcbn07XG5cbmV4cG9ydHMuU291cmNlTm9kZSA9IFNvdXJjZU5vZGU7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbi8qKlxuICogVGhpcyBpcyBhIGhlbHBlciBmdW5jdGlvbiBmb3IgZ2V0dGluZyB2YWx1ZXMgZnJvbSBwYXJhbWV0ZXIvb3B0aW9uc1xuICogb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0gYXJncyBUaGUgb2JqZWN0IHdlIGFyZSBleHRyYWN0aW5nIHZhbHVlcyBmcm9tXG4gKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgd2UgYXJlIGdldHRpbmcuXG4gKiBAcGFyYW0gZGVmYXVsdFZhbHVlIEFuIG9wdGlvbmFsIHZhbHVlIHRvIHJldHVybiBpZiB0aGUgcHJvcGVydHkgaXMgbWlzc2luZ1xuICogZnJvbSB0aGUgb2JqZWN0LiBJZiB0aGlzIGlzIG5vdCBzcGVjaWZpZWQgYW5kIHRoZSBwcm9wZXJ0eSBpcyBtaXNzaW5nLCBhblxuICogZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gKi9cbmZ1bmN0aW9uIGdldEFyZyhhQXJncywgYU5hbWUsIGFEZWZhdWx0VmFsdWUpIHtcbiAgaWYgKGFOYW1lIGluIGFBcmdzKSB7XG4gICAgcmV0dXJuIGFBcmdzW2FOYW1lXTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgcmV0dXJuIGFEZWZhdWx0VmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhTmFtZSArICdcIiBpcyBhIHJlcXVpcmVkIGFyZ3VtZW50LicpO1xuICB9XG59XG5leHBvcnRzLmdldEFyZyA9IGdldEFyZztcblxudmFyIHVybFJlZ2V4cCA9IC9eKD86KFtcXHcrXFwtLl0rKTopP1xcL1xcLyg/OihcXHcrOlxcdyspQCk/KFtcXHcuLV0qKSg/OjooXFxkKykpPyguKikkLztcbnZhciBkYXRhVXJsUmVnZXhwID0gL15kYXRhOi4rXFwsLiskLztcblxuZnVuY3Rpb24gdXJsUGFyc2UoYVVybCkge1xuICB2YXIgbWF0Y2ggPSBhVXJsLm1hdGNoKHVybFJlZ2V4cCk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHNjaGVtZTogbWF0Y2hbMV0sXG4gICAgYXV0aDogbWF0Y2hbMl0sXG4gICAgaG9zdDogbWF0Y2hbM10sXG4gICAgcG9ydDogbWF0Y2hbNF0sXG4gICAgcGF0aDogbWF0Y2hbNV1cbiAgfTtcbn1cbmV4cG9ydHMudXJsUGFyc2UgPSB1cmxQYXJzZTtcblxuZnVuY3Rpb24gdXJsR2VuZXJhdGUoYVBhcnNlZFVybCkge1xuICB2YXIgdXJsID0gJyc7XG4gIGlmIChhUGFyc2VkVXJsLnNjaGVtZSkge1xuICAgIHVybCArPSBhUGFyc2VkVXJsLnNjaGVtZSArICc6JztcbiAgfVxuICB1cmwgKz0gJy8vJztcbiAgaWYgKGFQYXJzZWRVcmwuYXV0aCkge1xuICAgIHVybCArPSBhUGFyc2VkVXJsLmF1dGggKyAnQCc7XG4gIH1cbiAgaWYgKGFQYXJzZWRVcmwuaG9zdCkge1xuICAgIHVybCArPSBhUGFyc2VkVXJsLmhvc3Q7XG4gIH1cbiAgaWYgKGFQYXJzZWRVcmwucG9ydCkge1xuICAgIHVybCArPSBcIjpcIiArIGFQYXJzZWRVcmwucG9ydFxuICB9XG4gIGlmIChhUGFyc2VkVXJsLnBhdGgpIHtcbiAgICB1cmwgKz0gYVBhcnNlZFVybC5wYXRoO1xuICB9XG4gIHJldHVybiB1cmw7XG59XG5leHBvcnRzLnVybEdlbmVyYXRlID0gdXJsR2VuZXJhdGU7XG5cbi8qKlxuICogTm9ybWFsaXplcyBhIHBhdGgsIG9yIHRoZSBwYXRoIHBvcnRpb24gb2YgYSBVUkw6XG4gKlxuICogLSBSZXBsYWNlcyBjb25zZWN1dGl2ZSBzbGFzaGVzIHdpdGggb25lIHNsYXNoLlxuICogLSBSZW1vdmVzIHVubmVjZXNzYXJ5ICcuJyBwYXJ0cy5cbiAqIC0gUmVtb3ZlcyB1bm5lY2Vzc2FyeSAnPGRpcj4vLi4nIHBhcnRzLlxuICpcbiAqIEJhc2VkIG9uIGNvZGUgaW4gdGhlIE5vZGUuanMgJ3BhdGgnIGNvcmUgbW9kdWxlLlxuICpcbiAqIEBwYXJhbSBhUGF0aCBUaGUgcGF0aCBvciB1cmwgdG8gbm9ybWFsaXplLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemUoYVBhdGgpIHtcbiAgdmFyIHBhdGggPSBhUGF0aDtcbiAgdmFyIHVybCA9IHVybFBhcnNlKGFQYXRoKTtcbiAgaWYgKHVybCkge1xuICAgIGlmICghdXJsLnBhdGgpIHtcbiAgICAgIHJldHVybiBhUGF0aDtcbiAgICB9XG4gICAgcGF0aCA9IHVybC5wYXRoO1xuICB9XG4gIHZhciBpc0Fic29sdXRlID0gZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpO1xuXG4gIHZhciBwYXJ0cyA9IHBhdGguc3BsaXQoL1xcLysvKTtcbiAgZm9yICh2YXIgcGFydCwgdXAgPSAwLCBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBwYXJ0ID0gcGFydHNbaV07XG4gICAgaWYgKHBhcnQgPT09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAocGFydCA9PT0gJy4uJykge1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwID4gMCkge1xuICAgICAgaWYgKHBhcnQgPT09ICcnKSB7XG4gICAgICAgIC8vIFRoZSBmaXJzdCBwYXJ0IGlzIGJsYW5rIGlmIHRoZSBwYXRoIGlzIGFic29sdXRlLiBUcnlpbmcgdG8gZ29cbiAgICAgICAgLy8gYWJvdmUgdGhlIHJvb3QgaXMgYSBuby1vcC4gVGhlcmVmb3JlIHdlIGNhbiByZW1vdmUgYWxsICcuLicgcGFydHNcbiAgICAgICAgLy8gZGlyZWN0bHkgYWZ0ZXIgdGhlIHJvb3QuXG4gICAgICAgIHBhcnRzLnNwbGljZShpICsgMSwgdXApO1xuICAgICAgICB1cCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0cy5zcGxpY2UoaSwgMik7XG4gICAgICAgIHVwLS07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHBhdGggPSBwYXJ0cy5qb2luKCcvJyk7XG5cbiAgaWYgKHBhdGggPT09ICcnKSB7XG4gICAgcGF0aCA9IGlzQWJzb2x1dGUgPyAnLycgOiAnLic7XG4gIH1cblxuICBpZiAodXJsKSB7XG4gICAgdXJsLnBhdGggPSBwYXRoO1xuICAgIHJldHVybiB1cmxHZW5lcmF0ZSh1cmwpO1xuICB9XG4gIHJldHVybiBwYXRoO1xufVxuZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG5cbi8qKlxuICogSm9pbnMgdHdvIHBhdGhzL1VSTHMuXG4gKlxuICogQHBhcmFtIGFSb290IFRoZSByb290IHBhdGggb3IgVVJMLlxuICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIFVSTCB0byBiZSBqb2luZWQgd2l0aCB0aGUgcm9vdC5cbiAqXG4gKiAtIElmIGFQYXRoIGlzIGEgVVJMIG9yIGEgZGF0YSBVUkksIGFQYXRoIGlzIHJldHVybmVkLCB1bmxlc3MgYVBhdGggaXMgYVxuICogICBzY2hlbWUtcmVsYXRpdmUgVVJMOiBUaGVuIHRoZSBzY2hlbWUgb2YgYVJvb3QsIGlmIGFueSwgaXMgcHJlcGVuZGVkXG4gKiAgIGZpcnN0LlxuICogLSBPdGhlcndpc2UgYVBhdGggaXMgYSBwYXRoLiBJZiBhUm9vdCBpcyBhIFVSTCwgdGhlbiBpdHMgcGF0aCBwb3J0aW9uXG4gKiAgIGlzIHVwZGF0ZWQgd2l0aCB0aGUgcmVzdWx0IGFuZCBhUm9vdCBpcyByZXR1cm5lZC4gT3RoZXJ3aXNlIHRoZSByZXN1bHRcbiAqICAgaXMgcmV0dXJuZWQuXG4gKiAgIC0gSWYgYVBhdGggaXMgYWJzb2x1dGUsIHRoZSByZXN1bHQgaXMgYVBhdGguXG4gKiAgIC0gT3RoZXJ3aXNlIHRoZSB0d28gcGF0aHMgYXJlIGpvaW5lZCB3aXRoIGEgc2xhc2guXG4gKiAtIEpvaW5pbmcgZm9yIGV4YW1wbGUgJ2h0dHA6Ly8nIGFuZCAnd3d3LmV4YW1wbGUuY29tJyBpcyBhbHNvIHN1cHBvcnRlZC5cbiAqL1xuZnVuY3Rpb24gam9pbihhUm9vdCwgYVBhdGgpIHtcbiAgaWYgKGFSb290ID09PSBcIlwiKSB7XG4gICAgYVJvb3QgPSBcIi5cIjtcbiAgfVxuICBpZiAoYVBhdGggPT09IFwiXCIpIHtcbiAgICBhUGF0aCA9IFwiLlwiO1xuICB9XG4gIHZhciBhUGF0aFVybCA9IHVybFBhcnNlKGFQYXRoKTtcbiAgdmFyIGFSb290VXJsID0gdXJsUGFyc2UoYVJvb3QpO1xuICBpZiAoYVJvb3RVcmwpIHtcbiAgICBhUm9vdCA9IGFSb290VXJsLnBhdGggfHwgJy8nO1xuICB9XG5cbiAgLy8gYGpvaW4oZm9vLCAnLy93d3cuZXhhbXBsZS5vcmcnKWBcbiAgaWYgKGFQYXRoVXJsICYmICFhUGF0aFVybC5zY2hlbWUpIHtcbiAgICBpZiAoYVJvb3RVcmwpIHtcbiAgICAgIGFQYXRoVXJsLnNjaGVtZSA9IGFSb290VXJsLnNjaGVtZTtcbiAgICB9XG4gICAgcmV0dXJuIHVybEdlbmVyYXRlKGFQYXRoVXJsKTtcbiAgfVxuXG4gIGlmIChhUGF0aFVybCB8fCBhUGF0aC5tYXRjaChkYXRhVXJsUmVnZXhwKSkge1xuICAgIHJldHVybiBhUGF0aDtcbiAgfVxuXG4gIC8vIGBqb2luKCdodHRwOi8vJywgJ3d3dy5leGFtcGxlLmNvbScpYFxuICBpZiAoYVJvb3RVcmwgJiYgIWFSb290VXJsLmhvc3QgJiYgIWFSb290VXJsLnBhdGgpIHtcbiAgICBhUm9vdFVybC5ob3N0ID0gYVBhdGg7XG4gICAgcmV0dXJuIHVybEdlbmVyYXRlKGFSb290VXJsKTtcbiAgfVxuXG4gIHZhciBqb2luZWQgPSBhUGF0aC5jaGFyQXQoMCkgPT09ICcvJ1xuICAgID8gYVBhdGhcbiAgICA6IG5vcm1hbGl6ZShhUm9vdC5yZXBsYWNlKC9cXC8rJC8sICcnKSArICcvJyArIGFQYXRoKTtcblxuICBpZiAoYVJvb3RVcmwpIHtcbiAgICBhUm9vdFVybC5wYXRoID0gam9pbmVkO1xuICAgIHJldHVybiB1cmxHZW5lcmF0ZShhUm9vdFVybCk7XG4gIH1cbiAgcmV0dXJuIGpvaW5lZDtcbn1cbmV4cG9ydHMuam9pbiA9IGpvaW47XG5cbmV4cG9ydHMuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uIChhUGF0aCkge1xuICByZXR1cm4gYVBhdGguY2hhckF0KDApID09PSAnLycgfHwgdXJsUmVnZXhwLnRlc3QoYVBhdGgpO1xufTtcblxuLyoqXG4gKiBNYWtlIGEgcGF0aCByZWxhdGl2ZSB0byBhIFVSTCBvciBhbm90aGVyIHBhdGguXG4gKlxuICogQHBhcmFtIGFSb290IFRoZSByb290IHBhdGggb3IgVVJMLlxuICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIFVSTCB0byBiZSBtYWRlIHJlbGF0aXZlIHRvIGFSb290LlxuICovXG5mdW5jdGlvbiByZWxhdGl2ZShhUm9vdCwgYVBhdGgpIHtcbiAgaWYgKGFSb290ID09PSBcIlwiKSB7XG4gICAgYVJvb3QgPSBcIi5cIjtcbiAgfVxuXG4gIGFSb290ID0gYVJvb3QucmVwbGFjZSgvXFwvJC8sICcnKTtcblxuICAvLyBJdCBpcyBwb3NzaWJsZSBmb3IgdGhlIHBhdGggdG8gYmUgYWJvdmUgdGhlIHJvb3QuIEluIHRoaXMgY2FzZSwgc2ltcGx5XG4gIC8vIGNoZWNraW5nIHdoZXRoZXIgdGhlIHJvb3QgaXMgYSBwcmVmaXggb2YgdGhlIHBhdGggd29uJ3Qgd29yay4gSW5zdGVhZCwgd2VcbiAgLy8gbmVlZCB0byByZW1vdmUgY29tcG9uZW50cyBmcm9tIHRoZSByb290IG9uZSBieSBvbmUsIHVudGlsIGVpdGhlciB3ZSBmaW5kXG4gIC8vIGEgcHJlZml4IHRoYXQgZml0cywgb3Igd2UgcnVuIG91dCBvZiBjb21wb25lbnRzIHRvIHJlbW92ZS5cbiAgdmFyIGxldmVsID0gMDtcbiAgd2hpbGUgKGFQYXRoLmluZGV4T2YoYVJvb3QgKyAnLycpICE9PSAwKSB7XG4gICAgdmFyIGluZGV4ID0gYVJvb3QubGFzdEluZGV4T2YoXCIvXCIpO1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHJldHVybiBhUGF0aDtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgb25seSBwYXJ0IG9mIHRoZSByb290IHRoYXQgaXMgbGVmdCBpcyB0aGUgc2NoZW1lIChpLmUuIGh0dHA6Ly8sXG4gICAgLy8gZmlsZTovLy8sIGV0Yy4pLCBvbmUgb3IgbW9yZSBzbGFzaGVzICgvKSwgb3Igc2ltcGx5IG5vdGhpbmcgYXQgYWxsLCB3ZVxuICAgIC8vIGhhdmUgZXhoYXVzdGVkIGFsbCBjb21wb25lbnRzLCBzbyB0aGUgcGF0aCBpcyBub3QgcmVsYXRpdmUgdG8gdGhlIHJvb3QuXG4gICAgYVJvb3QgPSBhUm9vdC5zbGljZSgwLCBpbmRleCk7XG4gICAgaWYgKGFSb290Lm1hdGNoKC9eKFteXFwvXSs6XFwvKT9cXC8qJC8pKSB7XG4gICAgICByZXR1cm4gYVBhdGg7XG4gICAgfVxuXG4gICAgKytsZXZlbDtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSB3ZSBhZGQgYSBcIi4uL1wiIGZvciBlYWNoIGNvbXBvbmVudCB3ZSByZW1vdmVkIGZyb20gdGhlIHJvb3QuXG4gIHJldHVybiBBcnJheShsZXZlbCArIDEpLmpvaW4oXCIuLi9cIikgKyBhUGF0aC5zdWJzdHIoYVJvb3QubGVuZ3RoICsgMSk7XG59XG5leHBvcnRzLnJlbGF0aXZlID0gcmVsYXRpdmU7XG5cbnZhciBzdXBwb3J0c051bGxQcm90byA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBvYmogPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gISgnX19wcm90b19fJyBpbiBvYmopO1xufSgpKTtcblxuZnVuY3Rpb24gaWRlbnRpdHkgKHMpIHtcbiAgcmV0dXJuIHM7XG59XG5cbi8qKlxuICogQmVjYXVzZSBiZWhhdmlvciBnb2VzIHdhY2t5IHdoZW4geW91IHNldCBgX19wcm90b19fYCBvbiBvYmplY3RzLCB3ZVxuICogaGF2ZSB0byBwcmVmaXggYWxsIHRoZSBzdHJpbmdzIGluIG91ciBzZXQgd2l0aCBhbiBhcmJpdHJhcnkgY2hhcmFjdGVyLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL3B1bGwvMzEgYW5kXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL2lzc3Vlcy8zMFxuICpcbiAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICovXG5mdW5jdGlvbiB0b1NldFN0cmluZyhhU3RyKSB7XG4gIGlmIChpc1Byb3RvU3RyaW5nKGFTdHIpKSB7XG4gICAgcmV0dXJuICckJyArIGFTdHI7XG4gIH1cblxuICByZXR1cm4gYVN0cjtcbn1cbmV4cG9ydHMudG9TZXRTdHJpbmcgPSBzdXBwb3J0c051bGxQcm90byA/IGlkZW50aXR5IDogdG9TZXRTdHJpbmc7XG5cbmZ1bmN0aW9uIGZyb21TZXRTdHJpbmcoYVN0cikge1xuICBpZiAoaXNQcm90b1N0cmluZyhhU3RyKSkge1xuICAgIHJldHVybiBhU3RyLnNsaWNlKDEpO1xuICB9XG5cbiAgcmV0dXJuIGFTdHI7XG59XG5leHBvcnRzLmZyb21TZXRTdHJpbmcgPSBzdXBwb3J0c051bGxQcm90byA/IGlkZW50aXR5IDogZnJvbVNldFN0cmluZztcblxuZnVuY3Rpb24gaXNQcm90b1N0cmluZyhzKSB7XG4gIGlmICghcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBzLmxlbmd0aDtcblxuICBpZiAobGVuZ3RoIDwgOSAvKiBcIl9fcHJvdG9fX1wiLmxlbmd0aCAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChzLmNoYXJDb2RlQXQobGVuZ3RoIC0gMSkgIT09IDk1ICAvKiAnXycgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSAyKSAhPT0gOTUgIC8qICdfJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDMpICE9PSAxMTEgLyogJ28nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gNCkgIT09IDExNiAvKiAndCcgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA1KSAhPT0gMTExIC8qICdvJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDYpICE9PSAxMTQgLyogJ3InICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gNykgIT09IDExMiAvKiAncCcgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA4KSAhPT0gOTUgIC8qICdfJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDkpICE9PSA5NSAgLyogJ18nICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IGxlbmd0aCAtIDEwOyBpID49IDA7IGktLSkge1xuICAgIGlmIChzLmNoYXJDb2RlQXQoaSkgIT09IDM2IC8qICckJyAqLykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIENvbXBhcmF0b3IgYmV0d2VlbiB0d28gbWFwcGluZ3Mgd2hlcmUgdGhlIG9yaWdpbmFsIHBvc2l0aW9ucyBhcmUgY29tcGFyZWQuXG4gKlxuICogT3B0aW9uYWxseSBwYXNzIGluIGB0cnVlYCBhcyBgb25seUNvbXBhcmVHZW5lcmF0ZWRgIHRvIGNvbnNpZGVyIHR3b1xuICogbWFwcGluZ3Mgd2l0aCB0aGUgc2FtZSBvcmlnaW5hbCBzb3VyY2UvbGluZS9jb2x1bW4sIGJ1dCBkaWZmZXJlbnQgZ2VuZXJhdGVkXG4gKiBsaW5lIGFuZCBjb2x1bW4gdGhlIHNhbWUuIFVzZWZ1bCB3aGVuIHNlYXJjaGluZyBmb3IgYSBtYXBwaW5nIHdpdGggYVxuICogc3R1YmJlZCBvdXQgbWFwcGluZy5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMobWFwcGluZ0EsIG1hcHBpbmdCLCBvbmx5Q29tcGFyZU9yaWdpbmFsKSB7XG4gIHZhciBjbXAgPSBzdHJjbXAobWFwcGluZ0Euc291cmNlLCBtYXBwaW5nQi5zb3VyY2UpO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsTGluZSAtIG1hcHBpbmdCLm9yaWdpbmFsTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICBpZiAoY21wICE9PSAwIHx8IG9ubHlDb21wYXJlT3JpZ2luYWwpIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uIC0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmUgLSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIHJldHVybiBzdHJjbXAobWFwcGluZ0EubmFtZSwgbWFwcGluZ0IubmFtZSk7XG59XG5leHBvcnRzLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zID0gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnM7XG5cbi8qKlxuICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aXRoIGRlZmxhdGVkIHNvdXJjZSBhbmQgbmFtZSBpbmRpY2VzIHdoZXJlXG4gKiB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucyBhcmUgY29tcGFyZWQuXG4gKlxuICogT3B0aW9uYWxseSBwYXNzIGluIGB0cnVlYCBhcyBgb25seUNvbXBhcmVHZW5lcmF0ZWRgIHRvIGNvbnNpZGVyIHR3b1xuICogbWFwcGluZ3Mgd2l0aCB0aGUgc2FtZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uLCBidXQgZGlmZmVyZW50XG4gKiBzb3VyY2UvbmFtZS9vcmlnaW5hbCBsaW5lIGFuZCBjb2x1bW4gdGhlIHNhbWUuIFVzZWZ1bCB3aGVuIHNlYXJjaGluZyBmb3IgYVxuICogbWFwcGluZyB3aXRoIGEgc3R1YmJlZCBvdXQgbWFwcGluZy5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQobWFwcGluZ0EsIG1hcHBpbmdCLCBvbmx5Q29tcGFyZUdlbmVyYXRlZCkge1xuICB2YXIgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZSAtIG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uIC0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICBpZiAoY21wICE9PSAwIHx8IG9ubHlDb21wYXJlR2VuZXJhdGVkKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IHN0cmNtcChtYXBwaW5nQS5zb3VyY2UsIG1hcHBpbmdCLnNvdXJjZSk7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxMaW5lIC0gbWFwcGluZ0Iub3JpZ2luYWxMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsQ29sdW1uIC0gbWFwcGluZ0Iub3JpZ2luYWxDb2x1bW47XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgcmV0dXJuIHN0cmNtcChtYXBwaW5nQS5uYW1lLCBtYXBwaW5nQi5uYW1lKTtcbn1cbmV4cG9ydHMuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQgPSBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZDtcblxuZnVuY3Rpb24gc3RyY21wKGFTdHIxLCBhU3RyMikge1xuICBpZiAoYVN0cjEgPT09IGFTdHIyKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBpZiAoYVN0cjEgPT09IG51bGwpIHtcbiAgICByZXR1cm4gMTsgLy8gYVN0cjIgIT09IG51bGxcbiAgfVxuXG4gIGlmIChhU3RyMiA9PT0gbnVsbCkge1xuICAgIHJldHVybiAtMTsgLy8gYVN0cjEgIT09IG51bGxcbiAgfVxuXG4gIGlmIChhU3RyMSA+IGFTdHIyKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aXRoIGluZmxhdGVkIHNvdXJjZSBhbmQgbmFtZSBzdHJpbmdzIHdoZXJlXG4gKiB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucyBhcmUgY29tcGFyZWQuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKG1hcHBpbmdBLCBtYXBwaW5nQikge1xuICB2YXIgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZSAtIG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uIC0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IHN0cmNtcChtYXBwaW5nQS5zb3VyY2UsIG1hcHBpbmdCLnNvdXJjZSk7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxMaW5lIC0gbWFwcGluZ0Iub3JpZ2luYWxMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsQ29sdW1uIC0gbWFwcGluZ0Iub3JpZ2luYWxDb2x1bW47XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgcmV0dXJuIHN0cmNtcChtYXBwaW5nQS5uYW1lLCBtYXBwaW5nQi5uYW1lKTtcbn1cbmV4cG9ydHMuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQgPSBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZDtcblxuLyoqXG4gKiBTdHJpcCBhbnkgSlNPTiBYU1NJIGF2b2lkYW5jZSBwcmVmaXggZnJvbSB0aGUgc3RyaW5nIChhcyBkb2N1bWVudGVkXG4gKiBpbiB0aGUgc291cmNlIG1hcHMgc3BlY2lmaWNhdGlvbiksIGFuZCB0aGVuIHBhcnNlIHRoZSBzdHJpbmcgYXNcbiAqIEpTT04uXG4gKi9cbmZ1bmN0aW9uIHBhcnNlU291cmNlTWFwSW5wdXQoc3RyKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKHN0ci5yZXBsYWNlKC9eXFwpXX0nW15cXG5dKlxcbi8sICcnKSk7XG59XG5leHBvcnRzLnBhcnNlU291cmNlTWFwSW5wdXQgPSBwYXJzZVNvdXJjZU1hcElucHV0O1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIFVSTCBvZiBhIHNvdXJjZSBnaXZlbiB0aGUgdGhlIHNvdXJjZSByb290LCB0aGUgc291cmNlJ3NcbiAqIFVSTCwgYW5kIHRoZSBzb3VyY2UgbWFwJ3MgVVJMLlxuICovXG5mdW5jdGlvbiBjb21wdXRlU291cmNlVVJMKHNvdXJjZVJvb3QsIHNvdXJjZVVSTCwgc291cmNlTWFwVVJMKSB7XG4gIHNvdXJjZVVSTCA9IHNvdXJjZVVSTCB8fCAnJztcblxuICBpZiAoc291cmNlUm9vdCkge1xuICAgIC8vIFRoaXMgZm9sbG93cyB3aGF0IENocm9tZSBkb2VzLlxuICAgIGlmIChzb3VyY2VSb290W3NvdXJjZVJvb3QubGVuZ3RoIC0gMV0gIT09ICcvJyAmJiBzb3VyY2VVUkxbMF0gIT09ICcvJykge1xuICAgICAgc291cmNlUm9vdCArPSAnLyc7XG4gICAgfVxuICAgIC8vIFRoZSBzcGVjIHNheXM6XG4gICAgLy8gICBMaW5lIDQ6IEFuIG9wdGlvbmFsIHNvdXJjZSByb290LCB1c2VmdWwgZm9yIHJlbG9jYXRpbmcgc291cmNlXG4gICAgLy8gICBmaWxlcyBvbiBhIHNlcnZlciBvciByZW1vdmluZyByZXBlYXRlZCB2YWx1ZXMgaW4gdGhlXG4gICAgLy8gICDigJxzb3VyY2Vz4oCdIGVudHJ5LiAgVGhpcyB2YWx1ZSBpcyBwcmVwZW5kZWQgdG8gdGhlIGluZGl2aWR1YWxcbiAgICAvLyAgIGVudHJpZXMgaW4gdGhlIOKAnHNvdXJjZeKAnSBmaWVsZC5cbiAgICBzb3VyY2VVUkwgPSBzb3VyY2VSb290ICsgc291cmNlVVJMO1xuICB9XG5cbiAgLy8gSGlzdG9yaWNhbGx5LCBTb3VyY2VNYXBDb25zdW1lciBkaWQgbm90IHRha2UgdGhlIHNvdXJjZU1hcFVSTCBhc1xuICAvLyBhIHBhcmFtZXRlci4gIFRoaXMgbW9kZSBpcyBzdGlsbCBzb21ld2hhdCBzdXBwb3J0ZWQsIHdoaWNoIGlzIHdoeVxuICAvLyB0aGlzIGNvZGUgYmxvY2sgaXMgY29uZGl0aW9uYWwuICBIb3dldmVyLCBpdCdzIHByZWZlcmFibGUgdG8gcGFzc1xuICAvLyB0aGUgc291cmNlIG1hcCBVUkwgdG8gU291cmNlTWFwQ29uc3VtZXIsIHNvIHRoYXQgdGhpcyBmdW5jdGlvblxuICAvLyBjYW4gaW1wbGVtZW50IHRoZSBzb3VyY2UgVVJMIHJlc29sdXRpb24gYWxnb3JpdGhtIGFzIG91dGxpbmVkIGluXG4gIC8vIHRoZSBzcGVjLiAgVGhpcyBibG9jayBpcyBiYXNpY2FsbHkgdGhlIGVxdWl2YWxlbnQgb2Y6XG4gIC8vICAgIG5ldyBVUkwoc291cmNlVVJMLCBzb3VyY2VNYXBVUkwpLnRvU3RyaW5nKClcbiAgLy8gLi4uIGV4Y2VwdCBpdCBhdm9pZHMgdXNpbmcgVVJMLCB3aGljaCB3YXNuJ3QgYXZhaWxhYmxlIGluIHRoZVxuICAvLyBvbGRlciByZWxlYXNlcyBvZiBub2RlIHN0aWxsIHN1cHBvcnRlZCBieSB0aGlzIGxpYnJhcnkuXG4gIC8vXG4gIC8vIFRoZSBzcGVjIHNheXM6XG4gIC8vICAgSWYgdGhlIHNvdXJjZXMgYXJlIG5vdCBhYnNvbHV0ZSBVUkxzIGFmdGVyIHByZXBlbmRpbmcgb2YgdGhlXG4gIC8vICAg4oCcc291cmNlUm9vdOKAnSwgdGhlIHNvdXJjZXMgYXJlIHJlc29sdmVkIHJlbGF0aXZlIHRvIHRoZVxuICAvLyAgIFNvdXJjZU1hcCAobGlrZSByZXNvbHZpbmcgc2NyaXB0IHNyYyBpbiBhIGh0bWwgZG9jdW1lbnQpLlxuICBpZiAoc291cmNlTWFwVVJMKSB7XG4gICAgdmFyIHBhcnNlZCA9IHVybFBhcnNlKHNvdXJjZU1hcFVSTCk7XG4gICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInNvdXJjZU1hcFVSTCBjb3VsZCBub3QgYmUgcGFyc2VkXCIpO1xuICAgIH1cbiAgICBpZiAocGFyc2VkLnBhdGgpIHtcbiAgICAgIC8vIFN0cmlwIHRoZSBsYXN0IHBhdGggY29tcG9uZW50LCBidXQga2VlcCB0aGUgXCIvXCIuXG4gICAgICB2YXIgaW5kZXggPSBwYXJzZWQucGF0aC5sYXN0SW5kZXhPZignLycpO1xuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgcGFyc2VkLnBhdGggPSBwYXJzZWQucGF0aC5zdWJzdHJpbmcoMCwgaW5kZXggKyAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc291cmNlVVJMID0gam9pbih1cmxHZW5lcmF0ZShwYXJzZWQpLCBzb3VyY2VVUkwpO1xuICB9XG5cbiAgcmV0dXJuIG5vcm1hbGl6ZShzb3VyY2VVUkwpO1xufVxuZXhwb3J0cy5jb21wdXRlU291cmNlVVJMID0gY29tcHV0ZVNvdXJjZVVSTDtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAwOS0yMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRS50eHQgb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmV4cG9ydHMuU291cmNlTWFwR2VuZXJhdG9yID0gcmVxdWlyZSgnLi9saWIvc291cmNlLW1hcC1nZW5lcmF0b3InKS5Tb3VyY2VNYXBHZW5lcmF0b3I7XG5leHBvcnRzLlNvdXJjZU1hcENvbnN1bWVyID0gcmVxdWlyZSgnLi9saWIvc291cmNlLW1hcC1jb25zdW1lcicpLlNvdXJjZU1hcENvbnN1bWVyO1xuZXhwb3J0cy5Tb3VyY2VOb2RlID0gcmVxdWlyZSgnLi9saWIvc291cmNlLW5vZGUnKS5Tb3VyY2VOb2RlO1xuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIl9hcmdzXCI6IFtcbiAgICBbXG4gICAgICBcImVzY29kZWdlbkAxLjE0LjFcIixcbiAgICAgIFwiL21udC9jL1VzZXJzL2RobjAzL3NvdXJjZS9wcm9qZWN0cy9qc2Zsb3cvanNmbG93LW1hc3RlclwiXG4gICAgXVxuICBdLFxuICBcIl9mcm9tXCI6IFwiZXNjb2RlZ2VuQDEuMTQuMVwiLFxuICBcIl9pZFwiOiBcImVzY29kZWdlbkAxLjE0LjFcIixcbiAgXCJfaW5CdW5kbGVcIjogZmFsc2UsXG4gIFwiX2ludGVncml0eVwiOiBcInNoYTUxMi1CbXQ3TmNSeVNkSWZOUGZVMlpvWERyclhzRzlaanZEeGNBbE1mRFVnUkJqTE9XVHVJQUNYUEJGSkg3WitjTGI0MEplUWNvNXRvaWt5Yzl0OVA4RTlTUT09XCIsXG4gIFwiX2xvY2F0aW9uXCI6IFwiL2VzY29kZWdlblwiLFxuICBcIl9waGFudG9tQ2hpbGRyZW5cIjoge30sXG4gIFwiX3JlcXVlc3RlZFwiOiB7XG4gICAgXCJ0eXBlXCI6IFwidmVyc2lvblwiLFxuICAgIFwicmVnaXN0cnlcIjogdHJ1ZSxcbiAgICBcInJhd1wiOiBcImVzY29kZWdlbkAxLjE0LjFcIixcbiAgICBcIm5hbWVcIjogXCJlc2NvZGVnZW5cIixcbiAgICBcImVzY2FwZWROYW1lXCI6IFwiZXNjb2RlZ2VuXCIsXG4gICAgXCJyYXdTcGVjXCI6IFwiMS4xNC4xXCIsXG4gICAgXCJzYXZlU3BlY1wiOiBudWxsLFxuICAgIFwiZmV0Y2hTcGVjXCI6IFwiMS4xNC4xXCJcbiAgfSxcbiAgXCJfcmVxdWlyZWRCeVwiOiBbXG4gICAgXCIvXCJcbiAgXSxcbiAgXCJfcmVzb2x2ZWRcIjogXCJodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9lc2NvZGVnZW4vLS9lc2NvZGVnZW4tMS4xNC4xLnRnelwiLFxuICBcIl9zcGVjXCI6IFwiMS4xNC4xXCIsXG4gIFwiX3doZXJlXCI6IFwiL21udC9jL1VzZXJzL2RobjAzL3NvdXJjZS9wcm9qZWN0cy9qc2Zsb3cvanNmbG93LW1hc3RlclwiLFxuICBcImJpblwiOiB7XG4gICAgXCJlc2dlbmVyYXRlXCI6IFwiYmluL2VzZ2VuZXJhdGUuanNcIixcbiAgICBcImVzY29kZWdlblwiOiBcImJpbi9lc2NvZGVnZW4uanNcIlxuICB9LFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2VzdG9vbHMvZXNjb2RlZ2VuL2lzc3Vlc1wiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcImVzcHJpbWFcIjogXCJeNC4wLjFcIixcbiAgICBcImVzdHJhdmVyc2VcIjogXCJeNC4yLjBcIixcbiAgICBcImVzdXRpbHNcIjogXCJeMi4wLjJcIixcbiAgICBcIm9wdGlvbmF0b3JcIjogXCJeMC44LjFcIixcbiAgICBcInNvdXJjZS1tYXBcIjogXCJ+MC42LjFcIlxuICB9LFxuICBcImRlc2NyaXB0aW9uXCI6IFwiRUNNQVNjcmlwdCBjb2RlIGdlbmVyYXRvclwiLFxuICBcImRldkRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJhY29yblwiOiBcIl43LjEuMFwiLFxuICAgIFwiYmx1ZWJpcmRcIjogXCJeMy40LjdcIixcbiAgICBcImJvd2VyLXJlZ2lzdHJ5LWNsaWVudFwiOiBcIl4xLjAuMFwiLFxuICAgIFwiY2hhaVwiOiBcIl4zLjUuMFwiLFxuICAgIFwiY29tbW9uanMtZXZlcnl3aGVyZVwiOiBcIl4wLjkuN1wiLFxuICAgIFwiZ3VscFwiOiBcIl4zLjguMTBcIixcbiAgICBcImd1bHAtZXNsaW50XCI6IFwiXjMuMC4xXCIsXG4gICAgXCJndWxwLW1vY2hhXCI6IFwiXjMuMC4xXCIsXG4gICAgXCJzZW12ZXJcIjogXCJeNS4xLjBcIlxuICB9LFxuICBcImVuZ2luZXNcIjoge1xuICAgIFwibm9kZVwiOiBcIj49NC4wXCJcbiAgfSxcbiAgXCJmaWxlc1wiOiBbXG4gICAgXCJMSUNFTlNFLkJTRFwiLFxuICAgIFwiUkVBRE1FLm1kXCIsXG4gICAgXCJiaW5cIixcbiAgICBcImVzY29kZWdlbi5qc1wiLFxuICAgIFwicGFja2FnZS5qc29uXCJcbiAgXSxcbiAgXCJob21lcGFnZVwiOiBcImh0dHA6Ly9naXRodWIuY29tL2VzdG9vbHMvZXNjb2RlZ2VuXCIsXG4gIFwibGljZW5zZVwiOiBcIkJTRC0yLUNsYXVzZVwiLFxuICBcIm1haW5cIjogXCJlc2NvZGVnZW4uanNcIixcbiAgXCJtYWludGFpbmVyc1wiOiBbXG4gICAge1xuICAgICAgXCJuYW1lXCI6IFwiWXVzdWtlIFN1enVraVwiLFxuICAgICAgXCJlbWFpbFwiOiBcInV0YXRhbmUudGVhQGdtYWlsLmNvbVwiLFxuICAgICAgXCJ1cmxcIjogXCJodHRwOi8vZ2l0aHViLmNvbS9Db25zdGVsbGF0aW9uXCJcbiAgICB9XG4gIF0sXG4gIFwibmFtZVwiOiBcImVzY29kZWdlblwiLFxuICBcIm9wdGlvbmFsRGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcInNvdXJjZS1tYXBcIjogXCJ+MC42LjFcIlxuICB9LFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiZ2l0K3NzaDovL2dpdEBnaXRodWIuY29tL2VzdG9vbHMvZXNjb2RlZ2VuLmdpdFwiXG4gIH0sXG4gIFwic2NyaXB0c1wiOiB7XG4gICAgXCJidWlsZFwiOiBcImNqc2lmeSAtYSBwYXRoOiB0b29scy9lbnRyeS1wb2ludC5qcyA+IGVzY29kZWdlbi5icm93c2VyLmpzXCIsXG4gICAgXCJidWlsZC1taW5cIjogXCJjanNpZnkgLW1hIHBhdGg6IHRvb2xzL2VudHJ5LXBvaW50LmpzID4gZXNjb2RlZ2VuLmJyb3dzZXIubWluLmpzXCIsXG4gICAgXCJsaW50XCI6IFwiZ3VscCBsaW50XCIsXG4gICAgXCJyZWxlYXNlXCI6IFwibm9kZSB0b29scy9yZWxlYXNlLmpzXCIsXG4gICAgXCJ0ZXN0XCI6IFwiZ3VscCB0cmF2aXNcIixcbiAgICBcInVuaXQtdGVzdFwiOiBcImd1bHAgdGVzdFwiXG4gIH0sXG4gIFwidmVyc2lvblwiOiBcIjEuMTQuMVwiXG59XG4iLCIvKlxuICBDb3B5cmlnaHQgKGMpIGpRdWVyeSBGb3VuZGF0aW9uLCBJbmMuIGFuZCBDb250cmlidXRvcnMsIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbiAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgPENPUFlSSUdIVCBIT0xERVI+IEJFIExJQUJMRSBGT1IgQU5ZXG4gIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4gIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbiAgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EXG4gIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRlxuICBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cblxuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLy8gVW5pdmVyc2FsIE1vZHVsZSBEZWZpbml0aW9uIChVTUQpIHRvIHN1cHBvcnQgQU1ELCBDb21tb25KUy9Ob2RlLmpzLFxuICAgIC8vIFJoaW5vLCBhbmQgcGxhaW4gYnJvd3NlciBsb2FkaW5nLlxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZmFjdG9yeShleHBvcnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmYWN0b3J5KChyb290LmVzcHJpbWEgPSB7fSkpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgVG9rZW4sXG4gICAgICAgIFRva2VuTmFtZSxcbiAgICAgICAgRm5FeHByVG9rZW5zLFxuICAgICAgICBTeW50YXgsXG4gICAgICAgIFBsYWNlSG9sZGVycyxcbiAgICAgICAgTWVzc2FnZXMsXG4gICAgICAgIFJlZ2V4LFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIHN0cmljdCxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGxpbmVOdW1iZXIsXG4gICAgICAgIGxpbmVTdGFydCxcbiAgICAgICAgaGFzTGluZVRlcm1pbmF0b3IsXG4gICAgICAgIGxhc3RJbmRleCxcbiAgICAgICAgbGFzdExpbmVOdW1iZXIsXG4gICAgICAgIGxhc3RMaW5lU3RhcnQsXG4gICAgICAgIHN0YXJ0SW5kZXgsXG4gICAgICAgIHN0YXJ0TGluZU51bWJlcixcbiAgICAgICAgc3RhcnRMaW5lU3RhcnQsXG4gICAgICAgIHNjYW5uaW5nLFxuICAgICAgICBsZW5ndGgsXG4gICAgICAgIGxvb2thaGVhZCxcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIGV4dHJhLFxuICAgICAgICBpc0JpbmRpbmdFbGVtZW50LFxuICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQsXG4gICAgICAgIGZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvcjtcblxuICAgIFRva2VuID0ge1xuICAgICAgICBCb29sZWFuTGl0ZXJhbDogMSxcbiAgICAgICAgRU9GOiAyLFxuICAgICAgICBJZGVudGlmaWVyOiAzLFxuICAgICAgICBLZXl3b3JkOiA0LFxuICAgICAgICBOdWxsTGl0ZXJhbDogNSxcbiAgICAgICAgTnVtZXJpY0xpdGVyYWw6IDYsXG4gICAgICAgIFB1bmN0dWF0b3I6IDcsXG4gICAgICAgIFN0cmluZ0xpdGVyYWw6IDgsXG4gICAgICAgIFJlZ3VsYXJFeHByZXNzaW9uOiA5LFxuICAgICAgICBUZW1wbGF0ZTogMTBcbiAgICB9O1xuXG4gICAgVG9rZW5OYW1lID0ge307XG4gICAgVG9rZW5OYW1lW1Rva2VuLkJvb2xlYW5MaXRlcmFsXSA9ICdCb29sZWFuJztcbiAgICBUb2tlbk5hbWVbVG9rZW4uRU9GXSA9ICc8ZW5kPic7XG4gICAgVG9rZW5OYW1lW1Rva2VuLklkZW50aWZpZXJdID0gJ0lkZW50aWZpZXInO1xuICAgIFRva2VuTmFtZVtUb2tlbi5LZXl3b3JkXSA9ICdLZXl3b3JkJztcbiAgICBUb2tlbk5hbWVbVG9rZW4uTnVsbExpdGVyYWxdID0gJ051bGwnO1xuICAgIFRva2VuTmFtZVtUb2tlbi5OdW1lcmljTGl0ZXJhbF0gPSAnTnVtZXJpYyc7XG4gICAgVG9rZW5OYW1lW1Rva2VuLlB1bmN0dWF0b3JdID0gJ1B1bmN0dWF0b3InO1xuICAgIFRva2VuTmFtZVtUb2tlbi5TdHJpbmdMaXRlcmFsXSA9ICdTdHJpbmcnO1xuICAgIFRva2VuTmFtZVtUb2tlbi5SZWd1bGFyRXhwcmVzc2lvbl0gPSAnUmVndWxhckV4cHJlc3Npb24nO1xuICAgIFRva2VuTmFtZVtUb2tlbi5UZW1wbGF0ZV0gPSAnVGVtcGxhdGUnO1xuXG4gICAgLy8gQSBmdW5jdGlvbiBmb2xsb3dpbmcgb25lIG9mIHRob3NlIHRva2VucyBpcyBhbiBleHByZXNzaW9uLlxuICAgIEZuRXhwclRva2VucyA9IFsnKCcsICd7JywgJ1snLCAnaW4nLCAndHlwZW9mJywgJ2luc3RhbmNlb2YnLCAnbmV3JyxcbiAgICAgICAgICAgICAgICAgICAgJ3JldHVybicsICdjYXNlJywgJ2RlbGV0ZScsICd0aHJvdycsICd2b2lkJyxcbiAgICAgICAgICAgICAgICAgICAgLy8gYXNzaWdubWVudCBvcGVyYXRvcnNcbiAgICAgICAgICAgICAgICAgICAgJz0nLCAnKz0nLCAnLT0nLCAnKj0nLCAnLz0nLCAnJT0nLCAnPDw9JywgJz4+PScsICc+Pj49JyxcbiAgICAgICAgICAgICAgICAgICAgJyY9JywgJ3w9JywgJ149JywgJywnLFxuICAgICAgICAgICAgICAgICAgICAvLyBiaW5hcnkvdW5hcnkgb3BlcmF0b3JzXG4gICAgICAgICAgICAgICAgICAgICcrJywgJy0nLCAnKicsICcvJywgJyUnLCAnKysnLCAnLS0nLCAnPDwnLCAnPj4nLCAnPj4+JywgJyYnLFxuICAgICAgICAgICAgICAgICAgICAnfCcsICdeJywgJyEnLCAnficsICcmJicsICd8fCcsICc/JywgJzonLCAnPT09JywgJz09JywgJz49JyxcbiAgICAgICAgICAgICAgICAgICAgJzw9JywgJzwnLCAnPicsICchPScsICchPT0nXTtcblxuICAgIFN5bnRheCA9IHtcbiAgICAgICAgQXNzaWdubWVudEV4cHJlc3Npb246ICdBc3NpZ25tZW50RXhwcmVzc2lvbicsXG4gICAgICAgIEFzc2lnbm1lbnRQYXR0ZXJuOiAnQXNzaWdubWVudFBhdHRlcm4nLFxuICAgICAgICBBcnJheUV4cHJlc3Npb246ICdBcnJheUV4cHJlc3Npb24nLFxuICAgICAgICBBcnJheVBhdHRlcm46ICdBcnJheVBhdHRlcm4nLFxuICAgICAgICBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjogJ0Fycm93RnVuY3Rpb25FeHByZXNzaW9uJyxcbiAgICAgICAgQmxvY2tTdGF0ZW1lbnQ6ICdCbG9ja1N0YXRlbWVudCcsXG4gICAgICAgIEJpbmFyeUV4cHJlc3Npb246ICdCaW5hcnlFeHByZXNzaW9uJyxcbiAgICAgICAgQnJlYWtTdGF0ZW1lbnQ6ICdCcmVha1N0YXRlbWVudCcsXG4gICAgICAgIENhbGxFeHByZXNzaW9uOiAnQ2FsbEV4cHJlc3Npb24nLFxuICAgICAgICBDYXRjaENsYXVzZTogJ0NhdGNoQ2xhdXNlJyxcbiAgICAgICAgQ2xhc3NCb2R5OiAnQ2xhc3NCb2R5JyxcbiAgICAgICAgQ2xhc3NEZWNsYXJhdGlvbjogJ0NsYXNzRGVjbGFyYXRpb24nLFxuICAgICAgICBDbGFzc0V4cHJlc3Npb246ICdDbGFzc0V4cHJlc3Npb24nLFxuICAgICAgICBDb25kaXRpb25hbEV4cHJlc3Npb246ICdDb25kaXRpb25hbEV4cHJlc3Npb24nLFxuICAgICAgICBDb250aW51ZVN0YXRlbWVudDogJ0NvbnRpbnVlU3RhdGVtZW50JyxcbiAgICAgICAgRG9XaGlsZVN0YXRlbWVudDogJ0RvV2hpbGVTdGF0ZW1lbnQnLFxuICAgICAgICBEZWJ1Z2dlclN0YXRlbWVudDogJ0RlYnVnZ2VyU3RhdGVtZW50JyxcbiAgICAgICAgRW1wdHlTdGF0ZW1lbnQ6ICdFbXB0eVN0YXRlbWVudCcsXG4gICAgICAgIEV4cG9ydEFsbERlY2xhcmF0aW9uOiAnRXhwb3J0QWxsRGVjbGFyYXRpb24nLFxuICAgICAgICBFeHBvcnREZWZhdWx0RGVjbGFyYXRpb246ICdFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24nLFxuICAgICAgICBFeHBvcnROYW1lZERlY2xhcmF0aW9uOiAnRXhwb3J0TmFtZWREZWNsYXJhdGlvbicsXG4gICAgICAgIEV4cG9ydFNwZWNpZmllcjogJ0V4cG9ydFNwZWNpZmllcicsXG4gICAgICAgIEV4cHJlc3Npb25TdGF0ZW1lbnQ6ICdFeHByZXNzaW9uU3RhdGVtZW50JyxcbiAgICAgICAgRm9yU3RhdGVtZW50OiAnRm9yU3RhdGVtZW50JyxcbiAgICAgICAgRm9yT2ZTdGF0ZW1lbnQ6ICdGb3JPZlN0YXRlbWVudCcsXG4gICAgICAgIEZvckluU3RhdGVtZW50OiAnRm9ySW5TdGF0ZW1lbnQnLFxuICAgICAgICBGdW5jdGlvbkRlY2xhcmF0aW9uOiAnRnVuY3Rpb25EZWNsYXJhdGlvbicsXG4gICAgICAgIEZ1bmN0aW9uRXhwcmVzc2lvbjogJ0Z1bmN0aW9uRXhwcmVzc2lvbicsXG4gICAgICAgIElkZW50aWZpZXI6ICdJZGVudGlmaWVyJyxcbiAgICAgICAgSWZTdGF0ZW1lbnQ6ICdJZlN0YXRlbWVudCcsXG4gICAgICAgIEltcG9ydERlY2xhcmF0aW9uOiAnSW1wb3J0RGVjbGFyYXRpb24nLFxuICAgICAgICBJbXBvcnREZWZhdWx0U3BlY2lmaWVyOiAnSW1wb3J0RGVmYXVsdFNwZWNpZmllcicsXG4gICAgICAgIEltcG9ydE5hbWVzcGFjZVNwZWNpZmllcjogJ0ltcG9ydE5hbWVzcGFjZVNwZWNpZmllcicsXG4gICAgICAgIEltcG9ydFNwZWNpZmllcjogJ0ltcG9ydFNwZWNpZmllcicsXG4gICAgICAgIExpdGVyYWw6ICdMaXRlcmFsJyxcbiAgICAgICAgTGFiZWxlZFN0YXRlbWVudDogJ0xhYmVsZWRTdGF0ZW1lbnQnLFxuICAgICAgICBMb2dpY2FsRXhwcmVzc2lvbjogJ0xvZ2ljYWxFeHByZXNzaW9uJyxcbiAgICAgICAgTWVtYmVyRXhwcmVzc2lvbjogJ01lbWJlckV4cHJlc3Npb24nLFxuICAgICAgICBNZXRhUHJvcGVydHk6ICdNZXRhUHJvcGVydHknLFxuICAgICAgICBNZXRob2REZWZpbml0aW9uOiAnTWV0aG9kRGVmaW5pdGlvbicsXG4gICAgICAgIE5ld0V4cHJlc3Npb246ICdOZXdFeHByZXNzaW9uJyxcbiAgICAgICAgT2JqZWN0RXhwcmVzc2lvbjogJ09iamVjdEV4cHJlc3Npb24nLFxuICAgICAgICBPYmplY3RQYXR0ZXJuOiAnT2JqZWN0UGF0dGVybicsXG4gICAgICAgIFByb2dyYW06ICdQcm9ncmFtJyxcbiAgICAgICAgUHJvcGVydHk6ICdQcm9wZXJ0eScsXG4gICAgICAgIFJlc3RFbGVtZW50OiAnUmVzdEVsZW1lbnQnLFxuICAgICAgICBSZXR1cm5TdGF0ZW1lbnQ6ICdSZXR1cm5TdGF0ZW1lbnQnLFxuICAgICAgICBTZXF1ZW5jZUV4cHJlc3Npb246ICdTZXF1ZW5jZUV4cHJlc3Npb24nLFxuICAgICAgICBTcHJlYWRFbGVtZW50OiAnU3ByZWFkRWxlbWVudCcsXG4gICAgICAgIFN1cGVyOiAnU3VwZXInLFxuICAgICAgICBTd2l0Y2hDYXNlOiAnU3dpdGNoQ2FzZScsXG4gICAgICAgIFN3aXRjaFN0YXRlbWVudDogJ1N3aXRjaFN0YXRlbWVudCcsXG4gICAgICAgIFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbjogJ1RhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbicsXG4gICAgICAgIFRlbXBsYXRlRWxlbWVudDogJ1RlbXBsYXRlRWxlbWVudCcsXG4gICAgICAgIFRlbXBsYXRlTGl0ZXJhbDogJ1RlbXBsYXRlTGl0ZXJhbCcsXG4gICAgICAgIFRoaXNFeHByZXNzaW9uOiAnVGhpc0V4cHJlc3Npb24nLFxuICAgICAgICBUaHJvd1N0YXRlbWVudDogJ1Rocm93U3RhdGVtZW50JyxcbiAgICAgICAgVHJ5U3RhdGVtZW50OiAnVHJ5U3RhdGVtZW50JyxcbiAgICAgICAgVW5hcnlFeHByZXNzaW9uOiAnVW5hcnlFeHByZXNzaW9uJyxcbiAgICAgICAgVXBkYXRlRXhwcmVzc2lvbjogJ1VwZGF0ZUV4cHJlc3Npb24nLFxuICAgICAgICBWYXJpYWJsZURlY2xhcmF0aW9uOiAnVmFyaWFibGVEZWNsYXJhdGlvbicsXG4gICAgICAgIFZhcmlhYmxlRGVjbGFyYXRvcjogJ1ZhcmlhYmxlRGVjbGFyYXRvcicsXG4gICAgICAgIFdoaWxlU3RhdGVtZW50OiAnV2hpbGVTdGF0ZW1lbnQnLFxuICAgICAgICBXaXRoU3RhdGVtZW50OiAnV2l0aFN0YXRlbWVudCcsXG4gICAgICAgIFlpZWxkRXhwcmVzc2lvbjogJ1lpZWxkRXhwcmVzc2lvbidcbiAgICB9O1xuXG4gICAgUGxhY2VIb2xkZXJzID0ge1xuICAgICAgICBBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyOiAnQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlcidcbiAgICB9O1xuXG4gICAgLy8gRXJyb3IgbWVzc2FnZXMgc2hvdWxkIGJlIGlkZW50aWNhbCB0byBWOC5cbiAgICBNZXNzYWdlcyA9IHtcbiAgICAgICAgVW5leHBlY3RlZFRva2VuOiAnVW5leHBlY3RlZCB0b2tlbiAlMCcsXG4gICAgICAgIFVuZXhwZWN0ZWROdW1iZXI6ICdVbmV4cGVjdGVkIG51bWJlcicsXG4gICAgICAgIFVuZXhwZWN0ZWRTdHJpbmc6ICdVbmV4cGVjdGVkIHN0cmluZycsXG4gICAgICAgIFVuZXhwZWN0ZWRJZGVudGlmaWVyOiAnVW5leHBlY3RlZCBpZGVudGlmaWVyJyxcbiAgICAgICAgVW5leHBlY3RlZFJlc2VydmVkOiAnVW5leHBlY3RlZCByZXNlcnZlZCB3b3JkJyxcbiAgICAgICAgVW5leHBlY3RlZFRlbXBsYXRlOiAnVW5leHBlY3RlZCBxdWFzaSAlMCcsXG4gICAgICAgIFVuZXhwZWN0ZWRFT1M6ICdVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCcsXG4gICAgICAgIE5ld2xpbmVBZnRlclRocm93OiAnSWxsZWdhbCBuZXdsaW5lIGFmdGVyIHRocm93JyxcbiAgICAgICAgSW52YWxpZFJlZ0V4cDogJ0ludmFsaWQgcmVndWxhciBleHByZXNzaW9uJyxcbiAgICAgICAgVW50ZXJtaW5hdGVkUmVnRXhwOiAnSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb246IG1pc3NpbmcgLycsXG4gICAgICAgIEludmFsaWRMSFNJbkFzc2lnbm1lbnQ6ICdJbnZhbGlkIGxlZnQtaGFuZCBzaWRlIGluIGFzc2lnbm1lbnQnLFxuICAgICAgICBJbnZhbGlkTEhTSW5Gb3JJbjogJ0ludmFsaWQgbGVmdC1oYW5kIHNpZGUgaW4gZm9yLWluJyxcbiAgICAgICAgSW52YWxpZExIU0luRm9yTG9vcDogJ0ludmFsaWQgbGVmdC1oYW5kIHNpZGUgaW4gZm9yLWxvb3AnLFxuICAgICAgICBNdWx0aXBsZURlZmF1bHRzSW5Td2l0Y2g6ICdNb3JlIHRoYW4gb25lIGRlZmF1bHQgY2xhdXNlIGluIHN3aXRjaCBzdGF0ZW1lbnQnLFxuICAgICAgICBOb0NhdGNoT3JGaW5hbGx5OiAnTWlzc2luZyBjYXRjaCBvciBmaW5hbGx5IGFmdGVyIHRyeScsXG4gICAgICAgIFVua25vd25MYWJlbDogJ1VuZGVmaW5lZCBsYWJlbCBcXCclMFxcJycsXG4gICAgICAgIFJlZGVjbGFyYXRpb246ICclMCBcXCclMVxcJyBoYXMgYWxyZWFkeSBiZWVuIGRlY2xhcmVkJyxcbiAgICAgICAgSWxsZWdhbENvbnRpbnVlOiAnSWxsZWdhbCBjb250aW51ZSBzdGF0ZW1lbnQnLFxuICAgICAgICBJbGxlZ2FsQnJlYWs6ICdJbGxlZ2FsIGJyZWFrIHN0YXRlbWVudCcsXG4gICAgICAgIElsbGVnYWxSZXR1cm46ICdJbGxlZ2FsIHJldHVybiBzdGF0ZW1lbnQnLFxuICAgICAgICBTdHJpY3RNb2RlV2l0aDogJ1N0cmljdCBtb2RlIGNvZGUgbWF5IG5vdCBpbmNsdWRlIGEgd2l0aCBzdGF0ZW1lbnQnLFxuICAgICAgICBTdHJpY3RDYXRjaFZhcmlhYmxlOiAnQ2F0Y2ggdmFyaWFibGUgbWF5IG5vdCBiZSBldmFsIG9yIGFyZ3VtZW50cyBpbiBzdHJpY3QgbW9kZScsXG4gICAgICAgIFN0cmljdFZhck5hbWU6ICdWYXJpYWJsZSBuYW1lIG1heSBub3QgYmUgZXZhbCBvciBhcmd1bWVudHMgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgICBTdHJpY3RQYXJhbU5hbWU6ICdQYXJhbWV0ZXIgbmFtZSBldmFsIG9yIGFyZ3VtZW50cyBpcyBub3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZScsXG4gICAgICAgIFN0cmljdFBhcmFtRHVwZTogJ1N0cmljdCBtb2RlIGZ1bmN0aW9uIG1heSBub3QgaGF2ZSBkdXBsaWNhdGUgcGFyYW1ldGVyIG5hbWVzJyxcbiAgICAgICAgU3RyaWN0RnVuY3Rpb25OYW1lOiAnRnVuY3Rpb24gbmFtZSBtYXkgbm90IGJlIGV2YWwgb3IgYXJndW1lbnRzIGluIHN0cmljdCBtb2RlJyxcbiAgICAgICAgU3RyaWN0T2N0YWxMaXRlcmFsOiAnT2N0YWwgbGl0ZXJhbHMgYXJlIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlLicsXG4gICAgICAgIFN0cmljdERlbGV0ZTogJ0RlbGV0ZSBvZiBhbiB1bnF1YWxpZmllZCBpZGVudGlmaWVyIGluIHN0cmljdCBtb2RlLicsXG4gICAgICAgIFN0cmljdExIU0Fzc2lnbm1lbnQ6ICdBc3NpZ25tZW50IHRvIGV2YWwgb3IgYXJndW1lbnRzIGlzIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlJyxcbiAgICAgICAgU3RyaWN0TEhTUG9zdGZpeDogJ1Bvc3RmaXggaW5jcmVtZW50L2RlY3JlbWVudCBtYXkgbm90IGhhdmUgZXZhbCBvciBhcmd1bWVudHMgb3BlcmFuZCBpbiBzdHJpY3QgbW9kZScsXG4gICAgICAgIFN0cmljdExIU1ByZWZpeDogJ1ByZWZpeCBpbmNyZW1lbnQvZGVjcmVtZW50IG1heSBub3QgaGF2ZSBldmFsIG9yIGFyZ3VtZW50cyBvcGVyYW5kIGluIHN0cmljdCBtb2RlJyxcbiAgICAgICAgU3RyaWN0UmVzZXJ2ZWRXb3JkOiAnVXNlIG9mIGZ1dHVyZSByZXNlcnZlZCB3b3JkIGluIHN0cmljdCBtb2RlJyxcbiAgICAgICAgVGVtcGxhdGVPY3RhbExpdGVyYWw6ICdPY3RhbCBsaXRlcmFscyBhcmUgbm90IGFsbG93ZWQgaW4gdGVtcGxhdGUgc3RyaW5ncy4nLFxuICAgICAgICBQYXJhbWV0ZXJBZnRlclJlc3RQYXJhbWV0ZXI6ICdSZXN0IHBhcmFtZXRlciBtdXN0IGJlIGxhc3QgZm9ybWFsIHBhcmFtZXRlcicsXG4gICAgICAgIERlZmF1bHRSZXN0UGFyYW1ldGVyOiAnVW5leHBlY3RlZCB0b2tlbiA9JyxcbiAgICAgICAgT2JqZWN0UGF0dGVybkFzUmVzdFBhcmFtZXRlcjogJ1VuZXhwZWN0ZWQgdG9rZW4geycsXG4gICAgICAgIER1cGxpY2F0ZVByb3RvUHJvcGVydHk6ICdEdXBsaWNhdGUgX19wcm90b19fIGZpZWxkcyBhcmUgbm90IGFsbG93ZWQgaW4gb2JqZWN0IGxpdGVyYWxzJyxcbiAgICAgICAgQ29uc3RydWN0b3JTcGVjaWFsTWV0aG9kOiAnQ2xhc3MgY29uc3RydWN0b3IgbWF5IG5vdCBiZSBhbiBhY2Nlc3NvcicsXG4gICAgICAgIER1cGxpY2F0ZUNvbnN0cnVjdG9yOiAnQSBjbGFzcyBtYXkgb25seSBoYXZlIG9uZSBjb25zdHJ1Y3RvcicsXG4gICAgICAgIFN0YXRpY1Byb3RvdHlwZTogJ0NsYXNzZXMgbWF5IG5vdCBoYXZlIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBwcm90b3R5cGUnLFxuICAgICAgICBNaXNzaW5nRnJvbUNsYXVzZTogJ1VuZXhwZWN0ZWQgdG9rZW4nLFxuICAgICAgICBOb0FzQWZ0ZXJJbXBvcnROYW1lc3BhY2U6ICdVbmV4cGVjdGVkIHRva2VuJyxcbiAgICAgICAgSW52YWxpZE1vZHVsZVNwZWNpZmllcjogJ1VuZXhwZWN0ZWQgdG9rZW4nLFxuICAgICAgICBJbGxlZ2FsSW1wb3J0RGVjbGFyYXRpb246ICdVbmV4cGVjdGVkIHRva2VuJyxcbiAgICAgICAgSWxsZWdhbEV4cG9ydERlY2xhcmF0aW9uOiAnVW5leHBlY3RlZCB0b2tlbicsXG4gICAgICAgIER1cGxpY2F0ZUJpbmRpbmc6ICdEdXBsaWNhdGUgYmluZGluZyAlMCdcbiAgICB9O1xuXG4gICAgLy8gU2VlIGFsc28gdG9vbHMvZ2VuZXJhdGUtdW5pY29kZS1yZWdleC5qcy5cbiAgICBSZWdleCA9IHtcbiAgICAgICAgLy8gRUNNQVNjcmlwdCA2L1VuaWNvZGUgdjcuMC4wIE5vbkFzY2lpSWRlbnRpZmllclN0YXJ0OlxuICAgICAgICBOb25Bc2NpaUlkZW50aWZpZXJTdGFydDogL1tcXHhBQVxceEI1XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzdGXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDhBLVxcdTA1MkZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYyMC1cXHUwNjRBXFx1MDY2RVxcdTA2NkZcXHUwNjcxLVxcdTA2RDNcXHUwNkQ1XFx1MDZFNVxcdTA2RTZcXHUwNkVFXFx1MDZFRlxcdTA2RkEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwXFx1MDcxMi1cXHUwNzJGXFx1MDc0RC1cXHUwN0E1XFx1MDdCMVxcdTA3Q0EtXFx1MDdFQVxcdTA3RjRcXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgxNVxcdTA4MUFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4QTAtXFx1MDhCMlxcdTA5MDQtXFx1MDkzOVxcdTA5M0RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTgwXFx1MDk4NS1cXHUwOThDXFx1MDk4RlxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjBcXHUwOUIyXFx1MDlCNi1cXHUwOUI5XFx1MDlCRFxcdTA5Q0VcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFMVxcdTA5RjBcXHUwOUYxXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE3Mi1cXHUwQTc0XFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJEXFx1MEFEMFxcdTBBRTBcXHUwQUUxXFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0RcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2MVxcdTBCNzFcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCRDBcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzlcXHUwQzNEXFx1MEM1OFxcdTBDNTlcXHUwQzYwXFx1MEM2MVxcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkRcXHUwQ0RFXFx1MENFMFxcdTBDRTFcXHUwQ0YxXFx1MENGMlxcdTBEMDUtXFx1MEQwQ1xcdTBEMEUtXFx1MEQxMFxcdTBEMTItXFx1MEQzQVxcdTBEM0RcXHUwRDRFXFx1MEQ2MFxcdTBENjFcXHUwRDdBLVxcdTBEN0ZcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MEUwMS1cXHUwRTMwXFx1MEUzMlxcdTBFMzNcXHUwRTQwLVxcdTBFNDZcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCMFxcdTBFQjJcXHUwRUIzXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFQzZcXHUwRURDLVxcdTBFREZcXHUwRjAwXFx1MEY0MC1cXHUwRjQ3XFx1MEY0OS1cXHUwRjZDXFx1MEY4OC1cXHUwRjhDXFx1MTAwMC1cXHUxMDJBXFx1MTAzRlxcdTEwNTAtXFx1MTA1NVxcdTEwNUEtXFx1MTA1RFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNkUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOEVcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEwRDAtXFx1MTBGQVxcdTEwRkMtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM4MC1cXHUxMzhGXFx1MTNBMC1cXHUxM0Y0XFx1MTQwMS1cXHUxNjZDXFx1MTY2Ri1cXHUxNjdGXFx1MTY4MS1cXHUxNjlBXFx1MTZBMC1cXHUxNkVBXFx1MTZFRS1cXHUxNkY4XFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc4MC1cXHUxN0IzXFx1MTdEN1xcdTE3RENcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4QThcXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFFXFx1MTk1MC1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlDMS1cXHUxOUM3XFx1MUEwMC1cXHUxQTE2XFx1MUEyMC1cXHUxQTU0XFx1MUFBN1xcdTFCMDUtXFx1MUIzM1xcdTFCNDUtXFx1MUI0QlxcdTFCODMtXFx1MUJBMFxcdTFCQUVcXHUxQkFGXFx1MUJCQS1cXHUxQkU1XFx1MUMwMC1cXHUxQzIzXFx1MUM0RC1cXHUxQzRGXFx1MUM1QS1cXHUxQzdEXFx1MUNFOS1cXHUxQ0VDXFx1MUNFRS1cXHUxQ0YxXFx1MUNGNVxcdTFDRjZcXHUxRDAwLVxcdTFEQkZcXHUxRTAwLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE4LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMzlcXHUyMTNDLVxcdTIxM0ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRFXFx1MjE2MC1cXHUyMTg4XFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0VFXFx1MkNGMlxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDgwLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMjlcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM0NcXHUzMDQxLVxcdTMwOTZcXHUzMDlCLVxcdTMwOUZcXHUzMEExLVxcdTMwRkFcXHUzMEZDLVxcdTMwRkZcXHUzMTA1LVxcdTMxMkRcXHUzMTMxLVxcdTMxOEVcXHUzMUEwLVxcdTMxQkFcXHUzMUYwLVxcdTMxRkZcXHUzNDAwLVxcdTREQjVcXHU0RTAwLVxcdTlGQ0NcXHVBMDAwLVxcdUE0OENcXHVBNEQwLVxcdUE0RkRcXHVBNTAwLVxcdUE2MENcXHVBNjEwLVxcdUE2MUZcXHVBNjJBXFx1QTYyQlxcdUE2NDAtXFx1QTY2RVxcdUE2N0YtXFx1QTY5RFxcdUE2QTAtXFx1QTZFRlxcdUE3MTctXFx1QTcxRlxcdUE3MjItXFx1QTc4OFxcdUE3OEItXFx1QTc4RVxcdUE3OTAtXFx1QTdBRFxcdUE3QjBcXHVBN0IxXFx1QTdGNy1cXHVBODAxXFx1QTgwMy1cXHVBODA1XFx1QTgwNy1cXHVBODBBXFx1QTgwQy1cXHVBODIyXFx1QTg0MC1cXHVBODczXFx1QTg4Mi1cXHVBOEIzXFx1QThGMi1cXHVBOEY3XFx1QThGQlxcdUE5MEEtXFx1QTkyNVxcdUE5MzAtXFx1QTk0NlxcdUE5NjAtXFx1QTk3Q1xcdUE5ODQtXFx1QTlCMlxcdUE5Q0ZcXHVBOUUwLVxcdUE5RTRcXHVBOUU2LVxcdUE5RUZcXHVBOUZBLVxcdUE5RkVcXHVBQTAwLVxcdUFBMjhcXHVBQTQwLVxcdUFBNDJcXHVBQTQ0LVxcdUFBNEJcXHVBQTYwLVxcdUFBNzZcXHVBQTdBXFx1QUE3RS1cXHVBQUFGXFx1QUFCMVxcdUFBQjVcXHVBQUI2XFx1QUFCOS1cXHVBQUJEXFx1QUFDMFxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUFcXHVBQUYyLVxcdUFBRjRcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQjMwLVxcdUFCNUFcXHVBQjVDLVxcdUFCNUZcXHVBQjY0XFx1QUI2NVxcdUFCQzAtXFx1QUJFMlxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZCMURcXHVGQjFGLVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGMjEtXFx1RkYzQVxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ118XFx1RDgwMFtcXHVEQzAwLVxcdURDMEJcXHVEQzBELVxcdURDMjZcXHVEQzI4LVxcdURDM0FcXHVEQzNDXFx1REMzRFxcdURDM0YtXFx1REM0RFxcdURDNTAtXFx1REM1RFxcdURDODAtXFx1RENGQVxcdURENDAtXFx1REQ3NFxcdURFODAtXFx1REU5Q1xcdURFQTAtXFx1REVEMFxcdURGMDAtXFx1REYxRlxcdURGMzAtXFx1REY0QVxcdURGNTAtXFx1REY3NVxcdURGODAtXFx1REY5RFxcdURGQTAtXFx1REZDM1xcdURGQzgtXFx1REZDRlxcdURGRDEtXFx1REZENV18XFx1RDgwMVtcXHVEQzAwLVxcdURDOURcXHVERDAwLVxcdUREMjdcXHVERDMwLVxcdURENjNcXHVERTAwLVxcdURGMzZcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNjddfFxcdUQ4MDJbXFx1REMwMC1cXHVEQzA1XFx1REMwOFxcdURDMEEtXFx1REMzNVxcdURDMzdcXHVEQzM4XFx1REMzQ1xcdURDM0YtXFx1REM1NVxcdURDNjAtXFx1REM3NlxcdURDODAtXFx1REM5RVxcdUREMDAtXFx1REQxNVxcdUREMjAtXFx1REQzOVxcdUREODAtXFx1RERCN1xcdUREQkVcXHVEREJGXFx1REUwMFxcdURFMTAtXFx1REUxM1xcdURFMTUtXFx1REUxN1xcdURFMTktXFx1REUzM1xcdURFNjAtXFx1REU3Q1xcdURFODAtXFx1REU5Q1xcdURFQzAtXFx1REVDN1xcdURFQzktXFx1REVFNFxcdURGMDAtXFx1REYzNVxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY3MlxcdURGODAtXFx1REY5MV18XFx1RDgwM1tcXHVEQzAwLVxcdURDNDhdfFxcdUQ4MDRbXFx1REMwMy1cXHVEQzM3XFx1REM4My1cXHVEQ0FGXFx1RENEMC1cXHVEQ0U4XFx1REQwMy1cXHVERDI2XFx1REQ1MC1cXHVERDcyXFx1REQ3NlxcdUREODMtXFx1RERCMlxcdUREQzEtXFx1RERDNFxcdUREREFcXHVERTAwLVxcdURFMTFcXHVERTEzLVxcdURFMkJcXHVERUIwLVxcdURFREVcXHVERjA1LVxcdURGMENcXHVERjBGXFx1REYxMFxcdURGMTMtXFx1REYyOFxcdURGMkEtXFx1REYzMFxcdURGMzJcXHVERjMzXFx1REYzNS1cXHVERjM5XFx1REYzRFxcdURGNUQtXFx1REY2MV18XFx1RDgwNVtcXHVEQzgwLVxcdURDQUZcXHVEQ0M0XFx1RENDNVxcdURDQzdcXHVERDgwLVxcdUREQUVcXHVERTAwLVxcdURFMkZcXHVERTQ0XFx1REU4MC1cXHVERUFBXXxcXHVEODA2W1xcdURDQTAtXFx1RENERlxcdURDRkZcXHVERUMwLVxcdURFRjhdfFxcdUQ4MDhbXFx1REMwMC1cXHVERjk4XXxcXHVEODA5W1xcdURDMDAtXFx1REM2RV18W1xcdUQ4MENcXHVEODQwLVxcdUQ4NjhcXHVEODZBLVxcdUQ4NkNdW1xcdURDMDAtXFx1REZGRl18XFx1RDgwRFtcXHVEQzAwLVxcdURDMkVdfFxcdUQ4MUFbXFx1REMwMC1cXHVERTM4XFx1REU0MC1cXHVERTVFXFx1REVEMC1cXHVERUVEXFx1REYwMC1cXHVERjJGXFx1REY0MC1cXHVERjQzXFx1REY2My1cXHVERjc3XFx1REY3RC1cXHVERjhGXXxcXHVEODFCW1xcdURGMDAtXFx1REY0NFxcdURGNTBcXHVERjkzLVxcdURGOUZdfFxcdUQ4MkNbXFx1REMwMFxcdURDMDFdfFxcdUQ4MkZbXFx1REMwMC1cXHVEQzZBXFx1REM3MC1cXHVEQzdDXFx1REM4MC1cXHVEQzg4XFx1REM5MC1cXHVEQzk5XXxcXHVEODM1W1xcdURDMDAtXFx1REM1NFxcdURDNTYtXFx1REM5Q1xcdURDOUVcXHVEQzlGXFx1RENBMlxcdURDQTVcXHVEQ0E2XFx1RENBOS1cXHVEQ0FDXFx1RENBRS1cXHVEQ0I5XFx1RENCQlxcdURDQkQtXFx1RENDM1xcdURDQzUtXFx1REQwNVxcdUREMDctXFx1REQwQVxcdUREMEQtXFx1REQxNFxcdUREMTYtXFx1REQxQ1xcdUREMUUtXFx1REQzOVxcdUREM0ItXFx1REQzRVxcdURENDAtXFx1REQ0NFxcdURENDZcXHVERDRBLVxcdURENTBcXHVERDUyLVxcdURFQTVcXHVERUE4LVxcdURFQzBcXHVERUMyLVxcdURFREFcXHVERURDLVxcdURFRkFcXHVERUZDLVxcdURGMTRcXHVERjE2LVxcdURGMzRcXHVERjM2LVxcdURGNEVcXHVERjUwLVxcdURGNkVcXHVERjcwLVxcdURGODhcXHVERjhBLVxcdURGQThcXHVERkFBLVxcdURGQzJcXHVERkM0LVxcdURGQ0JdfFxcdUQ4M0FbXFx1REMwMC1cXHVEQ0M0XXxcXHVEODNCW1xcdURFMDAtXFx1REUwM1xcdURFMDUtXFx1REUxRlxcdURFMjFcXHVERTIyXFx1REUyNFxcdURFMjdcXHVERTI5LVxcdURFMzJcXHVERTM0LVxcdURFMzdcXHVERTM5XFx1REUzQlxcdURFNDJcXHVERTQ3XFx1REU0OVxcdURFNEJcXHVERTRELVxcdURFNEZcXHVERTUxXFx1REU1MlxcdURFNTRcXHVERTU3XFx1REU1OVxcdURFNUJcXHVERTVEXFx1REU1RlxcdURFNjFcXHVERTYyXFx1REU2NFxcdURFNjctXFx1REU2QVxcdURFNkMtXFx1REU3MlxcdURFNzQtXFx1REU3N1xcdURFNzktXFx1REU3Q1xcdURFN0VcXHVERTgwLVxcdURFODlcXHVERThCLVxcdURFOUJcXHVERUExLVxcdURFQTNcXHVERUE1LVxcdURFQTlcXHVERUFCLVxcdURFQkJdfFxcdUQ4NjlbXFx1REMwMC1cXHVERUQ2XFx1REYwMC1cXHVERkZGXXxcXHVEODZEW1xcdURDMDAtXFx1REYzNFxcdURGNDAtXFx1REZGRl18XFx1RDg2RVtcXHVEQzAwLVxcdURDMURdfFxcdUQ4N0VbXFx1REMwMC1cXHVERTFEXS8sXG5cbiAgICAgICAgLy8gRUNNQVNjcmlwdCA2L1VuaWNvZGUgdjcuMC4wIE5vbkFzY2lpSWRlbnRpZmllclBhcnQ6XG4gICAgICAgIE5vbkFzY2lpSWRlbnRpZmllclBhcnQ6IC9bXFx4QUFcXHhCNVxceEI3XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDMwMC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzdGXFx1MDM4Ni1cXHUwMzhBXFx1MDM4Q1xcdTAzOEUtXFx1MDNBMVxcdTAzQTMtXFx1MDNGNVxcdTAzRjctXFx1MDQ4MVxcdTA0ODMtXFx1MDQ4N1xcdTA0OEEtXFx1MDUyRlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNTkxLVxcdTA1QkRcXHUwNUJGXFx1MDVDMVxcdTA1QzJcXHUwNUM0XFx1MDVDNVxcdTA1QzdcXHUwNUQwLVxcdTA1RUFcXHUwNUYwLVxcdTA1RjJcXHUwNjEwLVxcdTA2MUFcXHUwNjIwLVxcdTA2NjlcXHUwNjZFLVxcdTA2RDNcXHUwNkQ1LVxcdTA2RENcXHUwNkRGLVxcdTA2RThcXHUwNkVBLVxcdTA2RkNcXHUwNkZGXFx1MDcxMC1cXHUwNzRBXFx1MDc0RC1cXHUwN0IxXFx1MDdDMC1cXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgyRFxcdTA4NDAtXFx1MDg1QlxcdTA4QTAtXFx1MDhCMlxcdTA4RTQtXFx1MDk2M1xcdTA5NjYtXFx1MDk2RlxcdTA5NzEtXFx1MDk4M1xcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkMtXFx1MDlDNFxcdTA5QzdcXHUwOUM4XFx1MDlDQi1cXHUwOUNFXFx1MDlEN1xcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUzXFx1MDlFNi1cXHUwOUYxXFx1MEEwMS1cXHUwQTAzXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTNDXFx1MEEzRS1cXHUwQTQyXFx1MEE0N1xcdTBBNDhcXHUwQTRCLVxcdTBBNERcXHUwQTUxXFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNjYtXFx1MEE3NVxcdTBBODEtXFx1MEE4M1xcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCQy1cXHUwQUM1XFx1MEFDNy1cXHUwQUM5XFx1MEFDQi1cXHUwQUNEXFx1MEFEMFxcdTBBRTAtXFx1MEFFM1xcdTBBRTYtXFx1MEFFRlxcdTBCMDEtXFx1MEIwM1xcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNDLVxcdTBCNDRcXHUwQjQ3XFx1MEI0OFxcdTBCNEItXFx1MEI0RFxcdTBCNTZcXHUwQjU3XFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjNcXHUwQjY2LVxcdTBCNkZcXHUwQjcxXFx1MEI4MlxcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJCRS1cXHUwQkMyXFx1MEJDNi1cXHUwQkM4XFx1MEJDQS1cXHUwQkNEXFx1MEJEMFxcdTBCRDdcXHUwQkU2LVxcdTBCRUZcXHUwQzAwLVxcdTBDMDNcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzlcXHUwQzNELVxcdTBDNDRcXHUwQzQ2LVxcdTBDNDhcXHUwQzRBLVxcdTBDNERcXHUwQzU1XFx1MEM1NlxcdTBDNThcXHUwQzU5XFx1MEM2MC1cXHUwQzYzXFx1MEM2Ni1cXHUwQzZGXFx1MEM4MS1cXHUwQzgzXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCQy1cXHUwQ0M0XFx1MENDNi1cXHUwQ0M4XFx1MENDQS1cXHUwQ0NEXFx1MENENVxcdTBDRDZcXHUwQ0RFXFx1MENFMC1cXHUwQ0UzXFx1MENFNi1cXHUwQ0VGXFx1MENGMVxcdTBDRjJcXHUwRDAxLVxcdTBEMDNcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNELVxcdTBENDRcXHUwRDQ2LVxcdTBENDhcXHUwRDRBLVxcdTBENEVcXHUwRDU3XFx1MEQ2MC1cXHUwRDYzXFx1MEQ2Ni1cXHUwRDZGXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4MlxcdTBEODNcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MERDQVxcdTBEQ0YtXFx1MERENFxcdTBERDZcXHUwREQ4LVxcdTBEREZcXHUwREU2LVxcdTBERUZcXHUwREYyXFx1MERGM1xcdTBFMDEtXFx1MEUzQVxcdTBFNDAtXFx1MEU0RVxcdTBFNTAtXFx1MEU1OVxcdTBFODFcXHUwRTgyXFx1MEU4NFxcdTBFODdcXHUwRTg4XFx1MEU4QVxcdTBFOERcXHUwRTk0LVxcdTBFOTdcXHUwRTk5LVxcdTBFOUZcXHUwRUExLVxcdTBFQTNcXHUwRUE1XFx1MEVBN1xcdTBFQUFcXHUwRUFCXFx1MEVBRC1cXHUwRUI5XFx1MEVCQi1cXHUwRUJEXFx1MEVDMC1cXHUwRUM0XFx1MEVDNlxcdTBFQzgtXFx1MEVDRFxcdTBFRDAtXFx1MEVEOVxcdTBFREMtXFx1MEVERlxcdTBGMDBcXHUwRjE4XFx1MEYxOVxcdTBGMjAtXFx1MEYyOVxcdTBGMzVcXHUwRjM3XFx1MEYzOVxcdTBGM0UtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGNzEtXFx1MEY4NFxcdTBGODYtXFx1MEY5N1xcdTBGOTktXFx1MEZCQ1xcdTBGQzZcXHUxMDAwLVxcdTEwNDlcXHUxMDUwLVxcdTEwOURcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEwRDAtXFx1MTBGQVxcdTEwRkMtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM1RC1cXHUxMzVGXFx1MTM2OS1cXHUxMzcxXFx1MTM4MC1cXHUxMzhGXFx1MTNBMC1cXHUxM0Y0XFx1MTQwMS1cXHUxNjZDXFx1MTY2Ri1cXHUxNjdGXFx1MTY4MS1cXHUxNjlBXFx1MTZBMC1cXHUxNkVBXFx1MTZFRS1cXHUxNkY4XFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzE0XFx1MTcyMC1cXHUxNzM0XFx1MTc0MC1cXHUxNzUzXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc3MlxcdTE3NzNcXHUxNzgwLVxcdTE3RDNcXHUxN0Q3XFx1MTdEQ1xcdTE3RERcXHUxN0UwLVxcdTE3RTlcXHUxODBCLVxcdTE4MERcXHUxODEwLVxcdTE4MTlcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4QUFcXHUxOEIwLVxcdTE4RjVcXHUxOTAwLVxcdTE5MUVcXHUxOTIwLVxcdTE5MkJcXHUxOTMwLVxcdTE5M0JcXHUxOTQ2LVxcdTE5NkRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5QUJcXHUxOUIwLVxcdTE5QzlcXHUxOUQwLVxcdTE5REFcXHUxQTAwLVxcdTFBMUJcXHUxQTIwLVxcdTFBNUVcXHUxQTYwLVxcdTFBN0NcXHUxQTdGLVxcdTFBODlcXHUxQTkwLVxcdTFBOTlcXHUxQUE3XFx1MUFCMC1cXHUxQUJEXFx1MUIwMC1cXHUxQjRCXFx1MUI1MC1cXHUxQjU5XFx1MUI2Qi1cXHUxQjczXFx1MUI4MC1cXHUxQkYzXFx1MUMwMC1cXHUxQzM3XFx1MUM0MC1cXHUxQzQ5XFx1MUM0RC1cXHUxQzdEXFx1MUNEMC1cXHUxQ0QyXFx1MUNENC1cXHUxQ0Y2XFx1MUNGOFxcdTFDRjlcXHUxRDAwLVxcdTFERjVcXHUxREZDLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjAwQ1xcdTIwMERcXHUyMDNGXFx1MjA0MFxcdTIwNTRcXHUyMDcxXFx1MjA3RlxcdTIwOTAtXFx1MjA5Q1xcdTIwRDAtXFx1MjBEQ1xcdTIwRTFcXHUyMEU1LVxcdTIwRjBcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE4LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMzlcXHUyMTNDLVxcdTIxM0ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRFXFx1MjE2MC1cXHUyMTg4XFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ3Ri1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MkRFMC1cXHUyREZGXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDJGXFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5OS1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkNDXFx1QTAwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjJCXFx1QTY0MC1cXHVBNjZGXFx1QTY3NC1cXHVBNjdEXFx1QTY3Ri1cXHVBNjlEXFx1QTY5Ri1cXHVBNkYxXFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBNzhFXFx1QTc5MC1cXHVBN0FEXFx1QTdCMFxcdUE3QjFcXHVBN0Y3LVxcdUE4MjdcXHVBODQwLVxcdUE4NzNcXHVBODgwLVxcdUE4QzRcXHVBOEQwLVxcdUE4RDlcXHVBOEUwLVxcdUE4RjdcXHVBOEZCXFx1QTkwMC1cXHVBOTJEXFx1QTkzMC1cXHVBOTUzXFx1QTk2MC1cXHVBOTdDXFx1QTk4MC1cXHVBOUMwXFx1QTlDRi1cXHVBOUQ5XFx1QTlFMC1cXHVBOUZFXFx1QUEwMC1cXHVBQTM2XFx1QUE0MC1cXHVBQTREXFx1QUE1MC1cXHVBQTU5XFx1QUE2MC1cXHVBQTc2XFx1QUE3QS1cXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVGXFx1QUFGMi1cXHVBQUY2XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjVGXFx1QUI2NFxcdUFCNjVcXHVBQkMwLVxcdUFCRUFcXHVBQkVDXFx1QUJFRFxcdUFCRjAtXFx1QUJGOVxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZCMUQtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkUwMC1cXHVGRTBGXFx1RkUyMC1cXHVGRTJEXFx1RkUzM1xcdUZFMzRcXHVGRTRELVxcdUZFNEZcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjEwLVxcdUZGMTlcXHVGRjIxLVxcdUZGM0FcXHVGRjNGXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXXxcXHVEODAwW1xcdURDMDAtXFx1REMwQlxcdURDMEQtXFx1REMyNlxcdURDMjgtXFx1REMzQVxcdURDM0NcXHVEQzNEXFx1REMzRi1cXHVEQzREXFx1REM1MC1cXHVEQzVEXFx1REM4MC1cXHVEQ0ZBXFx1REQ0MC1cXHVERDc0XFx1RERGRFxcdURFODAtXFx1REU5Q1xcdURFQTAtXFx1REVEMFxcdURFRTBcXHVERjAwLVxcdURGMUZcXHVERjMwLVxcdURGNEFcXHVERjUwLVxcdURGN0FcXHVERjgwLVxcdURGOURcXHVERkEwLVxcdURGQzNcXHVERkM4LVxcdURGQ0ZcXHVERkQxLVxcdURGRDVdfFxcdUQ4MDFbXFx1REMwMC1cXHVEQzlEXFx1RENBMC1cXHVEQ0E5XFx1REQwMC1cXHVERDI3XFx1REQzMC1cXHVERDYzXFx1REUwMC1cXHVERjM2XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjY3XXxcXHVEODAyW1xcdURDMDAtXFx1REMwNVxcdURDMDhcXHVEQzBBLVxcdURDMzVcXHVEQzM3XFx1REMzOFxcdURDM0NcXHVEQzNGLVxcdURDNTVcXHVEQzYwLVxcdURDNzZcXHVEQzgwLVxcdURDOUVcXHVERDAwLVxcdUREMTVcXHVERDIwLVxcdUREMzlcXHVERDgwLVxcdUREQjdcXHVEREJFXFx1RERCRlxcdURFMDAtXFx1REUwM1xcdURFMDVcXHVERTA2XFx1REUwQy1cXHVERTEzXFx1REUxNS1cXHVERTE3XFx1REUxOS1cXHVERTMzXFx1REUzOC1cXHVERTNBXFx1REUzRlxcdURFNjAtXFx1REU3Q1xcdURFODAtXFx1REU5Q1xcdURFQzAtXFx1REVDN1xcdURFQzktXFx1REVFNlxcdURGMDAtXFx1REYzNVxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY3MlxcdURGODAtXFx1REY5MV18XFx1RDgwM1tcXHVEQzAwLVxcdURDNDhdfFxcdUQ4MDRbXFx1REMwMC1cXHVEQzQ2XFx1REM2Ni1cXHVEQzZGXFx1REM3Ri1cXHVEQ0JBXFx1RENEMC1cXHVEQ0U4XFx1RENGMC1cXHVEQ0Y5XFx1REQwMC1cXHVERDM0XFx1REQzNi1cXHVERDNGXFx1REQ1MC1cXHVERDczXFx1REQ3NlxcdUREODAtXFx1RERDNFxcdURERDAtXFx1REREQVxcdURFMDAtXFx1REUxMVxcdURFMTMtXFx1REUzN1xcdURFQjAtXFx1REVFQVxcdURFRjAtXFx1REVGOVxcdURGMDEtXFx1REYwM1xcdURGMDUtXFx1REYwQ1xcdURGMEZcXHVERjEwXFx1REYxMy1cXHVERjI4XFx1REYyQS1cXHVERjMwXFx1REYzMlxcdURGMzNcXHVERjM1LVxcdURGMzlcXHVERjNDLVxcdURGNDRcXHVERjQ3XFx1REY0OFxcdURGNEItXFx1REY0RFxcdURGNTdcXHVERjVELVxcdURGNjNcXHVERjY2LVxcdURGNkNcXHVERjcwLVxcdURGNzRdfFxcdUQ4MDVbXFx1REM4MC1cXHVEQ0M1XFx1RENDN1xcdURDRDAtXFx1RENEOVxcdUREODAtXFx1RERCNVxcdUREQjgtXFx1RERDMFxcdURFMDAtXFx1REU0MFxcdURFNDRcXHVERTUwLVxcdURFNTlcXHVERTgwLVxcdURFQjdcXHVERUMwLVxcdURFQzldfFxcdUQ4MDZbXFx1RENBMC1cXHVEQ0U5XFx1RENGRlxcdURFQzAtXFx1REVGOF18XFx1RDgwOFtcXHVEQzAwLVxcdURGOThdfFxcdUQ4MDlbXFx1REMwMC1cXHVEQzZFXXxbXFx1RDgwQ1xcdUQ4NDAtXFx1RDg2OFxcdUQ4NkEtXFx1RDg2Q11bXFx1REMwMC1cXHVERkZGXXxcXHVEODBEW1xcdURDMDAtXFx1REMyRV18XFx1RDgxQVtcXHVEQzAwLVxcdURFMzhcXHVERTQwLVxcdURFNUVcXHVERTYwLVxcdURFNjlcXHVERUQwLVxcdURFRURcXHVERUYwLVxcdURFRjRcXHVERjAwLVxcdURGMzZcXHVERjQwLVxcdURGNDNcXHVERjUwLVxcdURGNTlcXHVERjYzLVxcdURGNzdcXHVERjdELVxcdURGOEZdfFxcdUQ4MUJbXFx1REYwMC1cXHVERjQ0XFx1REY1MC1cXHVERjdFXFx1REY4Ri1cXHVERjlGXXxcXHVEODJDW1xcdURDMDBcXHVEQzAxXXxcXHVEODJGW1xcdURDMDAtXFx1REM2QVxcdURDNzAtXFx1REM3Q1xcdURDODAtXFx1REM4OFxcdURDOTAtXFx1REM5OVxcdURDOURcXHVEQzlFXXxcXHVEODM0W1xcdURENjUtXFx1REQ2OVxcdURENkQtXFx1REQ3MlxcdUREN0ItXFx1REQ4MlxcdUREODUtXFx1REQ4QlxcdUREQUEtXFx1RERBRFxcdURFNDItXFx1REU0NF18XFx1RDgzNVtcXHVEQzAwLVxcdURDNTRcXHVEQzU2LVxcdURDOUNcXHVEQzlFXFx1REM5RlxcdURDQTJcXHVEQ0E1XFx1RENBNlxcdURDQTktXFx1RENBQ1xcdURDQUUtXFx1RENCOVxcdURDQkJcXHVEQ0JELVxcdURDQzNcXHVEQ0M1LVxcdUREMDVcXHVERDA3LVxcdUREMEFcXHVERDBELVxcdUREMTRcXHVERDE2LVxcdUREMUNcXHVERDFFLVxcdUREMzlcXHVERDNCLVxcdUREM0VcXHVERDQwLVxcdURENDRcXHVERDQ2XFx1REQ0QS1cXHVERDUwXFx1REQ1Mi1cXHVERUE1XFx1REVBOC1cXHVERUMwXFx1REVDMi1cXHVERURBXFx1REVEQy1cXHVERUZBXFx1REVGQy1cXHVERjE0XFx1REYxNi1cXHVERjM0XFx1REYzNi1cXHVERjRFXFx1REY1MC1cXHVERjZFXFx1REY3MC1cXHVERjg4XFx1REY4QS1cXHVERkE4XFx1REZBQS1cXHVERkMyXFx1REZDNC1cXHVERkNCXFx1REZDRS1cXHVERkZGXXxcXHVEODNBW1xcdURDMDAtXFx1RENDNFxcdURDRDAtXFx1RENENl18XFx1RDgzQltcXHVERTAwLVxcdURFMDNcXHVERTA1LVxcdURFMUZcXHVERTIxXFx1REUyMlxcdURFMjRcXHVERTI3XFx1REUyOS1cXHVERTMyXFx1REUzNC1cXHVERTM3XFx1REUzOVxcdURFM0JcXHVERTQyXFx1REU0N1xcdURFNDlcXHVERTRCXFx1REU0RC1cXHVERTRGXFx1REU1MVxcdURFNTJcXHVERTU0XFx1REU1N1xcdURFNTlcXHVERTVCXFx1REU1RFxcdURFNUZcXHVERTYxXFx1REU2MlxcdURFNjRcXHVERTY3LVxcdURFNkFcXHVERTZDLVxcdURFNzJcXHVERTc0LVxcdURFNzdcXHVERTc5LVxcdURFN0NcXHVERTdFXFx1REU4MC1cXHVERTg5XFx1REU4Qi1cXHVERTlCXFx1REVBMS1cXHVERUEzXFx1REVBNS1cXHVERUE5XFx1REVBQi1cXHVERUJCXXxcXHVEODY5W1xcdURDMDAtXFx1REVENlxcdURGMDAtXFx1REZGRl18XFx1RDg2RFtcXHVEQzAwLVxcdURGMzRcXHVERjQwLVxcdURGRkZdfFxcdUQ4NkVbXFx1REMwMC1cXHVEQzFEXXxcXHVEODdFW1xcdURDMDAtXFx1REUxRF18XFx1REI0MFtcXHVERDAwLVxcdURERUZdL1xuICAgIH07XG5cbiAgICAvLyBFbnN1cmUgdGhlIGNvbmRpdGlvbiBpcyB0cnVlLCBvdGhlcndpc2UgdGhyb3cgYW4gZXJyb3IuXG4gICAgLy8gVGhpcyBpcyBvbmx5IHRvIGhhdmUgYSBiZXR0ZXIgY29udHJhY3Qgc2VtYW50aWMsIGkuZS4gYW5vdGhlciBzYWZldHkgbmV0XG4gICAgLy8gdG8gY2F0Y2ggYSBsb2dpYyBlcnJvci4gVGhlIGNvbmRpdGlvbiBzaGFsbCBiZSBmdWxmaWxsZWQgaW4gbm9ybWFsIGNhc2UuXG4gICAgLy8gRG8gTk9UIHVzZSB0aGlzIHRvIGVuZm9yY2UgYSBjZXJ0YWluIGNvbmRpdGlvbiBvbiBhbnkgdXNlciBpbnB1dC5cblxuICAgIGZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FTU0VSVDogJyArIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEZWNpbWFsRGlnaXQoY2gpIHtcbiAgICAgICAgcmV0dXJuIChjaCA+PSAweDMwICYmIGNoIDw9IDB4MzkpOyAgIC8vIDAuLjlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0hleERpZ2l0KGNoKSB7XG4gICAgICAgIHJldHVybiAnMDEyMzQ1Njc4OWFiY2RlZkFCQ0RFRicuaW5kZXhPZihjaCkgPj0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc09jdGFsRGlnaXQoY2gpIHtcbiAgICAgICAgcmV0dXJuICcwMTIzNDU2NycuaW5kZXhPZihjaCkgPj0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvY3RhbFRvRGVjaW1hbChjaCkge1xuICAgICAgICAvLyBcXDAgaXMgbm90IG9jdGFsIGVzY2FwZSBzZXF1ZW5jZVxuICAgICAgICB2YXIgb2N0YWwgPSAoY2ggIT09ICcwJyksIGNvZGUgPSAnMDEyMzQ1NjcnLmluZGV4T2YoY2gpO1xuXG4gICAgICAgIGlmIChpbmRleCA8IGxlbmd0aCAmJiBpc09jdGFsRGlnaXQoc291cmNlW2luZGV4XSkpIHtcbiAgICAgICAgICAgIG9jdGFsID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvZGUgPSBjb2RlICogOCArICcwMTIzNDU2NycuaW5kZXhPZihzb3VyY2VbaW5kZXgrK10pO1xuXG4gICAgICAgICAgICAvLyAzIGRpZ2l0cyBhcmUgb25seSBhbGxvd2VkIHdoZW4gc3RyaW5nIHN0YXJ0c1xuICAgICAgICAgICAgLy8gd2l0aCAwLCAxLCAyLCAzXG4gICAgICAgICAgICBpZiAoJzAxMjMnLmluZGV4T2YoY2gpID49IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPCBsZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgaXNPY3RhbERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgY29kZSA9IGNvZGUgKiA4ICsgJzAxMjM0NTY3Jy5pbmRleE9mKHNvdXJjZVtpbmRleCsrXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogY29kZSxcbiAgICAgICAgICAgIG9jdGFsOiBvY3RhbFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyIDExLjIgV2hpdGUgU3BhY2VcblxuICAgIGZ1bmN0aW9uIGlzV2hpdGVTcGFjZShjaCkge1xuICAgICAgICByZXR1cm4gKGNoID09PSAweDIwKSB8fCAoY2ggPT09IDB4MDkpIHx8IChjaCA9PT0gMHgwQikgfHwgKGNoID09PSAweDBDKSB8fCAoY2ggPT09IDB4QTApIHx8XG4gICAgICAgICAgICAoY2ggPj0gMHgxNjgwICYmIFsweDE2ODAsIDB4MTgwRSwgMHgyMDAwLCAweDIwMDEsIDB4MjAwMiwgMHgyMDAzLCAweDIwMDQsIDB4MjAwNSwgMHgyMDA2LCAweDIwMDcsIDB4MjAwOCwgMHgyMDA5LCAweDIwMEEsIDB4MjAyRiwgMHgyMDVGLCAweDMwMDAsIDB4RkVGRl0uaW5kZXhPZihjaCkgPj0gMCk7XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTEuMyBMaW5lIFRlcm1pbmF0b3JzXG5cbiAgICBmdW5jdGlvbiBpc0xpbmVUZXJtaW5hdG9yKGNoKSB7XG4gICAgICAgIHJldHVybiAoY2ggPT09IDB4MEEpIHx8IChjaCA9PT0gMHgwRCkgfHwgKGNoID09PSAweDIwMjgpIHx8IChjaCA9PT0gMHgyMDI5KTtcbiAgICB9XG5cbiAgICAvLyBFQ01BLTI2MiAxMS42IElkZW50aWZpZXIgTmFtZXMgYW5kIElkZW50aWZpZXJzXG5cbiAgICBmdW5jdGlvbiBmcm9tQ29kZVBvaW50KGNwKSB7XG4gICAgICAgIHJldHVybiAoY3AgPCAweDEwMDAwKSA/IFN0cmluZy5mcm9tQ2hhckNvZGUoY3ApIDpcbiAgICAgICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODAwICsgKChjcCAtIDB4MTAwMDApID4+IDEwKSkgK1xuICAgICAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZSgweERDMDAgKyAoKGNwIC0gMHgxMDAwMCkgJiAxMDIzKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNJZGVudGlmaWVyU3RhcnQoY2gpIHtcbiAgICAgICAgcmV0dXJuIChjaCA9PT0gMHgyNCkgfHwgKGNoID09PSAweDVGKSB8fCAgLy8gJCAoZG9sbGFyKSBhbmQgXyAodW5kZXJzY29yZSlcbiAgICAgICAgICAgIChjaCA+PSAweDQxICYmIGNoIDw9IDB4NUEpIHx8ICAgICAgICAgLy8gQS4uWlxuICAgICAgICAgICAgKGNoID49IDB4NjEgJiYgY2ggPD0gMHg3QSkgfHwgICAgICAgICAvLyBhLi56XG4gICAgICAgICAgICAoY2ggPT09IDB4NUMpIHx8ICAgICAgICAgICAgICAgICAgICAgIC8vIFxcIChiYWNrc2xhc2gpXG4gICAgICAgICAgICAoKGNoID49IDB4ODApICYmIFJlZ2V4Lk5vbkFzY2lpSWRlbnRpZmllclN0YXJ0LnRlc3QoZnJvbUNvZGVQb2ludChjaCkpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0lkZW50aWZpZXJQYXJ0KGNoKSB7XG4gICAgICAgIHJldHVybiAoY2ggPT09IDB4MjQpIHx8IChjaCA9PT0gMHg1RikgfHwgIC8vICQgKGRvbGxhcikgYW5kIF8gKHVuZGVyc2NvcmUpXG4gICAgICAgICAgICAoY2ggPj0gMHg0MSAmJiBjaCA8PSAweDVBKSB8fCAgICAgICAgIC8vIEEuLlpcbiAgICAgICAgICAgIChjaCA+PSAweDYxICYmIGNoIDw9IDB4N0EpIHx8ICAgICAgICAgLy8gYS4uelxuICAgICAgICAgICAgKGNoID49IDB4MzAgJiYgY2ggPD0gMHgzOSkgfHwgICAgICAgICAvLyAwLi45XG4gICAgICAgICAgICAoY2ggPT09IDB4NUMpIHx8ICAgICAgICAgICAgICAgICAgICAgIC8vIFxcIChiYWNrc2xhc2gpXG4gICAgICAgICAgICAoKGNoID49IDB4ODApICYmIFJlZ2V4Lk5vbkFzY2lpSWRlbnRpZmllclBhcnQudGVzdChmcm9tQ29kZVBvaW50KGNoKSkpO1xuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyIDExLjYuMi4yIEZ1dHVyZSBSZXNlcnZlZCBXb3Jkc1xuXG4gICAgZnVuY3Rpb24gaXNGdXR1cmVSZXNlcnZlZFdvcmQoaWQpIHtcbiAgICAgICAgc3dpdGNoIChpZCkge1xuICAgICAgICBjYXNlICdlbnVtJzpcbiAgICAgICAgY2FzZSAnZXhwb3J0JzpcbiAgICAgICAgY2FzZSAnaW1wb3J0JzpcbiAgICAgICAgY2FzZSAnc3VwZXInOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQoaWQpIHtcbiAgICAgICAgc3dpdGNoIChpZCkge1xuICAgICAgICBjYXNlICdpbXBsZW1lbnRzJzpcbiAgICAgICAgY2FzZSAnaW50ZXJmYWNlJzpcbiAgICAgICAgY2FzZSAncGFja2FnZSc6XG4gICAgICAgIGNhc2UgJ3ByaXZhdGUnOlxuICAgICAgICBjYXNlICdwcm90ZWN0ZWQnOlxuICAgICAgICBjYXNlICdwdWJsaWMnOlxuICAgICAgICBjYXNlICdzdGF0aWMnOlxuICAgICAgICBjYXNlICd5aWVsZCc6XG4gICAgICAgIGNhc2UgJ2xldCc6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzUmVzdHJpY3RlZFdvcmQoaWQpIHtcbiAgICAgICAgcmV0dXJuIGlkID09PSAnZXZhbCcgfHwgaWQgPT09ICdhcmd1bWVudHMnO1xuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyIDExLjYuMi4xIEtleXdvcmRzXG5cbiAgICBmdW5jdGlvbiBpc0tleXdvcmQoaWQpIHtcbiAgICAgICAgc3dpdGNoIChpZC5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2lmJykgfHwgKGlkID09PSAnaW4nKSB8fCAoaWQgPT09ICdkbycpO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gKGlkID09PSAndmFyJykgfHwgKGlkID09PSAnZm9yJykgfHwgKGlkID09PSAnbmV3JykgfHxcbiAgICAgICAgICAgICAgICAoaWQgPT09ICd0cnknKSB8fCAoaWQgPT09ICdsZXQnKTtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ3RoaXMnKSB8fCAoaWQgPT09ICdlbHNlJykgfHwgKGlkID09PSAnY2FzZScpIHx8XG4gICAgICAgICAgICAgICAgKGlkID09PSAndm9pZCcpIHx8IChpZCA9PT0gJ3dpdGgnKSB8fCAoaWQgPT09ICdlbnVtJyk7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICd3aGlsZScpIHx8IChpZCA9PT0gJ2JyZWFrJykgfHwgKGlkID09PSAnY2F0Y2gnKSB8fFxuICAgICAgICAgICAgICAgIChpZCA9PT0gJ3Rocm93JykgfHwgKGlkID09PSAnY29uc3QnKSB8fCAoaWQgPT09ICd5aWVsZCcpIHx8XG4gICAgICAgICAgICAgICAgKGlkID09PSAnY2xhc3MnKSB8fCAoaWQgPT09ICdzdXBlcicpO1xuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICByZXR1cm4gKGlkID09PSAncmV0dXJuJykgfHwgKGlkID09PSAndHlwZW9mJykgfHwgKGlkID09PSAnZGVsZXRlJykgfHxcbiAgICAgICAgICAgICAgICAoaWQgPT09ICdzd2l0Y2gnKSB8fCAoaWQgPT09ICdleHBvcnQnKSB8fCAoaWQgPT09ICdpbXBvcnQnKTtcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2RlZmF1bHQnKSB8fCAoaWQgPT09ICdmaW5hbGx5JykgfHwgKGlkID09PSAnZXh0ZW5kcycpO1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICByZXR1cm4gKGlkID09PSAnZnVuY3Rpb24nKSB8fCAoaWQgPT09ICdjb250aW51ZScpIHx8IChpZCA9PT0gJ2RlYnVnZ2VyJyk7XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICByZXR1cm4gKGlkID09PSAnaW5zdGFuY2VvZicpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTEuNCBDb21tZW50c1xuXG4gICAgZnVuY3Rpb24gYWRkQ29tbWVudCh0eXBlLCB2YWx1ZSwgc3RhcnQsIGVuZCwgbG9jKSB7XG4gICAgICAgIHZhciBjb21tZW50O1xuXG4gICAgICAgIGFzc2VydCh0eXBlb2Ygc3RhcnQgPT09ICdudW1iZXInLCAnQ29tbWVudCBtdXN0IGhhdmUgdmFsaWQgcG9zaXRpb24nKTtcblxuICAgICAgICBzdGF0ZS5sYXN0Q29tbWVudFN0YXJ0ID0gc3RhcnQ7XG5cbiAgICAgICAgY29tbWVudCA9IHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGV4dHJhLnJhbmdlKSB7XG4gICAgICAgICAgICBjb21tZW50LnJhbmdlID0gW3N0YXJ0LCBlbmRdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHRyYS5sb2MpIHtcbiAgICAgICAgICAgIGNvbW1lbnQubG9jID0gbG9jO1xuICAgICAgICB9XG4gICAgICAgIGV4dHJhLmNvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gICAgICAgIGlmIChleHRyYS5hdHRhY2hDb21tZW50KSB7XG4gICAgICAgICAgICBleHRyYS5sZWFkaW5nQ29tbWVudHMucHVzaChjb21tZW50KTtcbiAgICAgICAgICAgIGV4dHJhLnRyYWlsaW5nQ29tbWVudHMucHVzaChjb21tZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXh0cmEudG9rZW5pemUpIHtcbiAgICAgICAgICAgIGNvbW1lbnQudHlwZSA9IGNvbW1lbnQudHlwZSArICdDb21tZW50JztcbiAgICAgICAgICAgIGlmIChleHRyYS5kZWxlZ2F0ZSkge1xuICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBleHRyYS5kZWxlZ2F0ZShjb21tZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4dHJhLnRva2Vucy5wdXNoKGNvbW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2tpcFNpbmdsZUxpbmVDb21tZW50KG9mZnNldCkge1xuICAgICAgICB2YXIgc3RhcnQsIGxvYywgY2gsIGNvbW1lbnQ7XG5cbiAgICAgICAgc3RhcnQgPSBpbmRleCAtIG9mZnNldDtcbiAgICAgICAgbG9jID0ge1xuICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnQgLSBvZmZzZXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoKSkge1xuICAgICAgICAgICAgICAgIGhhc0xpbmVUZXJtaW5hdG9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZXh0cmEuY29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IHNvdXJjZS5zbGljZShzdGFydCArIG9mZnNldCwgaW5kZXggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgbG9jLmVuZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGluZGV4IC0gbGluZVN0YXJ0IC0gMVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBhZGRDb21tZW50KCdMaW5lJywgY29tbWVudCwgc3RhcnQsIGluZGV4IC0gMSwgbG9jKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAxMyAmJiBzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgPT09IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICsrbGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQgPSBpbmRleDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXh0cmEuY29tbWVudHMpIHtcbiAgICAgICAgICAgIGNvbW1lbnQgPSBzb3VyY2Uuc2xpY2Uoc3RhcnQgKyBvZmZzZXQsIGluZGV4KTtcbiAgICAgICAgICAgIGxvYy5lbmQgPSB7XG4gICAgICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBjb2x1bW46IGluZGV4IC0gbGluZVN0YXJ0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYWRkQ29tbWVudCgnTGluZScsIGNvbW1lbnQsIHN0YXJ0LCBpbmRleCwgbG9jKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNraXBNdWx0aUxpbmVDb21tZW50KCkge1xuICAgICAgICB2YXIgc3RhcnQsIGxvYywgY2gsIGNvbW1lbnQ7XG5cbiAgICAgICAgaWYgKGV4dHJhLmNvbW1lbnRzKSB7XG4gICAgICAgICAgICBzdGFydCA9IGluZGV4IC0gMjtcbiAgICAgICAgICAgIGxvYyA9IHtcbiAgICAgICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGluZGV4IC0gbGluZVN0YXJ0IC0gMlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgICAgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2gpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAweDBEICYmIHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4ICsgMSkgPT09IDB4MEEpIHtcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaGFzTGluZVRlcm1pbmF0b3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgICsrbGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgIGxpbmVTdGFydCA9IGluZGV4O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gMHgyQSkge1xuICAgICAgICAgICAgICAgIC8vIEJsb2NrIGNvbW1lbnQgZW5kcyB3aXRoICcqLycuXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4ICsgMSkgPT09IDB4MkYpIHtcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4dHJhLmNvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0gc291cmNlLnNsaWNlKHN0YXJ0ICsgMiwgaW5kZXggLSAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYy5lbmQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGluZGV4IC0gbGluZVN0YXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ29tbWVudCgnQmxvY2snLCBjb21tZW50LCBzdGFydCwgaW5kZXgsIGxvYyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmFuIG9mZiB0aGUgZW5kIG9mIHRoZSBmaWxlIC0gdGhlIHdob2xlIHRoaW5nIGlzIGEgY29tbWVudFxuICAgICAgICBpZiAoZXh0cmEuY29tbWVudHMpIHtcbiAgICAgICAgICAgIGxvYy5lbmQgPSB7XG4gICAgICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBjb2x1bW46IGluZGV4IC0gbGluZVN0YXJ0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29tbWVudCA9IHNvdXJjZS5zbGljZShzdGFydCArIDIsIGluZGV4KTtcbiAgICAgICAgICAgIGFkZENvbW1lbnQoJ0Jsb2NrJywgY29tbWVudCwgc3RhcnQsIGluZGV4LCBsb2MpO1xuICAgICAgICB9XG4gICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2tpcENvbW1lbnQoKSB7XG4gICAgICAgIHZhciBjaCwgc3RhcnQ7XG4gICAgICAgIGhhc0xpbmVUZXJtaW5hdG9yID0gZmFsc2U7XG5cbiAgICAgICAgc3RhcnQgPSAoaW5kZXggPT09IDApO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpO1xuXG4gICAgICAgICAgICBpZiAoaXNXaGl0ZVNwYWNlKGNoKSkge1xuICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2gpKSB7XG4gICAgICAgICAgICAgICAgaGFzTGluZVRlcm1pbmF0b3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAweDBEICYmIHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSA9PT0gMHgwQSkge1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICArK2xpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gMHgyRikgeyAvLyBVKzAwMkYgaXMgJy8nXG4gICAgICAgICAgICAgICAgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gMHgyRikge1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICBza2lwU2luZ2xlTGluZUNvbW1lbnQoMik7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAweDJBKSB7ICAvLyBVKzAwMkEgaXMgJyonXG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHNraXBNdWx0aUxpbmVDb21tZW50KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGFydCAmJiBjaCA9PT0gMHgyRCkgeyAvLyBVKzAwMkQgaXMgJy0nXG4gICAgICAgICAgICAgICAgLy8gVSswMDNFIGlzICc+J1xuICAgICAgICAgICAgICAgIGlmICgoc291cmNlLmNoYXJDb2RlQXQoaW5kZXggKyAxKSA9PT0gMHgyRCkgJiYgKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4ICsgMikgPT09IDB4M0UpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICctLT4nIGlzIGEgc2luZ2xlLWxpbmUgY29tbWVudFxuICAgICAgICAgICAgICAgICAgICBpbmRleCArPSAzO1xuICAgICAgICAgICAgICAgICAgICBza2lwU2luZ2xlTGluZUNvbW1lbnQoMyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gMHgzQykgeyAvLyBVKzAwM0MgaXMgJzwnXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5zbGljZShpbmRleCArIDEsIGluZGV4ICsgNCkgPT09ICchLS0nKSB7XG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7IC8vIGA8YFxuICAgICAgICAgICAgICAgICAgICArK2luZGV4OyAvLyBgIWBcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDsgLy8gYC1gXG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7IC8vIGAtYFxuICAgICAgICAgICAgICAgICAgICBza2lwU2luZ2xlTGluZUNvbW1lbnQoNCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjYW5IZXhFc2NhcGUocHJlZml4KSB7XG4gICAgICAgIHZhciBpLCBsZW4sIGNoLCBjb2RlID0gMDtcblxuICAgICAgICBsZW4gPSAocHJlZml4ID09PSAndScpID8gNCA6IDI7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgaWYgKGluZGV4IDwgbGVuZ3RoICYmIGlzSGV4RGlnaXQoc291cmNlW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgICAgICBjb2RlID0gY29kZSAqIDE2ICsgJzAxMjM0NTY3ODlhYmNkZWYnLmluZGV4T2YoY2gudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FuVW5pY29kZUNvZGVQb2ludEVzY2FwZSgpIHtcbiAgICAgICAgdmFyIGNoLCBjb2RlO1xuXG4gICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgY29kZSA9IDA7XG5cbiAgICAgICAgLy8gQXQgbGVhc3QsIG9uZSBoZXggZGlnaXQgaXMgcmVxdWlyZWQuXG4gICAgICAgIGlmIChjaCA9PT0gJ30nKSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgIGlmICghaXNIZXhEaWdpdChjaCkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvZGUgPSBjb2RlICogMTYgKyAnMDEyMzQ1Njc4OWFiY2RlZicuaW5kZXhPZihjaC50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb2RlID4gMHgxMEZGRkYgfHwgY2ggIT09ICd9Jykge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmcm9tQ29kZVBvaW50KGNvZGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvZGVQb2ludEF0KGkpIHtcbiAgICAgICAgdmFyIGNwLCBmaXJzdCwgc2Vjb25kO1xuXG4gICAgICAgIGNwID0gc291cmNlLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjcCA+PSAweEQ4MDAgJiYgY3AgPD0gMHhEQkZGKSB7XG4gICAgICAgICAgICBzZWNvbmQgPSBzb3VyY2UuY2hhckNvZGVBdChpICsgMSk7XG4gICAgICAgICAgICBpZiAoc2Vjb25kID49IDB4REMwMCAmJiBzZWNvbmQgPD0gMHhERkZGKSB7XG4gICAgICAgICAgICAgICAgZmlyc3QgPSBjcDtcbiAgICAgICAgICAgICAgICBjcCA9IChmaXJzdCAtIDB4RDgwMCkgKiAweDQwMCArIHNlY29uZCAtIDB4REMwMCArIDB4MTAwMDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3A7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Q29tcGxleElkZW50aWZpZXIoKSB7XG4gICAgICAgIHZhciBjcCwgY2gsIGlkO1xuXG4gICAgICAgIGNwID0gY29kZVBvaW50QXQoaW5kZXgpO1xuICAgICAgICBpZCA9IGZyb21Db2RlUG9pbnQoY3ApO1xuICAgICAgICBpbmRleCArPSBpZC5sZW5ndGg7XG5cbiAgICAgICAgLy8gJ1xcdScgKFUrMDA1QywgVSswMDc1KSBkZW5vdGVzIGFuIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAgICBpZiAoY3AgPT09IDB4NUMpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgIT09IDB4NzUpIHtcbiAgICAgICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgIGlmIChzb3VyY2VbaW5kZXhdID09PSAneycpIHtcbiAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgIGNoID0gc2NhblVuaWNvZGVDb2RlUG9pbnRFc2NhcGUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2ggPSBzY2FuSGV4RXNjYXBlKCd1Jyk7XG4gICAgICAgICAgICAgICAgY3AgPSBjaC5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgICAgIGlmICghY2ggfHwgY2ggPT09ICdcXFxcJyB8fCAhaXNJZGVudGlmaWVyU3RhcnQoY3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWQgPSBjaDtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY3AgPSBjb2RlUG9pbnRBdChpbmRleCk7XG4gICAgICAgICAgICBpZiAoIWlzSWRlbnRpZmllclBhcnQoY3ApKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaCA9IGZyb21Db2RlUG9pbnQoY3ApO1xuICAgICAgICAgICAgaWQgKz0gY2g7XG4gICAgICAgICAgICBpbmRleCArPSBjaC5sZW5ndGg7XG5cbiAgICAgICAgICAgIC8vICdcXHUnIChVKzAwNUMsIFUrMDA3NSkgZGVub3RlcyBhbiBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICAgICAgICAgIGlmIChjcCA9PT0gMHg1Qykge1xuICAgICAgICAgICAgICAgIGlkID0gaWQuc3Vic3RyKDAsIGlkLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgIT09IDB4NzUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlW2luZGV4XSA9PT0gJ3snKSB7XG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGNoID0gc2NhblVuaWNvZGVDb2RlUG9pbnRFc2NhcGUoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjaCA9IHNjYW5IZXhFc2NhcGUoJ3UnKTtcbiAgICAgICAgICAgICAgICAgICAgY3AgPSBjaC5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNoIHx8IGNoID09PSAnXFxcXCcgfHwgIWlzSWRlbnRpZmllclBhcnQoY3ApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlkICs9IGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldElkZW50aWZpZXIoKSB7XG4gICAgICAgIHZhciBzdGFydCwgY2g7XG5cbiAgICAgICAgc3RhcnQgPSBpbmRleCsrO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgICAgaWYgKGNoID09PSAweDVDKSB7XG4gICAgICAgICAgICAgICAgLy8gQmxhY2tzbGFzaCAoVSswMDVDKSBtYXJrcyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICBpbmRleCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRDb21wbGV4SWRlbnRpZmllcigpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA+PSAweEQ4MDAgJiYgY2ggPCAweERGRkYpIHtcbiAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIGhhbmRsZSBzdXJyb2dhdGUgcGFpcnMuXG4gICAgICAgICAgICAgICAgaW5kZXggPSBzdGFydDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Q29tcGxleElkZW50aWZpZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0lkZW50aWZpZXJQYXJ0KGNoKSkge1xuICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zbGljZShzdGFydCwgaW5kZXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjYW5JZGVudGlmaWVyKCkge1xuICAgICAgICB2YXIgc3RhcnQsIGlkLCB0eXBlO1xuXG4gICAgICAgIHN0YXJ0ID0gaW5kZXg7XG5cbiAgICAgICAgLy8gQmFja3NsYXNoIChVKzAwNUMpIHN0YXJ0cyBhbiBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICAgICAgaWQgPSAoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpID09PSAweDVDKSA/IGdldENvbXBsZXhJZGVudGlmaWVyKCkgOiBnZXRJZGVudGlmaWVyKCk7XG5cbiAgICAgICAgLy8gVGhlcmUgaXMgbm8ga2V5d29yZCBvciBsaXRlcmFsIHdpdGggb25seSBvbmUgY2hhcmFjdGVyLlxuICAgICAgICAvLyBUaHVzLCBpdCBtdXN0IGJlIGFuIGlkZW50aWZpZXIuXG4gICAgICAgIGlmIChpZC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHR5cGUgPSBUb2tlbi5JZGVudGlmaWVyO1xuICAgICAgICB9IGVsc2UgaWYgKGlzS2V5d29yZChpZCkpIHtcbiAgICAgICAgICAgIHR5cGUgPSBUb2tlbi5LZXl3b3JkO1xuICAgICAgICB9IGVsc2UgaWYgKGlkID09PSAnbnVsbCcpIHtcbiAgICAgICAgICAgIHR5cGUgPSBUb2tlbi5OdWxsTGl0ZXJhbDtcbiAgICAgICAgfSBlbHNlIGlmIChpZCA9PT0gJ3RydWUnIHx8IGlkID09PSAnZmFsc2UnKSB7XG4gICAgICAgICAgICB0eXBlID0gVG9rZW4uQm9vbGVhbkxpdGVyYWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0eXBlID0gVG9rZW4uSWRlbnRpZmllcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgdmFsdWU6IGlkLFxuICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICB9O1xuICAgIH1cblxuXG4gICAgLy8gRUNNQS0yNjIgMTEuNyBQdW5jdHVhdG9yc1xuXG4gICAgZnVuY3Rpb24gc2NhblB1bmN0dWF0b3IoKSB7XG4gICAgICAgIHZhciB0b2tlbiwgc3RyO1xuXG4gICAgICAgIHRva2VuID0ge1xuICAgICAgICAgICAgdHlwZTogVG9rZW4uUHVuY3R1YXRvcixcbiAgICAgICAgICAgIHZhbHVlOiAnJyxcbiAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgIHN0YXJ0OiBpbmRleCxcbiAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBDaGVjayBmb3IgbW9zdCBjb21tb24gc2luZ2xlLWNoYXJhY3RlciBwdW5jdHVhdG9ycy5cbiAgICAgICAgc3RyID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgc3dpdGNoIChzdHIpIHtcblxuICAgICAgICBjYXNlICcoJzpcbiAgICAgICAgICAgIGlmIChleHRyYS50b2tlbml6ZSkge1xuICAgICAgICAgICAgICAgIGV4dHJhLm9wZW5QYXJlblRva2VuID0gZXh0cmEudG9rZW5WYWx1ZXMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3snOlxuICAgICAgICAgICAgaWYgKGV4dHJhLnRva2VuaXplKSB7XG4gICAgICAgICAgICAgICAgZXh0cmEub3BlbkN1cmx5VG9rZW4gPSBleHRyYS50b2tlblZhbHVlcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZS5jdXJseVN0YWNrLnB1c2goJ3snKTtcbiAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICcuJzpcbiAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICBpZiAoc291cmNlW2luZGV4XSA9PT0gJy4nICYmIHNvdXJjZVtpbmRleCArIDFdID09PSAnLicpIHtcbiAgICAgICAgICAgICAgICAvLyBTcHJlYWQgb3BlcmF0b3I6IC4uLlxuICAgICAgICAgICAgICAgIGluZGV4ICs9IDI7XG4gICAgICAgICAgICAgICAgc3RyID0gJy4uLic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd9JzpcbiAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICBzdGF0ZS5jdXJseVN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJyknOlxuICAgICAgICBjYXNlICc7JzpcbiAgICAgICAgY2FzZSAnLCc6XG4gICAgICAgIGNhc2UgJ1snOlxuICAgICAgICBjYXNlICddJzpcbiAgICAgICAgY2FzZSAnOic6XG4gICAgICAgIGNhc2UgJz8nOlxuICAgICAgICBjYXNlICd+JzpcbiAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gNC1jaGFyYWN0ZXIgcHVuY3R1YXRvci5cbiAgICAgICAgICAgIHN0ciA9IHNvdXJjZS5zdWJzdHIoaW5kZXgsIDQpO1xuICAgICAgICAgICAgaWYgKHN0ciA9PT0gJz4+Pj0nKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggKz0gNDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAvLyAzLWNoYXJhY3RlciBwdW5jdHVhdG9ycy5cbiAgICAgICAgICAgICAgICBzdHIgPSBzdHIuc3Vic3RyKDAsIDMpO1xuICAgICAgICAgICAgICAgIGlmIChzdHIgPT09ICc9PT0nIHx8IHN0ciA9PT0gJyE9PScgfHwgc3RyID09PSAnPj4+JyB8fFxuICAgICAgICAgICAgICAgICAgICBzdHIgPT09ICc8PD0nIHx8IHN0ciA9PT0gJz4+PScpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gMztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIDItY2hhcmFjdGVyIHB1bmN0dWF0b3JzLlxuICAgICAgICAgICAgICAgICAgICBzdHIgPSBzdHIuc3Vic3RyKDAsIDIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyID09PSAnJiYnIHx8IHN0ciA9PT0gJ3x8JyB8fCBzdHIgPT09ICc9PScgfHwgc3RyID09PSAnIT0nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgPT09ICcrPScgfHwgc3RyID09PSAnLT0nIHx8IHN0ciA9PT0gJyo9JyB8fCBzdHIgPT09ICcvPScgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9PT0gJysrJyB8fCBzdHIgPT09ICctLScgfHwgc3RyID09PSAnPDwnIHx8IHN0ciA9PT0gJz4+JyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyID09PSAnJj0nIHx8IHN0ciA9PT0gJ3w9JyB8fCBzdHIgPT09ICdePScgfHwgc3RyID09PSAnJT0nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgPT09ICc8PScgfHwgc3RyID09PSAnPj0nIHx8IHN0ciA9PT0gJz0+Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gMS1jaGFyYWN0ZXIgcHVuY3R1YXRvcnMuXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCc8Pj0hKy0qJSZ8Xi8nLmluZGV4T2Yoc3RyKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmRleCA9PT0gdG9rZW4uc3RhcnQpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0b2tlbi5lbmQgPSBpbmRleDtcbiAgICAgICAgdG9rZW4udmFsdWUgPSBzdHI7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9XG5cbiAgICAvLyBFQ01BLTI2MiAxMS44LjMgTnVtZXJpYyBMaXRlcmFsc1xuXG4gICAgZnVuY3Rpb24gc2NhbkhleExpdGVyYWwoc3RhcnQpIHtcbiAgICAgICAgdmFyIG51bWJlciA9ICcnO1xuXG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCFpc0hleERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG51bWJlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBUb2tlbi5OdW1lcmljTGl0ZXJhbCxcbiAgICAgICAgICAgIHZhbHVlOiBwYXJzZUludCgnMHgnICsgbnVtYmVyLCAxNiksXG4gICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NhbkJpbmFyeUxpdGVyYWwoc3RhcnQpIHtcbiAgICAgICAgdmFyIGNoLCBudW1iZXI7XG5cbiAgICAgICAgbnVtYmVyID0gJyc7XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgICAgICBpZiAoY2ggIT09ICcwJyAmJiBjaCAhPT0gJzEnKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG51bWJlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIG9ubHkgMGIgb3IgMEJcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChjaCkgfHwgaXNEZWNpbWFsRGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBUb2tlbi5OdW1lcmljTGl0ZXJhbCxcbiAgICAgICAgICAgIHZhbHVlOiBwYXJzZUludChudW1iZXIsIDIpLFxuICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjYW5PY3RhbExpdGVyYWwocHJlZml4LCBzdGFydCkge1xuICAgICAgICB2YXIgbnVtYmVyLCBvY3RhbDtcblxuICAgICAgICBpZiAoaXNPY3RhbERpZ2l0KHByZWZpeCkpIHtcbiAgICAgICAgICAgIG9jdGFsID0gdHJ1ZTtcbiAgICAgICAgICAgIG51bWJlciA9ICcwJyArIHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9jdGFsID0gZmFsc2U7XG4gICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgbnVtYmVyID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghaXNPY3RhbERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFvY3RhbCAmJiBudW1iZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBvbmx5IDBvIG9yIDBPXG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkgfHwgaXNEZWNpbWFsRGlnaXQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBUb2tlbi5OdW1lcmljTGl0ZXJhbCxcbiAgICAgICAgICAgIHZhbHVlOiBwYXJzZUludChudW1iZXIsIDgpLFxuICAgICAgICAgICAgb2N0YWw6IG9jdGFsLFxuICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSW1wbGljaXRPY3RhbExpdGVyYWwoKSB7XG4gICAgICAgIHZhciBpLCBjaDtcblxuICAgICAgICAvLyBJbXBsaWNpdCBvY3RhbCwgdW5sZXNzIHRoZXJlIGlzIGEgbm9uLW9jdGFsIGRpZ2l0LlxuICAgICAgICAvLyAoQW5uZXggQi4xLjEgb24gTnVtZXJpYyBMaXRlcmFscylcbiAgICAgICAgZm9yIChpID0gaW5kZXggKyAxOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNoID0gc291cmNlW2ldO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnOCcgfHwgY2ggPT09ICc5Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNPY3RhbERpZ2l0KGNoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2Nhbk51bWVyaWNMaXRlcmFsKCkge1xuICAgICAgICB2YXIgbnVtYmVyLCBzdGFydCwgY2g7XG5cbiAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICBhc3NlcnQoaXNEZWNpbWFsRGlnaXQoY2guY2hhckNvZGVBdCgwKSkgfHwgKGNoID09PSAnLicpLFxuICAgICAgICAgICAgJ051bWVyaWMgbGl0ZXJhbCBtdXN0IHN0YXJ0IHdpdGggYSBkZWNpbWFsIGRpZ2l0IG9yIGEgZGVjaW1hbCBwb2ludCcpO1xuXG4gICAgICAgIHN0YXJ0ID0gaW5kZXg7XG4gICAgICAgIG51bWJlciA9ICcnO1xuICAgICAgICBpZiAoY2ggIT09ICcuJykge1xuICAgICAgICAgICAgbnVtYmVyID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuXG4gICAgICAgICAgICAvLyBIZXggbnVtYmVyIHN0YXJ0cyB3aXRoICcweCcuXG4gICAgICAgICAgICAvLyBPY3RhbCBudW1iZXIgc3RhcnRzIHdpdGggJzAnLlxuICAgICAgICAgICAgLy8gT2N0YWwgbnVtYmVyIGluIEVTNiBzdGFydHMgd2l0aCAnMG8nLlxuICAgICAgICAgICAgLy8gQmluYXJ5IG51bWJlciBpbiBFUzYgc3RhcnRzIHdpdGggJzBiJy5cbiAgICAgICAgICAgIGlmIChudW1iZXIgPT09ICcwJykge1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ3gnIHx8IGNoID09PSAnWCcpIHtcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjYW5IZXhMaXRlcmFsKHN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnYicgfHwgY2ggPT09ICdCJykge1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NhbkJpbmFyeUxpdGVyYWwoc3RhcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdvJyB8fCBjaCA9PT0gJ08nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzY2FuT2N0YWxMaXRlcmFsKGNoLCBzdGFydCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGlzT2N0YWxEaWdpdChjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSW1wbGljaXRPY3RhbExpdGVyYWwoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjYW5PY3RhbExpdGVyYWwoY2gsIHN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2hpbGUgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoID09PSAnLicpIHtcbiAgICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICB3aGlsZSAoaXNEZWNpbWFsRGlnaXQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2ggPT09ICdlJyB8fCBjaCA9PT0gJ0UnKSB7XG4gICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuXG4gICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgICAgICBpZiAoY2ggPT09ICcrJyB8fCBjaCA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0RlY2ltYWxEaWdpdChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBUb2tlbi5OdW1lcmljTGl0ZXJhbCxcbiAgICAgICAgICAgIHZhbHVlOiBwYXJzZUZsb2F0KG51bWJlciksXG4gICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTEuOC40IFN0cmluZyBMaXRlcmFsc1xuXG4gICAgZnVuY3Rpb24gc2NhblN0cmluZ0xpdGVyYWwoKSB7XG4gICAgICAgIHZhciBzdHIgPSAnJywgcXVvdGUsIHN0YXJ0LCBjaCwgdW5lc2NhcGVkLCBvY3RUb0RlYywgb2N0YWwgPSBmYWxzZTtcblxuICAgICAgICBxdW90ZSA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgIGFzc2VydCgocXVvdGUgPT09ICdcXCcnIHx8IHF1b3RlID09PSAnXCInKSxcbiAgICAgICAgICAgICdTdHJpbmcgbGl0ZXJhbCBtdXN0IHN0YXJ0cyB3aXRoIGEgcXVvdGUnKTtcblxuICAgICAgICBzdGFydCA9IGluZGV4O1xuICAgICAgICArK2luZGV4O1xuXG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG5cbiAgICAgICAgICAgIGlmIChjaCA9PT0gcXVvdGUpIHtcbiAgICAgICAgICAgICAgICBxdW90ZSA9ICcnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICAgICAgaWYgKCFjaCB8fCAhaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3UnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICd4JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VbaW5kZXhdID09PSAneycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBzY2FuVW5pY29kZUNvZGVQb2ludEVzY2FwZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmVzY2FwZWQgPSBzY2FuSGV4RXNjYXBlKGNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXVuZXNjYXBlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gdW5lc2NhcGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ24nOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXG4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3InOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXHInO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXHQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXGInO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXGYnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3YnOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXHgwQic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnOCc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJzknOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNPY3RhbERpZ2l0KGNoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9jdFRvRGVjID0gb2N0YWxUb0RlY2ltYWwoY2gpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2N0YWwgPSBvY3RUb0RlYy5vY3RhbCB8fCBvY3RhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShvY3RUb0RlYy5jb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICArK2xpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xccicgJiYgc291cmNlW2luZGV4XSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGluZVN0YXJ0ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0ciArPSBjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChxdW90ZSAhPT0gJycpIHtcbiAgICAgICAgICAgIGluZGV4ID0gc3RhcnQ7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFRva2VuLlN0cmluZ0xpdGVyYWwsXG4gICAgICAgICAgICB2YWx1ZTogc3RyLFxuICAgICAgICAgICAgb2N0YWw6IG9jdGFsLFxuICAgICAgICAgICAgbGluZU51bWJlcjogc3RhcnRMaW5lTnVtYmVyLFxuICAgICAgICAgICAgbGluZVN0YXJ0OiBzdGFydExpbmVTdGFydCxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBFQ01BLTI2MiAxMS44LjYgVGVtcGxhdGUgTGl0ZXJhbCBMZXhpY2FsIENvbXBvbmVudHNcblxuICAgIGZ1bmN0aW9uIHNjYW5UZW1wbGF0ZSgpIHtcbiAgICAgICAgdmFyIGNvb2tlZCA9ICcnLCBjaCwgc3RhcnQsIHJhd09mZnNldCwgdGVybWluYXRlZCwgaGVhZCwgdGFpbCwgcmVzdG9yZSwgdW5lc2NhcGVkO1xuXG4gICAgICAgIHRlcm1pbmF0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGFpbCA9IGZhbHNlO1xuICAgICAgICBzdGFydCA9IGluZGV4O1xuICAgICAgICBoZWFkID0gKHNvdXJjZVtpbmRleF0gPT09ICdgJyk7XG4gICAgICAgIHJhd09mZnNldCA9IDI7XG5cbiAgICAgICAgKytpbmRleDtcblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnYCcpIHtcbiAgICAgICAgICAgICAgICByYXdPZmZzZXQgPSAxO1xuICAgICAgICAgICAgICAgIHRhaWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRlcm1pbmF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJyQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZVtpbmRleF0gPT09ICd7Jykge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jdXJseVN0YWNrLnB1c2goJyR7Jyk7XG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29va2VkICs9IGNoO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICAgICAgaWYgKCFpc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gJ1xcbic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gJ1xccic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gJ1xcdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndSc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZVtpbmRleF0gPT09ICd7Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9IHNjYW5Vbmljb2RlQ29kZVBvaW50RXNjYXBlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3RvcmUgPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmVzY2FwZWQgPSBzY2FuSGV4RXNjYXBlKGNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodW5lc2NhcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSB1bmVzY2FwZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSByZXN0b3JlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXGInO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXGYnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3YnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXHYnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbDogXFwwMSBcXDAyIGFuZCBzbyBvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKE1lc3NhZ2VzLlRlbXBsYXRlT2N0YWxMaXRlcmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXDAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc09jdGFsRGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbDogXFwxIFxcMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoTWVzc2FnZXMuVGVtcGxhdGVPY3RhbExpdGVyYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICsrbGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiBzb3VyY2VbaW5kZXhdID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsaW5lU3RhcnQgPSBpbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICArK2xpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiBzb3VyY2VbaW5kZXhdID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQgPSBpbmRleDtcbiAgICAgICAgICAgICAgICBjb29rZWQgKz0gJ1xcbic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvb2tlZCArPSBjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGVybWluYXRlZCkge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaGVhZCkge1xuICAgICAgICAgICAgc3RhdGUuY3VybHlTdGFjay5wb3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBUb2tlbi5UZW1wbGF0ZSxcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgY29va2VkOiBjb29rZWQsXG4gICAgICAgICAgICAgICAgcmF3OiBzb3VyY2Uuc2xpY2Uoc3RhcnQgKyAxLCBpbmRleCAtIHJhd09mZnNldClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoZWFkOiBoZWFkLFxuICAgICAgICAgICAgdGFpbDogdGFpbCxcbiAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBFQ01BLTI2MiAxMS44LjUgUmVndWxhciBFeHByZXNzaW9uIExpdGVyYWxzXG5cbiAgICBmdW5jdGlvbiB0ZXN0UmVnRXhwKHBhdHRlcm4sIGZsYWdzKSB7XG4gICAgICAgIC8vIFRoZSBCTVAgY2hhcmFjdGVyIHRvIHVzZSBhcyBhIHJlcGxhY2VtZW50IGZvciBhc3RyYWwgc3ltYm9scyB3aGVuXG4gICAgICAgIC8vIHRyYW5zbGF0aW5nIGFuIEVTNiBcInVcIi1mbGFnZ2VkIHBhdHRlcm4gdG8gYW4gRVM1LWNvbXBhdGlibGVcbiAgICAgICAgLy8gYXBwcm94aW1hdGlvbi5cbiAgICAgICAgLy8gTm90ZTogcmVwbGFjaW5nIHdpdGggJ1xcdUZGRkYnIGVuYWJsZXMgZmFsc2UgcG9zaXRpdmVzIGluIHVubGlrZWx5XG4gICAgICAgIC8vIHNjZW5hcmlvcy4gRm9yIGV4YW1wbGUsIGBbXFx1ezEwNDRmfS1cXHV7MTA0NDB9XWAgaXMgYW4gaW52YWxpZFxuICAgICAgICAvLyBwYXR0ZXJuIHRoYXQgd291bGQgbm90IGJlIGRldGVjdGVkIGJ5IHRoaXMgc3Vic3RpdHV0aW9uLlxuICAgICAgICB2YXIgYXN0cmFsU3Vic3RpdHV0ZSA9ICdcXHVGRkZGJyxcbiAgICAgICAgICAgIHRtcCA9IHBhdHRlcm47XG5cbiAgICAgICAgaWYgKGZsYWdzLmluZGV4T2YoJ3UnKSA+PSAwKSB7XG4gICAgICAgICAgICB0bXAgPSB0bXBcbiAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIGV2ZXJ5IFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlIHdpdGggdGhlIGVxdWl2YWxlbnRcbiAgICAgICAgICAgICAgICAvLyBCTVAgY2hhcmFjdGVyIG9yIGEgY29uc3RhbnQgQVNDSUkgY29kZSBwb2ludCBpbiB0aGUgY2FzZSBvZlxuICAgICAgICAgICAgICAgIC8vIGFzdHJhbCBzeW1ib2xzLiAoU2VlIHRoZSBhYm92ZSBub3RlIG9uIGBhc3RyYWxTdWJzdGl0dXRlYFxuICAgICAgICAgICAgICAgIC8vIGZvciBtb3JlIGluZm9ybWF0aW9uLilcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXHVcXHsoWzAtOWEtZkEtRl0rKVxcfXxcXFxcdShbYS1mQS1GMC05XXs0fSkvZywgZnVuY3Rpb24gKCQwLCAkMSwgJDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvZGVQb2ludCA9IHBhcnNlSW50KCQxIHx8ICQyLCAxNik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPiAweDEwRkZGRikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obnVsbCwgTWVzc2FnZXMuSW52YWxpZFJlZ0V4cCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA8PSAweEZGRkYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFzdHJhbFN1YnN0aXR1dGU7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIGVhY2ggcGFpcmVkIHN1cnJvZ2F0ZSB3aXRoIGEgc2luZ2xlIEFTQ0lJIHN5bWJvbCB0b1xuICAgICAgICAgICAgICAgIC8vIGF2b2lkIHRocm93aW5nIG9uIHJlZ3VsYXIgZXhwcmVzc2lvbnMgdGhhdCBhcmUgb25seSB2YWxpZCBpblxuICAgICAgICAgICAgICAgIC8vIGNvbWJpbmF0aW9uIHdpdGggdGhlIFwidVwiIGZsYWcuXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgIC9bXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdL2csXG4gICAgICAgICAgICAgICAgICAgIGFzdHJhbFN1YnN0aXR1dGVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmlyc3QsIGRldGVjdCBpbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbnMuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBSZWdFeHAodG1wKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obnVsbCwgTWVzc2FnZXMuSW52YWxpZFJlZ0V4cCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXR1cm4gYSByZWd1bGFyIGV4cHJlc3Npb24gb2JqZWN0IGZvciB0aGlzIHBhdHRlcm4tZmxhZyBwYWlyLCBvclxuICAgICAgICAvLyBgbnVsbGAgaW4gY2FzZSB0aGUgY3VycmVudCBlbnZpcm9ubWVudCBkb2Vzbid0IHN1cHBvcnQgdGhlIGZsYWdzIGl0XG4gICAgICAgIC8vIHVzZXMuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChwYXR0ZXJuLCBmbGFncyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NhblJlZ0V4cEJvZHkoKSB7XG4gICAgICAgIHZhciBjaCwgc3RyLCBjbGFzc01hcmtlciwgdGVybWluYXRlZCwgYm9keTtcblxuICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgIGFzc2VydChjaCA9PT0gJy8nLCAnUmVndWxhciBleHByZXNzaW9uIGxpdGVyYWwgbXVzdCBzdGFydCB3aXRoIGEgc2xhc2gnKTtcbiAgICAgICAgc3RyID0gc291cmNlW2luZGV4KytdO1xuXG4gICAgICAgIGNsYXNzTWFya2VyID0gZmFsc2U7XG4gICAgICAgIHRlcm1pbmF0ZWQgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgIHN0ciArPSBjaDtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICAgICAgLy8gRUNNQS0yNjIgNy44LjVcbiAgICAgICAgICAgICAgICBpZiAoaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbihudWxsLCBNZXNzYWdlcy5VbnRlcm1pbmF0ZWRSZWdFeHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbihudWxsLCBNZXNzYWdlcy5VbnRlcm1pbmF0ZWRSZWdFeHApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjbGFzc01hcmtlcikge1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ10nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTWFya2VyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICcvJykge1xuICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTWFya2VyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRlcm1pbmF0ZWQpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKG51bGwsIE1lc3NhZ2VzLlVudGVybWluYXRlZFJlZ0V4cCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFeGNsdWRlIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoLlxuICAgICAgICBib2R5ID0gc3RyLnN1YnN0cigxLCBzdHIubGVuZ3RoIC0gMik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogYm9keSxcbiAgICAgICAgICAgIGxpdGVyYWw6IHN0clxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjYW5SZWdFeHBGbGFncygpIHtcbiAgICAgICAgdmFyIGNoLCBzdHIsIGZsYWdzLCByZXN0b3JlO1xuXG4gICAgICAgIHN0ciA9ICcnO1xuICAgICAgICBmbGFncyA9ICcnO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgICAgIGlmICghaXNJZGVudGlmaWVyUGFydChjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgaWYgKGNoID09PSAnXFxcXCcgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAndScpIHtcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgcmVzdG9yZSA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICBjaCA9IHNjYW5IZXhFc2NhcGUoJ3UnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbGFncyArPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoc3RyICs9ICdcXFxcdSc7IHJlc3RvcmUgPCBpbmRleDsgKytyZXN0b3JlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IHNvdXJjZVtyZXN0b3JlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gcmVzdG9yZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYWdzICs9ICd1JztcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXHUnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcJztcbiAgICAgICAgICAgICAgICAgICAgdG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZsYWdzICs9IGNoO1xuICAgICAgICAgICAgICAgIHN0ciArPSBjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogZmxhZ3MsXG4gICAgICAgICAgICBsaXRlcmFsOiBzdHJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FuUmVnRXhwKCkge1xuICAgICAgICB2YXIgc3RhcnQsIGJvZHksIGZsYWdzLCB2YWx1ZTtcbiAgICAgICAgc2Nhbm5pbmcgPSB0cnVlO1xuXG4gICAgICAgIGxvb2thaGVhZCA9IG51bGw7XG4gICAgICAgIHNraXBDb21tZW50KCk7XG4gICAgICAgIHN0YXJ0ID0gaW5kZXg7XG5cbiAgICAgICAgYm9keSA9IHNjYW5SZWdFeHBCb2R5KCk7XG4gICAgICAgIGZsYWdzID0gc2NhblJlZ0V4cEZsYWdzKCk7XG4gICAgICAgIHZhbHVlID0gdGVzdFJlZ0V4cChib2R5LnZhbHVlLCBmbGFncy52YWx1ZSk7XG4gICAgICAgIHNjYW5uaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChleHRyYS50b2tlbml6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5SZWd1bGFyRXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgcmVnZXg6IHtcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybjogYm9keS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3M6IGZsYWdzLnZhbHVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxpdGVyYWw6IGJvZHkubGl0ZXJhbCArIGZsYWdzLmxpdGVyYWwsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICByZWdleDoge1xuICAgICAgICAgICAgICAgIHBhdHRlcm46IGJvZHkudmFsdWUsXG4gICAgICAgICAgICAgICAgZmxhZ3M6IGZsYWdzLnZhbHVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbGxlY3RSZWdleCgpIHtcbiAgICAgICAgdmFyIHBvcywgbG9jLCByZWdleCwgdG9rZW47XG5cbiAgICAgICAgc2tpcENvbW1lbnQoKTtcblxuICAgICAgICBwb3MgPSBpbmRleDtcbiAgICAgICAgbG9jID0ge1xuICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZWdleCA9IHNjYW5SZWdFeHAoKTtcblxuICAgICAgICBsb2MuZW5kID0ge1xuICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnRcbiAgICAgICAgfTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBpZiAoIWV4dHJhLnRva2VuaXplKSB7XG4gICAgICAgICAgICAvLyBQb3AgdGhlIHByZXZpb3VzIHRva2VuLCB3aGljaCBpcyBsaWtlbHkgJy8nIG9yICcvPSdcbiAgICAgICAgICAgIGlmIChleHRyYS50b2tlbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRva2VuID0gZXh0cmEudG9rZW5zW2V4dHJhLnRva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4ucmFuZ2VbMF0gPT09IHBvcyAmJiB0b2tlbi50eXBlID09PSAnUHVuY3R1YXRvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlID09PSAnLycgfHwgdG9rZW4udmFsdWUgPT09ICcvPScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhLnRva2Vucy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXh0cmEudG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdSZWd1bGFyRXhwcmVzc2lvbicsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHJlZ2V4LmxpdGVyYWwsXG4gICAgICAgICAgICAgICAgcmVnZXg6IHJlZ2V4LnJlZ2V4LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBbcG9zLCBpbmRleF0sXG4gICAgICAgICAgICAgICAgbG9jOiBsb2NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlZ2V4O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSWRlbnRpZmllck5hbWUodG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIHRva2VuLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIgfHxcbiAgICAgICAgICAgIHRva2VuLnR5cGUgPT09IFRva2VuLktleXdvcmQgfHxcbiAgICAgICAgICAgIHRva2VuLnR5cGUgPT09IFRva2VuLkJvb2xlYW5MaXRlcmFsIHx8XG4gICAgICAgICAgICB0b2tlbi50eXBlID09PSBUb2tlbi5OdWxsTGl0ZXJhbDtcbiAgICB9XG5cbiAgICAvLyBVc2luZyB0aGUgZm9sbG93aW5nIGFsZ29yaXRobTpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zd2VldC5qcy93aWtpL2Rlc2lnblxuXG4gICAgZnVuY3Rpb24gYWR2YW5jZVNsYXNoKCkge1xuICAgICAgICB2YXIgcmVnZXgsIHByZXZpb3VzLCBjaGVjaztcblxuICAgICAgICBmdW5jdGlvbiB0ZXN0S2V5d29yZCh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICYmICh2YWx1ZS5sZW5ndGggPiAxKSAmJiAodmFsdWVbMF0gPj0gJ2EnKSAmJiAodmFsdWVbMF0gPD0gJ3onKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZpb3VzID0gZXh0cmEudG9rZW5WYWx1ZXNbZXh0cmEudG9rZW5WYWx1ZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIHJlZ2V4ID0gKHByZXZpb3VzICE9PSBudWxsKTtcblxuICAgICAgICBzd2l0Y2ggKHByZXZpb3VzKSB7XG4gICAgICAgIGNhc2UgJ3RoaXMnOlxuICAgICAgICBjYXNlICddJzpcbiAgICAgICAgICAgIHJlZ2V4ID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICcpJzpcbiAgICAgICAgICAgIGNoZWNrID0gZXh0cmEudG9rZW5WYWx1ZXNbZXh0cmEub3BlblBhcmVuVG9rZW4gLSAxXTtcbiAgICAgICAgICAgIHJlZ2V4ID0gKGNoZWNrID09PSAnaWYnIHx8IGNoZWNrID09PSAnd2hpbGUnIHx8IGNoZWNrID09PSAnZm9yJyB8fCBjaGVjayA9PT0gJ3dpdGgnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ30nOlxuICAgICAgICAgICAgLy8gRGl2aWRpbmcgYSBmdW5jdGlvbiBieSBhbnl0aGluZyBtYWtlcyBsaXR0bGUgc2Vuc2UsXG4gICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSB0byBjaGVjayBmb3IgdGhhdC5cbiAgICAgICAgICAgIHJlZ2V4ID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGVzdEtleXdvcmQoZXh0cmEudG9rZW5WYWx1ZXNbZXh0cmEub3BlbkN1cmx5VG9rZW4gLSAzXSkpIHtcbiAgICAgICAgICAgICAgICAvLyBBbm9ueW1vdXMgZnVuY3Rpb24sIGUuZy4gZnVuY3Rpb24oKXt9IC80MlxuICAgICAgICAgICAgICAgIGNoZWNrID0gZXh0cmEudG9rZW5WYWx1ZXNbZXh0cmEub3BlbkN1cmx5VG9rZW4gLSA0XTtcbiAgICAgICAgICAgICAgICByZWdleCA9IGNoZWNrID8gKEZuRXhwclRva2Vucy5pbmRleE9mKGNoZWNrKSA8IDApIDogZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRlc3RLZXl3b3JkKGV4dHJhLnRva2VuVmFsdWVzW2V4dHJhLm9wZW5DdXJseVRva2VuIC0gNF0pKSB7XG4gICAgICAgICAgICAgICAgLy8gTmFtZWQgZnVuY3Rpb24sIGUuZy4gZnVuY3Rpb24gZigpe30gLzQyL1xuICAgICAgICAgICAgICAgIGNoZWNrID0gZXh0cmEudG9rZW5WYWx1ZXNbZXh0cmEub3BlbkN1cmx5VG9rZW4gLSA1XTtcbiAgICAgICAgICAgICAgICByZWdleCA9IGNoZWNrID8gKEZuRXhwclRva2Vucy5pbmRleE9mKGNoZWNrKSA8IDApIDogdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWdleCA/IGNvbGxlY3RSZWdleCgpIDogc2NhblB1bmN0dWF0b3IoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZHZhbmNlKCkge1xuICAgICAgICB2YXIgY3AsIHRva2VuO1xuXG4gICAgICAgIGlmIChpbmRleCA+PSBsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogVG9rZW4uRU9GLFxuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgICAgc3RhcnQ6IGluZGV4LFxuICAgICAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBjcCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcblxuICAgICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoY3ApKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHNjYW5JZGVudGlmaWVyKCk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0b2tlbi50eXBlID0gVG9rZW4uS2V5d29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZlcnkgY29tbW9uOiAoIGFuZCApIGFuZCA7XG4gICAgICAgIGlmIChjcCA9PT0gMHgyOCB8fCBjcCA9PT0gMHgyOSB8fCBjcCA9PT0gMHgzQikge1xuICAgICAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdHJpbmcgbGl0ZXJhbCBzdGFydHMgd2l0aCBzaW5nbGUgcXVvdGUgKFUrMDAyNykgb3IgZG91YmxlIHF1b3RlIChVKzAwMjIpLlxuICAgICAgICBpZiAoY3AgPT09IDB4MjcgfHwgY3AgPT09IDB4MjIpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2FuU3RyaW5nTGl0ZXJhbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG90ICguKSBVKzAwMkUgY2FuIGFsc28gc3RhcnQgYSBmbG9hdGluZy1wb2ludCBudW1iZXIsIGhlbmNlIHRoZSBuZWVkXG4gICAgICAgIC8vIHRvIGNoZWNrIHRoZSBuZXh0IGNoYXJhY3Rlci5cbiAgICAgICAgaWYgKGNwID09PSAweDJFKSB7XG4gICAgICAgICAgICBpZiAoaXNEZWNpbWFsRGlnaXQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXggKyAxKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2Nhbk51bWVyaWNMaXRlcmFsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlY2ltYWxEaWdpdChjcCkpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2FuTnVtZXJpY0xpdGVyYWwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNsYXNoICgvKSBVKzAwMkYgY2FuIGFsc28gc3RhcnQgYSByZWdleC5cbiAgICAgICAgaWYgKGV4dHJhLnRva2VuaXplICYmIGNwID09PSAweDJGKSB7XG4gICAgICAgICAgICByZXR1cm4gYWR2YW5jZVNsYXNoKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUZW1wbGF0ZSBsaXRlcmFscyBzdGFydCB3aXRoIGAgKFUrMDA2MCkgZm9yIHRlbXBsYXRlIGhlYWRcbiAgICAgICAgLy8gb3IgfSAoVSswMDdEKSBmb3IgdGVtcGxhdGUgbWlkZGxlIG9yIHRlbXBsYXRlIHRhaWwuXG4gICAgICAgIGlmIChjcCA9PT0gMHg2MCB8fCAoY3AgPT09IDB4N0QgJiYgc3RhdGUuY3VybHlTdGFja1tzdGF0ZS5jdXJseVN0YWNrLmxlbmd0aCAtIDFdID09PSAnJHsnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNjYW5UZW1wbGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUG9zc2libGUgaWRlbnRpZmllciBzdGFydCBpbiBhIHN1cnJvZ2F0ZSBwYWlyLlxuICAgICAgICBpZiAoY3AgPj0gMHhEODAwICYmIGNwIDwgMHhERkZGKSB7XG4gICAgICAgICAgICBjcCA9IGNvZGVQb2ludEF0KGluZGV4KTtcbiAgICAgICAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChjcCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NhbklkZW50aWZpZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbGxlY3RUb2tlbigpIHtcbiAgICAgICAgdmFyIGxvYywgdG9rZW4sIHZhbHVlLCBlbnRyeTtcblxuICAgICAgICBsb2MgPSB7XG4gICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRva2VuID0gYWR2YW5jZSgpO1xuICAgICAgICBsb2MuZW5kID0ge1xuICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnRcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gVG9rZW4uRU9GKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHNvdXJjZS5zbGljZSh0b2tlbi5zdGFydCwgdG9rZW4uZW5kKTtcbiAgICAgICAgICAgIGVudHJ5ID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFRva2VuTmFtZVt0b2tlbi50eXBlXSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IFt0b2tlbi5zdGFydCwgdG9rZW4uZW5kXSxcbiAgICAgICAgICAgICAgICBsb2M6IGxvY1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0b2tlbi5yZWdleCkge1xuICAgICAgICAgICAgICAgIGVudHJ5LnJlZ2V4ID0ge1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuOiB0b2tlbi5yZWdleC5wYXR0ZXJuLFxuICAgICAgICAgICAgICAgICAgICBmbGFnczogdG9rZW4ucmVnZXguZmxhZ3NcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4dHJhLnRva2VuVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgZXh0cmEudG9rZW5WYWx1ZXMucHVzaCgoZW50cnkudHlwZSA9PT0gJ1B1bmN0dWF0b3InIHx8IGVudHJ5LnR5cGUgPT09ICdLZXl3b3JkJykgPyBlbnRyeS52YWx1ZSA6IG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4dHJhLnRva2VuaXplKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFleHRyYS5yYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZW50cnkucmFuZ2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZXh0cmEubG9jKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBlbnRyeS5sb2M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChleHRyYS5kZWxlZ2F0ZSkge1xuICAgICAgICAgICAgICAgICAgICBlbnRyeSA9IGV4dHJhLmRlbGVnYXRlKGVudHJ5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHRyYS50b2tlbnMucHVzaChlbnRyeSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGV4KCkge1xuICAgICAgICB2YXIgdG9rZW47XG4gICAgICAgIHNjYW5uaW5nID0gdHJ1ZTtcblxuICAgICAgICBsYXN0SW5kZXggPSBpbmRleDtcbiAgICAgICAgbGFzdExpbmVOdW1iZXIgPSBsaW5lTnVtYmVyO1xuICAgICAgICBsYXN0TGluZVN0YXJ0ID0gbGluZVN0YXJ0O1xuXG4gICAgICAgIHNraXBDb21tZW50KCk7XG5cbiAgICAgICAgdG9rZW4gPSBsb29rYWhlYWQ7XG5cbiAgICAgICAgc3RhcnRJbmRleCA9IGluZGV4O1xuICAgICAgICBzdGFydExpbmVOdW1iZXIgPSBsaW5lTnVtYmVyO1xuICAgICAgICBzdGFydExpbmVTdGFydCA9IGxpbmVTdGFydDtcblxuICAgICAgICBsb29rYWhlYWQgPSAodHlwZW9mIGV4dHJhLnRva2VucyAhPT0gJ3VuZGVmaW5lZCcpID8gY29sbGVjdFRva2VuKCkgOiBhZHZhbmNlKCk7XG4gICAgICAgIHNjYW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWVrKCkge1xuICAgICAgICBzY2FubmluZyA9IHRydWU7XG5cbiAgICAgICAgc2tpcENvbW1lbnQoKTtcblxuICAgICAgICBsYXN0SW5kZXggPSBpbmRleDtcbiAgICAgICAgbGFzdExpbmVOdW1iZXIgPSBsaW5lTnVtYmVyO1xuICAgICAgICBsYXN0TGluZVN0YXJ0ID0gbGluZVN0YXJ0O1xuXG4gICAgICAgIHN0YXJ0SW5kZXggPSBpbmRleDtcbiAgICAgICAgc3RhcnRMaW5lTnVtYmVyID0gbGluZU51bWJlcjtcbiAgICAgICAgc3RhcnRMaW5lU3RhcnQgPSBsaW5lU3RhcnQ7XG5cbiAgICAgICAgbG9va2FoZWFkID0gKHR5cGVvZiBleHRyYS50b2tlbnMgIT09ICd1bmRlZmluZWQnKSA/IGNvbGxlY3RUb2tlbigpIDogYWR2YW5jZSgpO1xuICAgICAgICBzY2FubmluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFBvc2l0aW9uKCkge1xuICAgICAgICB0aGlzLmxpbmUgPSBzdGFydExpbmVOdW1iZXI7XG4gICAgICAgIHRoaXMuY29sdW1uID0gc3RhcnRJbmRleCAtIHN0YXJ0TGluZVN0YXJ0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFNvdXJjZUxvY2F0aW9uKCkge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gbmV3IFBvc2l0aW9uKCk7XG4gICAgICAgIHRoaXMuZW5kID0gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBXcmFwcGluZ1NvdXJjZUxvY2F0aW9uKHN0YXJ0VG9rZW4pIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHtcbiAgICAgICAgICAgIGxpbmU6IHN0YXJ0VG9rZW4ubGluZU51bWJlcixcbiAgICAgICAgICAgIGNvbHVtbjogc3RhcnRUb2tlbi5zdGFydCAtIHN0YXJ0VG9rZW4ubGluZVN0YXJ0XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZW5kID0gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBOb2RlKCkge1xuICAgICAgICBpZiAoZXh0cmEucmFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMucmFuZ2UgPSBbc3RhcnRJbmRleCwgMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4dHJhLmxvYykge1xuICAgICAgICAgICAgdGhpcy5sb2MgPSBuZXcgU291cmNlTG9jYXRpb24oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIFdyYXBwaW5nTm9kZShzdGFydFRva2VuKSB7XG4gICAgICAgIGlmIChleHRyYS5yYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5yYW5nZSA9IFtzdGFydFRva2VuLnN0YXJ0LCAwXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXh0cmEubG9jKSB7XG4gICAgICAgICAgICB0aGlzLmxvYyA9IG5ldyBXcmFwcGluZ1NvdXJjZUxvY2F0aW9uKHN0YXJ0VG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgV3JhcHBpbmdOb2RlLnByb3RvdHlwZSA9IE5vZGUucHJvdG90eXBlID0ge1xuXG4gICAgICAgIHByb2Nlc3NDb21tZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbGFzdENoaWxkLFxuICAgICAgICAgICAgICAgIGlubmVyQ29tbWVudHMsXG4gICAgICAgICAgICAgICAgbGVhZGluZ0NvbW1lbnRzLFxuICAgICAgICAgICAgICAgIHRyYWlsaW5nQ29tbWVudHMsXG4gICAgICAgICAgICAgICAgYm90dG9tUmlnaHQgPSBleHRyYS5ib3R0b21SaWdodFN0YWNrLFxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgY29tbWVudCxcbiAgICAgICAgICAgICAgICBsYXN0ID0gYm90dG9tUmlnaHRbYm90dG9tUmlnaHQubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IFN5bnRheC5Qcm9ncmFtKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYm9keS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHBhdGNoIGlubm5lckNvbW1lbnRzIGZvciBwcm9wZXJ0aWVzIGVtcHR5IGJsb2NrXG4gICAgICAgICAgICAgKiBgZnVuY3Rpb24gYSgpIHsvKiogY29tbWVudHMgKipcXC99YFxuICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IFN5bnRheC5CbG9ja1N0YXRlbWVudCAmJiB0aGlzLmJvZHkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaW5uZXJDb21tZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IGV4dHJhLmxlYWRpbmdDb21tZW50cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0gZXh0cmEubGVhZGluZ0NvbW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yYW5nZVsxXSA+PSBjb21tZW50LnJhbmdlWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbm5lckNvbW1lbnRzLnVuc2hpZnQoY29tbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYS5sZWFkaW5nQ29tbWVudHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmEudHJhaWxpbmdDb21tZW50cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyQ29tbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5uZXJDb21tZW50cyA9IGlubmVyQ29tbWVudHM7XG4gICAgICAgICAgICAgICAgICAgIC8vYm90dG9tUmlnaHQucHVzaCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGV4dHJhLnRyYWlsaW5nQ29tbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRyYWlsaW5nQ29tbWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBleHRyYS50cmFpbGluZ0NvbW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBleHRyYS50cmFpbGluZ0NvbW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWVudC5yYW5nZVswXSA+PSB0aGlzLnJhbmdlWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFpbGluZ0NvbW1lbnRzLnVuc2hpZnQoY29tbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYS50cmFpbGluZ0NvbW1lbnRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleHRyYS50cmFpbGluZ0NvbW1lbnRzID0gW107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0ICYmIGxhc3QudHJhaWxpbmdDb21tZW50cyAmJiBsYXN0LnRyYWlsaW5nQ29tbWVudHNbMF0ucmFuZ2VbMF0gPj0gdGhpcy5yYW5nZVsxXSkge1xuICAgICAgICAgICAgICAgICAgICB0cmFpbGluZ0NvbW1lbnRzID0gbGFzdC50cmFpbGluZ0NvbW1lbnRzO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbGFzdC50cmFpbGluZ0NvbW1lbnRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRWF0aW5nIHRoZSBzdGFjay5cbiAgICAgICAgICAgIHdoaWxlIChsYXN0ICYmIGxhc3QucmFuZ2VbMF0gPj0gdGhpcy5yYW5nZVswXSkge1xuICAgICAgICAgICAgICAgIGxhc3RDaGlsZCA9IGJvdHRvbVJpZ2h0LnBvcCgpO1xuICAgICAgICAgICAgICAgIGxhc3QgPSBib3R0b21SaWdodFtib3R0b21SaWdodC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxhc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0Q2hpbGQubGVhZGluZ0NvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlYWRpbmdDb21tZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBsYXN0Q2hpbGQubGVhZGluZ0NvbW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0gbGFzdENoaWxkLmxlYWRpbmdDb21tZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21tZW50LnJhbmdlWzFdIDw9IHRoaXMucmFuZ2VbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWFkaW5nQ29tbWVudHMudW5zaGlmdChjb21tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0Q2hpbGQubGVhZGluZ0NvbW1lbnRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghbGFzdENoaWxkLmxlYWRpbmdDb21tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RDaGlsZC5sZWFkaW5nQ29tbWVudHMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV4dHJhLmxlYWRpbmdDb21tZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGVhZGluZ0NvbW1lbnRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChpID0gZXh0cmEubGVhZGluZ0NvbW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBleHRyYS5sZWFkaW5nQ29tbWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21tZW50LnJhbmdlWzFdIDw9IHRoaXMucmFuZ2VbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlYWRpbmdDb21tZW50cy51bnNoaWZ0KGNvbW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmEubGVhZGluZ0NvbW1lbnRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICBpZiAobGVhZGluZ0NvbW1lbnRzICYmIGxlYWRpbmdDb21tZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZWFkaW5nQ29tbWVudHMgPSBsZWFkaW5nQ29tbWVudHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJhaWxpbmdDb21tZW50cyAmJiB0cmFpbGluZ0NvbW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWlsaW5nQ29tbWVudHMgPSB0cmFpbGluZ0NvbW1lbnRzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBib3R0b21SaWdodC5wdXNoKHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGV4dHJhLnJhbmdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yYW5nZVsxXSA9IGxhc3RJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHRyYS5sb2MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYy5lbmQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IGxhc3RMaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGxhc3RJbmRleCAtIGxhc3RMaW5lU3RhcnRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChleHRyYS5zb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2Muc291cmNlID0gZXh0cmEuc291cmNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGV4dHJhLmF0dGFjaENvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NDb21tZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoQXJyYXlFeHByZXNzaW9uOiBmdW5jdGlvbiAoZWxlbWVudHMpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5BcnJheUV4cHJlc3Npb247XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoQXJyYXlQYXR0ZXJuOiBmdW5jdGlvbiAoZWxlbWVudHMpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5BcnJheVBhdHRlcm47XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoQXJyb3dGdW5jdGlvbkV4cHJlc3Npb246IGZ1bmN0aW9uIChwYXJhbXMsIGRlZmF1bHRzLCBib2R5LCBleHByZXNzaW9uKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguQXJyb3dGdW5jdGlvbkV4cHJlc3Npb247XG4gICAgICAgICAgICB0aGlzLmlkID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuICAgICAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdG9yID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaEFzc2lnbm1lbnRFeHByZXNzaW9uOiBmdW5jdGlvbiAob3BlcmF0b3IsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb247XG4gICAgICAgICAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaEFzc2lnbm1lbnRQYXR0ZXJuOiBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5Bc3NpZ25tZW50UGF0dGVybjtcbiAgICAgICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoQmluYXJ5RXhwcmVzc2lvbjogZnVuY3Rpb24gKG9wZXJhdG9yLCBsZWZ0LCByaWdodCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gKG9wZXJhdG9yID09PSAnfHwnIHx8IG9wZXJhdG9yID09PSAnJiYnKSA/IFN5bnRheC5Mb2dpY2FsRXhwcmVzc2lvbiA6IFN5bnRheC5CaW5hcnlFeHByZXNzaW9uO1xuICAgICAgICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAgICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hCbG9ja1N0YXRlbWVudDogZnVuY3Rpb24gKGJvZHkpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5CbG9ja1N0YXRlbWVudDtcbiAgICAgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoQnJlYWtTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChsYWJlbCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkJyZWFrU3RhdGVtZW50O1xuICAgICAgICAgICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaENhbGxFeHByZXNzaW9uOiBmdW5jdGlvbiAoY2FsbGVlLCBhcmdzKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguQ2FsbEV4cHJlc3Npb247XG4gICAgICAgICAgICB0aGlzLmNhbGxlZSA9IGNhbGxlZTtcbiAgICAgICAgICAgIHRoaXMuYXJndW1lbnRzID0gYXJncztcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hDYXRjaENsYXVzZTogZnVuY3Rpb24gKHBhcmFtLCBib2R5KSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguQ2F0Y2hDbGF1c2U7XG4gICAgICAgICAgICB0aGlzLnBhcmFtID0gcGFyYW07XG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaENsYXNzQm9keTogZnVuY3Rpb24gKGJvZHkpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5DbGFzc0JvZHk7XG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaENsYXNzRGVjbGFyYXRpb246IGZ1bmN0aW9uIChpZCwgc3VwZXJDbGFzcywgYm9keSkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkNsYXNzRGVjbGFyYXRpb247XG4gICAgICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgICAgICB0aGlzLnN1cGVyQ2xhc3MgPSBzdXBlckNsYXNzO1xuICAgICAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hDbGFzc0V4cHJlc3Npb246IGZ1bmN0aW9uIChpZCwgc3VwZXJDbGFzcywgYm9keSkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkNsYXNzRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgICAgIHRoaXMuc3VwZXJDbGFzcyA9IHN1cGVyQ2xhc3M7XG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaENvbmRpdGlvbmFsRXhwcmVzc2lvbjogZnVuY3Rpb24gKHRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkNvbmRpdGlvbmFsRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHRoaXMudGVzdCA9IHRlc3Q7XG4gICAgICAgICAgICB0aGlzLmNvbnNlcXVlbnQgPSBjb25zZXF1ZW50O1xuICAgICAgICAgICAgdGhpcy5hbHRlcm5hdGUgPSBhbHRlcm5hdGU7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoQ29udGludWVTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChsYWJlbCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkNvbnRpbnVlU3RhdGVtZW50O1xuICAgICAgICAgICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaERlYnVnZ2VyU3RhdGVtZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguRGVidWdnZXJTdGF0ZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoRG9XaGlsZVN0YXRlbWVudDogZnVuY3Rpb24gKGJvZHksIHRlc3QpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5Eb1doaWxlU3RhdGVtZW50O1xuICAgICAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgIHRoaXMudGVzdCA9IHRlc3Q7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoRW1wdHlTdGF0ZW1lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5FbXB0eVN0YXRlbWVudDtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hFeHByZXNzaW9uU3RhdGVtZW50OiBmdW5jdGlvbiAoZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkV4cHJlc3Npb25TdGF0ZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaEZvclN0YXRlbWVudDogZnVuY3Rpb24gKGluaXQsIHRlc3QsIHVwZGF0ZSwgYm9keSkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkZvclN0YXRlbWVudDtcbiAgICAgICAgICAgIHRoaXMuaW5pdCA9IGluaXQ7XG4gICAgICAgICAgICB0aGlzLnRlc3QgPSB0ZXN0O1xuICAgICAgICAgICAgdGhpcy51cGRhdGUgPSB1cGRhdGU7XG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaEZvck9mU3RhdGVtZW50OiBmdW5jdGlvbiAobGVmdCwgcmlnaHQsIGJvZHkpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5Gb3JPZlN0YXRlbWVudDtcbiAgICAgICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaEZvckluU3RhdGVtZW50OiBmdW5jdGlvbiAobGVmdCwgcmlnaHQsIGJvZHkpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5Gb3JJblN0YXRlbWVudDtcbiAgICAgICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy5lYWNoID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoRnVuY3Rpb25EZWNsYXJhdGlvbjogZnVuY3Rpb24gKGlkLCBwYXJhbXMsIGRlZmF1bHRzLCBib2R5LCBnZW5lcmF0b3IpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5GdW5jdGlvbkRlY2xhcmF0aW9uO1xuICAgICAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy5nZW5lcmF0b3IgPSBnZW5lcmF0b3I7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hGdW5jdGlvbkV4cHJlc3Npb246IGZ1bmN0aW9uIChpZCwgcGFyYW1zLCBkZWZhdWx0cywgYm9keSwgZ2VuZXJhdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguRnVuY3Rpb25FeHByZXNzaW9uO1xuICAgICAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy5nZW5lcmF0b3IgPSBnZW5lcmF0b3I7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hJZGVudGlmaWVyOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LklkZW50aWZpZXI7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaElmU3RhdGVtZW50OiBmdW5jdGlvbiAodGVzdCwgY29uc2VxdWVudCwgYWx0ZXJuYXRlKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguSWZTdGF0ZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLnRlc3QgPSB0ZXN0O1xuICAgICAgICAgICAgdGhpcy5jb25zZXF1ZW50ID0gY29uc2VxdWVudDtcbiAgICAgICAgICAgIHRoaXMuYWx0ZXJuYXRlID0gYWx0ZXJuYXRlO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaExhYmVsZWRTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChsYWJlbCwgYm9keSkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkxhYmVsZWRTdGF0ZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaExpdGVyYWw6IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkxpdGVyYWw7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdG9rZW4udmFsdWU7XG4gICAgICAgICAgICB0aGlzLnJhdyA9IHNvdXJjZS5zbGljZSh0b2tlbi5zdGFydCwgdG9rZW4uZW5kKTtcbiAgICAgICAgICAgIGlmICh0b2tlbi5yZWdleCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVnZXggPSB0b2tlbi5yZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hNZW1iZXJFeHByZXNzaW9uOiBmdW5jdGlvbiAoYWNjZXNzb3IsIG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uO1xuICAgICAgICAgICAgdGhpcy5jb21wdXRlZCA9IGFjY2Vzc29yID09PSAnWyc7XG4gICAgICAgICAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hNZXRhUHJvcGVydHk6IGZ1bmN0aW9uIChtZXRhLCBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4Lk1ldGFQcm9wZXJ0eTtcbiAgICAgICAgICAgIHRoaXMubWV0YSA9IG1ldGE7XG4gICAgICAgICAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoTmV3RXhwcmVzc2lvbjogZnVuY3Rpb24gKGNhbGxlZSwgYXJncykge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4Lk5ld0V4cHJlc3Npb247XG4gICAgICAgICAgICB0aGlzLmNhbGxlZSA9IGNhbGxlZTtcbiAgICAgICAgICAgIHRoaXMuYXJndW1lbnRzID0gYXJncztcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hPYmplY3RFeHByZXNzaW9uOiBmdW5jdGlvbiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4Lk9iamVjdEV4cHJlc3Npb247XG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaE9iamVjdFBhdHRlcm46IGZ1bmN0aW9uIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguT2JqZWN0UGF0dGVybjtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcyA9IHByb3BlcnRpZXM7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoUG9zdGZpeEV4cHJlc3Npb246IGZ1bmN0aW9uIChvcGVyYXRvciwgYXJndW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5VcGRhdGVFeHByZXNzaW9uO1xuICAgICAgICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICAgICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xuICAgICAgICAgICAgdGhpcy5wcmVmaXggPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hQcm9ncmFtOiBmdW5jdGlvbiAoYm9keSwgc291cmNlVHlwZSkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LlByb2dyYW07XG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy5zb3VyY2VUeXBlID0gc291cmNlVHlwZTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hQcm9wZXJ0eTogZnVuY3Rpb24gKGtpbmQsIGtleSwgY29tcHV0ZWQsIHZhbHVlLCBtZXRob2QsIHNob3J0aGFuZCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LlByb3BlcnR5O1xuICAgICAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgICAgICB0aGlzLmNvbXB1dGVkID0gY29tcHV0ZWQ7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmtpbmQgPSBraW5kO1xuICAgICAgICAgICAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gICAgICAgICAgICB0aGlzLnNob3J0aGFuZCA9IHNob3J0aGFuZDtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hSZXN0RWxlbWVudDogZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguUmVzdEVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoUmV0dXJuU3RhdGVtZW50OiBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5SZXR1cm5TdGF0ZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoU2VxdWVuY2VFeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5TZXF1ZW5jZUV4cHJlc3Npb247XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoU3ByZWFkRWxlbWVudDogZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguU3ByZWFkRWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hTd2l0Y2hDYXNlOiBmdW5jdGlvbiAodGVzdCwgY29uc2VxdWVudCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LlN3aXRjaENhc2U7XG4gICAgICAgICAgICB0aGlzLnRlc3QgPSB0ZXN0O1xuICAgICAgICAgICAgdGhpcy5jb25zZXF1ZW50ID0gY29uc2VxdWVudDtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hTdXBlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LlN1cGVyO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaFN3aXRjaFN0YXRlbWVudDogZnVuY3Rpb24gKGRpc2NyaW1pbmFudCwgY2FzZXMpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5Td2l0Y2hTdGF0ZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmRpc2NyaW1pbmFudCA9IGRpc2NyaW1pbmFudDtcbiAgICAgICAgICAgIHRoaXMuY2FzZXMgPSBjYXNlcztcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb246IGZ1bmN0aW9uICh0YWcsIHF1YXNpKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uO1xuICAgICAgICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgICAgICAgICB0aGlzLnF1YXNpID0gcXVhc2k7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoVGVtcGxhdGVFbGVtZW50OiBmdW5jdGlvbiAodmFsdWUsIHRhaWwpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5UZW1wbGF0ZUVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnRhaWwgPSB0YWlsO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaFRlbXBsYXRlTGl0ZXJhbDogZnVuY3Rpb24gKHF1YXNpcywgZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5UZW1wbGF0ZUxpdGVyYWw7XG4gICAgICAgICAgICB0aGlzLnF1YXNpcyA9IHF1YXNpcztcbiAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbnMgPSBleHByZXNzaW9ucztcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hUaGlzRXhwcmVzc2lvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LlRoaXNFeHByZXNzaW9uO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaFRocm93U3RhdGVtZW50OiBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5UaHJvd1N0YXRlbWVudDtcbiAgICAgICAgICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hUcnlTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChibG9jaywgaGFuZGxlciwgZmluYWxpemVyKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguVHJ5U3RhdGVtZW50O1xuICAgICAgICAgICAgdGhpcy5ibG9jayA9IGJsb2NrO1xuICAgICAgICAgICAgdGhpcy5ndWFyZGVkSGFuZGxlcnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlcnMgPSBoYW5kbGVyID8gW2hhbmRsZXJdIDogW107XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuICAgICAgICAgICAgdGhpcy5maW5hbGl6ZXIgPSBmaW5hbGl6ZXI7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoVW5hcnlFeHByZXNzaW9uOiBmdW5jdGlvbiAob3BlcmF0b3IsIGFyZ3VtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSAob3BlcmF0b3IgPT09ICcrKycgfHwgb3BlcmF0b3IgPT09ICctLScpID8gU3ludGF4LlVwZGF0ZUV4cHJlc3Npb24gOiBTeW50YXguVW5hcnlFeHByZXNzaW9uO1xuICAgICAgICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICAgICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xuICAgICAgICAgICAgdGhpcy5wcmVmaXggPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaFZhcmlhYmxlRGVjbGFyYXRpb246IGZ1bmN0aW9uIChkZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0aW9uO1xuICAgICAgICAgICAgdGhpcy5kZWNsYXJhdGlvbnMgPSBkZWNsYXJhdGlvbnM7XG4gICAgICAgICAgICB0aGlzLmtpbmQgPSAndmFyJztcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hMZXhpY2FsRGVjbGFyYXRpb246IGZ1bmN0aW9uIChkZWNsYXJhdGlvbnMsIGtpbmQpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0aW9uO1xuICAgICAgICAgICAgdGhpcy5kZWNsYXJhdGlvbnMgPSBkZWNsYXJhdGlvbnM7XG4gICAgICAgICAgICB0aGlzLmtpbmQgPSBraW5kO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaFZhcmlhYmxlRGVjbGFyYXRvcjogZnVuY3Rpb24gKGlkLCBpbml0KSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguVmFyaWFibGVEZWNsYXJhdG9yO1xuICAgICAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICAgICAgdGhpcy5pbml0ID0gaW5pdDtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hXaGlsZVN0YXRlbWVudDogZnVuY3Rpb24gKHRlc3QsIGJvZHkpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5XaGlsZVN0YXRlbWVudDtcbiAgICAgICAgICAgIHRoaXMudGVzdCA9IHRlc3Q7XG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaFdpdGhTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChvYmplY3QsIGJvZHkpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5XaXRoU3RhdGVtZW50O1xuICAgICAgICAgICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaEV4cG9ydFNwZWNpZmllcjogZnVuY3Rpb24gKGxvY2FsLCBleHBvcnRlZCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkV4cG9ydFNwZWNpZmllcjtcbiAgICAgICAgICAgIHRoaXMuZXhwb3J0ZWQgPSBleHBvcnRlZCB8fCBsb2NhbDtcbiAgICAgICAgICAgIHRoaXMubG9jYWwgPSBsb2NhbDtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hJbXBvcnREZWZhdWx0U3BlY2lmaWVyOiBmdW5jdGlvbiAobG9jYWwpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5JbXBvcnREZWZhdWx0U3BlY2lmaWVyO1xuICAgICAgICAgICAgdGhpcy5sb2NhbCA9IGxvY2FsO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaEltcG9ydE5hbWVzcGFjZVNwZWNpZmllcjogZnVuY3Rpb24gKGxvY2FsKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyO1xuICAgICAgICAgICAgdGhpcy5sb2NhbCA9IGxvY2FsO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaEV4cG9ydE5hbWVkRGVjbGFyYXRpb246IGZ1bmN0aW9uIChkZWNsYXJhdGlvbiwgc3BlY2lmaWVycywgc3JjKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguRXhwb3J0TmFtZWREZWNsYXJhdGlvbjtcbiAgICAgICAgICAgIHRoaXMuZGVjbGFyYXRpb24gPSBkZWNsYXJhdGlvbjtcbiAgICAgICAgICAgIHRoaXMuc3BlY2lmaWVycyA9IHNwZWNpZmllcnM7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZSA9IHNyYztcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hFeHBvcnREZWZhdWx0RGVjbGFyYXRpb246IGZ1bmN0aW9uIChkZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkV4cG9ydERlZmF1bHREZWNsYXJhdGlvbjtcbiAgICAgICAgICAgIHRoaXMuZGVjbGFyYXRpb24gPSBkZWNsYXJhdGlvbjtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hFeHBvcnRBbGxEZWNsYXJhdGlvbjogZnVuY3Rpb24gKHNyYykge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkV4cG9ydEFsbERlY2xhcmF0aW9uO1xuICAgICAgICAgICAgdGhpcy5zb3VyY2UgPSBzcmM7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoSW1wb3J0U3BlY2lmaWVyOiBmdW5jdGlvbiAobG9jYWwsIGltcG9ydGVkKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguSW1wb3J0U3BlY2lmaWVyO1xuICAgICAgICAgICAgdGhpcy5sb2NhbCA9IGxvY2FsIHx8IGltcG9ydGVkO1xuICAgICAgICAgICAgdGhpcy5pbXBvcnRlZCA9IGltcG9ydGVkO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaEltcG9ydERlY2xhcmF0aW9uOiBmdW5jdGlvbiAoc3BlY2lmaWVycywgc3JjKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguSW1wb3J0RGVjbGFyYXRpb247XG4gICAgICAgICAgICB0aGlzLnNwZWNpZmllcnMgPSBzcGVjaWZpZXJzO1xuICAgICAgICAgICAgdGhpcy5zb3VyY2UgPSBzcmM7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoWWllbGRFeHByZXNzaW9uOiBmdW5jdGlvbiAoYXJndW1lbnQsIGRlbGVnYXRlKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguWWllbGRFeHByZXNzaW9uO1xuICAgICAgICAgICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xuICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgZnVuY3Rpb24gcmVjb3JkRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgdmFyIGUsIGV4aXN0aW5nO1xuXG4gICAgICAgIGZvciAoZSA9IDA7IGUgPCBleHRyYS5lcnJvcnMubGVuZ3RoOyBlKyspIHtcbiAgICAgICAgICAgIGV4aXN0aW5nID0gZXh0cmEuZXJyb3JzW2VdO1xuICAgICAgICAgICAgLy8gUHJldmVudCBkdXBsaWNhdGVkIGVycm9yLlxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIGlmIChleGlzdGluZy5pbmRleCA9PT0gZXJyb3IuaW5kZXggJiYgZXhpc3RpbmcubWVzc2FnZSA9PT0gZXJyb3IubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4dHJhLmVycm9ycy5wdXNoKGVycm9yKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25zdHJ1Y3RFcnJvcihtc2csIGNvbHVtbikge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9IGNhdGNoIChiYXNlKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKE9iamVjdC5jcmVhdGUgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBPYmplY3QuY3JlYXRlKGJhc2UpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnJvciwgJ2NvbHVtbicsIHsgdmFsdWU6IGNvbHVtbiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUVycm9yKGxpbmUsIHBvcywgZGVzY3JpcHRpb24pIHtcbiAgICAgICAgdmFyIG1zZywgY29sdW1uLCBlcnJvcjtcblxuICAgICAgICBtc2cgPSAnTGluZSAnICsgbGluZSArICc6ICcgKyBkZXNjcmlwdGlvbjtcbiAgICAgICAgY29sdW1uID0gcG9zIC0gKHNjYW5uaW5nID8gbGluZVN0YXJ0IDogbGFzdExpbmVTdGFydCkgKyAxO1xuICAgICAgICBlcnJvciA9IGNvbnN0cnVjdEVycm9yKG1zZywgY29sdW1uKTtcbiAgICAgICAgZXJyb3IubGluZU51bWJlciA9IGxpbmU7XG4gICAgICAgIGVycm9yLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgICAgIGVycm9yLmluZGV4ID0gcG9zO1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxuXG4gICAgLy8gVGhyb3cgYW4gZXhjZXB0aW9uXG5cbiAgICBmdW5jdGlvbiB0aHJvd0Vycm9yKG1lc3NhZ2VGb3JtYXQpIHtcbiAgICAgICAgdmFyIGFyZ3MsIG1zZztcblxuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgbXNnID0gbWVzc2FnZUZvcm1hdC5yZXBsYWNlKC8lKFxcZCkvZyxcbiAgICAgICAgICAgIGZ1bmN0aW9uICh3aG9sZSwgaWR4KSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KGlkeCA8IGFyZ3MubGVuZ3RoLCAnTWVzc2FnZSByZWZlcmVuY2UgbXVzdCBiZSBpbiByYW5nZScpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmdzW2lkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3IobGFzdExpbmVOdW1iZXIsIGxhc3RJbmRleCwgbXNnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b2xlcmF0ZUVycm9yKG1lc3NhZ2VGb3JtYXQpIHtcbiAgICAgICAgdmFyIGFyZ3MsIG1zZywgZXJyb3I7XG5cbiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIG1zZyA9IG1lc3NhZ2VGb3JtYXQucmVwbGFjZSgvJShcXGQpL2csXG4gICAgICAgICAgICBmdW5jdGlvbiAod2hvbGUsIGlkeCkge1xuICAgICAgICAgICAgICAgIGFzc2VydChpZHggPCBhcmdzLmxlbmd0aCwgJ01lc3NhZ2UgcmVmZXJlbmNlIG11c3QgYmUgaW4gcmFuZ2UnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJnc1tpZHhdO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIGVycm9yID0gY3JlYXRlRXJyb3IobGluZU51bWJlciwgbGFzdEluZGV4LCBtc2cpO1xuICAgICAgICBpZiAoZXh0cmEuZXJyb3JzKSB7XG4gICAgICAgICAgICByZWNvcmRFcnJvcihlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRocm93IGFuIGV4Y2VwdGlvbiBiZWNhdXNlIG9mIHRoZSB0b2tlbi5cblxuICAgIGZ1bmN0aW9uIHVuZXhwZWN0ZWRUb2tlbkVycm9yKHRva2VuLCBtZXNzYWdlKSB7XG4gICAgICAgIHZhciB2YWx1ZSwgbXNnID0gbWVzc2FnZSB8fCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW47XG5cbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBtc2cgPSAodG9rZW4udHlwZSA9PT0gVG9rZW4uRU9GKSA/IE1lc3NhZ2VzLlVuZXhwZWN0ZWRFT1MgOlxuICAgICAgICAgICAgICAgICAgICAodG9rZW4udHlwZSA9PT0gVG9rZW4uSWRlbnRpZmllcikgPyBNZXNzYWdlcy5VbmV4cGVjdGVkSWRlbnRpZmllciA6XG4gICAgICAgICAgICAgICAgICAgICh0b2tlbi50eXBlID09PSBUb2tlbi5OdW1lcmljTGl0ZXJhbCkgPyBNZXNzYWdlcy5VbmV4cGVjdGVkTnVtYmVyIDpcbiAgICAgICAgICAgICAgICAgICAgKHRva2VuLnR5cGUgPT09IFRva2VuLlN0cmluZ0xpdGVyYWwpID8gTWVzc2FnZXMuVW5leHBlY3RlZFN0cmluZyA6XG4gICAgICAgICAgICAgICAgICAgICh0b2tlbi50eXBlID09PSBUb2tlbi5UZW1wbGF0ZSkgPyBNZXNzYWdlcy5VbmV4cGVjdGVkVGVtcGxhdGUgOlxuICAgICAgICAgICAgICAgICAgICBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW47XG5cbiAgICAgICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uS2V5d29yZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdXR1cmVSZXNlcnZlZFdvcmQodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtc2cgPSBNZXNzYWdlcy5VbmV4cGVjdGVkUmVzZXJ2ZWQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1zZyA9IE1lc3NhZ2VzLlN0cmljdFJlc2VydmVkV29yZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsdWUgPSAodG9rZW4udHlwZSA9PT0gVG9rZW4uVGVtcGxhdGUpID8gdG9rZW4udmFsdWUucmF3IDogdG9rZW4udmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICdJTExFR0FMJztcbiAgICAgICAgfVxuXG4gICAgICAgIG1zZyA9IG1zZy5yZXBsYWNlKCclMCcsIHZhbHVlKTtcblxuICAgICAgICByZXR1cm4gKHRva2VuICYmIHR5cGVvZiB0b2tlbi5saW5lTnVtYmVyID09PSAnbnVtYmVyJykgP1xuICAgICAgICAgICAgY3JlYXRlRXJyb3IodG9rZW4ubGluZU51bWJlciwgdG9rZW4uc3RhcnQsIG1zZykgOlxuICAgICAgICAgICAgY3JlYXRlRXJyb3Ioc2Nhbm5pbmcgPyBsaW5lTnVtYmVyIDogbGFzdExpbmVOdW1iZXIsIHNjYW5uaW5nID8gaW5kZXggOiBsYXN0SW5kZXgsIG1zZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhyb3cgdW5leHBlY3RlZFRva2VuRXJyb3IodG9rZW4sIG1lc3NhZ2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHVuZXhwZWN0ZWRUb2tlbkVycm9yKHRva2VuLCBtZXNzYWdlKTtcbiAgICAgICAgaWYgKGV4dHJhLmVycm9ycykge1xuICAgICAgICAgICAgcmVjb3JkRXJyb3IoZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFeHBlY3QgdGhlIG5leHQgdG9rZW4gdG8gbWF0Y2ggdGhlIHNwZWNpZmllZCBwdW5jdHVhdG9yLlxuICAgIC8vIElmIG5vdCwgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxuXG4gICAgZnVuY3Rpb24gZXhwZWN0KHZhbHVlKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IGxleCgpO1xuICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gVG9rZW4uUHVuY3R1YXRvciB8fCB0b2tlbi52YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBuYW1lIGV4cGVjdENvbW1hU2VwYXJhdG9yXG4gICAgICogQGRlc2NyaXB0aW9uIFF1aWV0bHkgZXhwZWN0IGEgY29tbWEgd2hlbiBpbiB0b2xlcmFudCBtb2RlLCBvdGhlcndpc2UgZGVsZWdhdGVzXG4gICAgICogdG8gPGNvZGU+ZXhwZWN0KHZhbHVlKTwvY29kZT5cbiAgICAgKiBAc2luY2UgMi4wXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXhwZWN0Q29tbWFTZXBhcmF0b3IoKSB7XG4gICAgICAgIHZhciB0b2tlbjtcblxuICAgICAgICBpZiAoZXh0cmEuZXJyb3JzKSB7XG4gICAgICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yICYmIHRva2VuLnZhbHVlID09PSAnLCcpIHtcbiAgICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uUHVuY3R1YXRvciAmJiB0b2tlbi52YWx1ZSA9PT0gJzsnKSB7XG4gICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgICAgdG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4cGVjdCgnLCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRXhwZWN0IHRoZSBuZXh0IHRva2VuIHRvIG1hdGNoIHRoZSBzcGVjaWZpZWQga2V5d29yZC5cbiAgICAvLyBJZiBub3QsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cblxuICAgIGZ1bmN0aW9uIGV4cGVjdEtleXdvcmQoa2V5d29yZCkge1xuICAgICAgICB2YXIgdG9rZW4gPSBsZXgoKTtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLktleXdvcmQgfHwgdG9rZW4udmFsdWUgIT09IGtleXdvcmQpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiB0cnVlIGlmIHRoZSBuZXh0IHRva2VuIG1hdGNoZXMgdGhlIHNwZWNpZmllZCBwdW5jdHVhdG9yLlxuXG4gICAgZnVuY3Rpb24gbWF0Y2godmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yICYmIGxvb2thaGVhZC52YWx1ZSA9PT0gdmFsdWU7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIG5leHQgdG9rZW4gbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIGtleXdvcmRcblxuICAgIGZ1bmN0aW9uIG1hdGNoS2V5d29yZChrZXl3b3JkKSB7XG4gICAgICAgIHJldHVybiBsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uS2V5d29yZCAmJiBsb29rYWhlYWQudmFsdWUgPT09IGtleXdvcmQ7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIG5leHQgdG9rZW4gbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIGNvbnRleHR1YWwga2V5d29yZFxuICAgIC8vICh3aGVyZSBhbiBpZGVudGlmaWVyIGlzIHNvbWV0aW1lcyBhIGtleXdvcmQgZGVwZW5kaW5nIG9uIHRoZSBjb250ZXh0KVxuXG4gICAgZnVuY3Rpb24gbWF0Y2hDb250ZXh0dWFsS2V5d29yZChrZXl3b3JkKSB7XG4gICAgICAgIHJldHVybiBsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uSWRlbnRpZmllciAmJiBsb29rYWhlYWQudmFsdWUgPT09IGtleXdvcmQ7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIG5leHQgdG9rZW4gaXMgYW4gYXNzaWdubWVudCBvcGVyYXRvclxuXG4gICAgZnVuY3Rpb24gbWF0Y2hBc3NpZ24oKSB7XG4gICAgICAgIHZhciBvcDtcblxuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuLlB1bmN0dWF0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBvcCA9IGxvb2thaGVhZC52YWx1ZTtcbiAgICAgICAgcmV0dXJuIG9wID09PSAnPScgfHxcbiAgICAgICAgICAgIG9wID09PSAnKj0nIHx8XG4gICAgICAgICAgICBvcCA9PT0gJy89JyB8fFxuICAgICAgICAgICAgb3AgPT09ICclPScgfHxcbiAgICAgICAgICAgIG9wID09PSAnKz0nIHx8XG4gICAgICAgICAgICBvcCA9PT0gJy09JyB8fFxuICAgICAgICAgICAgb3AgPT09ICc8PD0nIHx8XG4gICAgICAgICAgICBvcCA9PT0gJz4+PScgfHxcbiAgICAgICAgICAgIG9wID09PSAnPj4+PScgfHxcbiAgICAgICAgICAgIG9wID09PSAnJj0nIHx8XG4gICAgICAgICAgICBvcCA9PT0gJ149JyB8fFxuICAgICAgICAgICAgb3AgPT09ICd8PSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uc3VtZVNlbWljb2xvbigpIHtcbiAgICAgICAgLy8gQ2F0Y2ggdGhlIHZlcnkgY29tbW9uIGNhc2UgZmlyc3Q6IGltbWVkaWF0ZWx5IGEgc2VtaWNvbG9uIChVKzAwM0IpLlxuICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoc3RhcnRJbmRleCkgPT09IDB4M0IgfHwgbWF0Y2goJzsnKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzTGluZVRlcm1pbmF0b3IpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZJWE1FKGlrYXJpZW5hdG9yKTogdGhpcyBpcyBzZWVtaW5nbHkgYW4gaXNzdWUgaW4gdGhlIHByZXZpb3VzIGxvY2F0aW9uIGluZm8gY29udmVudGlvbi5cbiAgICAgICAgbGFzdEluZGV4ID0gc3RhcnRJbmRleDtcbiAgICAgICAgbGFzdExpbmVOdW1iZXIgPSBzdGFydExpbmVOdW1iZXI7XG4gICAgICAgIGxhc3RMaW5lU3RhcnQgPSBzdGFydExpbmVTdGFydDtcblxuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuLkVPRiAmJiAhbWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obG9va2FoZWFkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENvdmVyIGdyYW1tYXIgc3VwcG9ydC5cbiAgICAvL1xuICAgIC8vIFdoZW4gYW4gYXNzaWdubWVudCBleHByZXNzaW9uIHBvc2l0aW9uIHN0YXJ0cyB3aXRoIGFuIGxlZnQgcGFyZW50aGVzaXMsIHRoZSBkZXRlcm1pbmF0aW9uIG9mIHRoZSB0eXBlXG4gICAgLy8gb2YgdGhlIHN5bnRheCBpcyB0byBiZSBkZWZlcnJlZCBhcmJpdHJhcmlseSBsb25nIHVudGlsIHRoZSBlbmQgb2YgdGhlIHBhcmVudGhlc2VzIHBhaXIgKHBsdXMgYSBsb29rYWhlYWQpXG4gICAgLy8gb3IgdGhlIGZpcnN0IGNvbW1hLiBUaGlzIHNpdHVhdGlvbiBhbHNvIGRlZmVycyB0aGUgZGV0ZXJtaW5hdGlvbiBvZiBhbGwgdGhlIGV4cHJlc3Npb25zIG5lc3RlZCBpbiB0aGUgcGFpci5cbiAgICAvL1xuICAgIC8vIFRoZXJlIGFyZSB0aHJlZSBwcm9kdWN0aW9ucyB0aGF0IGNhbiBiZSBwYXJzZWQgaW4gYSBwYXJlbnRoZXNlcyBwYWlyIHRoYXQgbmVlZHMgdG8gYmUgZGV0ZXJtaW5lZFxuICAgIC8vIGFmdGVyIHRoZSBvdXRlcm1vc3QgcGFpciBpcyBjbG9zZWQuIFRoZXkgYXJlOlxuICAgIC8vXG4gICAgLy8gICAxLiBBc3NpZ25tZW50RXhwcmVzc2lvblxuICAgIC8vICAgMi4gQmluZGluZ0VsZW1lbnRzXG4gICAgLy8gICAzLiBBc3NpZ25tZW50VGFyZ2V0c1xuICAgIC8vXG4gICAgLy8gSW4gb3JkZXIgdG8gYXZvaWQgZXhwb25lbnRpYWwgYmFja3RyYWNraW5nLCB3ZSB1c2UgdHdvIGZsYWdzIHRvIGRlbm90ZSBpZiB0aGUgcHJvZHVjdGlvbiBjYW4gYmVcbiAgICAvLyBiaW5kaW5nIGVsZW1lbnQgb3IgYXNzaWdubWVudCB0YXJnZXQuXG4gICAgLy9cbiAgICAvLyBUaGUgdGhyZWUgcHJvZHVjdGlvbnMgaGF2ZSB0aGUgcmVsYXRpb25zaGlwOlxuICAgIC8vXG4gICAgLy8gICBCaW5kaW5nRWxlbWVudHMg4oqGIEFzc2lnbm1lbnRUYXJnZXRzIOKKhiBBc3NpZ25tZW50RXhwcmVzc2lvblxuICAgIC8vXG4gICAgLy8gd2l0aCBhIHNpbmdsZSBleGNlcHRpb24gdGhhdCBDb3ZlckluaXRpYWxpemVkTmFtZSB3aGVuIHVzZWQgZGlyZWN0bHkgaW4gYW4gRXhwcmVzc2lvbiwgZ2VuZXJhdGVzXG4gICAgLy8gYW4gZWFybHkgZXJyb3IuIFRoZXJlZm9yZSwgd2UgbmVlZCB0aGUgdGhpcmQgc3RhdGUsIGZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciwgdG8gdHJhY2sgdGhlXG4gICAgLy8gZmlyc3QgdXNhZ2Ugb2YgQ292ZXJJbml0aWFsaXplZE5hbWUgYW5kIHJlcG9ydCBpdCB3aGVuIHdlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgcGFyZW50aGVzZXMgcGFpci5cbiAgICAvL1xuICAgIC8vIGlzb2xhdGVDb3ZlckdyYW1tYXIgZnVuY3Rpb24gcnVucyB0aGUgZ2l2ZW4gcGFyc2VyIGZ1bmN0aW9uIHdpdGggYSBuZXcgY292ZXIgZ3JhbW1hciBjb250ZXh0LCBhbmQgaXQgZG9lcyBub3RcbiAgICAvLyBlZmZlY3QgdGhlIGN1cnJlbnQgZmxhZ3MuIFRoaXMgbWVhbnMgdGhlIHByb2R1Y3Rpb24gdGhlIHBhcnNlciBwYXJzZXMgaXMgb25seSB1c2VkIGFzIGFuIGV4cHJlc3Npb24uIFRoZXJlZm9yZVxuICAgIC8vIHRoZSBDb3ZlckluaXRpYWxpemVkTmFtZSBjaGVjayBpcyBjb25kdWN0ZWQuXG4gICAgLy9cbiAgICAvLyBpbmhlcml0Q292ZXJHcmFtbWFyIGZ1bmN0aW9uIHJ1bnMgdGhlIGdpdmVuIHBhcnNlIGZ1bmN0aW9uIHdpdGggYSBuZXcgY292ZXIgZ3JhbW1hciBjb250ZXh0LCBhbmQgaXQgcHJvcGFnYXRlc1xuICAgIC8vIHRoZSBmbGFncyBvdXRzaWRlIG9mIHRoZSBwYXJzZXIuIFRoaXMgbWVhbnMgdGhlIHByb2R1Y3Rpb24gdGhlIHBhcnNlciBwYXJzZXMgaXMgdXNlZCBhcyBhIHBhcnQgb2YgYSBwb3RlbnRpYWxcbiAgICAvLyBwYXR0ZXJuLiBUaGUgQ292ZXJJbml0aWFsaXplZE5hbWUgY2hlY2sgaXMgZGVmZXJyZWQuXG4gICAgZnVuY3Rpb24gaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZXIpIHtcbiAgICAgICAgdmFyIG9sZElzQmluZGluZ0VsZW1lbnQgPSBpc0JpbmRpbmdFbGVtZW50LFxuICAgICAgICAgICAgb2xkSXNBc3NpZ25tZW50VGFyZ2V0ID0gaXNBc3NpZ25tZW50VGFyZ2V0LFxuICAgICAgICAgICAgb2xkRmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yLFxuICAgICAgICAgICAgcmVzdWx0O1xuICAgICAgICBpc0JpbmRpbmdFbGVtZW50ID0gdHJ1ZTtcbiAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gbnVsbDtcbiAgICAgICAgcmVzdWx0ID0gcGFyc2VyKCk7XG4gICAgICAgIGlmIChmaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKGZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgaXNCaW5kaW5nRWxlbWVudCA9IG9sZElzQmluZGluZ0VsZW1lbnQ7XG4gICAgICAgIGlzQXNzaWdubWVudFRhcmdldCA9IG9sZElzQXNzaWdubWVudFRhcmdldDtcbiAgICAgICAgZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gb2xkRmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluaGVyaXRDb3ZlckdyYW1tYXIocGFyc2VyKSB7XG4gICAgICAgIHZhciBvbGRJc0JpbmRpbmdFbGVtZW50ID0gaXNCaW5kaW5nRWxlbWVudCxcbiAgICAgICAgICAgIG9sZElzQXNzaWdubWVudFRhcmdldCA9IGlzQXNzaWdubWVudFRhcmdldCxcbiAgICAgICAgICAgIG9sZEZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciA9IGZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvcixcbiAgICAgICAgICAgIHJlc3VsdDtcbiAgICAgICAgaXNCaW5kaW5nRWxlbWVudCA9IHRydWU7XG4gICAgICAgIGlzQXNzaWdubWVudFRhcmdldCA9IHRydWU7XG4gICAgICAgIGZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciA9IG51bGw7XG4gICAgICAgIHJlc3VsdCA9IHBhcnNlcigpO1xuICAgICAgICBpc0JpbmRpbmdFbGVtZW50ID0gaXNCaW5kaW5nRWxlbWVudCAmJiBvbGRJc0JpbmRpbmdFbGVtZW50O1xuICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQgPSBpc0Fzc2lnbm1lbnRUYXJnZXQgJiYgb2xkSXNBc3NpZ25tZW50VGFyZ2V0O1xuICAgICAgICBmaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgPSBvbGRGaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgfHwgZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyIDEzLjMuMyBEZXN0cnVjdHVyaW5nIEJpbmRpbmcgUGF0dGVybnNcblxuICAgIGZ1bmN0aW9uIHBhcnNlQXJyYXlQYXR0ZXJuKHBhcmFtcywga2luZCkge1xuICAgICAgICB2YXIgbm9kZSA9IG5ldyBOb2RlKCksIGVsZW1lbnRzID0gW10sIHJlc3QsIHJlc3ROb2RlO1xuICAgICAgICBleHBlY3QoJ1snKTtcblxuICAgICAgICB3aGlsZSAoIW1hdGNoKCddJykpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCgnLCcpKSB7XG4gICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChudWxsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKCcuLi4nKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN0Tm9kZSA9IG5ldyBOb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChsb29rYWhlYWQpO1xuICAgICAgICAgICAgICAgICAgICByZXN0ID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoa2luZCk7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2gocmVzdE5vZGUuZmluaXNoUmVzdEVsZW1lbnQocmVzdCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKHBhcnNlUGF0dGVybldpdGhEZWZhdWx0KHBhcmFtcywga2luZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoKCddJykpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KCcsJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3QoJ10nKTtcblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hBcnJheVBhdHRlcm4oZWxlbWVudHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlUHJvcGVydHlQYXR0ZXJuKHBhcmFtcywga2luZCkge1xuICAgICAgICB2YXIgbm9kZSA9IG5ldyBOb2RlKCksIGtleSwga2V5VG9rZW4sIGNvbXB1dGVkID0gbWF0Y2goJ1snKSwgaW5pdDtcbiAgICAgICAgaWYgKGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICBrZXlUb2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgICAgIGtleSA9IHBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XG4gICAgICAgICAgICBpZiAobWF0Y2goJz0nKSkge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKGtleVRva2VuKTtcbiAgICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgICAgICBpbml0ID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoUHJvcGVydHkoXG4gICAgICAgICAgICAgICAgICAgICdpbml0Jywga2V5LCBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbmV3IFdyYXBwaW5nTm9kZShrZXlUb2tlbikuZmluaXNoQXNzaWdubWVudFBhdHRlcm4oa2V5LCBpbml0KSwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghbWF0Y2goJzonKSkge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKGtleVRva2VuKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hQcm9wZXJ0eSgnaW5pdCcsIGtleSwgZmFsc2UsIGtleSwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAga2V5ID0gcGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuICAgICAgICB9XG4gICAgICAgIGV4cGVjdCgnOicpO1xuICAgICAgICBpbml0ID0gcGFyc2VQYXR0ZXJuV2l0aERlZmF1bHQocGFyYW1zLCBraW5kKTtcbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoUHJvcGVydHkoJ2luaXQnLCBrZXksIGNvbXB1dGVkLCBpbml0LCBmYWxzZSwgZmFsc2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlT2JqZWN0UGF0dGVybihwYXJhbXMsIGtpbmQpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBuZXcgTm9kZSgpLCBwcm9wZXJ0aWVzID0gW107XG5cbiAgICAgICAgZXhwZWN0KCd7Jyk7XG5cbiAgICAgICAgd2hpbGUgKCFtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2gocGFyc2VQcm9wZXJ0eVBhdHRlcm4ocGFyYW1zLCBraW5kKSk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoKCd9JykpIHtcbiAgICAgICAgICAgICAgICBleHBlY3QoJywnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxleCgpO1xuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaE9iamVjdFBhdHRlcm4ocHJvcGVydGllcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VQYXR0ZXJuKHBhcmFtcywga2luZCkge1xuICAgICAgICBpZiAobWF0Y2goJ1snKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlQXJyYXlQYXR0ZXJuKHBhcmFtcywga2luZCk7XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJ3snKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlT2JqZWN0UGF0dGVybihwYXJhbXMsIGtpbmQpO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoS2V5d29yZCgnbGV0JykpIHtcbiAgICAgICAgICAgIGlmIChraW5kID09PSAnY29uc3QnIHx8IGtpbmQgPT09ICdsZXQnKSB7XG4gICAgICAgICAgICAgICAgdG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4obG9va2FoZWFkLCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcGFyYW1zLnB1c2gobG9va2FoZWFkKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlVmFyaWFibGVJZGVudGlmaWVyKGtpbmQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlUGF0dGVybldpdGhEZWZhdWx0KHBhcmFtcywga2luZCkge1xuICAgICAgICB2YXIgc3RhcnRUb2tlbiA9IGxvb2thaGVhZCwgcGF0dGVybiwgcHJldmlvdXNBbGxvd1lpZWxkLCByaWdodDtcbiAgICAgICAgcGF0dGVybiA9IHBhcnNlUGF0dGVybihwYXJhbXMsIGtpbmQpO1xuICAgICAgICBpZiAobWF0Y2goJz0nKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICBwcmV2aW91c0FsbG93WWllbGQgPSBzdGF0ZS5hbGxvd1lpZWxkO1xuICAgICAgICAgICAgc3RhdGUuYWxsb3dZaWVsZCA9IHRydWU7XG4gICAgICAgICAgICByaWdodCA9IGlzb2xhdGVDb3ZlckdyYW1tYXIocGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XG4gICAgICAgICAgICBzdGF0ZS5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xuICAgICAgICAgICAgcGF0dGVybiA9IG5ldyBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikuZmluaXNoQXNzaWdubWVudFBhdHRlcm4ocGF0dGVybiwgcmlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXR0ZXJuO1xuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyIDEyLjIuNSBBcnJheSBJbml0aWFsaXplclxuXG4gICAgZnVuY3Rpb24gcGFyc2VBcnJheUluaXRpYWxpemVyKCkge1xuICAgICAgICB2YXIgZWxlbWVudHMgPSBbXSwgbm9kZSA9IG5ldyBOb2RlKCksIHJlc3RTcHJlYWQ7XG5cbiAgICAgICAgZXhwZWN0KCdbJyk7XG5cbiAgICAgICAgd2hpbGUgKCFtYXRjaCgnXScpKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2goJywnKSkge1xuICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCcuLi4nKSkge1xuICAgICAgICAgICAgICAgIHJlc3RTcHJlYWQgPSBuZXcgTm9kZSgpO1xuICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgIHJlc3RTcHJlYWQuZmluaXNoU3ByZWFkRWxlbWVudChpbmhlcml0Q292ZXJHcmFtbWFyKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pKTtcblxuICAgICAgICAgICAgICAgIGlmICghbWF0Y2goJ10nKSkge1xuICAgICAgICAgICAgICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQgPSBpc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdCgnLCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKHJlc3RTcHJlYWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKGluaGVyaXRDb3ZlckdyYW1tYXIocGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbikpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaCgnXScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdCgnLCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxleCgpO1xuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaEFycmF5RXhwcmVzc2lvbihlbGVtZW50cyk7XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTIuMi42IE9iamVjdCBJbml0aWFsaXplclxuXG4gICAgZnVuY3Rpb24gcGFyc2VQcm9wZXJ0eUZ1bmN0aW9uKG5vZGUsIHBhcmFtSW5mbywgaXNHZW5lcmF0b3IpIHtcbiAgICAgICAgdmFyIHByZXZpb3VzU3RyaWN0LCBib2R5O1xuXG4gICAgICAgIGlzQXNzaWdubWVudFRhcmdldCA9IGlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcblxuICAgICAgICBwcmV2aW91c1N0cmljdCA9IHN0cmljdDtcbiAgICAgICAgYm9keSA9IGlzb2xhdGVDb3ZlckdyYW1tYXIocGFyc2VGdW5jdGlvblNvdXJjZUVsZW1lbnRzKTtcblxuICAgICAgICBpZiAoc3RyaWN0ICYmIHBhcmFtSW5mby5maXJzdFJlc3RyaWN0ZWQpIHtcbiAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHBhcmFtSW5mby5maXJzdFJlc3RyaWN0ZWQsIHBhcmFtSW5mby5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyaWN0ICYmIHBhcmFtSW5mby5zdHJpY3RlZCkge1xuICAgICAgICAgICAgdG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4ocGFyYW1JbmZvLnN0cmljdGVkLCBwYXJhbUluZm8ubWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzdHJpY3QgPSBwcmV2aW91c1N0cmljdDtcbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoRnVuY3Rpb25FeHByZXNzaW9uKG51bGwsIHBhcmFtSW5mby5wYXJhbXMsIHBhcmFtSW5mby5kZWZhdWx0cywgYm9keSwgaXNHZW5lcmF0b3IpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlUHJvcGVydHlNZXRob2RGdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtcywgbWV0aG9kLCBub2RlID0gbmV3IE5vZGUoKSxcbiAgICAgICAgICAgIHByZXZpb3VzQWxsb3dZaWVsZCA9IHN0YXRlLmFsbG93WWllbGQ7XG5cbiAgICAgICAgc3RhdGUuYWxsb3dZaWVsZCA9IGZhbHNlO1xuICAgICAgICBwYXJhbXMgPSBwYXJzZVBhcmFtcygpO1xuICAgICAgICBzdGF0ZS5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xuXG4gICAgICAgIHN0YXRlLmFsbG93WWllbGQgPSBmYWxzZTtcbiAgICAgICAgbWV0aG9kID0gcGFyc2VQcm9wZXJ0eUZ1bmN0aW9uKG5vZGUsIHBhcmFtcywgZmFsc2UpO1xuICAgICAgICBzdGF0ZS5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xuXG4gICAgICAgIHJldHVybiBtZXRob2Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpIHtcbiAgICAgICAgdmFyIHRva2VuLCBub2RlID0gbmV3IE5vZGUoKSwgZXhwcjtcblxuICAgICAgICB0b2tlbiA9IGxleCgpO1xuXG4gICAgICAgIC8vIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgZnJvbSBwYXJzZU9iamVjdFByb3BlcnR5KCksIHdoZXJlXG4gICAgICAgIC8vIEVPRiBhbmQgUHVuY3R1YXRvciB0b2tlbnMgYXJlIGFscmVhZHkgZmlsdGVyZWQgb3V0LlxuXG4gICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICBjYXNlIFRva2VuLlN0cmluZ0xpdGVyYWw6XG4gICAgICAgIGNhc2UgVG9rZW4uTnVtZXJpY0xpdGVyYWw6XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIHRva2VuLm9jdGFsKSB7XG4gICAgICAgICAgICAgICAgdG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIE1lc3NhZ2VzLlN0cmljdE9jdGFsTGl0ZXJhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hMaXRlcmFsKHRva2VuKTtcbiAgICAgICAgY2FzZSBUb2tlbi5JZGVudGlmaWVyOlxuICAgICAgICBjYXNlIFRva2VuLkJvb2xlYW5MaXRlcmFsOlxuICAgICAgICBjYXNlIFRva2VuLk51bGxMaXRlcmFsOlxuICAgICAgICBjYXNlIFRva2VuLktleXdvcmQ6XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hJZGVudGlmaWVyKHRva2VuLnZhbHVlKTtcbiAgICAgICAgY2FzZSBUb2tlbi5QdW5jdHVhdG9yOlxuICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlID09PSAnWycpIHtcbiAgICAgICAgICAgICAgICBleHByID0gaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBleHBlY3QoJ10nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb29rYWhlYWRQcm9wZXJ0eU5hbWUoKSB7XG4gICAgICAgIHN3aXRjaCAobG9va2FoZWFkLnR5cGUpIHtcbiAgICAgICAgY2FzZSBUb2tlbi5JZGVudGlmaWVyOlxuICAgICAgICBjYXNlIFRva2VuLlN0cmluZ0xpdGVyYWw6XG4gICAgICAgIGNhc2UgVG9rZW4uQm9vbGVhbkxpdGVyYWw6XG4gICAgICAgIGNhc2UgVG9rZW4uTnVsbExpdGVyYWw6XG4gICAgICAgIGNhc2UgVG9rZW4uTnVtZXJpY0xpdGVyYWw6XG4gICAgICAgIGNhc2UgVG9rZW4uS2V5d29yZDpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjYXNlIFRva2VuLlB1bmN0dWF0b3I6XG4gICAgICAgICAgICByZXR1cm4gbG9va2FoZWFkLnZhbHVlID09PSAnWyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgdG8gdHJ5IHRvIHBhcnNlIGEgTWV0aG9kRGVmaW5pdGlvbiBhcyBkZWZpbmVkIGluIDE0LjMuIEJ1dCBpbiB0aGUgY2FzZSBvZiBvYmplY3QgbGl0ZXJhbHMsXG4gICAgLy8gaXQgbWlnaHQgYmUgY2FsbGVkIGF0IGEgcG9zaXRpb24gd2hlcmUgdGhlcmUgaXMgaW4gZmFjdCBhIHNob3J0IGhhbmQgaWRlbnRpZmllciBwYXR0ZXJuIG9yIGEgZGF0YSBwcm9wZXJ0eS5cbiAgICAvLyBUaGlzIGNhbiBvbmx5IGJlIGRldGVybWluZWQgYWZ0ZXIgd2UgY29uc3VtZWQgdXAgdG8gdGhlIGxlZnQgcGFyZW50aGVzZXMuXG4gICAgLy9cbiAgICAvLyBJbiBvcmRlciB0byBhdm9pZCBiYWNrIHRyYWNraW5nLCBpdCByZXR1cm5zIGBudWxsYCBpZiB0aGUgcG9zaXRpb24gaXMgbm90IGEgTWV0aG9kRGVmaW5pdGlvbiBhbmQgdGhlIGNhbGxlclxuICAgIC8vIGlzIHJlc3BvbnNpYmxlIHRvIHZpc2l0IG90aGVyIG9wdGlvbnMuXG4gICAgZnVuY3Rpb24gdHJ5UGFyc2VNZXRob2REZWZpbml0aW9uKHRva2VuLCBrZXksIGNvbXB1dGVkLCBub2RlKSB7XG4gICAgICAgIHZhciB2YWx1ZSwgb3B0aW9ucywgbWV0aG9kTm9kZSwgcGFyYW1zLFxuICAgICAgICAgICAgcHJldmlvdXNBbGxvd1lpZWxkID0gc3RhdGUuYWxsb3dZaWVsZDtcblxuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uSWRlbnRpZmllcikge1xuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGBnZXRgIGFuZCBgc2V0YDtcblxuICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlID09PSAnZ2V0JyAmJiBsb29rYWhlYWRQcm9wZXJ0eU5hbWUoKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVkID0gbWF0Y2goJ1snKTtcbiAgICAgICAgICAgICAgICBrZXkgPSBwYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XG4gICAgICAgICAgICAgICAgbWV0aG9kTm9kZSA9IG5ldyBOb2RlKCk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KCcoJyk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KCcpJyk7XG5cbiAgICAgICAgICAgICAgICBzdGF0ZS5hbGxvd1lpZWxkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZVByb3BlcnR5RnVuY3Rpb24obWV0aG9kTm9kZSwge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0czogW10sXG4gICAgICAgICAgICAgICAgICAgIHN0cmljdGVkOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG51bGxcbiAgICAgICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgc3RhdGUuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcblxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaFByb3BlcnR5KCdnZXQnLCBrZXksIGNvbXB1dGVkLCB2YWx1ZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW4udmFsdWUgPT09ICdzZXQnICYmIGxvb2thaGVhZFByb3BlcnR5TmFtZSgpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZWQgPSBtYXRjaCgnWycpO1xuICAgICAgICAgICAgICAgIGtleSA9IHBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcbiAgICAgICAgICAgICAgICBtZXRob2ROb2RlID0gbmV3IE5vZGUoKTtcbiAgICAgICAgICAgICAgICBleHBlY3QoJygnKTtcblxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczogW10sXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRDb3VudDogMCxcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtU2V0OiB7fVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKCcpJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4obG9va2FoZWFkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5hbGxvd1lpZWxkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlUGFyYW0ob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmFsbG93WWllbGQgPSBwcmV2aW91c0FsbG93WWllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kZWZhdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICAgICAgICAgICAgc3RhdGUuYWxsb3dZaWVsZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VQcm9wZXJ0eUZ1bmN0aW9uKG1ldGhvZE5vZGUsIG9wdGlvbnMsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoUHJvcGVydHkoJ3NldCcsIGtleSwgY29tcHV0ZWQsIHZhbHVlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLlB1bmN0dWF0b3IgJiYgdG9rZW4udmFsdWUgPT09ICcqJyAmJiBsb29rYWhlYWRQcm9wZXJ0eU5hbWUoKSkge1xuICAgICAgICAgICAgY29tcHV0ZWQgPSBtYXRjaCgnWycpO1xuICAgICAgICAgICAga2V5ID0gcGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuICAgICAgICAgICAgbWV0aG9kTm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgICAgICAgIHN0YXRlLmFsbG93WWllbGQgPSB0cnVlO1xuICAgICAgICAgICAgcGFyYW1zID0gcGFyc2VQYXJhbXMoKTtcbiAgICAgICAgICAgIHN0YXRlLmFsbG93WWllbGQgPSBwcmV2aW91c0FsbG93WWllbGQ7XG5cbiAgICAgICAgICAgIHN0YXRlLmFsbG93WWllbGQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhbHVlID0gcGFyc2VQcm9wZXJ0eUZ1bmN0aW9uKG1ldGhvZE5vZGUsIHBhcmFtcywgdHJ1ZSk7XG4gICAgICAgICAgICBzdGF0ZS5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xuXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hQcm9wZXJ0eSgnaW5pdCcsIGtleSwgY29tcHV0ZWQsIHZhbHVlLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa2V5ICYmIG1hdGNoKCcoJykpIHtcbiAgICAgICAgICAgIHZhbHVlID0gcGFyc2VQcm9wZXJ0eU1ldGhvZEZ1bmN0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hQcm9wZXJ0eSgnaW5pdCcsIGtleSwgY29tcHV0ZWQsIHZhbHVlLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3QgYSBNZXRob2REZWZpbml0aW9uLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU9iamVjdFByb3BlcnR5KGhhc1Byb3RvKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IGxvb2thaGVhZCwgbm9kZSA9IG5ldyBOb2RlKCksIGNvbXB1dGVkLCBrZXksIG1heWJlTWV0aG9kLCBwcm90bywgdmFsdWU7XG5cbiAgICAgICAgY29tcHV0ZWQgPSBtYXRjaCgnWycpO1xuICAgICAgICBpZiAobWF0Y2goJyonKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBrZXkgPSBwYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XG4gICAgICAgIH1cbiAgICAgICAgbWF5YmVNZXRob2QgPSB0cnlQYXJzZU1ldGhvZERlZmluaXRpb24odG9rZW4sIGtleSwgY29tcHV0ZWQsIG5vZGUpO1xuICAgICAgICBpZiAobWF5YmVNZXRob2QpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXliZU1ldGhvZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbihsb29rYWhlYWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIGR1cGxpY2F0ZWQgX19wcm90b19fXG4gICAgICAgIGlmICghY29tcHV0ZWQpIHtcbiAgICAgICAgICAgIHByb3RvID0gKGtleS50eXBlID09PSBTeW50YXguSWRlbnRpZmllciAmJiBrZXkubmFtZSA9PT0gJ19fcHJvdG9fXycpIHx8XG4gICAgICAgICAgICAgICAgKGtleS50eXBlID09PSBTeW50YXguTGl0ZXJhbCAmJiBrZXkudmFsdWUgPT09ICdfX3Byb3RvX18nKTtcbiAgICAgICAgICAgIGlmIChoYXNQcm90by52YWx1ZSAmJiBwcm90bykge1xuICAgICAgICAgICAgICAgIHRvbGVyYXRlRXJyb3IoTWVzc2FnZXMuRHVwbGljYXRlUHJvdG9Qcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYXNQcm90by52YWx1ZSB8PSBwcm90bztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaCgnOicpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIHZhbHVlID0gaW5oZXJpdENvdmVyR3JhbW1hcihwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcbiAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaFByb3BlcnR5KCdpbml0Jywga2V5LCBjb21wdXRlZCwgdmFsdWUsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uSWRlbnRpZmllcikge1xuICAgICAgICAgICAgaWYgKG1hdGNoKCc9JykpIHtcbiAgICAgICAgICAgICAgICBmaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgPSBsb29rYWhlYWQ7XG4gICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBpc29sYXRlQ292ZXJHcmFtbWFyKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaFByb3BlcnR5KCdpbml0Jywga2V5LCBjb21wdXRlZCxcbiAgICAgICAgICAgICAgICAgICAgbmV3IFdyYXBwaW5nTm9kZSh0b2tlbikuZmluaXNoQXNzaWdubWVudFBhdHRlcm4oa2V5LCB2YWx1ZSksIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaFByb3BlcnR5KCdpbml0Jywga2V5LCBjb21wdXRlZCwga2V5LCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbihsb29rYWhlYWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlT2JqZWN0SW5pdGlhbGl6ZXIoKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0aWVzID0gW10sIGhhc1Byb3RvID0ge3ZhbHVlOiBmYWxzZX0sIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGV4cGVjdCgneycpO1xuXG4gICAgICAgIHdoaWxlICghbWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKHBhcnNlT2JqZWN0UHJvcGVydHkoaGFzUHJvdG8pKTtcblxuICAgICAgICAgICAgaWYgKCFtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICAgICAgZXhwZWN0Q29tbWFTZXBhcmF0b3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGVjdCgnfScpO1xuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaE9iamVjdEV4cHJlc3Npb24ocHJvcGVydGllcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGV4cHIpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHN3aXRjaCAoZXhwci50eXBlKSB7XG4gICAgICAgIGNhc2UgU3ludGF4LklkZW50aWZpZXI6XG4gICAgICAgIGNhc2UgU3ludGF4Lk1lbWJlckV4cHJlc3Npb246XG4gICAgICAgIGNhc2UgU3ludGF4LlJlc3RFbGVtZW50OlxuICAgICAgICBjYXNlIFN5bnRheC5Bc3NpZ25tZW50UGF0dGVybjpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFN5bnRheC5TcHJlYWRFbGVtZW50OlxuICAgICAgICAgICAgZXhwci50eXBlID0gU3ludGF4LlJlc3RFbGVtZW50O1xuICAgICAgICAgICAgcmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGV4cHIuYXJndW1lbnQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU3ludGF4LkFycmF5RXhwcmVzc2lvbjpcbiAgICAgICAgICAgIGV4cHIudHlwZSA9IFN5bnRheC5BcnJheVBhdHRlcm47XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXhwci5lbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChleHByLmVsZW1lbnRzW2ldICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByLmVsZW1lbnRzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTeW50YXguT2JqZWN0RXhwcmVzc2lvbjpcbiAgICAgICAgICAgIGV4cHIudHlwZSA9IFN5bnRheC5PYmplY3RQYXR0ZXJuO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGV4cHIucHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByLnByb3BlcnRpZXNbaV0udmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uOlxuICAgICAgICAgICAgZXhwci50eXBlID0gU3ludGF4LkFzc2lnbm1lbnRQYXR0ZXJuO1xuICAgICAgICAgICAgcmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGV4cHIubGVmdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIEFsbG93IG90aGVyIG5vZGUgdHlwZSBmb3IgdG9sZXJhbnQgcGFyc2luZy5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTIuMi45IFRlbXBsYXRlIExpdGVyYWxzXG5cbiAgICBmdW5jdGlvbiBwYXJzZVRlbXBsYXRlRWxlbWVudChvcHRpb24pIHtcbiAgICAgICAgdmFyIG5vZGUsIHRva2VuO1xuXG4gICAgICAgIGlmIChsb29rYWhlYWQudHlwZSAhPT0gVG9rZW4uVGVtcGxhdGUgfHwgKG9wdGlvbi5oZWFkICYmICFsb29rYWhlYWQuaGVhZCkpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKCk7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gbmV3IE5vZGUoKTtcbiAgICAgICAgdG9rZW4gPSBsZXgoKTtcblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hUZW1wbGF0ZUVsZW1lbnQoeyByYXc6IHRva2VuLnZhbHVlLnJhdywgY29va2VkOiB0b2tlbi52YWx1ZS5jb29rZWQgfSwgdG9rZW4udGFpbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VUZW1wbGF0ZUxpdGVyYWwoKSB7XG4gICAgICAgIHZhciBxdWFzaSwgcXVhc2lzLCBleHByZXNzaW9ucywgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgICAgcXVhc2kgPSBwYXJzZVRlbXBsYXRlRWxlbWVudCh7IGhlYWQ6IHRydWUgfSk7XG4gICAgICAgIHF1YXNpcyA9IFtxdWFzaV07XG4gICAgICAgIGV4cHJlc3Npb25zID0gW107XG5cbiAgICAgICAgd2hpbGUgKCFxdWFzaS50YWlsKSB7XG4gICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKHBhcnNlRXhwcmVzc2lvbigpKTtcbiAgICAgICAgICAgIHF1YXNpID0gcGFyc2VUZW1wbGF0ZUVsZW1lbnQoeyBoZWFkOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIHF1YXNpcy5wdXNoKHF1YXNpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaFRlbXBsYXRlTGl0ZXJhbChxdWFzaXMsIGV4cHJlc3Npb25zKTtcbiAgICB9XG5cbiAgICAvLyBFQ01BLTI2MiAxMi4yLjEwIFRoZSBHcm91cGluZyBPcGVyYXRvclxuXG4gICAgZnVuY3Rpb24gcGFyc2VHcm91cEV4cHJlc3Npb24oKSB7XG4gICAgICAgIHZhciBleHByLCBleHByZXNzaW9ucywgc3RhcnRUb2tlbiwgaSwgcGFyYW1zID0gW107XG5cbiAgICAgICAgZXhwZWN0KCcoJyk7XG5cbiAgICAgICAgaWYgKG1hdGNoKCcpJykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaCgnPT4nKSkge1xuICAgICAgICAgICAgICAgIGV4cGVjdCgnPT4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogUGxhY2VIb2xkZXJzLkFycm93UGFyYW1ldGVyUGxhY2VIb2xkZXIsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBbXSxcbiAgICAgICAgICAgICAgICByYXdQYXJhbXM6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgaWYgKG1hdGNoKCcuLi4nKSkge1xuICAgICAgICAgICAgZXhwciA9IHBhcnNlUmVzdEVsZW1lbnQocGFyYW1zKTtcbiAgICAgICAgICAgIGV4cGVjdCgnKScpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaCgnPT4nKSkge1xuICAgICAgICAgICAgICAgIGV4cGVjdCgnPT4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogUGxhY2VIb2xkZXJzLkFycm93UGFyYW1ldGVyUGxhY2VIb2xkZXIsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBbZXhwcl1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpc0JpbmRpbmdFbGVtZW50ID0gdHJ1ZTtcbiAgICAgICAgZXhwciA9IGluaGVyaXRDb3ZlckdyYW1tYXIocGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XG5cbiAgICAgICAgaWYgKG1hdGNoKCcsJykpIHtcbiAgICAgICAgICAgIGlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xuICAgICAgICAgICAgZXhwcmVzc2lvbnMgPSBbZXhwcl07XG5cbiAgICAgICAgICAgIHdoaWxlIChzdGFydEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaCgnLCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXgoKTtcblxuICAgICAgICAgICAgICAgIGlmIChtYXRjaCgnLi4uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0JpbmRpbmdFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbihsb29rYWhlYWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2gocGFyc2VSZXN0RWxlbWVudChwYXJhbXMpKTtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KCcpJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2goJz0+JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdCgnPT4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBleHByZXNzaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGV4cHJlc3Npb25zW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogUGxhY2VIb2xkZXJzLkFycm93UGFyYW1ldGVyUGxhY2VIb2xkZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IGV4cHJlc3Npb25zXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChpbmhlcml0Q292ZXJHcmFtbWFyKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikuZmluaXNoU2VxdWVuY2VFeHByZXNzaW9uKGV4cHJlc3Npb25zKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgZXhwZWN0KCcpJyk7XG5cbiAgICAgICAgaWYgKG1hdGNoKCc9PicpKSB7XG4gICAgICAgICAgICBpZiAoZXhwci50eXBlID09PSBTeW50YXguSWRlbnRpZmllciAmJiBleHByLm5hbWUgPT09ICd5aWVsZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBQbGFjZUhvbGRlcnMuQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlcixcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBbZXhwcl1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWlzQmluZGluZ0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbihsb29rYWhlYWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXhwci50eXBlID09PSBTeW50YXguU2VxdWVuY2VFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGV4cHIuZXhwcmVzc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGV4cHIuZXhwcmVzc2lvbnNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGV4cHIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleHByID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFBsYWNlSG9sZGVycy5BcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyLFxuICAgICAgICAgICAgICAgIHBhcmFtczogZXhwci50eXBlID09PSBTeW50YXguU2VxdWVuY2VFeHByZXNzaW9uID8gZXhwci5leHByZXNzaW9ucyA6IFtleHByXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuXG4gICAgLy8gRUNNQS0yNjIgMTIuMiBQcmltYXJ5IEV4cHJlc3Npb25zXG5cbiAgICBmdW5jdGlvbiBwYXJzZVByaW1hcnlFeHByZXNzaW9uKCkge1xuICAgICAgICB2YXIgdHlwZSwgdG9rZW4sIGV4cHIsIG5vZGU7XG5cbiAgICAgICAgaWYgKG1hdGNoKCcoJykpIHtcbiAgICAgICAgICAgIGlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBpbmhlcml0Q292ZXJHcmFtbWFyKHBhcnNlR3JvdXBFeHByZXNzaW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaCgnWycpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5oZXJpdENvdmVyR3JhbW1hcihwYXJzZUFycmF5SW5pdGlhbGl6ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoKCd7JykpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmhlcml0Q292ZXJHcmFtbWFyKHBhcnNlT2JqZWN0SW5pdGlhbGl6ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdHlwZSA9IGxvb2thaGVhZC50eXBlO1xuICAgICAgICBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgICBpZiAodHlwZSA9PT0gVG9rZW4uSWRlbnRpZmllcikge1xuICAgICAgICAgICAgaWYgKHN0YXRlLnNvdXJjZVR5cGUgPT09ICdtb2R1bGUnICYmIGxvb2thaGVhZC52YWx1ZSA9PT0gJ2F3YWl0Jykge1xuICAgICAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKGxvb2thaGVhZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHByID0gbm9kZS5maW5pc2hJZGVudGlmaWVyKGxleCgpLnZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBUb2tlbi5TdHJpbmdMaXRlcmFsIHx8IHR5cGUgPT09IFRva2VuLk51bWVyaWNMaXRlcmFsKSB7XG4gICAgICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQgPSBpc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGxvb2thaGVhZC5vY3RhbCkge1xuICAgICAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKGxvb2thaGVhZCwgTWVzc2FnZXMuU3RyaWN0T2N0YWxMaXRlcmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cHIgPSBub2RlLmZpbmlzaExpdGVyYWwobGV4KCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICAgIGlmICghc3RyaWN0ICYmIHN0YXRlLmFsbG93WWllbGQgJiYgbWF0Y2hLZXl3b3JkKCd5aWVsZCcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlTm9uQ29tcHV0ZWRQcm9wZXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzdHJpY3QgJiYgbWF0Y2hLZXl3b3JkKCdsZXQnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaElkZW50aWZpZXIobGV4KCkudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0ID0gaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgnZnVuY3Rpb24nKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZ1bmN0aW9uRXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgndGhpcycpKSB7XG4gICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoVGhpc0V4cHJlc3Npb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2NsYXNzJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VDbGFzc0V4cHJlc3Npb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKGxleCgpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBUb2tlbi5Cb29sZWFuTGl0ZXJhbCkge1xuICAgICAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0ID0gaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgdG9rZW4gPSBsZXgoKTtcbiAgICAgICAgICAgIHRva2VuLnZhbHVlID0gKHRva2VuLnZhbHVlID09PSAndHJ1ZScpO1xuICAgICAgICAgICAgZXhwciA9IG5vZGUuZmluaXNoTGl0ZXJhbCh0b2tlbik7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVG9rZW4uTnVsbExpdGVyYWwpIHtcbiAgICAgICAgICAgIGlzQXNzaWdubWVudFRhcmdldCA9IGlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRva2VuID0gbGV4KCk7XG4gICAgICAgICAgICB0b2tlbi52YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICBleHByID0gbm9kZS5maW5pc2hMaXRlcmFsKHRva2VuKTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaCgnLycpIHx8IG1hdGNoKCcvPScpKSB7XG4gICAgICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQgPSBpc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICBpbmRleCA9IHN0YXJ0SW5kZXg7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXh0cmEudG9rZW5zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRva2VuID0gY29sbGVjdFJlZ2V4KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRva2VuID0gc2NhblJlZ0V4cCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICBleHByID0gbm9kZS5maW5pc2hMaXRlcmFsKHRva2VuKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBUb2tlbi5UZW1wbGF0ZSkge1xuICAgICAgICAgICAgZXhwciA9IHBhcnNlVGVtcGxhdGVMaXRlcmFsKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbihsZXgoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICAvLyBFQ01BLTI2MiAxMi4zIExlZnQtSGFuZC1TaWRlIEV4cHJlc3Npb25zXG5cbiAgICBmdW5jdGlvbiBwYXJzZUFyZ3VtZW50cygpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgZXhwcjtcblxuICAgICAgICBleHBlY3QoJygnKTtcblxuICAgICAgICBpZiAoIW1hdGNoKCcpJykpIHtcbiAgICAgICAgICAgIHdoaWxlIChzdGFydEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKCcuLi4nKSkge1xuICAgICAgICAgICAgICAgICAgICBleHByID0gbmV3IE5vZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIGV4cHIuZmluaXNoU3ByZWFkRWxlbWVudChpc29sYXRlQ292ZXJHcmFtbWFyKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBleHByID0gaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKGV4cHIpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCgnKScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleHBlY3RDb21tYVNlcGFyYXRvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZXhwZWN0KCcpJyk7XG5cbiAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VOb25Db21wdXRlZFByb3BlcnR5KCkge1xuICAgICAgICB2YXIgdG9rZW4sIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIHRva2VuID0gbGV4KCk7XG5cbiAgICAgICAgaWYgKCFpc0lkZW50aWZpZXJOYW1lKHRva2VuKSkge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoSWRlbnRpZmllcih0b2tlbi52YWx1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VOb25Db21wdXRlZE1lbWJlcigpIHtcbiAgICAgICAgZXhwZWN0KCcuJyk7XG5cbiAgICAgICAgcmV0dXJuIHBhcnNlTm9uQ29tcHV0ZWRQcm9wZXJ0eSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlQ29tcHV0ZWRNZW1iZXIoKSB7XG4gICAgICAgIHZhciBleHByO1xuXG4gICAgICAgIGV4cGVjdCgnWycpO1xuXG4gICAgICAgIGV4cHIgPSBpc29sYXRlQ292ZXJHcmFtbWFyKHBhcnNlRXhwcmVzc2lvbik7XG5cbiAgICAgICAgZXhwZWN0KCddJyk7XG5cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTIuMy4zIFRoZSBuZXcgT3BlcmF0b3JcblxuICAgIGZ1bmN0aW9uIHBhcnNlTmV3RXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGNhbGxlZSwgYXJncywgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnbmV3Jyk7XG5cbiAgICAgICAgaWYgKG1hdGNoKCcuJykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgaWYgKGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5JZGVudGlmaWVyICYmIGxvb2thaGVhZC52YWx1ZSA9PT0gJ3RhcmdldCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaW5GdW5jdGlvbkJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaE1ldGFQcm9wZXJ0eSgnbmV3JywgJ3RhcmdldCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKGxvb2thaGVhZCk7XG4gICAgICAgIH1cblxuICAgICAgICBjYWxsZWUgPSBpc29sYXRlQ292ZXJHcmFtbWFyKHBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbik7XG4gICAgICAgIGFyZ3MgPSBtYXRjaCgnKCcpID8gcGFyc2VBcmd1bWVudHMoKSA6IFtdO1xuXG4gICAgICAgIGlzQXNzaWdubWVudFRhcmdldCA9IGlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hOZXdFeHByZXNzaW9uKGNhbGxlZSwgYXJncyk7XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTIuMy40IEZ1bmN0aW9uIENhbGxzXG5cbiAgICBmdW5jdGlvbiBwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwoKSB7XG4gICAgICAgIHZhciBxdWFzaSwgZXhwciwgYXJncywgcHJvcGVydHksIHN0YXJ0VG9rZW4sIHByZXZpb3VzQWxsb3dJbiA9IHN0YXRlLmFsbG93SW47XG5cbiAgICAgICAgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgc3RhdGUuYWxsb3dJbiA9IHRydWU7XG5cbiAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgnc3VwZXInKSAmJiBzdGF0ZS5pbkZ1bmN0aW9uQm9keSkge1xuICAgICAgICAgICAgZXhwciA9IG5ldyBOb2RlKCk7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIGV4cHIgPSBleHByLmZpbmlzaFN1cGVyKCk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoKCcoJykgJiYgIW1hdGNoKCcuJykgJiYgIW1hdGNoKCdbJykpIHtcbiAgICAgICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbihsb29rYWhlYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhwciA9IGluaGVyaXRDb3ZlckdyYW1tYXIobWF0Y2hLZXl3b3JkKCduZXcnKSA/IHBhcnNlTmV3RXhwcmVzc2lvbiA6IHBhcnNlUHJpbWFyeUV4cHJlc3Npb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKG1hdGNoKCcuJykpIHtcbiAgICAgICAgICAgICAgICBpc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9IHBhcnNlTm9uQ29tcHV0ZWRNZW1iZXIoKTtcbiAgICAgICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hNZW1iZXJFeHByZXNzaW9uKCcuJywgZXhwciwgcHJvcGVydHkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaCgnKCcpKSB7XG4gICAgICAgICAgICAgICAgaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGFyZ3MgPSBwYXJzZUFyZ3VtZW50cygpO1xuICAgICAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaENhbGxFeHByZXNzaW9uKGV4cHIsIGFyZ3MpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaCgnWycpKSB7XG4gICAgICAgICAgICAgICAgaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlzQXNzaWdubWVudFRhcmdldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcHJvcGVydHkgPSBwYXJzZUNvbXB1dGVkTWVtYmVyKCk7XG4gICAgICAgICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikuZmluaXNoTWVtYmVyRXhwcmVzc2lvbignWycsIGV4cHIsIHByb3BlcnR5KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobG9va2FoZWFkLnR5cGUgPT09IFRva2VuLlRlbXBsYXRlICYmIGxvb2thaGVhZC5oZWFkKSB7XG4gICAgICAgICAgICAgICAgcXVhc2kgPSBwYXJzZVRlbXBsYXRlTGl0ZXJhbCgpO1xuICAgICAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbihleHByLCBxdWFzaSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmFsbG93SW4gPSBwcmV2aW91c0FsbG93SW47XG5cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTIuMyBMZWZ0LUhhbmQtU2lkZSBFeHByZXNzaW9uc1xuXG4gICAgZnVuY3Rpb24gcGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uKCkge1xuICAgICAgICB2YXIgcXVhc2ksIGV4cHIsIHByb3BlcnR5LCBzdGFydFRva2VuO1xuICAgICAgICBhc3NlcnQoc3RhdGUuYWxsb3dJbiwgJ2NhbGxlZSBvZiBuZXcgZXhwcmVzc2lvbiBhbHdheXMgYWxsb3cgaW4ga2V5d29yZC4nKTtcblxuICAgICAgICBzdGFydFRva2VuID0gbG9va2FoZWFkO1xuXG4gICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ3N1cGVyJykgJiYgc3RhdGUuaW5GdW5jdGlvbkJvZHkpIHtcbiAgICAgICAgICAgIGV4cHIgPSBuZXcgTm9kZSgpO1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICBleHByID0gZXhwci5maW5pc2hTdXBlcigpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaCgnWycpICYmICFtYXRjaCgnLicpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obG9va2FoZWFkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4cHIgPSBpbmhlcml0Q292ZXJHcmFtbWFyKG1hdGNoS2V5d29yZCgnbmV3JykgPyBwYXJzZU5ld0V4cHJlc3Npb24gOiBwYXJzZVByaW1hcnlFeHByZXNzaW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCgnWycpKSB7XG4gICAgICAgICAgICAgICAgaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlzQXNzaWdubWVudFRhcmdldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcHJvcGVydHkgPSBwYXJzZUNvbXB1dGVkTWVtYmVyKCk7XG4gICAgICAgICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikuZmluaXNoTWVtYmVyRXhwcmVzc2lvbignWycsIGV4cHIsIHByb3BlcnR5KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJy4nKSkge1xuICAgICAgICAgICAgICAgIGlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHByb3BlcnR5ID0gcGFyc2VOb25Db21wdXRlZE1lbWJlcigpO1xuICAgICAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaE1lbWJlckV4cHJlc3Npb24oJy4nLCBleHByLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5UZW1wbGF0ZSAmJiBsb29rYWhlYWQuaGVhZCkge1xuICAgICAgICAgICAgICAgIHF1YXNpID0gcGFyc2VUZW1wbGF0ZUxpdGVyYWwoKTtcbiAgICAgICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24oZXhwciwgcXVhc2kpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICAvLyBFQ01BLTI2MiAxMi40IFBvc3RmaXggRXhwcmVzc2lvbnNcblxuICAgIGZ1bmN0aW9uIHBhcnNlUG9zdGZpeEV4cHJlc3Npb24oKSB7XG4gICAgICAgIHZhciBleHByLCB0b2tlbiwgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcblxuICAgICAgICBleHByID0gaW5oZXJpdENvdmVyR3JhbW1hcihwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwpO1xuXG4gICAgICAgIGlmICghaGFzTGluZVRlcm1pbmF0b3IgJiYgbG9va2FoZWFkLnR5cGUgPT09IFRva2VuLlB1bmN0dWF0b3IpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCgnKysnKSB8fCBtYXRjaCgnLS0nKSkge1xuICAgICAgICAgICAgICAgIC8vIEVDTUEtMjYyIDExLjMuMSwgMTEuMy4yXG4gICAgICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBleHByLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyICYmIGlzUmVzdHJpY3RlZFdvcmQoZXhwci5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICB0b2xlcmF0ZUVycm9yKE1lc3NhZ2VzLlN0cmljdExIU1Bvc3RmaXgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghaXNBc3NpZ25tZW50VGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRvbGVyYXRlRXJyb3IoTWVzc2FnZXMuSW52YWxpZExIU0luQXNzaWdubWVudCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0ID0gaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgdG9rZW4gPSBsZXgoKTtcbiAgICAgICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hQb3N0Zml4RXhwcmVzc2lvbih0b2tlbi52YWx1ZSwgZXhwcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICAvLyBFQ01BLTI2MiAxMi41IFVuYXJ5IE9wZXJhdG9yc1xuXG4gICAgZnVuY3Rpb24gcGFyc2VVbmFyeUV4cHJlc3Npb24oKSB7XG4gICAgICAgIHZhciB0b2tlbiwgZXhwciwgc3RhcnRUb2tlbjtcblxuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuLlB1bmN0dWF0b3IgJiYgbG9va2FoZWFkLnR5cGUgIT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICAgIGV4cHIgPSBwYXJzZVBvc3RmaXhFeHByZXNzaW9uKCk7XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJysrJykgfHwgbWF0Y2goJy0tJykpIHtcbiAgICAgICAgICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICAgICAgICB0b2tlbiA9IGxleCgpO1xuICAgICAgICAgICAgZXhwciA9IGluaGVyaXRDb3ZlckdyYW1tYXIocGFyc2VVbmFyeUV4cHJlc3Npb24pO1xuICAgICAgICAgICAgLy8gRUNNQS0yNjIgMTEuNC40LCAxMS40LjVcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgZXhwci50eXBlID09PSBTeW50YXguSWRlbnRpZmllciAmJiBpc1Jlc3RyaWN0ZWRXb3JkKGV4cHIubmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0b2xlcmF0ZUVycm9yKE1lc3NhZ2VzLlN0cmljdExIU1ByZWZpeCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaXNBc3NpZ25tZW50VGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdG9sZXJhdGVFcnJvcihNZXNzYWdlcy5JbnZhbGlkTEhTSW5Bc3NpZ25tZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaFVuYXJ5RXhwcmVzc2lvbih0b2tlbi52YWx1ZSwgZXhwcik7XG4gICAgICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQgPSBpc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJysnKSB8fCBtYXRjaCgnLScpIHx8IG1hdGNoKCd+JykgfHwgbWF0Y2goJyEnKSkge1xuICAgICAgICAgICAgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgICAgIHRva2VuID0gbGV4KCk7XG4gICAgICAgICAgICBleHByID0gaW5oZXJpdENvdmVyR3JhbW1hcihwYXJzZVVuYXJ5RXhwcmVzc2lvbik7XG4gICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hVbmFyeUV4cHJlc3Npb24odG9rZW4udmFsdWUsIGV4cHIpO1xuICAgICAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0ID0gaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoS2V5d29yZCgnZGVsZXRlJykgfHwgbWF0Y2hLZXl3b3JkKCd2b2lkJykgfHwgbWF0Y2hLZXl3b3JkKCd0eXBlb2YnKSkge1xuICAgICAgICAgICAgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgICAgIHRva2VuID0gbGV4KCk7XG4gICAgICAgICAgICBleHByID0gaW5oZXJpdENvdmVyR3JhbW1hcihwYXJzZVVuYXJ5RXhwcmVzc2lvbik7XG4gICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hVbmFyeUV4cHJlc3Npb24odG9rZW4udmFsdWUsIGV4cHIpO1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBleHByLm9wZXJhdG9yID09PSAnZGVsZXRlJyAmJiBleHByLmFyZ3VtZW50LnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgdG9sZXJhdGVFcnJvcihNZXNzYWdlcy5TdHJpY3REZWxldGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0ID0gaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhwciA9IHBhcnNlUG9zdGZpeEV4cHJlc3Npb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJpbmFyeVByZWNlZGVuY2UodG9rZW4sIGFsbG93SW4pIHtcbiAgICAgICAgdmFyIHByZWMgPSAwO1xuXG4gICAgICAgIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5QdW5jdHVhdG9yICYmIHRva2VuLnR5cGUgIT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoICh0b2tlbi52YWx1ZSkge1xuICAgICAgICBjYXNlICd8fCc6XG4gICAgICAgICAgICBwcmVjID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJyYmJzpcbiAgICAgICAgICAgIHByZWMgPSAyO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnfCc6XG4gICAgICAgICAgICBwcmVjID0gMztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ14nOlxuICAgICAgICAgICAgcHJlYyA9IDQ7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICcmJzpcbiAgICAgICAgICAgIHByZWMgPSA1O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnPT0nOlxuICAgICAgICBjYXNlICchPSc6XG4gICAgICAgIGNhc2UgJz09PSc6XG4gICAgICAgIGNhc2UgJyE9PSc6XG4gICAgICAgICAgICBwcmVjID0gNjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJzwnOlxuICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgY2FzZSAnPD0nOlxuICAgICAgICBjYXNlICc+PSc6XG4gICAgICAgIGNhc2UgJ2luc3RhbmNlb2YnOlxuICAgICAgICAgICAgcHJlYyA9IDc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdpbic6XG4gICAgICAgICAgICBwcmVjID0gYWxsb3dJbiA/IDcgOiAwO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnPDwnOlxuICAgICAgICBjYXNlICc+Pic6XG4gICAgICAgIGNhc2UgJz4+Pic6XG4gICAgICAgICAgICBwcmVjID0gODtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJysnOlxuICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgIHByZWMgPSA5O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnKic6XG4gICAgICAgIGNhc2UgJy8nOlxuICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICAgIHByZWMgPSAxMTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcmVjO1xuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyIDEyLjYgTXVsdGlwbGljYXRpdmUgT3BlcmF0b3JzXG4gICAgLy8gRUNNQS0yNjIgMTIuNyBBZGRpdGl2ZSBPcGVyYXRvcnNcbiAgICAvLyBFQ01BLTI2MiAxMi44IEJpdHdpc2UgU2hpZnQgT3BlcmF0b3JzXG4gICAgLy8gRUNNQS0yNjIgMTIuOSBSZWxhdGlvbmFsIE9wZXJhdG9yc1xuICAgIC8vIEVDTUEtMjYyIDEyLjEwIEVxdWFsaXR5IE9wZXJhdG9yc1xuICAgIC8vIEVDTUEtMjYyIDEyLjExIEJpbmFyeSBCaXR3aXNlIE9wZXJhdG9yc1xuICAgIC8vIEVDTUEtMjYyIDEyLjEyIEJpbmFyeSBMb2dpY2FsIE9wZXJhdG9yc1xuXG4gICAgZnVuY3Rpb24gcGFyc2VCaW5hcnlFeHByZXNzaW9uKCkge1xuICAgICAgICB2YXIgbWFya2VyLCBtYXJrZXJzLCBleHByLCB0b2tlbiwgcHJlYywgc3RhY2ssIHJpZ2h0LCBvcGVyYXRvciwgbGVmdCwgaTtcblxuICAgICAgICBtYXJrZXIgPSBsb29rYWhlYWQ7XG4gICAgICAgIGxlZnQgPSBpbmhlcml0Q292ZXJHcmFtbWFyKHBhcnNlVW5hcnlFeHByZXNzaW9uKTtcblxuICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgcHJlYyA9IGJpbmFyeVByZWNlZGVuY2UodG9rZW4sIHN0YXRlLmFsbG93SW4pO1xuICAgICAgICBpZiAocHJlYyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0ID0gaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICB0b2tlbi5wcmVjID0gcHJlYztcbiAgICAgICAgbGV4KCk7XG5cbiAgICAgICAgbWFya2VycyA9IFttYXJrZXIsIGxvb2thaGVhZF07XG4gICAgICAgIHJpZ2h0ID0gaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZVVuYXJ5RXhwcmVzc2lvbik7XG5cbiAgICAgICAgc3RhY2sgPSBbbGVmdCwgdG9rZW4sIHJpZ2h0XTtcblxuICAgICAgICB3aGlsZSAoKHByZWMgPSBiaW5hcnlQcmVjZWRlbmNlKGxvb2thaGVhZCwgc3RhdGUuYWxsb3dJbikpID4gMCkge1xuXG4gICAgICAgICAgICAvLyBSZWR1Y2U6IG1ha2UgYSBiaW5hcnkgZXhwcmVzc2lvbiBmcm9tIHRoZSB0aHJlZSB0b3Btb3N0IGVudHJpZXMuXG4gICAgICAgICAgICB3aGlsZSAoKHN0YWNrLmxlbmd0aCA+IDIpICYmIChwcmVjIDw9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDJdLnByZWMpKSB7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICBvcGVyYXRvciA9IHN0YWNrLnBvcCgpLnZhbHVlO1xuICAgICAgICAgICAgICAgIGxlZnQgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICBtYXJrZXJzLnBvcCgpO1xuICAgICAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKG1hcmtlcnNbbWFya2Vycy5sZW5ndGggLSAxXSkuZmluaXNoQmluYXJ5RXhwcmVzc2lvbihvcGVyYXRvciwgbGVmdCwgcmlnaHQpO1xuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goZXhwcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNoaWZ0LlxuICAgICAgICAgICAgdG9rZW4gPSBsZXgoKTtcbiAgICAgICAgICAgIHRva2VuLnByZWMgPSBwcmVjO1xuICAgICAgICAgICAgc3RhY2sucHVzaCh0b2tlbik7XG4gICAgICAgICAgICBtYXJrZXJzLnB1c2gobG9va2FoZWFkKTtcbiAgICAgICAgICAgIGV4cHIgPSBpc29sYXRlQ292ZXJHcmFtbWFyKHBhcnNlVW5hcnlFeHByZXNzaW9uKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goZXhwcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaW5hbCByZWR1Y2UgdG8gY2xlYW4tdXAgdGhlIHN0YWNrLlxuICAgICAgICBpID0gc3RhY2subGVuZ3RoIC0gMTtcbiAgICAgICAgZXhwciA9IHN0YWNrW2ldO1xuICAgICAgICBtYXJrZXJzLnBvcCgpO1xuICAgICAgICB3aGlsZSAoaSA+IDEpIHtcbiAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKG1hcmtlcnMucG9wKCkpLmZpbmlzaEJpbmFyeUV4cHJlc3Npb24oc3RhY2tbaSAtIDFdLnZhbHVlLCBzdGFja1tpIC0gMl0sIGV4cHIpO1xuICAgICAgICAgICAgaSAtPSAyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuXG5cbiAgICAvLyBFQ01BLTI2MiAxMi4xMyBDb25kaXRpb25hbCBPcGVyYXRvclxuXG4gICAgZnVuY3Rpb24gcGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb24oKSB7XG4gICAgICAgIHZhciBleHByLCBwcmV2aW91c0FsbG93SW4sIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSwgc3RhcnRUb2tlbjtcblxuICAgICAgICBzdGFydFRva2VuID0gbG9va2FoZWFkO1xuXG4gICAgICAgIGV4cHIgPSBpbmhlcml0Q292ZXJHcmFtbWFyKHBhcnNlQmluYXJ5RXhwcmVzc2lvbik7XG4gICAgICAgIGlmIChtYXRjaCgnPycpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIHByZXZpb3VzQWxsb3dJbiA9IHN0YXRlLmFsbG93SW47XG4gICAgICAgICAgICBzdGF0ZS5hbGxvd0luID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnNlcXVlbnQgPSBpc29sYXRlQ292ZXJHcmFtbWFyKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xuICAgICAgICAgICAgc3RhdGUuYWxsb3dJbiA9IHByZXZpb3VzQWxsb3dJbjtcbiAgICAgICAgICAgIGV4cGVjdCgnOicpO1xuICAgICAgICAgICAgYWx0ZXJuYXRlID0gaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcblxuICAgICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikuZmluaXNoQ29uZGl0aW9uYWxFeHByZXNzaW9uKGV4cHIsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSk7XG4gICAgICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQgPSBpc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICAvLyBFQ01BLTI2MiAxNC4yIEFycm93IEZ1bmN0aW9uIERlZmluaXRpb25zXG5cbiAgICBmdW5jdGlvbiBwYXJzZUNvbmNpc2VCb2R5KCkge1xuICAgICAgICBpZiAobWF0Y2goJ3snKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc29sYXRlQ292ZXJHcmFtbWFyKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrUGF0dGVyblBhcmFtKG9wdGlvbnMsIHBhcmFtKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBzd2l0Y2ggKHBhcmFtLnR5cGUpIHtcbiAgICAgICAgY2FzZSBTeW50YXguSWRlbnRpZmllcjpcbiAgICAgICAgICAgIHZhbGlkYXRlUGFyYW0ob3B0aW9ucywgcGFyYW0sIHBhcmFtLm5hbWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU3ludGF4LlJlc3RFbGVtZW50OlxuICAgICAgICAgICAgY2hlY2tQYXR0ZXJuUGFyYW0ob3B0aW9ucywgcGFyYW0uYXJndW1lbnQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU3ludGF4LkFzc2lnbm1lbnRQYXR0ZXJuOlxuICAgICAgICAgICAgY2hlY2tQYXR0ZXJuUGFyYW0ob3B0aW9ucywgcGFyYW0ubGVmdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTeW50YXguQXJyYXlQYXR0ZXJuOlxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhcmFtLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtLmVsZW1lbnRzW2ldICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrUGF0dGVyblBhcmFtKG9wdGlvbnMsIHBhcmFtLmVsZW1lbnRzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTeW50YXguWWllbGRFeHByZXNzaW9uOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBhc3NlcnQocGFyYW0udHlwZSA9PT0gU3ludGF4Lk9iamVjdFBhdHRlcm4sICdJbnZhbGlkIHR5cGUnKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXJhbS5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2hlY2tQYXR0ZXJuUGFyYW0ob3B0aW9ucywgcGFyYW0ucHJvcGVydGllc1tpXS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWludGVycHJldEFzQ292ZXJGb3JtYWxzTGlzdChleHByKSB7XG4gICAgICAgIHZhciBpLCBsZW4sIHBhcmFtLCBwYXJhbXMsIGRlZmF1bHRzLCBkZWZhdWx0Q291bnQsIG9wdGlvbnMsIHRva2VuO1xuXG4gICAgICAgIGRlZmF1bHRzID0gW107XG4gICAgICAgIGRlZmF1bHRDb3VudCA9IDA7XG4gICAgICAgIHBhcmFtcyA9IFtleHByXTtcblxuICAgICAgICBzd2l0Y2ggKGV4cHIudHlwZSkge1xuICAgICAgICBjYXNlIFN5bnRheC5JZGVudGlmaWVyOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgUGxhY2VIb2xkZXJzLkFycm93UGFyYW1ldGVyUGxhY2VIb2xkZXI6XG4gICAgICAgICAgICBwYXJhbXMgPSBleHByLnBhcmFtcztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgcGFyYW1TZXQ6IHt9XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcGFyYW1zLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBwYXJhbSA9IHBhcmFtc1tpXTtcbiAgICAgICAgICAgIHN3aXRjaCAocGFyYW0udHlwZSkge1xuICAgICAgICAgICAgY2FzZSBTeW50YXguQXNzaWdubWVudFBhdHRlcm46XG4gICAgICAgICAgICAgICAgcGFyYW1zW2ldID0gcGFyYW0ubGVmdDtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW0ucmlnaHQudHlwZSA9PT0gU3ludGF4LllpZWxkRXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW0ucmlnaHQuYXJndW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKGxvb2thaGVhZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGFyYW0ucmlnaHQudHlwZSA9IFN5bnRheC5JZGVudGlmaWVyO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbS5yaWdodC5uYW1lID0gJ3lpZWxkJztcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhcmFtLnJpZ2h0LmFyZ3VtZW50O1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcGFyYW0ucmlnaHQuZGVsZWdhdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHRzLnB1c2gocGFyYW0ucmlnaHQpO1xuICAgICAgICAgICAgICAgICsrZGVmYXVsdENvdW50O1xuICAgICAgICAgICAgICAgIGNoZWNrUGF0dGVyblBhcmFtKG9wdGlvbnMsIHBhcmFtLmxlZnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjaGVja1BhdHRlcm5QYXJhbShvcHRpb25zLCBwYXJhbSk7XG4gICAgICAgICAgICAgICAgcGFyYW1zW2ldID0gcGFyYW07XG4gICAgICAgICAgICAgICAgZGVmYXVsdHMucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHJpY3QgfHwgIXN0YXRlLmFsbG93WWllbGQpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHBhcmFtcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIHBhcmFtID0gcGFyYW1zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbS50eXBlID09PSBTeW50YXguWWllbGRFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKGxvb2thaGVhZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMubWVzc2FnZSA9PT0gTWVzc2FnZXMuU3RyaWN0UGFyYW1EdXBlKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHN0cmljdCA/IG9wdGlvbnMuc3RyaWN0ZWQgOiBvcHRpb25zLmZpcnN0UmVzdHJpY3RlZDtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKHRva2VuLCBvcHRpb25zLm1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlZmF1bHRDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgZGVmYXVsdHMgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICAgIGRlZmF1bHRzOiBkZWZhdWx0cyxcbiAgICAgICAgICAgIHN0cmljdGVkOiBvcHRpb25zLnN0cmljdGVkLFxuICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkOiBvcHRpb25zLmZpcnN0UmVzdHJpY3RlZCxcbiAgICAgICAgICAgIG1lc3NhZ2U6IG9wdGlvbnMubWVzc2FnZVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24ob3B0aW9ucywgbm9kZSkge1xuICAgICAgICB2YXIgcHJldmlvdXNTdHJpY3QsIHByZXZpb3VzQWxsb3dZaWVsZCwgYm9keTtcblxuICAgICAgICBpZiAoaGFzTGluZVRlcm1pbmF0b3IpIHtcbiAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKGxvb2thaGVhZCk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwZWN0KCc9PicpO1xuXG4gICAgICAgIHByZXZpb3VzU3RyaWN0ID0gc3RyaWN0O1xuICAgICAgICBwcmV2aW91c0FsbG93WWllbGQgPSBzdGF0ZS5hbGxvd1lpZWxkO1xuICAgICAgICBzdGF0ZS5hbGxvd1lpZWxkID0gdHJ1ZTtcblxuICAgICAgICBib2R5ID0gcGFyc2VDb25jaXNlQm9keSgpO1xuXG4gICAgICAgIGlmIChzdHJpY3QgJiYgb3B0aW9ucy5maXJzdFJlc3RyaWN0ZWQpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKG9wdGlvbnMuZmlyc3RSZXN0cmljdGVkLCBvcHRpb25zLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJpY3QgJiYgb3B0aW9ucy5zdHJpY3RlZCkge1xuICAgICAgICAgICAgdG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4ob3B0aW9ucy5zdHJpY3RlZCwgb3B0aW9ucy5tZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0cmljdCA9IHByZXZpb3VzU3RyaWN0O1xuICAgICAgICBzdGF0ZS5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaEFycm93RnVuY3Rpb25FeHByZXNzaW9uKG9wdGlvbnMucGFyYW1zLCBvcHRpb25zLmRlZmF1bHRzLCBib2R5LCBib2R5LnR5cGUgIT09IFN5bnRheC5CbG9ja1N0YXRlbWVudCk7XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTQuNCBZaWVsZCBleHByZXNzaW9uXG5cbiAgICBmdW5jdGlvbiBwYXJzZVlpZWxkRXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGFyZ3VtZW50LCBleHByLCBkZWxlZ2F0ZSwgcHJldmlvdXNBbGxvd1lpZWxkO1xuXG4gICAgICAgIGFyZ3VtZW50ID0gbnVsbDtcbiAgICAgICAgZXhwciA9IG5ldyBOb2RlKCk7XG4gICAgICAgIGRlbGVnYXRlID0gZmFsc2U7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgneWllbGQnKTtcblxuICAgICAgICBpZiAoIWhhc0xpbmVUZXJtaW5hdG9yKSB7XG4gICAgICAgICAgICBwcmV2aW91c0FsbG93WWllbGQgPSBzdGF0ZS5hbGxvd1lpZWxkO1xuICAgICAgICAgICAgc3RhdGUuYWxsb3dZaWVsZCA9IGZhbHNlO1xuICAgICAgICAgICAgZGVsZWdhdGUgPSBtYXRjaCgnKicpO1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgICAgYXJndW1lbnQgPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2goJzsnKSAmJiAhbWF0Y2goJ30nKSAmJiAhbWF0Y2goJyknKSAmJiBsb29rYWhlYWQudHlwZSAhPT0gVG9rZW4uRU9GKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50ID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRlLmFsbG93WWllbGQgPSBwcmV2aW91c0FsbG93WWllbGQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwci5maW5pc2hZaWVsZEV4cHJlc3Npb24oYXJndW1lbnQsIGRlbGVnYXRlKTtcbiAgICB9XG5cbiAgICAvLyBFQ01BLTI2MiAxMi4xNCBBc3NpZ25tZW50IE9wZXJhdG9yc1xuXG4gICAgZnVuY3Rpb24gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIHRva2VuLCBleHByLCByaWdodCwgbGlzdCwgc3RhcnRUb2tlbjtcblxuICAgICAgICBzdGFydFRva2VuID0gbG9va2FoZWFkO1xuICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDtcblxuICAgICAgICBpZiAoIXN0YXRlLmFsbG93WWllbGQgJiYgbWF0Y2hLZXl3b3JkKCd5aWVsZCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VZaWVsZEV4cHJlc3Npb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV4cHIgPSBwYXJzZUNvbmRpdGlvbmFsRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIGlmIChleHByLnR5cGUgPT09IFBsYWNlSG9sZGVycy5BcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyIHx8IG1hdGNoKCc9PicpKSB7XG4gICAgICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQgPSBpc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICBsaXN0ID0gcmVpbnRlcnByZXRBc0NvdmVyRm9ybWFsc0xpc3QoZXhwcik7XG5cbiAgICAgICAgICAgIGlmIChsaXN0KSB7XG4gICAgICAgICAgICAgICAgZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbihsaXN0LCBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2hBc3NpZ24oKSkge1xuICAgICAgICAgICAgaWYgKCFpc0Fzc2lnbm1lbnRUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0b2xlcmF0ZUVycm9yKE1lc3NhZ2VzLkludmFsaWRMSFNJbkFzc2lnbm1lbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFQ01BLTI2MiAxMi4xLjFcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgZXhwci50eXBlID09PSBTeW50YXguSWRlbnRpZmllcikge1xuICAgICAgICAgICAgICAgIGlmIChpc1Jlc3RyaWN0ZWRXb3JkKGV4cHIubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIE1lc3NhZ2VzLlN0cmljdExIU0Fzc2lnbm1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKGV4cHIubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIE1lc3NhZ2VzLlN0cmljdFJlc2VydmVkV29yZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW1hdGNoKCc9JykpIHtcbiAgICAgICAgICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQgPSBpc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG9rZW4gPSBsZXgoKTtcbiAgICAgICAgICAgIHJpZ2h0ID0gaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcbiAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaEFzc2lnbm1lbnRFeHByZXNzaW9uKHRva2VuLnZhbHVlLCBleHByLCByaWdodCk7XG4gICAgICAgICAgICBmaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTIuMTUgQ29tbWEgT3BlcmF0b3JcblxuICAgIGZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGV4cHIsIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQsIGV4cHJlc3Npb25zO1xuXG4gICAgICAgIGV4cHIgPSBpc29sYXRlQ292ZXJHcmFtbWFyKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xuXG4gICAgICAgIGlmIChtYXRjaCgnLCcpKSB7XG4gICAgICAgICAgICBleHByZXNzaW9ucyA9IFtleHByXTtcblxuICAgICAgICAgICAgd2hpbGUgKHN0YXJ0SW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoKCcsJykpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2goaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaFNlcXVlbmNlRXhwcmVzc2lvbihleHByZXNzaW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICAvLyBFQ01BLTI2MiAxMy4yIEJsb2NrXG5cbiAgICBmdW5jdGlvbiBwYXJzZVN0YXRlbWVudExpc3RJdGVtKCkge1xuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgPT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAobG9va2FoZWFkLnZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlICdleHBvcnQnOlxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zb3VyY2VUeXBlICE9PSAnbW9kdWxlJykge1xuICAgICAgICAgICAgICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihsb29rYWhlYWQsIE1lc3NhZ2VzLklsbGVnYWxFeHBvcnREZWNsYXJhdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUV4cG9ydERlY2xhcmF0aW9uKCk7XG4gICAgICAgICAgICBjYXNlICdpbXBvcnQnOlxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zb3VyY2VUeXBlICE9PSAnbW9kdWxlJykge1xuICAgICAgICAgICAgICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihsb29rYWhlYWQsIE1lc3NhZ2VzLklsbGVnYWxJbXBvcnREZWNsYXJhdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUltcG9ydERlY2xhcmF0aW9uKCk7XG4gICAgICAgICAgICBjYXNlICdjb25zdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlTGV4aWNhbERlY2xhcmF0aW9uKHtpbkZvcjogZmFsc2V9KTtcbiAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uKG5ldyBOb2RlKCkpO1xuICAgICAgICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUNsYXNzRGVjbGFyYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2xldCcpICYmIGlzTGV4aWNhbERlY2xhcmF0aW9uKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUxleGljYWxEZWNsYXJhdGlvbih7aW5Gb3I6IGZhbHNlfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyc2VTdGF0ZW1lbnQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVN0YXRlbWVudExpc3QoKSB7XG4gICAgICAgIHZhciBsaXN0ID0gW107XG4gICAgICAgIHdoaWxlIChzdGFydEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlzdC5wdXNoKHBhcnNlU3RhdGVtZW50TGlzdEl0ZW0oKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUJsb2NrKCkge1xuICAgICAgICB2YXIgYmxvY2ssIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGV4cGVjdCgneycpO1xuXG4gICAgICAgIGJsb2NrID0gcGFyc2VTdGF0ZW1lbnRMaXN0KCk7XG5cbiAgICAgICAgZXhwZWN0KCd9Jyk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoQmxvY2tTdGF0ZW1lbnQoYmxvY2spO1xuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyIDEzLjMuMiBWYXJpYWJsZSBTdGF0ZW1lbnRcblxuICAgIGZ1bmN0aW9uIHBhcnNlVmFyaWFibGVJZGVudGlmaWVyKGtpbmQpIHtcbiAgICAgICAgdmFyIHRva2VuLCBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgICB0b2tlbiA9IGxleCgpO1xuXG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5LZXl3b3JkICYmIHRva2VuLnZhbHVlID09PSAneWllbGQnKSB7XG4gICAgICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgdG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIE1lc3NhZ2VzLlN0cmljdFJlc2VydmVkV29yZCk7XG4gICAgICAgICAgICB9IGlmICghc3RhdGUuYWxsb3dZaWVsZCkge1xuICAgICAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIHRva2VuLnR5cGUgPT09IFRva2VuLktleXdvcmQgJiYgaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBNZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RyaWN0IHx8IHRva2VuLnZhbHVlICE9PSAnbGV0JyB8fCBraW5kICE9PSAndmFyJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLnNvdXJjZVR5cGUgPT09ICdtb2R1bGUnICYmIHRva2VuLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIgJiYgdG9rZW4udmFsdWUgPT09ICdhd2FpdCcpIHtcbiAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaElkZW50aWZpZXIodG9rZW4udmFsdWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBpbml0ID0gbnVsbCwgaWQsIG5vZGUgPSBuZXcgTm9kZSgpLCBwYXJhbXMgPSBbXTtcblxuICAgICAgICBpZCA9IHBhcnNlUGF0dGVybihwYXJhbXMsICd2YXInKTtcblxuICAgICAgICAvLyBFQ01BLTI2MiAxMi4yLjFcbiAgICAgICAgaWYgKHN0cmljdCAmJiBpc1Jlc3RyaWN0ZWRXb3JkKGlkLm5hbWUpKSB7XG4gICAgICAgICAgICB0b2xlcmF0ZUVycm9yKE1lc3NhZ2VzLlN0cmljdFZhck5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoKCc9JykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgaW5pdCA9IGlzb2xhdGVDb3ZlckdyYW1tYXIocGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XG4gICAgICAgIH0gZWxzZSBpZiAoaWQudHlwZSAhPT0gU3ludGF4LklkZW50aWZpZXIgJiYgIW9wdGlvbnMuaW5Gb3IpIHtcbiAgICAgICAgICAgIGV4cGVjdCgnPScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoVmFyaWFibGVEZWNsYXJhdG9yKGlkLCBpbml0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG9wdCwgbGlzdDtcblxuICAgICAgICBvcHQgPSB7IGluRm9yOiBvcHRpb25zLmluRm9yIH07XG4gICAgICAgIGxpc3QgPSBbcGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uKG9wdCldO1xuXG4gICAgICAgIHdoaWxlIChtYXRjaCgnLCcpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIGxpc3QucHVzaChwYXJzZVZhcmlhYmxlRGVjbGFyYXRpb24ob3B0KSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVZhcmlhYmxlU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgdmFyIGRlY2xhcmF0aW9ucztcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCd2YXInKTtcblxuICAgICAgICBkZWNsYXJhdGlvbnMgPSBwYXJzZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KHsgaW5Gb3I6IGZhbHNlIH0pO1xuXG4gICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hWYXJpYWJsZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9ucyk7XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTMuMy4xIExldCBhbmQgQ29uc3QgRGVjbGFyYXRpb25zXG5cbiAgICBmdW5jdGlvbiBwYXJzZUxleGljYWxCaW5kaW5nKGtpbmQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGluaXQgPSBudWxsLCBpZCwgbm9kZSA9IG5ldyBOb2RlKCksIHBhcmFtcyA9IFtdO1xuXG4gICAgICAgIGlkID0gcGFyc2VQYXR0ZXJuKHBhcmFtcywga2luZCk7XG5cbiAgICAgICAgLy8gRUNNQS0yNjIgMTIuMi4xXG4gICAgICAgIGlmIChzdHJpY3QgJiYgaWQudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIgJiYgaXNSZXN0cmljdGVkV29yZChpZC5uYW1lKSkge1xuICAgICAgICAgICAgdG9sZXJhdGVFcnJvcihNZXNzYWdlcy5TdHJpY3RWYXJOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChraW5kID09PSAnY29uc3QnKSB7XG4gICAgICAgICAgICBpZiAoIW1hdGNoS2V5d29yZCgnaW4nKSAmJiAhbWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnb2YnKSkge1xuICAgICAgICAgICAgICAgIGV4cGVjdCgnPScpO1xuICAgICAgICAgICAgICAgIGluaXQgPSBpc29sYXRlQ292ZXJHcmFtbWFyKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCghb3B0aW9ucy5pbkZvciAmJiBpZC50eXBlICE9PSBTeW50YXguSWRlbnRpZmllcikgfHwgbWF0Y2goJz0nKSkge1xuICAgICAgICAgICAgZXhwZWN0KCc9Jyk7XG4gICAgICAgICAgICBpbml0ID0gaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaFZhcmlhYmxlRGVjbGFyYXRvcihpZCwgaW5pdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VCaW5kaW5nTGlzdChraW5kLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBsaXN0ID0gW3BhcnNlTGV4aWNhbEJpbmRpbmcoa2luZCwgb3B0aW9ucyldO1xuXG4gICAgICAgIHdoaWxlIChtYXRjaCgnLCcpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIGxpc3QucHVzaChwYXJzZUxleGljYWxCaW5kaW5nKGtpbmQsIG9wdGlvbnMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gdG9rZW5pemVyU3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICBoYXNMaW5lVGVybWluYXRvcjogaGFzTGluZVRlcm1pbmF0b3IsXG4gICAgICAgICAgICBsYXN0SW5kZXg6IGxhc3RJbmRleCxcbiAgICAgICAgICAgIGxhc3RMaW5lTnVtYmVyOiBsYXN0TGluZU51bWJlcixcbiAgICAgICAgICAgIGxhc3RMaW5lU3RhcnQ6IGxhc3RMaW5lU3RhcnQsXG4gICAgICAgICAgICBzdGFydEluZGV4OiBzdGFydEluZGV4LFxuICAgICAgICAgICAgc3RhcnRMaW5lTnVtYmVyOiBzdGFydExpbmVOdW1iZXIsXG4gICAgICAgICAgICBzdGFydExpbmVTdGFydDogc3RhcnRMaW5lU3RhcnQsXG4gICAgICAgICAgICBsb29rYWhlYWQ6IGxvb2thaGVhZCxcbiAgICAgICAgICAgIHRva2VuQ291bnQ6IGV4dHJhLnRva2VucyA/IGV4dHJhLnRva2Vucy5sZW5ndGggOiAwXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzZXRUb2tlbml6ZXJTdGF0ZSh0cykge1xuICAgICAgICBpbmRleCA9IHRzLmluZGV4O1xuICAgICAgICBsaW5lTnVtYmVyID0gdHMubGluZU51bWJlcjtcbiAgICAgICAgbGluZVN0YXJ0ID0gdHMubGluZVN0YXJ0O1xuICAgICAgICBoYXNMaW5lVGVybWluYXRvciA9IHRzLmhhc0xpbmVUZXJtaW5hdG9yO1xuICAgICAgICBsYXN0SW5kZXggPSB0cy5sYXN0SW5kZXg7XG4gICAgICAgIGxhc3RMaW5lTnVtYmVyID0gdHMubGFzdExpbmVOdW1iZXI7XG4gICAgICAgIGxhc3RMaW5lU3RhcnQgPSB0cy5sYXN0TGluZVN0YXJ0O1xuICAgICAgICBzdGFydEluZGV4ID0gdHMuc3RhcnRJbmRleDtcbiAgICAgICAgc3RhcnRMaW5lTnVtYmVyID0gdHMuc3RhcnRMaW5lTnVtYmVyO1xuICAgICAgICBzdGFydExpbmVTdGFydCA9IHRzLnN0YXJ0TGluZVN0YXJ0O1xuICAgICAgICBsb29rYWhlYWQgPSB0cy5sb29rYWhlYWQ7XG4gICAgICAgIGlmIChleHRyYS50b2tlbnMpIHtcbiAgICAgICAgICAgIGV4dHJhLnRva2Vucy5zcGxpY2UodHMudG9rZW5Db3VudCwgZXh0cmEudG9rZW5zLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0xleGljYWxEZWNsYXJhdGlvbigpIHtcbiAgICAgICAgdmFyIGxleGljYWwsIHRzO1xuXG4gICAgICAgIHRzID0gdG9rZW5pemVyU3RhdGUoKTtcblxuICAgICAgICBsZXgoKTtcbiAgICAgICAgbGV4aWNhbCA9IChsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uSWRlbnRpZmllcikgfHwgbWF0Y2goJ1snKSB8fCBtYXRjaCgneycpIHx8XG4gICAgICAgICAgICBtYXRjaEtleXdvcmQoJ2xldCcpIHx8IG1hdGNoS2V5d29yZCgneWllbGQnKTtcblxuICAgICAgICByZXNldFRva2VuaXplclN0YXRlKHRzKTtcblxuICAgICAgICByZXR1cm4gbGV4aWNhbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUxleGljYWxEZWNsYXJhdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBraW5kLCBkZWNsYXJhdGlvbnMsIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGtpbmQgPSBsZXgoKS52YWx1ZTtcbiAgICAgICAgYXNzZXJ0KGtpbmQgPT09ICdsZXQnIHx8IGtpbmQgPT09ICdjb25zdCcsICdMZXhpY2FsIGRlY2xhcmF0aW9uIG11c3QgYmUgZWl0aGVyIGxldCBvciBjb25zdCcpO1xuXG4gICAgICAgIGRlY2xhcmF0aW9ucyA9IHBhcnNlQmluZGluZ0xpc3Qoa2luZCwgb3B0aW9ucyk7XG5cbiAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaExleGljYWxEZWNsYXJhdGlvbihkZWNsYXJhdGlvbnMsIGtpbmQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlUmVzdEVsZW1lbnQocGFyYW1zKSB7XG4gICAgICAgIHZhciBwYXJhbSwgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgICAgbGV4KCk7XG5cbiAgICAgICAgaWYgKG1hdGNoKCd7JykpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoTWVzc2FnZXMuT2JqZWN0UGF0dGVybkFzUmVzdFBhcmFtZXRlcik7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJhbXMucHVzaChsb29rYWhlYWQpO1xuXG4gICAgICAgIHBhcmFtID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcblxuICAgICAgICBpZiAobWF0Y2goJz0nKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihNZXNzYWdlcy5EZWZhdWx0UmVzdFBhcmFtZXRlcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW1hdGNoKCcpJykpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoTWVzc2FnZXMuUGFyYW1ldGVyQWZ0ZXJSZXN0UGFyYW1ldGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaFJlc3RFbGVtZW50KHBhcmFtKTtcbiAgICB9XG5cbiAgICAvLyBFQ01BLTI2MiAxMy40IEVtcHR5IFN0YXRlbWVudFxuXG4gICAgZnVuY3Rpb24gcGFyc2VFbXB0eVN0YXRlbWVudChub2RlKSB7XG4gICAgICAgIGV4cGVjdCgnOycpO1xuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hFbXB0eVN0YXRlbWVudCgpO1xuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyIDEyLjQgRXhwcmVzc2lvbiBTdGF0ZW1lbnRcblxuICAgIGZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvblN0YXRlbWVudChub2RlKSB7XG4gICAgICAgIHZhciBleHByID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoRXhwcmVzc2lvblN0YXRlbWVudChleHByKTtcbiAgICB9XG5cbiAgICAvLyBFQ01BLTI2MiAxMy42IElmIHN0YXRlbWVudFxuXG4gICAgZnVuY3Rpb24gcGFyc2VJZlN0YXRlbWVudChub2RlKSB7XG4gICAgICAgIHZhciB0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGU7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnaWYnKTtcblxuICAgICAgICBleHBlY3QoJygnKTtcblxuICAgICAgICB0ZXN0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgZXhwZWN0KCcpJyk7XG5cbiAgICAgICAgY29uc2VxdWVudCA9IHBhcnNlU3RhdGVtZW50KCk7XG5cbiAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgnZWxzZScpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIGFsdGVybmF0ZSA9IHBhcnNlU3RhdGVtZW50KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbHRlcm5hdGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoSWZTdGF0ZW1lbnQodGVzdCwgY29uc2VxdWVudCwgYWx0ZXJuYXRlKTtcbiAgICB9XG5cbiAgICAvLyBFQ01BLTI2MiAxMy43IEl0ZXJhdGlvbiBTdGF0ZW1lbnRzXG5cbiAgICBmdW5jdGlvbiBwYXJzZURvV2hpbGVTdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICB2YXIgYm9keSwgdGVzdCwgb2xkSW5JdGVyYXRpb247XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnZG8nKTtcblxuICAgICAgICBvbGRJbkl0ZXJhdGlvbiA9IHN0YXRlLmluSXRlcmF0aW9uO1xuICAgICAgICBzdGF0ZS5pbkl0ZXJhdGlvbiA9IHRydWU7XG5cbiAgICAgICAgYm9keSA9IHBhcnNlU3RhdGVtZW50KCk7XG5cbiAgICAgICAgc3RhdGUuaW5JdGVyYXRpb24gPSBvbGRJbkl0ZXJhdGlvbjtcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCd3aGlsZScpO1xuXG4gICAgICAgIGV4cGVjdCgnKCcpO1xuXG4gICAgICAgIHRlc3QgPSBwYXJzZUV4cHJlc3Npb24oKTtcblxuICAgICAgICBleHBlY3QoJyknKTtcblxuICAgICAgICBpZiAobWF0Y2goJzsnKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hEb1doaWxlU3RhdGVtZW50KGJvZHksIHRlc3QpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlV2hpbGVTdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICB2YXIgdGVzdCwgYm9keSwgb2xkSW5JdGVyYXRpb247XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnd2hpbGUnKTtcblxuICAgICAgICBleHBlY3QoJygnKTtcblxuICAgICAgICB0ZXN0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgZXhwZWN0KCcpJyk7XG5cbiAgICAgICAgb2xkSW5JdGVyYXRpb24gPSBzdGF0ZS5pbkl0ZXJhdGlvbjtcbiAgICAgICAgc3RhdGUuaW5JdGVyYXRpb24gPSB0cnVlO1xuXG4gICAgICAgIGJvZHkgPSBwYXJzZVN0YXRlbWVudCgpO1xuXG4gICAgICAgIHN0YXRlLmluSXRlcmF0aW9uID0gb2xkSW5JdGVyYXRpb247XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoV2hpbGVTdGF0ZW1lbnQodGVzdCwgYm9keSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VGb3JTdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICB2YXIgaW5pdCwgZm9ySW4sIGluaXRTZXEsIGluaXRTdGFydFRva2VuLCB0ZXN0LCB1cGRhdGUsIGxlZnQsIHJpZ2h0LCBraW5kLCBkZWNsYXJhdGlvbnMsXG4gICAgICAgICAgICBib2R5LCBvbGRJbkl0ZXJhdGlvbiwgcHJldmlvdXNBbGxvd0luID0gc3RhdGUuYWxsb3dJbjtcblxuICAgICAgICBpbml0ID0gdGVzdCA9IHVwZGF0ZSA9IG51bGw7XG4gICAgICAgIGZvckluID0gdHJ1ZTtcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCdmb3InKTtcblxuICAgICAgICBleHBlY3QoJygnKTtcblxuICAgICAgICBpZiAobWF0Y2goJzsnKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobWF0Y2hLZXl3b3JkKCd2YXInKSkge1xuICAgICAgICAgICAgICAgIGluaXQgPSBuZXcgTm9kZSgpO1xuICAgICAgICAgICAgICAgIGxleCgpO1xuXG4gICAgICAgICAgICAgICAgc3RhdGUuYWxsb3dJbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9ucyA9IHBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QoeyBpbkZvcjogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5hbGxvd0luID0gcHJldmlvdXNBbGxvd0luO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRlY2xhcmF0aW9ucy5sZW5ndGggPT09IDEgJiYgbWF0Y2hLZXl3b3JkKCdpbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluaXQgPSBpbml0LmZpbmlzaFZhcmlhYmxlRGVjbGFyYXRpb24oZGVjbGFyYXRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBpbml0O1xuICAgICAgICAgICAgICAgICAgICByaWdodCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICAgICAgICBpbml0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRlY2xhcmF0aW9ucy5sZW5ndGggPT09IDEgJiYgZGVjbGFyYXRpb25zWzBdLmluaXQgPT09IG51bGwgJiYgbWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnb2YnKSkge1xuICAgICAgICAgICAgICAgICAgICBpbml0ID0gaW5pdC5maW5pc2hWYXJpYWJsZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gaW5pdDtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGluaXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBmb3JJbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGluaXQgPSBpbml0LmZpbmlzaFZhcmlhYmxlRGVjbGFyYXRpb24oZGVjbGFyYXRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KCc7Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaEtleXdvcmQoJ2NvbnN0JykgfHwgbWF0Y2hLZXl3b3JkKCdsZXQnKSkge1xuICAgICAgICAgICAgICAgIGluaXQgPSBuZXcgTm9kZSgpO1xuICAgICAgICAgICAgICAgIGtpbmQgPSBsZXgoKS52YWx1ZTtcblxuICAgICAgICAgICAgICAgIGlmICghc3RyaWN0ICYmIGxvb2thaGVhZC52YWx1ZSA9PT0gJ2luJykge1xuICAgICAgICAgICAgICAgICAgICBpbml0ID0gaW5pdC5maW5pc2hJZGVudGlmaWVyKGtpbmQpO1xuICAgICAgICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGluaXQ7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGluaXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmFsbG93SW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zID0gcGFyc2VCaW5kaW5nTGlzdChraW5kLCB7aW5Gb3I6IHRydWV9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuYWxsb3dJbiA9IHByZXZpb3VzQWxsb3dJbjtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVjbGFyYXRpb25zLmxlbmd0aCA9PT0gMSAmJiBkZWNsYXJhdGlvbnNbMF0uaW5pdCA9PT0gbnVsbCAmJiBtYXRjaEtleXdvcmQoJ2luJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXQgPSBpbml0LmZpbmlzaExleGljYWxEZWNsYXJhdGlvbihkZWNsYXJhdGlvbnMsIGtpbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gaW5pdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxICYmIGRlY2xhcmF0aW9uc1swXS5pbml0ID09PSBudWxsICYmIG1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ29mJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXQgPSBpbml0LmZpbmlzaExleGljYWxEZWNsYXJhdGlvbihkZWNsYXJhdGlvbnMsIGtpbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gaW5pdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JJbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdCA9IGluaXQuZmluaXNoTGV4aWNhbERlY2xhcmF0aW9uKGRlY2xhcmF0aW9ucywga2luZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGluaXRTdGFydFRva2VuID0gbG9va2FoZWFkO1xuICAgICAgICAgICAgICAgIHN0YXRlLmFsbG93SW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpbml0ID0gaW5oZXJpdENvdmVyR3JhbW1hcihwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5hbGxvd0luID0gcHJldmlvdXNBbGxvd0luO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgnaW4nKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQXNzaWdubWVudFRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9sZXJhdGVFcnJvcihNZXNzYWdlcy5JbnZhbGlkTEhTSW5Gb3JJbik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGluaXQpO1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gaW5pdDtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgICAgICAgaW5pdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaENvbnRleHR1YWxLZXl3b3JkKCdvZicpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNBc3NpZ25tZW50VGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2xlcmF0ZUVycm9yKE1lc3NhZ2VzLkludmFsaWRMSFNJbkZvckxvb3ApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIHJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihpbml0KTtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGluaXQ7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICAgICAgICBpbml0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgZm9ySW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2goJywnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdFNlcSA9IFtpbml0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChtYXRjaCgnLCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdFNlcS5wdXNoKGlzb2xhdGVDb3ZlckdyYW1tYXIocGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdCA9IG5ldyBXcmFwcGluZ05vZGUoaW5pdFN0YXJ0VG9rZW4pLmZpbmlzaFNlcXVlbmNlRXhwcmVzc2lvbihpbml0U2VxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBleHBlY3QoJzsnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGxlZnQgPT09ICd1bmRlZmluZWQnKSB7XG5cbiAgICAgICAgICAgIGlmICghbWF0Y2goJzsnKSkge1xuICAgICAgICAgICAgICAgIHRlc3QgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cGVjdCgnOycpO1xuXG4gICAgICAgICAgICBpZiAoIW1hdGNoKCcpJykpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGUgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICAgIG9sZEluSXRlcmF0aW9uID0gc3RhdGUuaW5JdGVyYXRpb247XG4gICAgICAgIHN0YXRlLmluSXRlcmF0aW9uID0gdHJ1ZTtcblxuICAgICAgICBib2R5ID0gaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZVN0YXRlbWVudCk7XG5cbiAgICAgICAgc3RhdGUuaW5JdGVyYXRpb24gPSBvbGRJbkl0ZXJhdGlvbjtcblxuICAgICAgICByZXR1cm4gKHR5cGVvZiBsZWZ0ID09PSAndW5kZWZpbmVkJykgP1xuICAgICAgICAgICAgICAgIG5vZGUuZmluaXNoRm9yU3RhdGVtZW50KGluaXQsIHRlc3QsIHVwZGF0ZSwgYm9keSkgOlxuICAgICAgICAgICAgICAgIGZvckluID8gbm9kZS5maW5pc2hGb3JJblN0YXRlbWVudChsZWZ0LCByaWdodCwgYm9keSkgOlxuICAgICAgICAgICAgICAgICAgICBub2RlLmZpbmlzaEZvck9mU3RhdGVtZW50KGxlZnQsIHJpZ2h0LCBib2R5KTtcbiAgICB9XG5cbiAgICAvLyBFQ01BLTI2MiAxMy44IFRoZSBjb250aW51ZSBzdGF0ZW1lbnRcblxuICAgIGZ1bmN0aW9uIHBhcnNlQ29udGludWVTdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICB2YXIgbGFiZWwgPSBudWxsLCBrZXk7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnY29udGludWUnKTtcblxuICAgICAgICAvLyBPcHRpbWl6ZSB0aGUgbW9zdCBjb21tb24gZm9ybTogJ2NvbnRpbnVlOycuXG4gICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChzdGFydEluZGV4KSA9PT0gMHgzQikge1xuICAgICAgICAgICAgbGV4KCk7XG5cbiAgICAgICAgICAgIGlmICghc3RhdGUuaW5JdGVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKE1lc3NhZ2VzLklsbGVnYWxDb250aW51ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaENvbnRpbnVlU3RhdGVtZW50KG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc0xpbmVUZXJtaW5hdG9yKSB7XG4gICAgICAgICAgICBpZiAoIXN0YXRlLmluSXRlcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihNZXNzYWdlcy5JbGxlZ2FsQ29udGludWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hDb250aW51ZVN0YXRlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uSWRlbnRpZmllcikge1xuICAgICAgICAgICAgbGFiZWwgPSBwYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xuXG4gICAgICAgICAgICBrZXkgPSAnJCcgKyBsYWJlbC5uYW1lO1xuICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3RhdGUubGFiZWxTZXQsIGtleSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKE1lc3NhZ2VzLlVua25vd25MYWJlbCwgbGFiZWwubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG5cbiAgICAgICAgaWYgKGxhYmVsID09PSBudWxsICYmICFzdGF0ZS5pbkl0ZXJhdGlvbikge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihNZXNzYWdlcy5JbGxlZ2FsQ29udGludWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoQ29udGludWVTdGF0ZW1lbnQobGFiZWwpO1xuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyIDEzLjkgVGhlIGJyZWFrIHN0YXRlbWVudFxuXG4gICAgZnVuY3Rpb24gcGFyc2VCcmVha1N0YXRlbWVudChub2RlKSB7XG4gICAgICAgIHZhciBsYWJlbCA9IG51bGwsIGtleTtcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCdicmVhaycpO1xuXG4gICAgICAgIC8vIENhdGNoIHRoZSB2ZXJ5IGNvbW1vbiBjYXNlIGZpcnN0OiBpbW1lZGlhdGVseSBhIHNlbWljb2xvbiAoVSswMDNCKS5cbiAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KGxhc3RJbmRleCkgPT09IDB4M0IpIHtcbiAgICAgICAgICAgIGxleCgpO1xuXG4gICAgICAgICAgICBpZiAoIShzdGF0ZS5pbkl0ZXJhdGlvbiB8fCBzdGF0ZS5pblN3aXRjaCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKE1lc3NhZ2VzLklsbGVnYWxCcmVhayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaEJyZWFrU3RhdGVtZW50KG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc0xpbmVUZXJtaW5hdG9yKSB7XG4gICAgICAgICAgICBpZiAoIShzdGF0ZS5pbkl0ZXJhdGlvbiB8fCBzdGF0ZS5pblN3aXRjaCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKE1lc3NhZ2VzLklsbGVnYWxCcmVhayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobG9va2FoZWFkLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIGxhYmVsID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcblxuICAgICAgICAgICAga2V5ID0gJyQnICsgbGFiZWwubmFtZTtcbiAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlLmxhYmVsU2V0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihNZXNzYWdlcy5Vbmtub3duTGFiZWwsIGxhYmVsLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuXG4gICAgICAgIGlmIChsYWJlbCA9PT0gbnVsbCAmJiAhKHN0YXRlLmluSXRlcmF0aW9uIHx8IHN0YXRlLmluU3dpdGNoKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihNZXNzYWdlcy5JbGxlZ2FsQnJlYWspO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoQnJlYWtTdGF0ZW1lbnQobGFiZWwpO1xuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyIDEzLjEwIFRoZSByZXR1cm4gc3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZVJldHVyblN0YXRlbWVudChub2RlKSB7XG4gICAgICAgIHZhciBhcmd1bWVudCA9IG51bGw7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgncmV0dXJuJyk7XG5cbiAgICAgICAgaWYgKCFzdGF0ZS5pbkZ1bmN0aW9uQm9keSkge1xuICAgICAgICAgICAgdG9sZXJhdGVFcnJvcihNZXNzYWdlcy5JbGxlZ2FsUmV0dXJuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICdyZXR1cm4nIGZvbGxvd2VkIGJ5IGEgc3BhY2UgYW5kIGFuIGlkZW50aWZpZXIgaXMgdmVyeSBjb21tb24uXG4gICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChsYXN0SW5kZXgpID09PSAweDIwKSB7XG4gICAgICAgICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoc291cmNlLmNoYXJDb2RlQXQobGFzdEluZGV4ICsgMSkpKSB7XG4gICAgICAgICAgICAgICAgYXJndW1lbnQgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoUmV0dXJuU3RhdGVtZW50KGFyZ3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNMaW5lVGVybWluYXRvcikge1xuICAgICAgICAgICAgLy8gSEFDS1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoUmV0dXJuU3RhdGVtZW50KG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtYXRjaCgnOycpKSB7XG4gICAgICAgICAgICBpZiAoIW1hdGNoKCd9JykgJiYgbG9va2FoZWFkLnR5cGUgIT09IFRva2VuLkVPRikge1xuICAgICAgICAgICAgICAgIGFyZ3VtZW50ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoUmV0dXJuU3RhdGVtZW50KGFyZ3VtZW50KTtcbiAgICB9XG5cbiAgICAvLyBFQ01BLTI2MiAxMy4xMSBUaGUgd2l0aCBzdGF0ZW1lbnRcblxuICAgIGZ1bmN0aW9uIHBhcnNlV2l0aFN0YXRlbWVudChub2RlKSB7XG4gICAgICAgIHZhciBvYmplY3QsIGJvZHk7XG5cbiAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgdG9sZXJhdGVFcnJvcihNZXNzYWdlcy5TdHJpY3RNb2RlV2l0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3RLZXl3b3JkKCd3aXRoJyk7XG5cbiAgICAgICAgZXhwZWN0KCcoJyk7XG5cbiAgICAgICAgb2JqZWN0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgZXhwZWN0KCcpJyk7XG5cbiAgICAgICAgYm9keSA9IHBhcnNlU3RhdGVtZW50KCk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoV2l0aFN0YXRlbWVudChvYmplY3QsIGJvZHkpO1xuICAgIH1cblxuICAgIC8vIEVDTUEtMjYyIDEzLjEyIFRoZSBzd2l0Y2ggc3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZVN3aXRjaENhc2UoKSB7XG4gICAgICAgIHZhciB0ZXN0LCBjb25zZXF1ZW50ID0gW10sIHN0YXRlbWVudCwgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgnZGVmYXVsdCcpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIHRlc3QgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhwZWN0S2V5d29yZCgnY2FzZScpO1xuICAgICAgICAgICAgdGVzdCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICB9XG4gICAgICAgIGV4cGVjdCgnOicpO1xuXG4gICAgICAgIHdoaWxlIChzdGFydEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2goJ30nKSB8fCBtYXRjaEtleXdvcmQoJ2RlZmF1bHQnKSB8fCBtYXRjaEtleXdvcmQoJ2Nhc2UnKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGVtZW50ID0gcGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSgpO1xuICAgICAgICAgICAgY29uc2VxdWVudC5wdXNoKHN0YXRlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hTd2l0Y2hDYXNlKHRlc3QsIGNvbnNlcXVlbnQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlU3dpdGNoU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgdmFyIGRpc2NyaW1pbmFudCwgY2FzZXMsIGNsYXVzZSwgb2xkSW5Td2l0Y2gsIGRlZmF1bHRGb3VuZDtcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCdzd2l0Y2gnKTtcblxuICAgICAgICBleHBlY3QoJygnKTtcblxuICAgICAgICBkaXNjcmltaW5hbnQgPSBwYXJzZUV4cHJlc3Npb24oKTtcblxuICAgICAgICBleHBlY3QoJyknKTtcblxuICAgICAgICBleHBlY3QoJ3snKTtcblxuICAgICAgICBjYXNlcyA9IFtdO1xuXG4gICAgICAgIGlmIChtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaFN3aXRjaFN0YXRlbWVudChkaXNjcmltaW5hbnQsIGNhc2VzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9sZEluU3dpdGNoID0gc3RhdGUuaW5Td2l0Y2g7XG4gICAgICAgIHN0YXRlLmluU3dpdGNoID0gdHJ1ZTtcbiAgICAgICAgZGVmYXVsdEZvdW5kID0gZmFsc2U7XG5cbiAgICAgICAgd2hpbGUgKHN0YXJ0SW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGF1c2UgPSBwYXJzZVN3aXRjaENhc2UoKTtcbiAgICAgICAgICAgIGlmIChjbGF1c2UudGVzdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0Rm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihNZXNzYWdlcy5NdWx0aXBsZURlZmF1bHRzSW5Td2l0Y2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0Rm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZXMucHVzaChjbGF1c2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuaW5Td2l0Y2ggPSBvbGRJblN3aXRjaDtcblxuICAgICAgICBleHBlY3QoJ30nKTtcblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hTd2l0Y2hTdGF0ZW1lbnQoZGlzY3JpbWluYW50LCBjYXNlcyk7XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTMuMTQgVGhlIHRocm93IHN0YXRlbWVudFxuXG4gICAgZnVuY3Rpb24gcGFyc2VUaHJvd1N0YXRlbWVudChub2RlKSB7XG4gICAgICAgIHZhciBhcmd1bWVudDtcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCd0aHJvdycpO1xuXG4gICAgICAgIGlmIChoYXNMaW5lVGVybWluYXRvcikge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihNZXNzYWdlcy5OZXdsaW5lQWZ0ZXJUaHJvdyk7XG4gICAgICAgIH1cblxuICAgICAgICBhcmd1bWVudCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hUaHJvd1N0YXRlbWVudChhcmd1bWVudCk7XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTMuMTUgVGhlIHRyeSBzdGF0ZW1lbnRcblxuICAgIGZ1bmN0aW9uIHBhcnNlQ2F0Y2hDbGF1c2UoKSB7XG4gICAgICAgIHZhciBwYXJhbSwgcGFyYW1zID0gW10sIHBhcmFtTWFwID0ge30sIGtleSwgaSwgYm9keSwgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnY2F0Y2gnKTtcblxuICAgICAgICBleHBlY3QoJygnKTtcbiAgICAgICAgaWYgKG1hdGNoKCcpJykpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKGxvb2thaGVhZCk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJhbSA9IHBhcnNlUGF0dGVybihwYXJhbXMpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBrZXkgPSAnJCcgKyBwYXJhbXNbaV0udmFsdWU7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhcmFtTWFwLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgdG9sZXJhdGVFcnJvcihNZXNzYWdlcy5EdXBsaWNhdGVCaW5kaW5nLCBwYXJhbXNbaV0udmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyYW1NYXBba2V5XSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFQ01BLTI2MiAxMi4xNC4xXG4gICAgICAgIGlmIChzdHJpY3QgJiYgaXNSZXN0cmljdGVkV29yZChwYXJhbS5uYW1lKSkge1xuICAgICAgICAgICAgdG9sZXJhdGVFcnJvcihNZXNzYWdlcy5TdHJpY3RDYXRjaFZhcmlhYmxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGVjdCgnKScpO1xuICAgICAgICBib2R5ID0gcGFyc2VCbG9jaygpO1xuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hDYXRjaENsYXVzZShwYXJhbSwgYm9keSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VUcnlTdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICB2YXIgYmxvY2ssIGhhbmRsZXIgPSBudWxsLCBmaW5hbGl6ZXIgPSBudWxsO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ3RyeScpO1xuXG4gICAgICAgIGJsb2NrID0gcGFyc2VCbG9jaygpO1xuXG4gICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2NhdGNoJykpIHtcbiAgICAgICAgICAgIGhhbmRsZXIgPSBwYXJzZUNhdGNoQ2xhdXNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2hLZXl3b3JkKCdmaW5hbGx5JykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgZmluYWxpemVyID0gcGFyc2VCbG9jaygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFoYW5kbGVyICYmICFmaW5hbGl6ZXIpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoTWVzc2FnZXMuTm9DYXRjaE9yRmluYWxseSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hUcnlTdGF0ZW1lbnQoYmxvY2ssIGhhbmRsZXIsIGZpbmFsaXplcik7XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTMuMTYgVGhlIGRlYnVnZ2VyIHN0YXRlbWVudFxuXG4gICAgZnVuY3Rpb24gcGFyc2VEZWJ1Z2dlclN0YXRlbWVudChub2RlKSB7XG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2RlYnVnZ2VyJyk7XG5cbiAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaERlYnVnZ2VyU3RhdGVtZW50KCk7XG4gICAgfVxuXG4gICAgLy8gMTMgU3RhdGVtZW50c1xuXG4gICAgZnVuY3Rpb24gcGFyc2VTdGF0ZW1lbnQoKSB7XG4gICAgICAgIHZhciB0eXBlID0gbG9va2FoZWFkLnR5cGUsXG4gICAgICAgICAgICBleHByLFxuICAgICAgICAgICAgbGFiZWxlZEJvZHksXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBub2RlO1xuXG4gICAgICAgIGlmICh0eXBlID09PSBUb2tlbi5FT0YpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKGxvb2thaGVhZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZSA9PT0gVG9rZW4uUHVuY3R1YXRvciAmJiBsb29rYWhlYWQudmFsdWUgPT09ICd7Jykge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlQmxvY2soKTtcbiAgICAgICAgfVxuICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQgPSBpc0JpbmRpbmdFbGVtZW50ID0gdHJ1ZTtcbiAgICAgICAgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IFRva2VuLlB1bmN0dWF0b3IpIHtcbiAgICAgICAgICAgIHN3aXRjaCAobG9va2FoZWFkLnZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlICc7JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VFbXB0eVN0YXRlbWVudChub2RlKTtcbiAgICAgICAgICAgIGNhc2UgJygnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAobG9va2FoZWFkLnZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlICdicmVhayc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlQnJlYWtTdGF0ZW1lbnQobm9kZSk7XG4gICAgICAgICAgICBjYXNlICdjb250aW51ZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlQ29udGludWVTdGF0ZW1lbnQobm9kZSk7XG4gICAgICAgICAgICBjYXNlICdkZWJ1Z2dlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRGVidWdnZXJTdGF0ZW1lbnQobm9kZSk7XG4gICAgICAgICAgICBjYXNlICdkbyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRG9XaGlsZVN0YXRlbWVudChub2RlKTtcbiAgICAgICAgICAgIGNhc2UgJ2Zvcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRm9yU3RhdGVtZW50KG5vZGUpO1xuICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24obm9kZSk7XG4gICAgICAgICAgICBjYXNlICdpZic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSWZTdGF0ZW1lbnQobm9kZSk7XG4gICAgICAgICAgICBjYXNlICdyZXR1cm4nOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVJldHVyblN0YXRlbWVudChub2RlKTtcbiAgICAgICAgICAgIGNhc2UgJ3N3aXRjaCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlU3dpdGNoU3RhdGVtZW50KG5vZGUpO1xuICAgICAgICAgICAgY2FzZSAndGhyb3cnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVRocm93U3RhdGVtZW50KG5vZGUpO1xuICAgICAgICAgICAgY2FzZSAndHJ5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VUcnlTdGF0ZW1lbnQobm9kZSk7XG4gICAgICAgICAgICBjYXNlICd2YXInOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVZhcmlhYmxlU3RhdGVtZW50KG5vZGUpO1xuICAgICAgICAgICAgY2FzZSAnd2hpbGUnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVdoaWxlU3RhdGVtZW50KG5vZGUpO1xuICAgICAgICAgICAgY2FzZSAnd2l0aCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlV2l0aFN0YXRlbWVudChub2RlKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHByID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgLy8gRUNNQS0yNjIgMTIuMTIgTGFiZWxsZWQgU3RhdGVtZW50c1xuICAgICAgICBpZiAoKGV4cHIudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIpICYmIG1hdGNoKCc6JykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuXG4gICAgICAgICAgICBrZXkgPSAnJCcgKyBleHByLm5hbWU7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlLmxhYmVsU2V0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihNZXNzYWdlcy5SZWRlY2xhcmF0aW9uLCAnTGFiZWwnLCBleHByLm5hbWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGF0ZS5sYWJlbFNldFtrZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIGxhYmVsZWRCb2R5ID0gcGFyc2VTdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5sYWJlbFNldFtrZXldO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoTGFiZWxlZFN0YXRlbWVudChleHByLCBsYWJlbGVkQm9keSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoRXhwcmVzc2lvblN0YXRlbWVudChleHByKTtcbiAgICB9XG5cbiAgICAvLyBFQ01BLTI2MiAxNC4xIEZ1bmN0aW9uIERlZmluaXRpb25cblxuICAgIGZ1bmN0aW9uIHBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cygpIHtcbiAgICAgICAgdmFyIHN0YXRlbWVudCwgYm9keSA9IFtdLCB0b2tlbiwgZGlyZWN0aXZlLCBmaXJzdFJlc3RyaWN0ZWQsXG4gICAgICAgICAgICBvbGRMYWJlbFNldCwgb2xkSW5JdGVyYXRpb24sIG9sZEluU3dpdGNoLCBvbGRJbkZ1bmN0aW9uQm9keSxcbiAgICAgICAgICAgIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGV4cGVjdCgneycpO1xuXG4gICAgICAgIHdoaWxlIChzdGFydEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuLlN0cmluZ0xpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRva2VuID0gbG9va2FoZWFkO1xuXG4gICAgICAgICAgICBzdGF0ZW1lbnQgPSBwYXJzZVN0YXRlbWVudExpc3RJdGVtKCk7XG4gICAgICAgICAgICBib2R5LnB1c2goc3RhdGVtZW50KTtcbiAgICAgICAgICAgIGlmIChzdGF0ZW1lbnQuZXhwcmVzc2lvbi50eXBlICE9PSBTeW50YXguTGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgbm90IGRpcmVjdGl2ZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlyZWN0aXZlID0gc291cmNlLnNsaWNlKHRva2VuLnN0YXJ0ICsgMSwgdG9rZW4uZW5kIC0gMSk7XG4gICAgICAgICAgICBpZiAoZGlyZWN0aXZlID09PSAndXNlIHN0cmljdCcpIHtcbiAgICAgICAgICAgICAgICBzdHJpY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdFJlc3RyaWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4oZmlyc3RSZXN0cmljdGVkLCBNZXNzYWdlcy5TdHJpY3RPY3RhbExpdGVyYWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmaXJzdFJlc3RyaWN0ZWQgJiYgdG9rZW4ub2N0YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG9rZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb2xkTGFiZWxTZXQgPSBzdGF0ZS5sYWJlbFNldDtcbiAgICAgICAgb2xkSW5JdGVyYXRpb24gPSBzdGF0ZS5pbkl0ZXJhdGlvbjtcbiAgICAgICAgb2xkSW5Td2l0Y2ggPSBzdGF0ZS5pblN3aXRjaDtcbiAgICAgICAgb2xkSW5GdW5jdGlvbkJvZHkgPSBzdGF0ZS5pbkZ1bmN0aW9uQm9keTtcblxuICAgICAgICBzdGF0ZS5sYWJlbFNldCA9IHt9O1xuICAgICAgICBzdGF0ZS5pbkl0ZXJhdGlvbiA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5pblN3aXRjaCA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5pbkZ1bmN0aW9uQm9keSA9IHRydWU7XG5cbiAgICAgICAgd2hpbGUgKHN0YXJ0SW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib2R5LnB1c2gocGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGVjdCgnfScpO1xuXG4gICAgICAgIHN0YXRlLmxhYmVsU2V0ID0gb2xkTGFiZWxTZXQ7XG4gICAgICAgIHN0YXRlLmluSXRlcmF0aW9uID0gb2xkSW5JdGVyYXRpb247XG4gICAgICAgIHN0YXRlLmluU3dpdGNoID0gb2xkSW5Td2l0Y2g7XG4gICAgICAgIHN0YXRlLmluRnVuY3Rpb25Cb2R5ID0gb2xkSW5GdW5jdGlvbkJvZHk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoQmxvY2tTdGF0ZW1lbnQoYm9keSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVQYXJhbShvcHRpb25zLCBwYXJhbSwgbmFtZSkge1xuICAgICAgICB2YXIga2V5ID0gJyQnICsgbmFtZTtcbiAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgaWYgKGlzUmVzdHJpY3RlZFdvcmQobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnN0cmljdGVkID0gcGFyYW07XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5tZXNzYWdlID0gTWVzc2FnZXMuU3RyaWN0UGFyYW1OYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLnBhcmFtU2V0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zdHJpY3RlZCA9IHBhcmFtO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMubWVzc2FnZSA9IE1lc3NhZ2VzLlN0cmljdFBhcmFtRHVwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghb3B0aW9ucy5maXJzdFJlc3RyaWN0ZWQpIHtcbiAgICAgICAgICAgIGlmIChpc1Jlc3RyaWN0ZWRXb3JkKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5maXJzdFJlc3RyaWN0ZWQgPSBwYXJhbTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLm1lc3NhZ2UgPSBNZXNzYWdlcy5TdHJpY3RQYXJhbU5hbWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZChuYW1lKSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZmlyc3RSZXN0cmljdGVkID0gcGFyYW07XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5tZXNzYWdlID0gTWVzc2FnZXMuU3RyaWN0UmVzZXJ2ZWRXb3JkO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucy5wYXJhbVNldCwga2V5KSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuc3RyaWN0ZWQgPSBwYXJhbTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLm1lc3NhZ2UgPSBNZXNzYWdlcy5TdHJpY3RQYXJhbUR1cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy5wYXJhbVNldFtrZXldID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVBhcmFtKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHRva2VuLCBwYXJhbSwgcGFyYW1zID0gW10sIGksIGRlZjtcblxuICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgaWYgKHRva2VuLnZhbHVlID09PSAnLi4uJykge1xuICAgICAgICAgICAgcGFyYW0gPSBwYXJzZVJlc3RFbGVtZW50KHBhcmFtcyk7XG4gICAgICAgICAgICB2YWxpZGF0ZVBhcmFtKG9wdGlvbnMsIHBhcmFtLmFyZ3VtZW50LCBwYXJhbS5hcmd1bWVudC5uYW1lKTtcbiAgICAgICAgICAgIG9wdGlvbnMucGFyYW1zLnB1c2gocGFyYW0pO1xuICAgICAgICAgICAgb3B0aW9ucy5kZWZhdWx0cy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyYW0gPSBwYXJzZVBhdHRlcm5XaXRoRGVmYXVsdChwYXJhbXMpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZVBhcmFtKG9wdGlvbnMsIHBhcmFtc1tpXSwgcGFyYW1zW2ldLnZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJhbS50eXBlID09PSBTeW50YXguQXNzaWdubWVudFBhdHRlcm4pIHtcbiAgICAgICAgICAgIGRlZiA9IHBhcmFtLnJpZ2h0O1xuICAgICAgICAgICAgcGFyYW0gPSBwYXJhbS5sZWZ0O1xuICAgICAgICAgICAgKytvcHRpb25zLmRlZmF1bHRDb3VudDtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMucGFyYW1zLnB1c2gocGFyYW0pO1xuICAgICAgICBvcHRpb25zLmRlZmF1bHRzLnB1c2goZGVmKTtcblxuICAgICAgICByZXR1cm4gIW1hdGNoKCcpJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VQYXJhbXMoZmlyc3RSZXN0cmljdGVkKSB7XG4gICAgICAgIHZhciBvcHRpb25zO1xuXG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBwYXJhbXM6IFtdLFxuICAgICAgICAgICAgZGVmYXVsdENvdW50OiAwLFxuICAgICAgICAgICAgZGVmYXVsdHM6IFtdLFxuICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkOiBmaXJzdFJlc3RyaWN0ZWRcbiAgICAgICAgfTtcblxuICAgICAgICBleHBlY3QoJygnKTtcblxuICAgICAgICBpZiAoIW1hdGNoKCcpJykpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucGFyYW1TZXQgPSB7fTtcbiAgICAgICAgICAgIHdoaWxlIChzdGFydEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJzZVBhcmFtKG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleHBlY3QoJywnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgb3B0aW9ucy5kZWZhdWx0cyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhcmFtczogb3B0aW9ucy5wYXJhbXMsXG4gICAgICAgICAgICBkZWZhdWx0czogb3B0aW9ucy5kZWZhdWx0cyxcbiAgICAgICAgICAgIHN0cmljdGVkOiBvcHRpb25zLnN0cmljdGVkLFxuICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkOiBvcHRpb25zLmZpcnN0UmVzdHJpY3RlZCxcbiAgICAgICAgICAgIG1lc3NhZ2U6IG9wdGlvbnMubWVzc2FnZVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbihub2RlLCBpZGVudGlmaWVySXNPcHRpb25hbCkge1xuICAgICAgICB2YXIgaWQgPSBudWxsLCBwYXJhbXMgPSBbXSwgZGVmYXVsdHMgPSBbXSwgYm9keSwgdG9rZW4sIHN0cmljdGVkLCB0bXAsIGZpcnN0UmVzdHJpY3RlZCwgbWVzc2FnZSwgcHJldmlvdXNTdHJpY3QsXG4gICAgICAgICAgICBpc0dlbmVyYXRvciwgcHJldmlvdXNBbGxvd1lpZWxkO1xuXG4gICAgICAgIHByZXZpb3VzQWxsb3dZaWVsZCA9IHN0YXRlLmFsbG93WWllbGQ7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnZnVuY3Rpb24nKTtcblxuICAgICAgICBpc0dlbmVyYXRvciA9IG1hdGNoKCcqJyk7XG4gICAgICAgIGlmIChpc0dlbmVyYXRvcikge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlkZW50aWZpZXJJc09wdGlvbmFsIHx8ICFtYXRjaCgnKCcpKSB7XG4gICAgICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgICAgIGlkID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcbiAgICAgICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZXN0cmljdGVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIE1lc3NhZ2VzLlN0cmljdEZ1bmN0aW9uTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZXN0cmljdGVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBNZXNzYWdlcy5TdHJpY3RGdW5jdGlvbk5hbWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gTWVzc2FnZXMuU3RyaWN0UmVzZXJ2ZWRXb3JkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmFsbG93WWllbGQgPSAhaXNHZW5lcmF0b3I7XG4gICAgICAgIHRtcCA9IHBhcnNlUGFyYW1zKGZpcnN0UmVzdHJpY3RlZCk7XG4gICAgICAgIHBhcmFtcyA9IHRtcC5wYXJhbXM7XG4gICAgICAgIGRlZmF1bHRzID0gdG1wLmRlZmF1bHRzO1xuICAgICAgICBzdHJpY3RlZCA9IHRtcC5zdHJpY3RlZDtcbiAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG1wLmZpcnN0UmVzdHJpY3RlZDtcbiAgICAgICAgaWYgKHRtcC5tZXNzYWdlKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gdG1wLm1lc3NhZ2U7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHByZXZpb3VzU3RyaWN0ID0gc3RyaWN0O1xuICAgICAgICBib2R5ID0gcGFyc2VGdW5jdGlvblNvdXJjZUVsZW1lbnRzKCk7XG4gICAgICAgIGlmIChzdHJpY3QgJiYgZmlyc3RSZXN0cmljdGVkKSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbihmaXJzdFJlc3RyaWN0ZWQsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJpY3QgJiYgc3RyaWN0ZWQpIHtcbiAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHN0cmljdGVkLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0cmljdCA9IHByZXZpb3VzU3RyaWN0O1xuICAgICAgICBzdGF0ZS5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaEZ1bmN0aW9uRGVjbGFyYXRpb24oaWQsIHBhcmFtcywgZGVmYXVsdHMsIGJvZHksIGlzR2VuZXJhdG9yKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUZ1bmN0aW9uRXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIHRva2VuLCBpZCA9IG51bGwsIHN0cmljdGVkLCBmaXJzdFJlc3RyaWN0ZWQsIG1lc3NhZ2UsIHRtcCxcbiAgICAgICAgICAgIHBhcmFtcyA9IFtdLCBkZWZhdWx0cyA9IFtdLCBib2R5LCBwcmV2aW91c1N0cmljdCwgbm9kZSA9IG5ldyBOb2RlKCksXG4gICAgICAgICAgICBpc0dlbmVyYXRvciwgcHJldmlvdXNBbGxvd1lpZWxkO1xuXG4gICAgICAgIHByZXZpb3VzQWxsb3dZaWVsZCA9IHN0YXRlLmFsbG93WWllbGQ7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnZnVuY3Rpb24nKTtcblxuICAgICAgICBpc0dlbmVyYXRvciA9IG1hdGNoKCcqJyk7XG4gICAgICAgIGlmIChpc0dlbmVyYXRvcikge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5hbGxvd1lpZWxkID0gIWlzR2VuZXJhdG9yO1xuICAgICAgICBpZiAoIW1hdGNoKCcoJykpIHtcbiAgICAgICAgICAgIHRva2VuID0gbG9va2FoZWFkO1xuICAgICAgICAgICAgaWQgPSAoIXN0cmljdCAmJiAhaXNHZW5lcmF0b3IgJiYgbWF0Y2hLZXl3b3JkKCd5aWVsZCcpKSA/IHBhcnNlTm9uQ29tcHV0ZWRQcm9wZXJ0eSgpIDogcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcbiAgICAgICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZXN0cmljdGVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIE1lc3NhZ2VzLlN0cmljdEZ1bmN0aW9uTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZXN0cmljdGVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBNZXNzYWdlcy5TdHJpY3RGdW5jdGlvbk5hbWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gTWVzc2FnZXMuU3RyaWN0UmVzZXJ2ZWRXb3JkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRtcCA9IHBhcnNlUGFyYW1zKGZpcnN0UmVzdHJpY3RlZCk7XG4gICAgICAgIHBhcmFtcyA9IHRtcC5wYXJhbXM7XG4gICAgICAgIGRlZmF1bHRzID0gdG1wLmRlZmF1bHRzO1xuICAgICAgICBzdHJpY3RlZCA9IHRtcC5zdHJpY3RlZDtcbiAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG1wLmZpcnN0UmVzdHJpY3RlZDtcbiAgICAgICAgaWYgKHRtcC5tZXNzYWdlKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gdG1wLm1lc3NhZ2U7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2aW91c1N0cmljdCA9IHN0cmljdDtcbiAgICAgICAgYm9keSA9IHBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cygpO1xuICAgICAgICBpZiAoc3RyaWN0ICYmIGZpcnN0UmVzdHJpY3RlZCkge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4oZmlyc3RSZXN0cmljdGVkLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyaWN0ICYmIHN0cmljdGVkKSB7XG4gICAgICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihzdHJpY3RlZCwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyaWN0ID0gcHJldmlvdXNTdHJpY3Q7XG4gICAgICAgIHN0YXRlLmFsbG93WWllbGQgPSBwcmV2aW91c0FsbG93WWllbGQ7XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoRnVuY3Rpb25FeHByZXNzaW9uKGlkLCBwYXJhbXMsIGRlZmF1bHRzLCBib2R5LCBpc0dlbmVyYXRvcik7XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTQuNSBDbGFzcyBEZWZpbml0aW9uc1xuXG4gICAgZnVuY3Rpb24gcGFyc2VDbGFzc0JvZHkoKSB7XG4gICAgICAgIHZhciBjbGFzc0JvZHksIHRva2VuLCBpc1N0YXRpYywgaGFzQ29uc3RydWN0b3IgPSBmYWxzZSwgYm9keSwgbWV0aG9kLCBjb21wdXRlZCwga2V5O1xuXG4gICAgICAgIGNsYXNzQm9keSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgICAgZXhwZWN0KCd7Jyk7XG4gICAgICAgIGJvZHkgPSBbXTtcbiAgICAgICAgd2hpbGUgKCFtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2goJzsnKSkge1xuICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXRob2QgPSBuZXcgTm9kZSgpO1xuICAgICAgICAgICAgICAgIHRva2VuID0gbG9va2FoZWFkO1xuICAgICAgICAgICAgICAgIGlzU3RhdGljID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29tcHV0ZWQgPSBtYXRjaCgnWycpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCgnKicpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IHBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleS5uYW1lID09PSAnc3RhdGljJyAmJiAobG9va2FoZWFkUHJvcGVydHlOYW1lKCkgfHwgbWF0Y2goJyonKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gbG9va2FoZWFkO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNTdGF0aWMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWQgPSBtYXRjaCgnWycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKCcqJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gcGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1ldGhvZCA9IHRyeVBhcnNlTWV0aG9kRGVmaW5pdGlvbih0b2tlbiwga2V5LCBjb21wdXRlZCwgbWV0aG9kKTtcbiAgICAgICAgICAgICAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZFsnc3RhdGljJ10gPSBpc1N0YXRpYzsgLy8ganNjczppZ25vcmUgcmVxdWlyZURvdE5vdGF0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2Qua2luZCA9PT0gJ2luaXQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Qua2luZCA9ICdtZXRob2QnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNTdGF0aWMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWV0aG9kLmNvbXB1dGVkICYmIChtZXRob2Qua2V5Lm5hbWUgfHwgbWV0aG9kLmtleS52YWx1ZS50b1N0cmluZygpKSA9PT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2Qua2luZCAhPT0gJ21ldGhvZCcgfHwgIW1ldGhvZC5tZXRob2QgfHwgbWV0aG9kLnZhbHVlLmdlbmVyYXRvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbiwgTWVzc2FnZXMuQ29uc3RydWN0b3JTcGVjaWFsTWV0aG9kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0NvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKHRva2VuLCBNZXNzYWdlcy5EdXBsaWNhdGVDb25zdHJ1Y3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzQ29uc3RydWN0b3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Qua2luZCA9ICdjb25zdHJ1Y3Rvcic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1ldGhvZC5jb21wdXRlZCAmJiAobWV0aG9kLmtleS5uYW1lIHx8IG1ldGhvZC5rZXkudmFsdWUudG9TdHJpbmcoKSkgPT09ICdwcm90b3R5cGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4sIE1lc3NhZ2VzLlN0YXRpY1Byb3RvdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kLnR5cGUgPSBTeW50YXguTWV0aG9kRGVmaW5pdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG1ldGhvZC5tZXRob2Q7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBtZXRob2Quc2hvcnRoYW5kO1xuICAgICAgICAgICAgICAgICAgICBib2R5LnB1c2gobWV0aG9kKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbihsb29rYWhlYWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXgoKTtcbiAgICAgICAgcmV0dXJuIGNsYXNzQm9keS5maW5pc2hDbGFzc0JvZHkoYm9keSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VDbGFzc0RlY2xhcmF0aW9uKGlkZW50aWZpZXJJc09wdGlvbmFsKSB7XG4gICAgICAgIHZhciBpZCA9IG51bGwsIHN1cGVyQ2xhc3MgPSBudWxsLCBjbGFzc05vZGUgPSBuZXcgTm9kZSgpLCBjbGFzc0JvZHksIHByZXZpb3VzU3RyaWN0ID0gc3RyaWN0O1xuICAgICAgICBzdHJpY3QgPSB0cnVlO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2NsYXNzJyk7XG5cbiAgICAgICAgaWYgKCFpZGVudGlmaWVySXNPcHRpb25hbCB8fCBsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uSWRlbnRpZmllcikge1xuICAgICAgICAgICAgaWQgPSBwYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgnZXh0ZW5kcycpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIHN1cGVyQ2xhc3MgPSBpc29sYXRlQ292ZXJHcmFtbWFyKHBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbkFsbG93Q2FsbCk7XG4gICAgICAgIH1cbiAgICAgICAgY2xhc3NCb2R5ID0gcGFyc2VDbGFzc0JvZHkoKTtcbiAgICAgICAgc3RyaWN0ID0gcHJldmlvdXNTdHJpY3Q7XG5cbiAgICAgICAgcmV0dXJuIGNsYXNzTm9kZS5maW5pc2hDbGFzc0RlY2xhcmF0aW9uKGlkLCBzdXBlckNsYXNzLCBjbGFzc0JvZHkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlQ2xhc3NFeHByZXNzaW9uKCkge1xuICAgICAgICB2YXIgaWQgPSBudWxsLCBzdXBlckNsYXNzID0gbnVsbCwgY2xhc3NOb2RlID0gbmV3IE5vZGUoKSwgY2xhc3NCb2R5LCBwcmV2aW91c1N0cmljdCA9IHN0cmljdDtcbiAgICAgICAgc3RyaWN0ID0gdHJ1ZTtcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCdjbGFzcycpO1xuXG4gICAgICAgIGlmIChsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uSWRlbnRpZmllcikge1xuICAgICAgICAgICAgaWQgPSBwYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgnZXh0ZW5kcycpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIHN1cGVyQ2xhc3MgPSBpc29sYXRlQ292ZXJHcmFtbWFyKHBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbkFsbG93Q2FsbCk7XG4gICAgICAgIH1cbiAgICAgICAgY2xhc3NCb2R5ID0gcGFyc2VDbGFzc0JvZHkoKTtcbiAgICAgICAgc3RyaWN0ID0gcHJldmlvdXNTdHJpY3Q7XG5cbiAgICAgICAgcmV0dXJuIGNsYXNzTm9kZS5maW5pc2hDbGFzc0V4cHJlc3Npb24oaWQsIHN1cGVyQ2xhc3MsIGNsYXNzQm9keSk7XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTUuMiBNb2R1bGVzXG5cbiAgICBmdW5jdGlvbiBwYXJzZU1vZHVsZVNwZWNpZmllcigpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGlmIChsb29rYWhlYWQudHlwZSAhPT0gVG9rZW4uU3RyaW5nTGl0ZXJhbCkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihNZXNzYWdlcy5JbnZhbGlkTW9kdWxlU3BlY2lmaWVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hMaXRlcmFsKGxleCgpKTtcbiAgICB9XG5cbiAgICAvLyBFQ01BLTI2MiAxNS4yLjMgRXhwb3J0c1xuXG4gICAgZnVuY3Rpb24gcGFyc2VFeHBvcnRTcGVjaWZpZXIoKSB7XG4gICAgICAgIHZhciBleHBvcnRlZCwgbG9jYWwsIG5vZGUgPSBuZXcgTm9kZSgpLCBkZWY7XG4gICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2RlZmF1bHQnKSkge1xuICAgICAgICAgICAgLy8gZXhwb3J0IHtkZWZhdWx0fSBmcm9tICdzb21ldGhpbmcnO1xuICAgICAgICAgICAgZGVmID0gbmV3IE5vZGUoKTtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgbG9jYWwgPSBkZWYuZmluaXNoSWRlbnRpZmllcignZGVmYXVsdCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9jYWwgPSBwYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaENvbnRleHR1YWxLZXl3b3JkKCdhcycpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIGV4cG9ydGVkID0gcGFyc2VOb25Db21wdXRlZFByb3BlcnR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoRXhwb3J0U3BlY2lmaWVyKGxvY2FsLCBleHBvcnRlZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VFeHBvcnROYW1lZERlY2xhcmF0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIGRlY2xhcmF0aW9uID0gbnVsbCxcbiAgICAgICAgICAgIGlzRXhwb3J0RnJvbUlkZW50aWZpZXIsXG4gICAgICAgICAgICBzcmMgPSBudWxsLCBzcGVjaWZpZXJzID0gW107XG5cbiAgICAgICAgLy8gbm9uLWRlZmF1bHQgZXhwb3J0XG4gICAgICAgIGlmIChsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uS2V5d29yZCkge1xuICAgICAgICAgICAgLy8gY292ZXJzOlxuICAgICAgICAgICAgLy8gZXhwb3J0IHZhciBmID0gMTtcbiAgICAgICAgICAgIHN3aXRjaCAobG9va2FoZWFkLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnbGV0JzpcbiAgICAgICAgICAgICAgICBjYXNlICdjb25zdCc6XG4gICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uID0gcGFyc2VMZXhpY2FsRGVjbGFyYXRpb24oe2luRm9yOiBmYWxzZX0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hFeHBvcnROYW1lZERlY2xhcmF0aW9uKGRlY2xhcmF0aW9uLCBzcGVjaWZpZXJzLCBudWxsKTtcbiAgICAgICAgICAgICAgICBjYXNlICd2YXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uID0gcGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hFeHBvcnROYW1lZERlY2xhcmF0aW9uKGRlY2xhcmF0aW9uLCBzcGVjaWZpZXJzLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGVjdCgneycpO1xuICAgICAgICB3aGlsZSAoIW1hdGNoKCd9JykpIHtcbiAgICAgICAgICAgIGlzRXhwb3J0RnJvbUlkZW50aWZpZXIgPSBpc0V4cG9ydEZyb21JZGVudGlmaWVyIHx8IG1hdGNoS2V5d29yZCgnZGVmYXVsdCcpO1xuICAgICAgICAgICAgc3BlY2lmaWVycy5wdXNoKHBhcnNlRXhwb3J0U3BlY2lmaWVyKCkpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICAgICAgZXhwZWN0KCcsJyk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKCd9JykpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGV4cGVjdCgnfScpO1xuXG4gICAgICAgIGlmIChtYXRjaENvbnRleHR1YWxLZXl3b3JkKCdmcm9tJykpIHtcbiAgICAgICAgICAgIC8vIGNvdmVyaW5nOlxuICAgICAgICAgICAgLy8gZXhwb3J0IHtkZWZhdWx0fSBmcm9tICdmb28nO1xuICAgICAgICAgICAgLy8gZXhwb3J0IHtmb299IGZyb20gJ2Zvbyc7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIHNyYyA9IHBhcnNlTW9kdWxlU3BlY2lmaWVyKCk7XG4gICAgICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNFeHBvcnRGcm9tSWRlbnRpZmllcikge1xuICAgICAgICAgICAgLy8gY292ZXJpbmc6XG4gICAgICAgICAgICAvLyBleHBvcnQge2RlZmF1bHR9OyAvLyBtaXNzaW5nIGZyb21DbGF1c2VcbiAgICAgICAgICAgIHRocm93RXJyb3IobG9va2FoZWFkLnZhbHVlID9cbiAgICAgICAgICAgICAgICAgICAgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuIDogTWVzc2FnZXMuTWlzc2luZ0Zyb21DbGF1c2UsIGxvb2thaGVhZC52YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjb3ZlclxuICAgICAgICAgICAgLy8gZXhwb3J0IHtmb299O1xuICAgICAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaEV4cG9ydE5hbWVkRGVjbGFyYXRpb24oZGVjbGFyYXRpb24sIHNwZWNpZmllcnMsIHNyYyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24obm9kZSkge1xuICAgICAgICB2YXIgZGVjbGFyYXRpb24gPSBudWxsLFxuICAgICAgICAgICAgZXhwcmVzc2lvbiA9IG51bGw7XG5cbiAgICAgICAgLy8gY292ZXJzOlxuICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCAuLi5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnZGVmYXVsdCcpO1xuXG4gICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICAgIC8vIGNvdmVyczpcbiAgICAgICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZvbyAoKSB7fVxuICAgICAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCkge31cbiAgICAgICAgICAgIGRlY2xhcmF0aW9uID0gcGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uKG5ldyBOb2RlKCksIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKGRlY2xhcmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2hLZXl3b3JkKCdjbGFzcycpKSB7XG4gICAgICAgICAgICBkZWNsYXJhdGlvbiA9IHBhcnNlQ2xhc3NEZWNsYXJhdGlvbih0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbihkZWNsYXJhdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnZnJvbScpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgbG9va2FoZWFkLnZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvdmVyczpcbiAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQge307XG4gICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0IFtdO1xuICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCAoMSArIDIpO1xuICAgICAgICBpZiAobWF0Y2goJ3snKSkge1xuICAgICAgICAgICAgZXhwcmVzc2lvbiA9IHBhcnNlT2JqZWN0SW5pdGlhbGl6ZXIoKTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaCgnWycpKSB7XG4gICAgICAgICAgICBleHByZXNzaW9uID0gcGFyc2VBcnJheUluaXRpYWxpemVyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleHByZXNzaW9uID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKGV4cHJlc3Npb24pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlRXhwb3J0QWxsRGVjbGFyYXRpb24obm9kZSkge1xuICAgICAgICB2YXIgc3JjO1xuXG4gICAgICAgIC8vIGNvdmVyczpcbiAgICAgICAgLy8gZXhwb3J0ICogZnJvbSAnZm9vJztcbiAgICAgICAgZXhwZWN0KCcqJyk7XG4gICAgICAgIGlmICghbWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnZnJvbScpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGxvb2thaGVhZC52YWx1ZSA/XG4gICAgICAgICAgICAgICAgICAgIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiA6IE1lc3NhZ2VzLk1pc3NpbmdGcm9tQ2xhdXNlLCBsb29rYWhlYWQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGxleCgpO1xuICAgICAgICBzcmMgPSBwYXJzZU1vZHVsZVNwZWNpZmllcigpO1xuICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoRXhwb3J0QWxsRGVjbGFyYXRpb24oc3JjKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUV4cG9ydERlY2xhcmF0aW9uKCkge1xuICAgICAgICB2YXIgbm9kZSA9IG5ldyBOb2RlKCk7XG4gICAgICAgIGlmIChzdGF0ZS5pbkZ1bmN0aW9uQm9keSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihNZXNzYWdlcy5JbGxlZ2FsRXhwb3J0RGVjbGFyYXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnZXhwb3J0Jyk7XG5cbiAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgnZGVmYXVsdCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24obm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoKCcqJykpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUV4cG9ydEFsbERlY2xhcmF0aW9uKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZUV4cG9ydE5hbWVkRGVjbGFyYXRpb24obm9kZSk7XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTUuMi4yIEltcG9ydHNcblxuICAgIGZ1bmN0aW9uIHBhcnNlSW1wb3J0U3BlY2lmaWVyKCkge1xuICAgICAgICAvLyBpbXBvcnQgezxmb28gYXMgYmFyPn0gLi4uO1xuICAgICAgICB2YXIgbG9jYWwsIGltcG9ydGVkLCBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgICBpbXBvcnRlZCA9IHBhcnNlTm9uQ29tcHV0ZWRQcm9wZXJ0eSgpO1xuICAgICAgICBpZiAobWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnYXMnKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICBsb2NhbCA9IHBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hJbXBvcnRTcGVjaWZpZXIobG9jYWwsIGltcG9ydGVkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU5hbWVkSW1wb3J0cygpIHtcbiAgICAgICAgdmFyIHNwZWNpZmllcnMgPSBbXTtcbiAgICAgICAgLy8ge2ZvbywgYmFyIGFzIGJhc31cbiAgICAgICAgZXhwZWN0KCd7Jyk7XG4gICAgICAgIHdoaWxlICghbWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgc3BlY2lmaWVycy5wdXNoKHBhcnNlSW1wb3J0U3BlY2lmaWVyKCkpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICAgICAgZXhwZWN0KCcsJyk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKCd9JykpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGV4cGVjdCgnfScpO1xuICAgICAgICByZXR1cm4gc3BlY2lmaWVycztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUltcG9ydERlZmF1bHRTcGVjaWZpZXIoKSB7XG4gICAgICAgIC8vIGltcG9ydCA8Zm9vPiAuLi47XG4gICAgICAgIHZhciBsb2NhbCwgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgICAgbG9jYWwgPSBwYXJzZU5vbkNvbXB1dGVkUHJvcGVydHkoKTtcblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hJbXBvcnREZWZhdWx0U3BlY2lmaWVyKGxvY2FsKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUltcG9ydE5hbWVzcGFjZVNwZWNpZmllcigpIHtcbiAgICAgICAgLy8gaW1wb3J0IDwqIGFzIGZvbz4gLi4uO1xuICAgICAgICB2YXIgbG9jYWwsIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGV4cGVjdCgnKicpO1xuICAgICAgICBpZiAoIW1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2FzJykpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoTWVzc2FnZXMuTm9Bc0FmdGVySW1wb3J0TmFtZXNwYWNlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXgoKTtcbiAgICAgICAgbG9jYWwgPSBwYXJzZU5vbkNvbXB1dGVkUHJvcGVydHkoKTtcblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIobG9jYWwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlSW1wb3J0RGVjbGFyYXRpb24oKSB7XG4gICAgICAgIHZhciBzcGVjaWZpZXJzID0gW10sIHNyYywgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgICAgaWYgKHN0YXRlLmluRnVuY3Rpb25Cb2R5KSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKE1lc3NhZ2VzLklsbGVnYWxJbXBvcnREZWNsYXJhdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3RLZXl3b3JkKCdpbXBvcnQnKTtcblxuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgPT09IFRva2VuLlN0cmluZ0xpdGVyYWwpIHtcbiAgICAgICAgICAgIC8vIGltcG9ydCAnZm9vJztcbiAgICAgICAgICAgIHNyYyA9IHBhcnNlTW9kdWxlU3BlY2lmaWVyKCk7XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGlmIChtYXRjaCgneycpKSB7XG4gICAgICAgICAgICAgICAgLy8gaW1wb3J0IHtiYXJ9XG4gICAgICAgICAgICAgICAgc3BlY2lmaWVycyA9IHNwZWNpZmllcnMuY29uY2F0KHBhcnNlTmFtZWRJbXBvcnRzKCkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaCgnKicpKSB7XG4gICAgICAgICAgICAgICAgLy8gaW1wb3J0ICogYXMgZm9vXG4gICAgICAgICAgICAgICAgc3BlY2lmaWVycy5wdXNoKHBhcnNlSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyKCkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0lkZW50aWZpZXJOYW1lKGxvb2thaGVhZCkgJiYgIW1hdGNoS2V5d29yZCgnZGVmYXVsdCcpKSB7XG4gICAgICAgICAgICAgICAgLy8gaW1wb3J0IGZvb1xuICAgICAgICAgICAgICAgIHNwZWNpZmllcnMucHVzaChwYXJzZUltcG9ydERlZmF1bHRTcGVjaWZpZXIoKSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKCcsJykpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCgnKicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbXBvcnQgZm9vLCAqIGFzIGZvb1xuICAgICAgICAgICAgICAgICAgICAgICAgc3BlY2lmaWVycy5wdXNoKHBhcnNlSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyKCkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCd7JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGltcG9ydCBmb28sIHtiYXJ9XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGVjaWZpZXJzID0gc3BlY2lmaWVycy5jb25jYXQocGFyc2VOYW1lZEltcG9ydHMoKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbihsb29rYWhlYWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbihsZXgoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghbWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnZnJvbScpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihsb29rYWhlYWQudmFsdWUgP1xuICAgICAgICAgICAgICAgICAgICAgICAgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuIDogTWVzc2FnZXMuTWlzc2luZ0Zyb21DbGF1c2UsIGxvb2thaGVhZC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIHNyYyA9IHBhcnNlTW9kdWxlU3BlY2lmaWVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaEltcG9ydERlY2xhcmF0aW9uKHNwZWNpZmllcnMsIHNyYyk7XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIgMTUuMSBTY3JpcHRzXG5cbiAgICBmdW5jdGlvbiBwYXJzZVNjcmlwdEJvZHkoKSB7XG4gICAgICAgIHZhciBzdGF0ZW1lbnQsIGJvZHkgPSBbXSwgdG9rZW4sIGRpcmVjdGl2ZSwgZmlyc3RSZXN0cmljdGVkO1xuXG4gICAgICAgIHdoaWxlIChzdGFydEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgICAgIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5TdHJpbmdMaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0YXRlbWVudCA9IHBhcnNlU3RhdGVtZW50TGlzdEl0ZW0oKTtcbiAgICAgICAgICAgIGJvZHkucHVzaChzdGF0ZW1lbnQpO1xuICAgICAgICAgICAgaWYgKHN0YXRlbWVudC5leHByZXNzaW9uLnR5cGUgIT09IFN5bnRheC5MaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBub3QgZGlyZWN0aXZlXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXJlY3RpdmUgPSBzb3VyY2Uuc2xpY2UodG9rZW4uc3RhcnQgKyAxLCB0b2tlbi5lbmQgLSAxKTtcbiAgICAgICAgICAgIGlmIChkaXJlY3RpdmUgPT09ICd1c2Ugc3RyaWN0Jykge1xuICAgICAgICAgICAgICAgIHN0cmljdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0UmVzdHJpY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihmaXJzdFJlc3RyaWN0ZWQsIE1lc3NhZ2VzLlN0cmljdE9jdGFsTGl0ZXJhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWZpcnN0UmVzdHJpY3RlZCAmJiB0b2tlbi5vY3RhbCkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoc3RhcnRJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgc3RhdGVtZW50ID0gcGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSgpO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0YXRlbWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJvZHkucHVzaChzdGF0ZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBib2R5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlUHJvZ3JhbSgpIHtcbiAgICAgICAgdmFyIGJvZHksIG5vZGU7XG5cbiAgICAgICAgcGVlaygpO1xuICAgICAgICBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgICBib2R5ID0gcGFyc2VTY3JpcHRCb2R5KCk7XG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaFByb2dyYW0oYm9keSwgc3RhdGUuc291cmNlVHlwZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmlsdGVyVG9rZW5Mb2NhdGlvbigpIHtcbiAgICAgICAgdmFyIGksIGVudHJ5LCB0b2tlbiwgdG9rZW5zID0gW107XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGV4dHJhLnRva2Vucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgZW50cnkgPSBleHRyYS50b2tlbnNbaV07XG4gICAgICAgICAgICB0b2tlbiA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBlbnRyeS50eXBlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBlbnRyeS52YWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChlbnRyeS5yZWdleCkge1xuICAgICAgICAgICAgICAgIHRva2VuLnJlZ2V4ID0ge1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuOiBlbnRyeS5yZWdleC5wYXR0ZXJuLFxuICAgICAgICAgICAgICAgICAgICBmbGFnczogZW50cnkucmVnZXguZmxhZ3NcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4dHJhLnJhbmdlKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4ucmFuZ2UgPSBlbnRyeS5yYW5nZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHRyYS5sb2MpIHtcbiAgICAgICAgICAgICAgICB0b2tlbi5sb2MgPSBlbnRyeS5sb2M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIH1cblxuICAgICAgICBleHRyYS50b2tlbnMgPSB0b2tlbnM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9rZW5pemUoY29kZSwgb3B0aW9ucywgZGVsZWdhdGUpIHtcbiAgICAgICAgdmFyIHRvU3RyaW5nLFxuICAgICAgICAgICAgdG9rZW5zO1xuXG4gICAgICAgIHRvU3RyaW5nID0gU3RyaW5nO1xuICAgICAgICBpZiAodHlwZW9mIGNvZGUgIT09ICdzdHJpbmcnICYmICEoY29kZSBpbnN0YW5jZW9mIFN0cmluZykpIHtcbiAgICAgICAgICAgIGNvZGUgPSB0b1N0cmluZyhjb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNvdXJjZSA9IGNvZGU7XG4gICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgbGluZU51bWJlciA9IChzb3VyY2UubGVuZ3RoID4gMCkgPyAxIDogMDtcbiAgICAgICAgbGluZVN0YXJ0ID0gMDtcbiAgICAgICAgc3RhcnRJbmRleCA9IGluZGV4O1xuICAgICAgICBzdGFydExpbmVOdW1iZXIgPSBsaW5lTnVtYmVyO1xuICAgICAgICBzdGFydExpbmVTdGFydCA9IGxpbmVTdGFydDtcbiAgICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgICAgICAgbG9va2FoZWFkID0gbnVsbDtcbiAgICAgICAgc3RhdGUgPSB7XG4gICAgICAgICAgICBhbGxvd0luOiB0cnVlLFxuICAgICAgICAgICAgYWxsb3dZaWVsZDogdHJ1ZSxcbiAgICAgICAgICAgIGxhYmVsU2V0OiB7fSxcbiAgICAgICAgICAgIGluRnVuY3Rpb25Cb2R5OiBmYWxzZSxcbiAgICAgICAgICAgIGluSXRlcmF0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgIGluU3dpdGNoOiBmYWxzZSxcbiAgICAgICAgICAgIGxhc3RDb21tZW50U3RhcnQ6IC0xLFxuICAgICAgICAgICAgY3VybHlTdGFjazogW11cbiAgICAgICAgfTtcblxuICAgICAgICBleHRyYSA9IHt9O1xuXG4gICAgICAgIC8vIE9wdGlvbnMgbWF0Y2hpbmcuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIC8vIE9mIGNvdXJzZSB3ZSBjb2xsZWN0IHRva2VucyBoZXJlLlxuICAgICAgICBvcHRpb25zLnRva2VucyA9IHRydWU7XG4gICAgICAgIGV4dHJhLnRva2VucyA9IFtdO1xuICAgICAgICBleHRyYS50b2tlblZhbHVlcyA9IFtdO1xuICAgICAgICBleHRyYS50b2tlbml6ZSA9IHRydWU7XG4gICAgICAgIGV4dHJhLmRlbGVnYXRlID0gZGVsZWdhdGU7XG5cbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyB0d28gZmllbGRzIGFyZSBuZWNlc3NhcnkgdG8gY29tcHV0ZSB0aGUgUmVnZXggdG9rZW5zLlxuICAgICAgICBleHRyYS5vcGVuUGFyZW5Ub2tlbiA9IC0xO1xuICAgICAgICBleHRyYS5vcGVuQ3VybHlUb2tlbiA9IC0xO1xuXG4gICAgICAgIGV4dHJhLnJhbmdlID0gKHR5cGVvZiBvcHRpb25zLnJhbmdlID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMucmFuZ2U7XG4gICAgICAgIGV4dHJhLmxvYyA9ICh0eXBlb2Ygb3B0aW9ucy5sb2MgPT09ICdib29sZWFuJykgJiYgb3B0aW9ucy5sb2M7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmNvbW1lbnQgPT09ICdib29sZWFuJyAmJiBvcHRpb25zLmNvbW1lbnQpIHtcbiAgICAgICAgICAgIGV4dHJhLmNvbW1lbnRzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnRvbGVyYW50ID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy50b2xlcmFudCkge1xuICAgICAgICAgICAgZXh0cmEuZXJyb3JzID0gW107XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGVlaygpO1xuICAgICAgICAgICAgaWYgKGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5FT0YpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXh0cmEudG9rZW5zO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIHdoaWxlIChsb29rYWhlYWQudHlwZSAhPT0gVG9rZW4uRU9GKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAobGV4RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4dHJhLmVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkRXJyb3IobGV4RXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSB0byBicmVhayBvbiB0aGUgZmlyc3QgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIGF2b2lkIGluZmluaXRlIGxvb3BzLlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBsZXhFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG9rZW5zID0gZXh0cmEudG9rZW5zO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHRyYS5lcnJvcnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5zLmVycm9ycyA9IGV4dHJhLmVycm9ycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGV4dHJhID0ge307XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZShjb2RlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBwcm9ncmFtLCB0b1N0cmluZztcblxuICAgICAgICB0b1N0cmluZyA9IFN0cmluZztcbiAgICAgICAgaWYgKHR5cGVvZiBjb2RlICE9PSAnc3RyaW5nJyAmJiAhKGNvZGUgaW5zdGFuY2VvZiBTdHJpbmcpKSB7XG4gICAgICAgICAgICBjb2RlID0gdG9TdHJpbmcoY29kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzb3VyY2UgPSBjb2RlO1xuICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIGxpbmVOdW1iZXIgPSAoc291cmNlLmxlbmd0aCA+IDApID8gMSA6IDA7XG4gICAgICAgIGxpbmVTdGFydCA9IDA7XG4gICAgICAgIHN0YXJ0SW5kZXggPSBpbmRleDtcbiAgICAgICAgc3RhcnRMaW5lTnVtYmVyID0gbGluZU51bWJlcjtcbiAgICAgICAgc3RhcnRMaW5lU3RhcnQgPSBsaW5lU3RhcnQ7XG4gICAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG4gICAgICAgIGxvb2thaGVhZCA9IG51bGw7XG4gICAgICAgIHN0YXRlID0ge1xuICAgICAgICAgICAgYWxsb3dJbjogdHJ1ZSxcbiAgICAgICAgICAgIGFsbG93WWllbGQ6IHRydWUsXG4gICAgICAgICAgICBsYWJlbFNldDoge30sXG4gICAgICAgICAgICBpbkZ1bmN0aW9uQm9keTogZmFsc2UsXG4gICAgICAgICAgICBpbkl0ZXJhdGlvbjogZmFsc2UsXG4gICAgICAgICAgICBpblN3aXRjaDogZmFsc2UsXG4gICAgICAgICAgICBsYXN0Q29tbWVudFN0YXJ0OiAtMSxcbiAgICAgICAgICAgIGN1cmx5U3RhY2s6IFtdLFxuICAgICAgICAgICAgc291cmNlVHlwZTogJ3NjcmlwdCdcbiAgICAgICAgfTtcbiAgICAgICAgc3RyaWN0ID0gZmFsc2U7XG5cbiAgICAgICAgZXh0cmEgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgZXh0cmEucmFuZ2UgPSAodHlwZW9mIG9wdGlvbnMucmFuZ2UgPT09ICdib29sZWFuJykgJiYgb3B0aW9ucy5yYW5nZTtcbiAgICAgICAgICAgIGV4dHJhLmxvYyA9ICh0eXBlb2Ygb3B0aW9ucy5sb2MgPT09ICdib29sZWFuJykgJiYgb3B0aW9ucy5sb2M7XG4gICAgICAgICAgICBleHRyYS5hdHRhY2hDb21tZW50ID0gKHR5cGVvZiBvcHRpb25zLmF0dGFjaENvbW1lbnQgPT09ICdib29sZWFuJykgJiYgb3B0aW9ucy5hdHRhY2hDb21tZW50O1xuXG4gICAgICAgICAgICBpZiAoZXh0cmEubG9jICYmIG9wdGlvbnMuc291cmNlICE9PSBudWxsICYmIG9wdGlvbnMuc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBleHRyYS5zb3VyY2UgPSB0b1N0cmluZyhvcHRpb25zLnNvdXJjZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50b2tlbnMgPT09ICdib29sZWFuJyAmJiBvcHRpb25zLnRva2Vucykge1xuICAgICAgICAgICAgICAgIGV4dHJhLnRva2VucyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmNvbW1lbnQgPT09ICdib29sZWFuJyAmJiBvcHRpb25zLmNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICBleHRyYS5jb21tZW50cyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnRvbGVyYW50ID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy50b2xlcmFudCkge1xuICAgICAgICAgICAgICAgIGV4dHJhLmVycm9ycyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4dHJhLmF0dGFjaENvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICBleHRyYS5yYW5nZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgZXh0cmEuY29tbWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICBleHRyYS5ib3R0b21SaWdodFN0YWNrID0gW107XG4gICAgICAgICAgICAgICAgZXh0cmEudHJhaWxpbmdDb21tZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIGV4dHJhLmxlYWRpbmdDb21tZW50cyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc291cmNlVHlwZSA9PT0gJ21vZHVsZScpIHtcbiAgICAgICAgICAgICAgICAvLyB2ZXJ5IHJlc3RyaWN0aXZlIGNvbmRpdGlvbiBmb3Igbm93XG4gICAgICAgICAgICAgICAgc3RhdGUuc291cmNlVHlwZSA9IG9wdGlvbnMuc291cmNlVHlwZTtcbiAgICAgICAgICAgICAgICBzdHJpY3QgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHByb2dyYW0gPSBwYXJzZVByb2dyYW0oKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXh0cmEuY29tbWVudHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcHJvZ3JhbS5jb21tZW50cyA9IGV4dHJhLmNvbW1lbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHRyYS50b2tlbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyVG9rZW5Mb2NhdGlvbigpO1xuICAgICAgICAgICAgICAgIHByb2dyYW0udG9rZW5zID0gZXh0cmEudG9rZW5zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHRyYS5lcnJvcnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcHJvZ3JhbS5lcnJvcnMgPSBleHRyYS5lcnJvcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBleHRyYSA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByb2dyYW07XG4gICAgfVxuXG4gICAgLy8gU3luYyB3aXRoICouanNvbiBtYW5pZmVzdHMuXG4gICAgZXhwb3J0cy52ZXJzaW9uID0gJzIuNy4zJztcblxuICAgIGV4cG9ydHMudG9rZW5pemUgPSB0b2tlbml6ZTtcblxuICAgIGV4cG9ydHMucGFyc2UgPSBwYXJzZTtcblxuICAgIC8vIERlZXAgY29weS5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGV4cG9ydHMuU3ludGF4ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5hbWUsIHR5cGVzID0ge307XG5cbiAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0eXBlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKG5hbWUgaW4gU3ludGF4KSB7XG4gICAgICAgICAgICBpZiAoU3ludGF4Lmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdHlwZXNbbmFtZV0gPSBTeW50YXhbbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIE9iamVjdC5mcmVlemUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIE9iamVjdC5mcmVlemUodHlwZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIH0oKSk7XG5cbn0pKTtcbi8qIHZpbTogc2V0IHN3PTQgdHM9NCBldCB0dz04MCA6ICovXG4iLCIvKlxuICBDb3B5cmlnaHQgKEMpIDIwMTItMjAxMyBZdXN1a2UgU3V6dWtpIDx1dGF0YW5lLnRlYUBnbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMiBBcml5YSBIaWRheWF0IDxhcml5YS5oaWRheWF0QGdtYWlsLmNvbT5cblxuICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuICBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCA8Q09QWVJJR0hUIEhPTERFUj4gQkUgTElBQkxFIEZPUiBBTllcbiAgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbiAgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuICBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkRcbiAgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GXG4gIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xuLypqc2xpbnQgdmFyczpmYWxzZSwgYml0d2lzZTp0cnVlKi9cbi8qanNoaW50IGluZGVudDo0Ki9cbi8qZ2xvYmFsIGV4cG9ydHM6dHJ1ZSovXG4oZnVuY3Rpb24gY2xvbmUoZXhwb3J0cykge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBTeW50YXgsXG4gICAgICAgIFZpc2l0b3JPcHRpb24sXG4gICAgICAgIFZpc2l0b3JLZXlzLFxuICAgICAgICBCUkVBSyxcbiAgICAgICAgU0tJUCxcbiAgICAgICAgUkVNT1ZFO1xuXG4gICAgZnVuY3Rpb24gZGVlcENvcHkob2JqKSB7XG4gICAgICAgIHZhciByZXQgPSB7fSwga2V5LCB2YWw7XG4gICAgICAgIGZvciAoa2V5IGluIG9iaikge1xuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gb2JqW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXRba2V5XSA9IGRlZXBDb3B5KHZhbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0W2tleV0gPSB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgLy8gYmFzZWQgb24gTExWTSBsaWJjKysgdXBwZXJfYm91bmQgLyBsb3dlcl9ib3VuZFxuICAgIC8vIE1JVCBMaWNlbnNlXG5cbiAgICBmdW5jdGlvbiB1cHBlckJvdW5kKGFycmF5LCBmdW5jKSB7XG4gICAgICAgIHZhciBkaWZmLCBsZW4sIGksIGN1cnJlbnQ7XG5cbiAgICAgICAgbGVuID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICBpID0gMDtcblxuICAgICAgICB3aGlsZSAobGVuKSB7XG4gICAgICAgICAgICBkaWZmID0gbGVuID4+PiAxO1xuICAgICAgICAgICAgY3VycmVudCA9IGkgKyBkaWZmO1xuICAgICAgICAgICAgaWYgKGZ1bmMoYXJyYXlbY3VycmVudF0pKSB7XG4gICAgICAgICAgICAgICAgbGVuID0gZGlmZjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaSA9IGN1cnJlbnQgKyAxO1xuICAgICAgICAgICAgICAgIGxlbiAtPSBkaWZmICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaTtcbiAgICB9XG5cbiAgICBTeW50YXggPSB7XG4gICAgICAgIEFzc2lnbm1lbnRFeHByZXNzaW9uOiAnQXNzaWdubWVudEV4cHJlc3Npb24nLFxuICAgICAgICBBc3NpZ25tZW50UGF0dGVybjogJ0Fzc2lnbm1lbnRQYXR0ZXJuJyxcbiAgICAgICAgQXJyYXlFeHByZXNzaW9uOiAnQXJyYXlFeHByZXNzaW9uJyxcbiAgICAgICAgQXJyYXlQYXR0ZXJuOiAnQXJyYXlQYXR0ZXJuJyxcbiAgICAgICAgQXJyb3dGdW5jdGlvbkV4cHJlc3Npb246ICdBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbicsXG4gICAgICAgIEF3YWl0RXhwcmVzc2lvbjogJ0F3YWl0RXhwcmVzc2lvbicsIC8vIENBVVRJT046IEl0J3MgZGVmZXJyZWQgdG8gRVM3LlxuICAgICAgICBCbG9ja1N0YXRlbWVudDogJ0Jsb2NrU3RhdGVtZW50JyxcbiAgICAgICAgQmluYXJ5RXhwcmVzc2lvbjogJ0JpbmFyeUV4cHJlc3Npb24nLFxuICAgICAgICBCcmVha1N0YXRlbWVudDogJ0JyZWFrU3RhdGVtZW50JyxcbiAgICAgICAgQ2FsbEV4cHJlc3Npb246ICdDYWxsRXhwcmVzc2lvbicsXG4gICAgICAgIENhdGNoQ2xhdXNlOiAnQ2F0Y2hDbGF1c2UnLFxuICAgICAgICBDbGFzc0JvZHk6ICdDbGFzc0JvZHknLFxuICAgICAgICBDbGFzc0RlY2xhcmF0aW9uOiAnQ2xhc3NEZWNsYXJhdGlvbicsXG4gICAgICAgIENsYXNzRXhwcmVzc2lvbjogJ0NsYXNzRXhwcmVzc2lvbicsXG4gICAgICAgIENvbXByZWhlbnNpb25CbG9jazogJ0NvbXByZWhlbnNpb25CbG9jaycsICAvLyBDQVVUSU9OOiBJdCdzIGRlZmVycmVkIHRvIEVTNy5cbiAgICAgICAgQ29tcHJlaGVuc2lvbkV4cHJlc3Npb246ICdDb21wcmVoZW5zaW9uRXhwcmVzc2lvbicsICAvLyBDQVVUSU9OOiBJdCdzIGRlZmVycmVkIHRvIEVTNy5cbiAgICAgICAgQ29uZGl0aW9uYWxFeHByZXNzaW9uOiAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJyxcbiAgICAgICAgQ29udGludWVTdGF0ZW1lbnQ6ICdDb250aW51ZVN0YXRlbWVudCcsXG4gICAgICAgIERlYnVnZ2VyU3RhdGVtZW50OiAnRGVidWdnZXJTdGF0ZW1lbnQnLFxuICAgICAgICBEaXJlY3RpdmVTdGF0ZW1lbnQ6ICdEaXJlY3RpdmVTdGF0ZW1lbnQnLFxuICAgICAgICBEb1doaWxlU3RhdGVtZW50OiAnRG9XaGlsZVN0YXRlbWVudCcsXG4gICAgICAgIEVtcHR5U3RhdGVtZW50OiAnRW1wdHlTdGF0ZW1lbnQnLFxuICAgICAgICBFeHBvcnRBbGxEZWNsYXJhdGlvbjogJ0V4cG9ydEFsbERlY2xhcmF0aW9uJyxcbiAgICAgICAgRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uOiAnRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uJyxcbiAgICAgICAgRXhwb3J0TmFtZWREZWNsYXJhdGlvbjogJ0V4cG9ydE5hbWVkRGVjbGFyYXRpb24nLFxuICAgICAgICBFeHBvcnRTcGVjaWZpZXI6ICdFeHBvcnRTcGVjaWZpZXInLFxuICAgICAgICBFeHByZXNzaW9uU3RhdGVtZW50OiAnRXhwcmVzc2lvblN0YXRlbWVudCcsXG4gICAgICAgIEZvclN0YXRlbWVudDogJ0ZvclN0YXRlbWVudCcsXG4gICAgICAgIEZvckluU3RhdGVtZW50OiAnRm9ySW5TdGF0ZW1lbnQnLFxuICAgICAgICBGb3JPZlN0YXRlbWVudDogJ0Zvck9mU3RhdGVtZW50JyxcbiAgICAgICAgRnVuY3Rpb25EZWNsYXJhdGlvbjogJ0Z1bmN0aW9uRGVjbGFyYXRpb24nLFxuICAgICAgICBGdW5jdGlvbkV4cHJlc3Npb246ICdGdW5jdGlvbkV4cHJlc3Npb24nLFxuICAgICAgICBHZW5lcmF0b3JFeHByZXNzaW9uOiAnR2VuZXJhdG9yRXhwcmVzc2lvbicsICAvLyBDQVVUSU9OOiBJdCdzIGRlZmVycmVkIHRvIEVTNy5cbiAgICAgICAgSWRlbnRpZmllcjogJ0lkZW50aWZpZXInLFxuICAgICAgICBJZlN0YXRlbWVudDogJ0lmU3RhdGVtZW50JyxcbiAgICAgICAgSW1wb3J0RXhwcmVzc2lvbjogJ0ltcG9ydEV4cHJlc3Npb24nLFxuICAgICAgICBJbXBvcnREZWNsYXJhdGlvbjogJ0ltcG9ydERlY2xhcmF0aW9uJyxcbiAgICAgICAgSW1wb3J0RGVmYXVsdFNwZWNpZmllcjogJ0ltcG9ydERlZmF1bHRTcGVjaWZpZXInLFxuICAgICAgICBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI6ICdJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXInLFxuICAgICAgICBJbXBvcnRTcGVjaWZpZXI6ICdJbXBvcnRTcGVjaWZpZXInLFxuICAgICAgICBMaXRlcmFsOiAnTGl0ZXJhbCcsXG4gICAgICAgIExhYmVsZWRTdGF0ZW1lbnQ6ICdMYWJlbGVkU3RhdGVtZW50JyxcbiAgICAgICAgTG9naWNhbEV4cHJlc3Npb246ICdMb2dpY2FsRXhwcmVzc2lvbicsXG4gICAgICAgIE1lbWJlckV4cHJlc3Npb246ICdNZW1iZXJFeHByZXNzaW9uJyxcbiAgICAgICAgTWV0YVByb3BlcnR5OiAnTWV0YVByb3BlcnR5JyxcbiAgICAgICAgTWV0aG9kRGVmaW5pdGlvbjogJ01ldGhvZERlZmluaXRpb24nLFxuICAgICAgICBNb2R1bGVTcGVjaWZpZXI6ICdNb2R1bGVTcGVjaWZpZXInLFxuICAgICAgICBOZXdFeHByZXNzaW9uOiAnTmV3RXhwcmVzc2lvbicsXG4gICAgICAgIE9iamVjdEV4cHJlc3Npb246ICdPYmplY3RFeHByZXNzaW9uJyxcbiAgICAgICAgT2JqZWN0UGF0dGVybjogJ09iamVjdFBhdHRlcm4nLFxuICAgICAgICBQcm9ncmFtOiAnUHJvZ3JhbScsXG4gICAgICAgIFByb3BlcnR5OiAnUHJvcGVydHknLFxuICAgICAgICBSZXN0RWxlbWVudDogJ1Jlc3RFbGVtZW50JyxcbiAgICAgICAgUmV0dXJuU3RhdGVtZW50OiAnUmV0dXJuU3RhdGVtZW50JyxcbiAgICAgICAgU2VxdWVuY2VFeHByZXNzaW9uOiAnU2VxdWVuY2VFeHByZXNzaW9uJyxcbiAgICAgICAgU3ByZWFkRWxlbWVudDogJ1NwcmVhZEVsZW1lbnQnLFxuICAgICAgICBTdXBlcjogJ1N1cGVyJyxcbiAgICAgICAgU3dpdGNoU3RhdGVtZW50OiAnU3dpdGNoU3RhdGVtZW50JyxcbiAgICAgICAgU3dpdGNoQ2FzZTogJ1N3aXRjaENhc2UnLFxuICAgICAgICBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb246ICdUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24nLFxuICAgICAgICBUZW1wbGF0ZUVsZW1lbnQ6ICdUZW1wbGF0ZUVsZW1lbnQnLFxuICAgICAgICBUZW1wbGF0ZUxpdGVyYWw6ICdUZW1wbGF0ZUxpdGVyYWwnLFxuICAgICAgICBUaGlzRXhwcmVzc2lvbjogJ1RoaXNFeHByZXNzaW9uJyxcbiAgICAgICAgVGhyb3dTdGF0ZW1lbnQ6ICdUaHJvd1N0YXRlbWVudCcsXG4gICAgICAgIFRyeVN0YXRlbWVudDogJ1RyeVN0YXRlbWVudCcsXG4gICAgICAgIFVuYXJ5RXhwcmVzc2lvbjogJ1VuYXJ5RXhwcmVzc2lvbicsXG4gICAgICAgIFVwZGF0ZUV4cHJlc3Npb246ICdVcGRhdGVFeHByZXNzaW9uJyxcbiAgICAgICAgVmFyaWFibGVEZWNsYXJhdGlvbjogJ1ZhcmlhYmxlRGVjbGFyYXRpb24nLFxuICAgICAgICBWYXJpYWJsZURlY2xhcmF0b3I6ICdWYXJpYWJsZURlY2xhcmF0b3InLFxuICAgICAgICBXaGlsZVN0YXRlbWVudDogJ1doaWxlU3RhdGVtZW50JyxcbiAgICAgICAgV2l0aFN0YXRlbWVudDogJ1dpdGhTdGF0ZW1lbnQnLFxuICAgICAgICBZaWVsZEV4cHJlc3Npb246ICdZaWVsZEV4cHJlc3Npb24nXG4gICAgfTtcblxuICAgIFZpc2l0b3JLZXlzID0ge1xuICAgICAgICBBc3NpZ25tZW50RXhwcmVzc2lvbjogWydsZWZ0JywgJ3JpZ2h0J10sXG4gICAgICAgIEFzc2lnbm1lbnRQYXR0ZXJuOiBbJ2xlZnQnLCAncmlnaHQnXSxcbiAgICAgICAgQXJyYXlFeHByZXNzaW9uOiBbJ2VsZW1lbnRzJ10sXG4gICAgICAgIEFycmF5UGF0dGVybjogWydlbGVtZW50cyddLFxuICAgICAgICBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjogWydwYXJhbXMnLCAnYm9keSddLFxuICAgICAgICBBd2FpdEV4cHJlc3Npb246IFsnYXJndW1lbnQnXSwgLy8gQ0FVVElPTjogSXQncyBkZWZlcnJlZCB0byBFUzcuXG4gICAgICAgIEJsb2NrU3RhdGVtZW50OiBbJ2JvZHknXSxcbiAgICAgICAgQmluYXJ5RXhwcmVzc2lvbjogWydsZWZ0JywgJ3JpZ2h0J10sXG4gICAgICAgIEJyZWFrU3RhdGVtZW50OiBbJ2xhYmVsJ10sXG4gICAgICAgIENhbGxFeHByZXNzaW9uOiBbJ2NhbGxlZScsICdhcmd1bWVudHMnXSxcbiAgICAgICAgQ2F0Y2hDbGF1c2U6IFsncGFyYW0nLCAnYm9keSddLFxuICAgICAgICBDbGFzc0JvZHk6IFsnYm9keSddLFxuICAgICAgICBDbGFzc0RlY2xhcmF0aW9uOiBbJ2lkJywgJ3N1cGVyQ2xhc3MnLCAnYm9keSddLFxuICAgICAgICBDbGFzc0V4cHJlc3Npb246IFsnaWQnLCAnc3VwZXJDbGFzcycsICdib2R5J10sXG4gICAgICAgIENvbXByZWhlbnNpb25CbG9jazogWydsZWZ0JywgJ3JpZ2h0J10sICAvLyBDQVVUSU9OOiBJdCdzIGRlZmVycmVkIHRvIEVTNy5cbiAgICAgICAgQ29tcHJlaGVuc2lvbkV4cHJlc3Npb246IFsnYmxvY2tzJywgJ2ZpbHRlcicsICdib2R5J10sICAvLyBDQVVUSU9OOiBJdCdzIGRlZmVycmVkIHRvIEVTNy5cbiAgICAgICAgQ29uZGl0aW9uYWxFeHByZXNzaW9uOiBbJ3Rlc3QnLCAnY29uc2VxdWVudCcsICdhbHRlcm5hdGUnXSxcbiAgICAgICAgQ29udGludWVTdGF0ZW1lbnQ6IFsnbGFiZWwnXSxcbiAgICAgICAgRGVidWdnZXJTdGF0ZW1lbnQ6IFtdLFxuICAgICAgICBEaXJlY3RpdmVTdGF0ZW1lbnQ6IFtdLFxuICAgICAgICBEb1doaWxlU3RhdGVtZW50OiBbJ2JvZHknLCAndGVzdCddLFxuICAgICAgICBFbXB0eVN0YXRlbWVudDogW10sXG4gICAgICAgIEV4cG9ydEFsbERlY2xhcmF0aW9uOiBbJ3NvdXJjZSddLFxuICAgICAgICBFeHBvcnREZWZhdWx0RGVjbGFyYXRpb246IFsnZGVjbGFyYXRpb24nXSxcbiAgICAgICAgRXhwb3J0TmFtZWREZWNsYXJhdGlvbjogWydkZWNsYXJhdGlvbicsICdzcGVjaWZpZXJzJywgJ3NvdXJjZSddLFxuICAgICAgICBFeHBvcnRTcGVjaWZpZXI6IFsnZXhwb3J0ZWQnLCAnbG9jYWwnXSxcbiAgICAgICAgRXhwcmVzc2lvblN0YXRlbWVudDogWydleHByZXNzaW9uJ10sXG4gICAgICAgIEZvclN0YXRlbWVudDogWydpbml0JywgJ3Rlc3QnLCAndXBkYXRlJywgJ2JvZHknXSxcbiAgICAgICAgRm9ySW5TdGF0ZW1lbnQ6IFsnbGVmdCcsICdyaWdodCcsICdib2R5J10sXG4gICAgICAgIEZvck9mU3RhdGVtZW50OiBbJ2xlZnQnLCAncmlnaHQnLCAnYm9keSddLFxuICAgICAgICBGdW5jdGlvbkRlY2xhcmF0aW9uOiBbJ2lkJywgJ3BhcmFtcycsICdib2R5J10sXG4gICAgICAgIEZ1bmN0aW9uRXhwcmVzc2lvbjogWydpZCcsICdwYXJhbXMnLCAnYm9keSddLFxuICAgICAgICBHZW5lcmF0b3JFeHByZXNzaW9uOiBbJ2Jsb2NrcycsICdmaWx0ZXInLCAnYm9keSddLCAgLy8gQ0FVVElPTjogSXQncyBkZWZlcnJlZCB0byBFUzcuXG4gICAgICAgIElkZW50aWZpZXI6IFtdLFxuICAgICAgICBJZlN0YXRlbWVudDogWyd0ZXN0JywgJ2NvbnNlcXVlbnQnLCAnYWx0ZXJuYXRlJ10sXG4gICAgICAgIEltcG9ydEV4cHJlc3Npb246IFsnc291cmNlJ10sXG4gICAgICAgIEltcG9ydERlY2xhcmF0aW9uOiBbJ3NwZWNpZmllcnMnLCAnc291cmNlJ10sXG4gICAgICAgIEltcG9ydERlZmF1bHRTcGVjaWZpZXI6IFsnbG9jYWwnXSxcbiAgICAgICAgSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyOiBbJ2xvY2FsJ10sXG4gICAgICAgIEltcG9ydFNwZWNpZmllcjogWydpbXBvcnRlZCcsICdsb2NhbCddLFxuICAgICAgICBMaXRlcmFsOiBbXSxcbiAgICAgICAgTGFiZWxlZFN0YXRlbWVudDogWydsYWJlbCcsICdib2R5J10sXG4gICAgICAgIExvZ2ljYWxFeHByZXNzaW9uOiBbJ2xlZnQnLCAncmlnaHQnXSxcbiAgICAgICAgTWVtYmVyRXhwcmVzc2lvbjogWydvYmplY3QnLCAncHJvcGVydHknXSxcbiAgICAgICAgTWV0YVByb3BlcnR5OiBbJ21ldGEnLCAncHJvcGVydHknXSxcbiAgICAgICAgTWV0aG9kRGVmaW5pdGlvbjogWydrZXknLCAndmFsdWUnXSxcbiAgICAgICAgTW9kdWxlU3BlY2lmaWVyOiBbXSxcbiAgICAgICAgTmV3RXhwcmVzc2lvbjogWydjYWxsZWUnLCAnYXJndW1lbnRzJ10sXG4gICAgICAgIE9iamVjdEV4cHJlc3Npb246IFsncHJvcGVydGllcyddLFxuICAgICAgICBPYmplY3RQYXR0ZXJuOiBbJ3Byb3BlcnRpZXMnXSxcbiAgICAgICAgUHJvZ3JhbTogWydib2R5J10sXG4gICAgICAgIFByb3BlcnR5OiBbJ2tleScsICd2YWx1ZSddLFxuICAgICAgICBSZXN0RWxlbWVudDogWyAnYXJndW1lbnQnIF0sXG4gICAgICAgIFJldHVyblN0YXRlbWVudDogWydhcmd1bWVudCddLFxuICAgICAgICBTZXF1ZW5jZUV4cHJlc3Npb246IFsnZXhwcmVzc2lvbnMnXSxcbiAgICAgICAgU3ByZWFkRWxlbWVudDogWydhcmd1bWVudCddLFxuICAgICAgICBTdXBlcjogW10sXG4gICAgICAgIFN3aXRjaFN0YXRlbWVudDogWydkaXNjcmltaW5hbnQnLCAnY2FzZXMnXSxcbiAgICAgICAgU3dpdGNoQ2FzZTogWyd0ZXN0JywgJ2NvbnNlcXVlbnQnXSxcbiAgICAgICAgVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uOiBbJ3RhZycsICdxdWFzaSddLFxuICAgICAgICBUZW1wbGF0ZUVsZW1lbnQ6IFtdLFxuICAgICAgICBUZW1wbGF0ZUxpdGVyYWw6IFsncXVhc2lzJywgJ2V4cHJlc3Npb25zJ10sXG4gICAgICAgIFRoaXNFeHByZXNzaW9uOiBbXSxcbiAgICAgICAgVGhyb3dTdGF0ZW1lbnQ6IFsnYXJndW1lbnQnXSxcbiAgICAgICAgVHJ5U3RhdGVtZW50OiBbJ2Jsb2NrJywgJ2hhbmRsZXInLCAnZmluYWxpemVyJ10sXG4gICAgICAgIFVuYXJ5RXhwcmVzc2lvbjogWydhcmd1bWVudCddLFxuICAgICAgICBVcGRhdGVFeHByZXNzaW9uOiBbJ2FyZ3VtZW50J10sXG4gICAgICAgIFZhcmlhYmxlRGVjbGFyYXRpb246IFsnZGVjbGFyYXRpb25zJ10sXG4gICAgICAgIFZhcmlhYmxlRGVjbGFyYXRvcjogWydpZCcsICdpbml0J10sXG4gICAgICAgIFdoaWxlU3RhdGVtZW50OiBbJ3Rlc3QnLCAnYm9keSddLFxuICAgICAgICBXaXRoU3RhdGVtZW50OiBbJ29iamVjdCcsICdib2R5J10sXG4gICAgICAgIFlpZWxkRXhwcmVzc2lvbjogWydhcmd1bWVudCddXG4gICAgfTtcblxuICAgIC8vIHVuaXF1ZSBpZFxuICAgIEJSRUFLID0ge307XG4gICAgU0tJUCA9IHt9O1xuICAgIFJFTU9WRSA9IHt9O1xuXG4gICAgVmlzaXRvck9wdGlvbiA9IHtcbiAgICAgICAgQnJlYWs6IEJSRUFLLFxuICAgICAgICBTa2lwOiBTS0lQLFxuICAgICAgICBSZW1vdmU6IFJFTU9WRVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBSZWZlcmVuY2UocGFyZW50LCBrZXkpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIH1cblxuICAgIFJlZmVyZW5jZS5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2Uobm9kZSkge1xuICAgICAgICB0aGlzLnBhcmVudFt0aGlzLmtleV0gPSBub2RlO1xuICAgIH07XG5cbiAgICBSZWZlcmVuY2UucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5wYXJlbnQpKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5zcGxpY2UodGhpcy5rZXksIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlcGxhY2UobnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gRWxlbWVudChub2RlLCBwYXRoLCB3cmFwLCByZWYpIHtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy53cmFwID0gd3JhcDtcbiAgICAgICAgdGhpcy5yZWYgPSByZWY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQ29udHJvbGxlcigpIHsgfVxuXG4gICAgLy8gQVBJOlxuICAgIC8vIHJldHVybiBwcm9wZXJ0eSBwYXRoIGFycmF5IGZyb20gcm9vdCB0byBjdXJyZW50IG5vZGVcbiAgICBDb250cm9sbGVyLnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24gcGF0aCgpIHtcbiAgICAgICAgdmFyIGksIGl6LCBqLCBqeiwgcmVzdWx0LCBlbGVtZW50O1xuXG4gICAgICAgIGZ1bmN0aW9uIGFkZFRvUGF0aChyZXN1bHQsIHBhdGgpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMCwganogPSBwYXRoLmxlbmd0aDsgaiA8IGp6OyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocGF0aFtqXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJvb3Qgbm9kZVxuICAgICAgICBpZiAoIXRoaXMuX19jdXJyZW50LnBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmlyc3Qgbm9kZSBpcyBzZW50aW5lbCwgc2Vjb25kIG5vZGUgaXMgcm9vdCBlbGVtZW50XG4gICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAyLCBpeiA9IHRoaXMuX19sZWF2ZWxpc3QubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgZWxlbWVudCA9IHRoaXMuX19sZWF2ZWxpc3RbaV07XG4gICAgICAgICAgICBhZGRUb1BhdGgocmVzdWx0LCBlbGVtZW50LnBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGFkZFRvUGF0aChyZXN1bHQsIHRoaXMuX19jdXJyZW50LnBhdGgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvLyBBUEk6XG4gICAgLy8gcmV0dXJuIHR5cGUgb2YgY3VycmVudCBub2RlXG4gICAgQ29udHJvbGxlci5wcm90b3R5cGUudHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmN1cnJlbnQoKTtcbiAgICAgICAgcmV0dXJuIG5vZGUudHlwZSB8fCB0aGlzLl9fY3VycmVudC53cmFwO1xuICAgIH07XG5cbiAgICAvLyBBUEk6XG4gICAgLy8gcmV0dXJuIGFycmF5IG9mIHBhcmVudCBlbGVtZW50c1xuICAgIENvbnRyb2xsZXIucHJvdG90eXBlLnBhcmVudHMgPSBmdW5jdGlvbiBwYXJlbnRzKCkge1xuICAgICAgICB2YXIgaSwgaXosIHJlc3VsdDtcblxuICAgICAgICAvLyBmaXJzdCBub2RlIGlzIHNlbnRpbmVsXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAxLCBpeiA9IHRoaXMuX19sZWF2ZWxpc3QubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5fX2xlYXZlbGlzdFtpXS5ub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8vIEFQSTpcbiAgICAvLyByZXR1cm4gY3VycmVudCBub2RlXG4gICAgQ29udHJvbGxlci5wcm90b3R5cGUuY3VycmVudCA9IGZ1bmN0aW9uIGN1cnJlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fY3VycmVudC5ub2RlO1xuICAgIH07XG5cbiAgICBDb250cm9sbGVyLnByb3RvdHlwZS5fX2V4ZWN1dGUgPSBmdW5jdGlvbiBfX2V4ZWN1dGUoY2FsbGJhY2ssIGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHByZXZpb3VzLCByZXN1bHQ7XG5cbiAgICAgICAgcmVzdWx0ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHByZXZpb3VzICA9IHRoaXMuX19jdXJyZW50O1xuICAgICAgICB0aGlzLl9fY3VycmVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuX19zdGF0ZSA9IG51bGw7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgcmVzdWx0ID0gY2FsbGJhY2suY2FsbCh0aGlzLCBlbGVtZW50Lm5vZGUsIHRoaXMuX19sZWF2ZWxpc3RbdGhpcy5fX2xlYXZlbGlzdC5sZW5ndGggLSAxXS5ub2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fY3VycmVudCA9IHByZXZpb3VzO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8vIEFQSTpcbiAgICAvLyBub3RpZnkgY29udHJvbCBza2lwIC8gYnJlYWtcbiAgICBDb250cm9sbGVyLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbiBub3RpZnkoZmxhZykge1xuICAgICAgICB0aGlzLl9fc3RhdGUgPSBmbGFnO1xuICAgIH07XG5cbiAgICAvLyBBUEk6XG4gICAgLy8gc2tpcCBjaGlsZCBub2RlcyBvZiBjdXJyZW50IG5vZGVcbiAgICBDb250cm9sbGVyLnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm5vdGlmeShTS0lQKTtcbiAgICB9O1xuXG4gICAgLy8gQVBJOlxuICAgIC8vIGJyZWFrIHRyYXZlcnNhbHNcbiAgICBDb250cm9sbGVyLnByb3RvdHlwZVsnYnJlYWsnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5ub3RpZnkoQlJFQUspO1xuICAgIH07XG5cbiAgICAvLyBBUEk6XG4gICAgLy8gcmVtb3ZlIG5vZGVcbiAgICBDb250cm9sbGVyLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubm90aWZ5KFJFTU9WRSk7XG4gICAgfTtcblxuICAgIENvbnRyb2xsZXIucHJvdG90eXBlLl9faW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKHJvb3QsIHZpc2l0b3IpIHtcbiAgICAgICAgdGhpcy52aXNpdG9yID0gdmlzaXRvcjtcbiAgICAgICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICAgICAgdGhpcy5fX3dvcmtsaXN0ID0gW107XG4gICAgICAgIHRoaXMuX19sZWF2ZWxpc3QgPSBbXTtcbiAgICAgICAgdGhpcy5fX2N1cnJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9fc3RhdGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9fZmFsbGJhY2sgPSBudWxsO1xuICAgICAgICBpZiAodmlzaXRvci5mYWxsYmFjayA9PT0gJ2l0ZXJhdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuX19mYWxsYmFjayA9IE9iamVjdC5rZXlzO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2aXNpdG9yLmZhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLl9fZmFsbGJhY2sgPSB2aXNpdG9yLmZhbGxiYWNrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fX2tleXMgPSBWaXNpdG9yS2V5cztcbiAgICAgICAgaWYgKHZpc2l0b3Iua2V5cykge1xuICAgICAgICAgICAgdGhpcy5fX2tleXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUodGhpcy5fX2tleXMpLCB2aXNpdG9yLmtleXMpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGlzTm9kZShub2RlKSB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZW9mIG5vZGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBub2RlLnR5cGUgPT09ICdzdHJpbmcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzUHJvcGVydHkobm9kZVR5cGUsIGtleSkge1xuICAgICAgICByZXR1cm4gKG5vZGVUeXBlID09PSBTeW50YXguT2JqZWN0RXhwcmVzc2lvbiB8fCBub2RlVHlwZSA9PT0gU3ludGF4Lk9iamVjdFBhdHRlcm4pICYmICdwcm9wZXJ0aWVzJyA9PT0ga2V5O1xuICAgIH1cblxuICAgIENvbnRyb2xsZXIucHJvdG90eXBlLnRyYXZlcnNlID0gZnVuY3Rpb24gdHJhdmVyc2Uocm9vdCwgdmlzaXRvcikge1xuICAgICAgICB2YXIgd29ya2xpc3QsXG4gICAgICAgICAgICBsZWF2ZWxpc3QsXG4gICAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIG5vZGVUeXBlLFxuICAgICAgICAgICAgcmV0LFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIGN1cnJlbnQyLFxuICAgICAgICAgICAgY2FuZGlkYXRlcyxcbiAgICAgICAgICAgIGNhbmRpZGF0ZSxcbiAgICAgICAgICAgIHNlbnRpbmVsO1xuXG4gICAgICAgIHRoaXMuX19pbml0aWFsaXplKHJvb3QsIHZpc2l0b3IpO1xuXG4gICAgICAgIHNlbnRpbmVsID0ge307XG5cbiAgICAgICAgLy8gcmVmZXJlbmNlXG4gICAgICAgIHdvcmtsaXN0ID0gdGhpcy5fX3dvcmtsaXN0O1xuICAgICAgICBsZWF2ZWxpc3QgPSB0aGlzLl9fbGVhdmVsaXN0O1xuXG4gICAgICAgIC8vIGluaXRpYWxpemVcbiAgICAgICAgd29ya2xpc3QucHVzaChuZXcgRWxlbWVudChyb290LCBudWxsLCBudWxsLCBudWxsKSk7XG4gICAgICAgIGxlYXZlbGlzdC5wdXNoKG5ldyBFbGVtZW50KG51bGwsIG51bGwsIG51bGwsIG51bGwpKTtcblxuICAgICAgICB3aGlsZSAod29ya2xpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICBlbGVtZW50ID0gd29ya2xpc3QucG9wKCk7XG5cbiAgICAgICAgICAgIGlmIChlbGVtZW50ID09PSBzZW50aW5lbCkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBsZWF2ZWxpc3QucG9wKCk7XG5cbiAgICAgICAgICAgICAgICByZXQgPSB0aGlzLl9fZXhlY3V0ZSh2aXNpdG9yLmxlYXZlLCBlbGVtZW50KTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fc3RhdGUgPT09IEJSRUFLIHx8IHJldCA9PT0gQlJFQUspIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVsZW1lbnQubm9kZSkge1xuXG4gICAgICAgICAgICAgICAgcmV0ID0gdGhpcy5fX2V4ZWN1dGUodmlzaXRvci5lbnRlciwgZWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX3N0YXRlID09PSBCUkVBSyB8fCByZXQgPT09IEJSRUFLKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB3b3JrbGlzdC5wdXNoKHNlbnRpbmVsKTtcbiAgICAgICAgICAgICAgICBsZWF2ZWxpc3QucHVzaChlbGVtZW50KTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fc3RhdGUgPT09IFNLSVAgfHwgcmV0ID09PSBTS0lQKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG5vZGUgPSBlbGVtZW50Lm5vZGU7XG4gICAgICAgICAgICAgICAgbm9kZVR5cGUgPSBub2RlLnR5cGUgfHwgZWxlbWVudC53cmFwO1xuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZXMgPSB0aGlzLl9fa2V5c1tub2RlVHlwZV07XG4gICAgICAgICAgICAgICAgaWYgKCFjYW5kaWRhdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fZmFsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZXMgPSB0aGlzLl9fZmFsbGJhY2sobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbm9kZSB0eXBlICcgKyBub2RlVHlwZSArICcuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY2FuZGlkYXRlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKChjdXJyZW50IC09IDEpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gY2FuZGlkYXRlc1tjdXJyZW50XTtcbiAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlID0gbm9kZVtrZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmRpZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjYW5kaWRhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50MiA9IGNhbmRpZGF0ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGN1cnJlbnQyIC09IDEpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmRpZGF0ZVtjdXJyZW50Ml0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1Byb3BlcnR5KG5vZGVUeXBlLCBjYW5kaWRhdGVzW2N1cnJlbnRdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gbmV3IEVsZW1lbnQoY2FuZGlkYXRlW2N1cnJlbnQyXSwgW2tleSwgY3VycmVudDJdLCAnUHJvcGVydHknLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzTm9kZShjYW5kaWRhdGVbY3VycmVudDJdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gbmV3IEVsZW1lbnQoY2FuZGlkYXRlW2N1cnJlbnQyXSwgW2tleSwgY3VycmVudDJdLCBudWxsLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ya2xpc3QucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc05vZGUoY2FuZGlkYXRlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd29ya2xpc3QucHVzaChuZXcgRWxlbWVudChjYW5kaWRhdGUsIGtleSwgbnVsbCwgbnVsbCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIENvbnRyb2xsZXIucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHJvb3QsIHZpc2l0b3IpIHtcbiAgICAgICAgdmFyIHdvcmtsaXN0LFxuICAgICAgICAgICAgbGVhdmVsaXN0LFxuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIG5vZGVUeXBlLFxuICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICBjdXJyZW50MixcbiAgICAgICAgICAgIGNhbmRpZGF0ZXMsXG4gICAgICAgICAgICBjYW5kaWRhdGUsXG4gICAgICAgICAgICBzZW50aW5lbCxcbiAgICAgICAgICAgIG91dGVyLFxuICAgICAgICAgICAga2V5O1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZUVsZW0oZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIG5leHRFbGVtLFxuICAgICAgICAgICAgICAgIHBhcmVudDtcblxuICAgICAgICAgICAgaWYgKGVsZW1lbnQucmVmLnJlbW92ZSgpKSB7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgcmVmZXJlbmNlIGlzIGFuIGVsZW1lbnQgb2YgYW4gYXJyYXkuXG4gICAgICAgICAgICAgICAga2V5ID0gZWxlbWVudC5yZWYua2V5O1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IGVsZW1lbnQucmVmLnBhcmVudDtcblxuICAgICAgICAgICAgICAgIC8vIElmIHJlbW92ZWQgZnJvbSBhcnJheSwgdGhlbiBkZWNyZWFzZSBmb2xsb3dpbmcgaXRlbXMnIGtleXMuXG4gICAgICAgICAgICAgICAgaSA9IHdvcmtsaXN0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRFbGVtID0gd29ya2xpc3RbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0RWxlbS5yZWYgJiYgbmV4dEVsZW0ucmVmLnBhcmVudCA9PT0gcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAgKG5leHRFbGVtLnJlZi5rZXkgPCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC0tbmV4dEVsZW0ucmVmLmtleTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX19pbml0aWFsaXplKHJvb3QsIHZpc2l0b3IpO1xuXG4gICAgICAgIHNlbnRpbmVsID0ge307XG5cbiAgICAgICAgLy8gcmVmZXJlbmNlXG4gICAgICAgIHdvcmtsaXN0ID0gdGhpcy5fX3dvcmtsaXN0O1xuICAgICAgICBsZWF2ZWxpc3QgPSB0aGlzLl9fbGVhdmVsaXN0O1xuXG4gICAgICAgIC8vIGluaXRpYWxpemVcbiAgICAgICAgb3V0ZXIgPSB7XG4gICAgICAgICAgICByb290OiByb290XG4gICAgICAgIH07XG4gICAgICAgIGVsZW1lbnQgPSBuZXcgRWxlbWVudChyb290LCBudWxsLCBudWxsLCBuZXcgUmVmZXJlbmNlKG91dGVyLCAncm9vdCcpKTtcbiAgICAgICAgd29ya2xpc3QucHVzaChlbGVtZW50KTtcbiAgICAgICAgbGVhdmVsaXN0LnB1c2goZWxlbWVudCk7XG5cbiAgICAgICAgd2hpbGUgKHdvcmtsaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgZWxlbWVudCA9IHdvcmtsaXN0LnBvcCgpO1xuXG4gICAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gc2VudGluZWwpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gbGVhdmVsaXN0LnBvcCgpO1xuXG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcy5fX2V4ZWN1dGUodmlzaXRvci5sZWF2ZSwgZWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICAvLyBub2RlIG1heSBiZSByZXBsYWNlZCB3aXRoIG51bGwsXG4gICAgICAgICAgICAgICAgLy8gc28gZGlzdGluZ3Vpc2ggYmV0d2VlbiB1bmRlZmluZWQgYW5kIG51bGwgaW4gdGhpcyBwbGFjZVxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgIT09IHVuZGVmaW5lZCAmJiB0YXJnZXQgIT09IEJSRUFLICYmIHRhcmdldCAhPT0gU0tJUCAmJiB0YXJnZXQgIT09IFJFTU9WRSkge1xuICAgICAgICAgICAgICAgICAgICAvLyByZXBsYWNlXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucmVmLnJlcGxhY2UodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX3N0YXRlID09PSBSRU1PVkUgfHwgdGFyZ2V0ID09PSBSRU1PVkUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRWxlbShlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX3N0YXRlID09PSBCUkVBSyB8fCB0YXJnZXQgPT09IEJSRUFLKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXRlci5yb290O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcy5fX2V4ZWN1dGUodmlzaXRvci5lbnRlciwgZWxlbWVudCk7XG5cbiAgICAgICAgICAgIC8vIG5vZGUgbWF5IGJlIHJlcGxhY2VkIHdpdGggbnVsbCxcbiAgICAgICAgICAgIC8vIHNvIGRpc3Rpbmd1aXNoIGJldHdlZW4gdW5kZWZpbmVkIGFuZCBudWxsIGluIHRoaXMgcGxhY2VcbiAgICAgICAgICAgIGlmICh0YXJnZXQgIT09IHVuZGVmaW5lZCAmJiB0YXJnZXQgIT09IEJSRUFLICYmIHRhcmdldCAhPT0gU0tJUCAmJiB0YXJnZXQgIT09IFJFTU9WRSkge1xuICAgICAgICAgICAgICAgIC8vIHJlcGxhY2VcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlZi5yZXBsYWNlKHRhcmdldCk7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5ub2RlID0gdGFyZ2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fX3N0YXRlID09PSBSRU1PVkUgfHwgdGFyZ2V0ID09PSBSRU1PVkUpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVFbGVtKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQubm9kZSA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9fc3RhdGUgPT09IEJSRUFLIHx8IHRhcmdldCA9PT0gQlJFQUspIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0ZXIucm9vdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbm9kZSBtYXkgYmUgbnVsbFxuICAgICAgICAgICAgbm9kZSA9IGVsZW1lbnQubm9kZTtcbiAgICAgICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3b3JrbGlzdC5wdXNoKHNlbnRpbmVsKTtcbiAgICAgICAgICAgIGxlYXZlbGlzdC5wdXNoKGVsZW1lbnQpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fX3N0YXRlID09PSBTS0lQIHx8IHRhcmdldCA9PT0gU0tJUCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub2RlVHlwZSA9IG5vZGUudHlwZSB8fCBlbGVtZW50LndyYXA7XG4gICAgICAgICAgICBjYW5kaWRhdGVzID0gdGhpcy5fX2tleXNbbm9kZVR5cGVdO1xuICAgICAgICAgICAgaWYgKCFjYW5kaWRhdGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19mYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGVzID0gdGhpcy5fX2ZhbGxiYWNrKG5vZGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBub2RlIHR5cGUgJyArIG5vZGVUeXBlICsgJy4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1cnJlbnQgPSBjYW5kaWRhdGVzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgoY3VycmVudCAtPSAxKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gY2FuZGlkYXRlc1tjdXJyZW50XTtcbiAgICAgICAgICAgICAgICBjYW5kaWRhdGUgPSBub2RlW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKCFjYW5kaWRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2FuZGlkYXRlKSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50MiA9IGNhbmRpZGF0ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgoY3VycmVudDIgLT0gMSkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5kaWRhdGVbY3VycmVudDJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNQcm9wZXJ0eShub2RlVHlwZSwgY2FuZGlkYXRlc1tjdXJyZW50XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gbmV3IEVsZW1lbnQoY2FuZGlkYXRlW2N1cnJlbnQyXSwgW2tleSwgY3VycmVudDJdLCAnUHJvcGVydHknLCBuZXcgUmVmZXJlbmNlKGNhbmRpZGF0ZSwgY3VycmVudDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNOb2RlKGNhbmRpZGF0ZVtjdXJyZW50Ml0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IG5ldyBFbGVtZW50KGNhbmRpZGF0ZVtjdXJyZW50Ml0sIFtrZXksIGN1cnJlbnQyXSwgbnVsbCwgbmV3IFJlZmVyZW5jZShjYW5kaWRhdGUsIGN1cnJlbnQyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya2xpc3QucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNOb2RlKGNhbmRpZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgd29ya2xpc3QucHVzaChuZXcgRWxlbWVudChjYW5kaWRhdGUsIGtleSwgbnVsbCwgbmV3IFJlZmVyZW5jZShub2RlLCBrZXkpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dGVyLnJvb3Q7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHRyYXZlcnNlKHJvb3QsIHZpc2l0b3IpIHtcbiAgICAgICAgdmFyIGNvbnRyb2xsZXIgPSBuZXcgQ29udHJvbGxlcigpO1xuICAgICAgICByZXR1cm4gY29udHJvbGxlci50cmF2ZXJzZShyb290LCB2aXNpdG9yKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlKHJvb3QsIHZpc2l0b3IpIHtcbiAgICAgICAgdmFyIGNvbnRyb2xsZXIgPSBuZXcgQ29udHJvbGxlcigpO1xuICAgICAgICByZXR1cm4gY29udHJvbGxlci5yZXBsYWNlKHJvb3QsIHZpc2l0b3IpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4dGVuZENvbW1lbnRSYW5nZShjb21tZW50LCB0b2tlbnMpIHtcbiAgICAgICAgdmFyIHRhcmdldDtcblxuICAgICAgICB0YXJnZXQgPSB1cHBlckJvdW5kKHRva2VucywgZnVuY3Rpb24gc2VhcmNoKHRva2VuKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW4ucmFuZ2VbMF0gPiBjb21tZW50LnJhbmdlWzBdO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb21tZW50LmV4dGVuZGVkUmFuZ2UgPSBbY29tbWVudC5yYW5nZVswXSwgY29tbWVudC5yYW5nZVsxXV07XG5cbiAgICAgICAgaWYgKHRhcmdldCAhPT0gdG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgY29tbWVudC5leHRlbmRlZFJhbmdlWzFdID0gdG9rZW5zW3RhcmdldF0ucmFuZ2VbMF07XG4gICAgICAgIH1cblxuICAgICAgICB0YXJnZXQgLT0gMTtcbiAgICAgICAgaWYgKHRhcmdldCA+PSAwKSB7XG4gICAgICAgICAgICBjb21tZW50LmV4dGVuZGVkUmFuZ2VbMF0gPSB0b2tlbnNbdGFyZ2V0XS5yYW5nZVsxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb21tZW50O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGF0dGFjaENvbW1lbnRzKHRyZWUsIHByb3ZpZGVkQ29tbWVudHMsIHRva2Vucykge1xuICAgICAgICAvLyBBdCBmaXJzdCwgd2Ugc2hvdWxkIGNhbGN1bGF0ZSBleHRlbmRlZCBjb21tZW50IHJhbmdlcy5cbiAgICAgICAgdmFyIGNvbW1lbnRzID0gW10sIGNvbW1lbnQsIGxlbiwgaSwgY3Vyc29yO1xuXG4gICAgICAgIGlmICghdHJlZS5yYW5nZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhdHRhY2hDb21tZW50cyBuZWVkcyByYW5nZSBpbmZvcm1hdGlvbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdG9rZW5zIGFycmF5IGlzIGVtcHR5LCB3ZSBhdHRhY2ggY29tbWVudHMgdG8gdHJlZSBhcyAnbGVhZGluZ0NvbW1lbnRzJ1xuICAgICAgICBpZiAoIXRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChwcm92aWRlZENvbW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHByb3ZpZGVkQ29tbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IGRlZXBDb3B5KHByb3ZpZGVkQ29tbWVudHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50LmV4dGVuZGVkUmFuZ2UgPSBbMCwgdHJlZS5yYW5nZVswXV07XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyZWUubGVhZGluZ0NvbW1lbnRzID0gY29tbWVudHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHByb3ZpZGVkQ29tbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbW1lbnRzLnB1c2goZXh0ZW5kQ29tbWVudFJhbmdlKGRlZXBDb3B5KHByb3ZpZGVkQ29tbWVudHNbaV0pLCB0b2tlbnMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoaXMgaXMgYmFzZWQgb24gSm9obiBGcmVlbWFuJ3MgaW1wbGVtZW50YXRpb24uXG4gICAgICAgIGN1cnNvciA9IDA7XG4gICAgICAgIHRyYXZlcnNlKHRyZWUsIHtcbiAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBjb21tZW50O1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKGN1cnNvciA8IGNvbW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0gY29tbWVudHNbY3Vyc29yXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1lbnQuZXh0ZW5kZWRSYW5nZVsxXSA+IG5vZGUucmFuZ2VbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1lbnQuZXh0ZW5kZWRSYW5nZVsxXSA9PT0gbm9kZS5yYW5nZVswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLmxlYWRpbmdDb21tZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubGVhZGluZ0NvbW1lbnRzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmxlYWRpbmdDb21tZW50cy5wdXNoKGNvbW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudHMuc3BsaWNlKGN1cnNvciwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGFscmVhZHkgb3V0IG9mIG93bmVkIG5vZGVcbiAgICAgICAgICAgICAgICBpZiAoY3Vyc29yID09PSBjb21tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFZpc2l0b3JPcHRpb24uQnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGNvbW1lbnRzW2N1cnNvcl0uZXh0ZW5kZWRSYW5nZVswXSA+IG5vZGUucmFuZ2VbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFZpc2l0b3JPcHRpb24uU2tpcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGN1cnNvciA9IDA7XG4gICAgICAgIHRyYXZlcnNlKHRyZWUsIHtcbiAgICAgICAgICAgIGxlYXZlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBjb21tZW50O1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKGN1cnNvciA8IGNvbW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0gY29tbWVudHNbY3Vyc29yXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUucmFuZ2VbMV0gPCBjb21tZW50LmV4dGVuZGVkUmFuZ2VbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUucmFuZ2VbMV0gPT09IGNvbW1lbnQuZXh0ZW5kZWRSYW5nZVswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLnRyYWlsaW5nQ29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnRyYWlsaW5nQ29tbWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUudHJhaWxpbmdDb21tZW50cy5wdXNoKGNvbW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudHMuc3BsaWNlKGN1cnNvciwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGFscmVhZHkgb3V0IG9mIG93bmVkIG5vZGVcbiAgICAgICAgICAgICAgICBpZiAoY3Vyc29yID09PSBjb21tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFZpc2l0b3JPcHRpb24uQnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGNvbW1lbnRzW2N1cnNvcl0uZXh0ZW5kZWRSYW5nZVswXSA+IG5vZGUucmFuZ2VbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFZpc2l0b3JPcHRpb24uU2tpcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgIH1cblxuICAgIGV4cG9ydHMudmVyc2lvbiA9IHJlcXVpcmUoJy4vcGFja2FnZS5qc29uJykudmVyc2lvbjtcbiAgICBleHBvcnRzLlN5bnRheCA9IFN5bnRheDtcbiAgICBleHBvcnRzLnRyYXZlcnNlID0gdHJhdmVyc2U7XG4gICAgZXhwb3J0cy5yZXBsYWNlID0gcmVwbGFjZTtcbiAgICBleHBvcnRzLmF0dGFjaENvbW1lbnRzID0gYXR0YWNoQ29tbWVudHM7XG4gICAgZXhwb3J0cy5WaXNpdG9yS2V5cyA9IFZpc2l0b3JLZXlzO1xuICAgIGV4cG9ydHMuVmlzaXRvck9wdGlvbiA9IFZpc2l0b3JPcHRpb247XG4gICAgZXhwb3J0cy5Db250cm9sbGVyID0gQ29udHJvbGxlcjtcbiAgICBleHBvcnRzLmNsb25lRW52aXJvbm1lbnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjbG9uZSh7fSk7IH07XG5cbiAgICByZXR1cm4gZXhwb3J0cztcbn0oZXhwb3J0cykpO1xuLyogdmltOiBzZXQgc3c9NCB0cz00IGV0IHR3PTgwIDogKi9cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJfYXJnc1wiOiBbXG4gICAgW1xuICAgICAgXCJlc3RyYXZlcnNlQDQuMy4wXCIsXG4gICAgICBcIi9tbnQvYy9Vc2Vycy9kaG4wMy9zb3VyY2UvcHJvamVjdHMvanNmbG93L2pzZmxvdy1tYXN0ZXJcIlxuICAgIF1cbiAgXSxcbiAgXCJfZnJvbVwiOiBcImVzdHJhdmVyc2VANC4zLjBcIixcbiAgXCJfaWRcIjogXCJlc3RyYXZlcnNlQDQuMy4wXCIsXG4gIFwiX2luQnVuZGxlXCI6IGZhbHNlLFxuICBcIl9pbnRlZ3JpdHlcIjogXCJzaGE1MTItMzlubktmZld6OHhOMUJVLzJjNzluOW5COUhEem8wbmlZVXF4Nnh5cVVueW9BblF5eVdwT1RkWkVlaUNjaDhCQnU1MTV0NHdwOVptZ1ZmVmhuOUVCcHc9PVwiLFxuICBcIl9sb2NhdGlvblwiOiBcIi9lc3RyYXZlcnNlXCIsXG4gIFwiX3BoYW50b21DaGlsZHJlblwiOiB7fSxcbiAgXCJfcmVxdWVzdGVkXCI6IHtcbiAgICBcInR5cGVcIjogXCJ2ZXJzaW9uXCIsXG4gICAgXCJyZWdpc3RyeVwiOiB0cnVlLFxuICAgIFwicmF3XCI6IFwiZXN0cmF2ZXJzZUA0LjMuMFwiLFxuICAgIFwibmFtZVwiOiBcImVzdHJhdmVyc2VcIixcbiAgICBcImVzY2FwZWROYW1lXCI6IFwiZXN0cmF2ZXJzZVwiLFxuICAgIFwicmF3U3BlY1wiOiBcIjQuMy4wXCIsXG4gICAgXCJzYXZlU3BlY1wiOiBudWxsLFxuICAgIFwiZmV0Y2hTcGVjXCI6IFwiNC4zLjBcIlxuICB9LFxuICBcIl9yZXF1aXJlZEJ5XCI6IFtcbiAgICBcIi9cIixcbiAgICBcIi9lc2NvZGVnZW5cIixcbiAgICBcIi9zdGF0aWMtZXZhbC9lc2NvZGVnZW5cIixcbiAgICBcIi9zdGF0aWMtbW9kdWxlL2VzY29kZWdlblwiXG4gIF0sXG4gIFwiX3Jlc29sdmVkXCI6IFwiaHR0cHM6Ly9yZWdpc3RyeS5ucG1qcy5vcmcvZXN0cmF2ZXJzZS8tL2VzdHJhdmVyc2UtNC4zLjAudGd6XCIsXG4gIFwiX3NwZWNcIjogXCI0LjMuMFwiLFxuICBcIl93aGVyZVwiOiBcIi9tbnQvYy9Vc2Vycy9kaG4wMy9zb3VyY2UvcHJvamVjdHMvanNmbG93L2pzZmxvdy1tYXN0ZXJcIixcbiAgXCJidWdzXCI6IHtcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9lc3Rvb2xzL2VzdHJhdmVyc2UvaXNzdWVzXCJcbiAgfSxcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkVDTUFTY3JpcHQgSlMgQVNUIHRyYXZlcnNhbCBmdW5jdGlvbnNcIixcbiAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiYmFiZWwtcHJlc2V0LWVudlwiOiBcIl4xLjYuMVwiLFxuICAgIFwiYmFiZWwtcmVnaXN0ZXJcIjogXCJeNi4zLjEzXCIsXG4gICAgXCJjaGFpXCI6IFwiXjIuMS4xXCIsXG4gICAgXCJlc3ByZWVcIjogXCJeMS4xMS4wXCIsXG4gICAgXCJndWxwXCI6IFwiXjMuOC4xMFwiLFxuICAgIFwiZ3VscC1idW1wXCI6IFwiXjAuMi4yXCIsXG4gICAgXCJndWxwLWZpbHRlclwiOiBcIl4yLjAuMFwiLFxuICAgIFwiZ3VscC1naXRcIjogXCJeMS4wLjFcIixcbiAgICBcImd1bHAtdGFnLXZlcnNpb25cIjogXCJeMS4zLjBcIixcbiAgICBcImpzaGludFwiOiBcIl4yLjUuNlwiLFxuICAgIFwibW9jaGFcIjogXCJeMi4xLjBcIlxuICB9LFxuICBcImVuZ2luZXNcIjoge1xuICAgIFwibm9kZVwiOiBcIj49NC4wXCJcbiAgfSxcbiAgXCJob21lcGFnZVwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9lc3Rvb2xzL2VzdHJhdmVyc2VcIixcbiAgXCJsaWNlbnNlXCI6IFwiQlNELTItQ2xhdXNlXCIsXG4gIFwibWFpblwiOiBcImVzdHJhdmVyc2UuanNcIixcbiAgXCJtYWludGFpbmVyc1wiOiBbXG4gICAge1xuICAgICAgXCJuYW1lXCI6IFwiWXVzdWtlIFN1enVraVwiLFxuICAgICAgXCJlbWFpbFwiOiBcInV0YXRhbmUudGVhQGdtYWlsLmNvbVwiLFxuICAgICAgXCJ1cmxcIjogXCJodHRwOi8vZ2l0aHViLmNvbS9Db25zdGVsbGF0aW9uXCJcbiAgICB9XG4gIF0sXG4gIFwibmFtZVwiOiBcImVzdHJhdmVyc2VcIixcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImdpdCtzc2g6Ly9naXRAZ2l0aHViLmNvbS9lc3Rvb2xzL2VzdHJhdmVyc2UuZ2l0XCJcbiAgfSxcbiAgXCJzY3JpcHRzXCI6IHtcbiAgICBcImxpbnRcIjogXCJqc2hpbnQgZXN0cmF2ZXJzZS5qc1wiLFxuICAgIFwidGVzdFwiOiBcIm5wbSBydW4tc2NyaXB0IGxpbnQgJiYgbnBtIHJ1bi1zY3JpcHQgdW5pdC10ZXN0XCIsXG4gICAgXCJ1bml0LXRlc3RcIjogXCJtb2NoYSAtLWNvbXBpbGVycyBqczpiYWJlbC1yZWdpc3RlclwiXG4gIH0sXG4gIFwidmVyc2lvblwiOiBcIjQuMy4wXCJcbn1cbiIsIi8qXG4gIENvcHlyaWdodCAoQykgMjAxMyBZdXN1a2UgU3V6dWtpIDx1dGF0YW5lLnRlYUBnbWFpbC5jb20+XG5cbiAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyAnQVMgSVMnXG4gIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxuICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcbiAgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5cbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgZnVuY3Rpb24gaXNFeHByZXNzaW9uKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0FycmF5RXhwcmVzc2lvbic6XG4gICAgICAgICAgICBjYXNlICdBc3NpZ25tZW50RXhwcmVzc2lvbic6XG4gICAgICAgICAgICBjYXNlICdCaW5hcnlFeHByZXNzaW9uJzpcbiAgICAgICAgICAgIGNhc2UgJ0NhbGxFeHByZXNzaW9uJzpcbiAgICAgICAgICAgIGNhc2UgJ0NvbmRpdGlvbmFsRXhwcmVzc2lvbic6XG4gICAgICAgICAgICBjYXNlICdGdW5jdGlvbkV4cHJlc3Npb24nOlxuICAgICAgICAgICAgY2FzZSAnSWRlbnRpZmllcic6XG4gICAgICAgICAgICBjYXNlICdMaXRlcmFsJzpcbiAgICAgICAgICAgIGNhc2UgJ0xvZ2ljYWxFeHByZXNzaW9uJzpcbiAgICAgICAgICAgIGNhc2UgJ01lbWJlckV4cHJlc3Npb24nOlxuICAgICAgICAgICAgY2FzZSAnTmV3RXhwcmVzc2lvbic6XG4gICAgICAgICAgICBjYXNlICdPYmplY3RFeHByZXNzaW9uJzpcbiAgICAgICAgICAgIGNhc2UgJ1NlcXVlbmNlRXhwcmVzc2lvbic6XG4gICAgICAgICAgICBjYXNlICdUaGlzRXhwcmVzc2lvbic6XG4gICAgICAgICAgICBjYXNlICdVbmFyeUV4cHJlc3Npb24nOlxuICAgICAgICAgICAgY2FzZSAnVXBkYXRlRXhwcmVzc2lvbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSXRlcmF0aW9uU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0RvV2hpbGVTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnRm9ySW5TdGF0ZW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnRm9yU3RhdGVtZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ1doaWxlU3RhdGVtZW50JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnQmxvY2tTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnQnJlYWtTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnQ29udGludWVTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnRGVidWdnZXJTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnRG9XaGlsZVN0YXRlbWVudCc6XG4gICAgICAgICAgICBjYXNlICdFbXB0eVN0YXRlbWVudCc6XG4gICAgICAgICAgICBjYXNlICdFeHByZXNzaW9uU3RhdGVtZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ0ZvckluU3RhdGVtZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ0ZvclN0YXRlbWVudCc6XG4gICAgICAgICAgICBjYXNlICdJZlN0YXRlbWVudCc6XG4gICAgICAgICAgICBjYXNlICdMYWJlbGVkU3RhdGVtZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ1JldHVyblN0YXRlbWVudCc6XG4gICAgICAgICAgICBjYXNlICdTd2l0Y2hTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnVGhyb3dTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnVHJ5U3RhdGVtZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ1ZhcmlhYmxlRGVjbGFyYXRpb24nOlxuICAgICAgICAgICAgY2FzZSAnV2hpbGVTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnV2l0aFN0YXRlbWVudCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU291cmNlRWxlbWVudChub2RlKSB7XG4gICAgICByZXR1cm4gaXNTdGF0ZW1lbnQobm9kZSkgfHwgbm9kZSAhPSBudWxsICYmIG5vZGUudHlwZSA9PT0gJ0Z1bmN0aW9uRGVjbGFyYXRpb24nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYWlsaW5nU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnSWZTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgaWYgKG5vZGUuYWx0ZXJuYXRlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5hbHRlcm5hdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5jb25zZXF1ZW50O1xuXG4gICAgICAgIGNhc2UgJ0xhYmVsZWRTdGF0ZW1lbnQnOlxuICAgICAgICBjYXNlICdGb3JTdGF0ZW1lbnQnOlxuICAgICAgICBjYXNlICdGb3JJblN0YXRlbWVudCc6XG4gICAgICAgIGNhc2UgJ1doaWxlU3RhdGVtZW50JzpcbiAgICAgICAgY2FzZSAnV2l0aFN0YXRlbWVudCc6XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5ib2R5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzUHJvYmxlbWF0aWNJZlN0YXRlbWVudChub2RlKSB7XG4gICAgICAgIHZhciBjdXJyZW50O1xuXG4gICAgICAgIGlmIChub2RlLnR5cGUgIT09ICdJZlN0YXRlbWVudCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5hbHRlcm5hdGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBub2RlLmNvbnNlcXVlbnQ7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50LnR5cGUgPT09ICdJZlN0YXRlbWVudCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5hbHRlcm5hdGUgPT0gbnVsbCkgIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudCA9IHRyYWlsaW5nU3RhdGVtZW50KGN1cnJlbnQpO1xuICAgICAgICB9IHdoaWxlIChjdXJyZW50KTtcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGlzRXhwcmVzc2lvbjogaXNFeHByZXNzaW9uLFxuICAgICAgICBpc1N0YXRlbWVudDogaXNTdGF0ZW1lbnQsXG4gICAgICAgIGlzSXRlcmF0aW9uU3RhdGVtZW50OiBpc0l0ZXJhdGlvblN0YXRlbWVudCxcbiAgICAgICAgaXNTb3VyY2VFbGVtZW50OiBpc1NvdXJjZUVsZW1lbnQsXG4gICAgICAgIGlzUHJvYmxlbWF0aWNJZlN0YXRlbWVudDogaXNQcm9ibGVtYXRpY0lmU3RhdGVtZW50LFxuXG4gICAgICAgIHRyYWlsaW5nU3RhdGVtZW50OiB0cmFpbGluZ1N0YXRlbWVudFxuICAgIH07XG59KCkpO1xuLyogdmltOiBzZXQgc3c9NCB0cz00IGV0IHR3PTgwIDogKi9cbiIsIi8qXG4gIENvcHlyaWdodCAoQykgMjAxMy0yMDE0IFl1c3VrZSBTdXp1a2kgPHV0YXRhbmUudGVhQGdtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDE0IEl2YW4gTmlrdWxpbiA8aWZhYWFuQGdtYWlsLmNvbT5cblxuICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuICBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCA8Q09QWVJJR0hUIEhPTERFUj4gQkUgTElBQkxFIEZPUiBBTllcbiAgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbiAgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuICBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkRcbiAgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GXG4gIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xuXG4oZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBFUzZSZWdleCwgRVM1UmVnZXgsIE5PTl9BU0NJSV9XSElURVNQQUNFUywgSURFTlRJRklFUl9TVEFSVCwgSURFTlRJRklFUl9QQVJULCBjaDtcblxuICAgIC8vIFNlZSBgdG9vbHMvZ2VuZXJhdGUtaWRlbnRpZmllci1yZWdleC5qc2AuXG4gICAgRVM1UmVnZXggPSB7XG4gICAgICAgIC8vIEVDTUFTY3JpcHQgNS4xL1VuaWNvZGUgdjkuMC4wIE5vbkFzY2lpSWRlbnRpZmllclN0YXJ0OlxuICAgICAgICBOb25Bc2NpaUlkZW50aWZpZXJTdGFydDogL1tcXHhBQVxceEI1XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzdGXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDhBLVxcdTA1MkZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYyMC1cXHUwNjRBXFx1MDY2RVxcdTA2NkZcXHUwNjcxLVxcdTA2RDNcXHUwNkQ1XFx1MDZFNVxcdTA2RTZcXHUwNkVFXFx1MDZFRlxcdTA2RkEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwXFx1MDcxMi1cXHUwNzJGXFx1MDc0RC1cXHUwN0E1XFx1MDdCMVxcdTA3Q0EtXFx1MDdFQVxcdTA3RjRcXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgxNVxcdTA4MUFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4QTAtXFx1MDhCNFxcdTA4QjYtXFx1MDhCRFxcdTA5MDQtXFx1MDkzOVxcdTA5M0RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTgwXFx1MDk4NS1cXHUwOThDXFx1MDk4RlxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjBcXHUwOUIyXFx1MDlCNi1cXHUwOUI5XFx1MDlCRFxcdTA5Q0VcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFMVxcdTA5RjBcXHUwOUYxXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE3Mi1cXHUwQTc0XFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJEXFx1MEFEMFxcdTBBRTBcXHUwQUUxXFx1MEFGOVxcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNEXFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjFcXHUwQjcxXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkQwXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRFxcdTBDNTgtXFx1MEM1QVxcdTBDNjBcXHUwQzYxXFx1MEM4MFxcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkRcXHUwQ0RFXFx1MENFMFxcdTBDRTFcXHUwQ0YxXFx1MENGMlxcdTBEMDUtXFx1MEQwQ1xcdTBEMEUtXFx1MEQxMFxcdTBEMTItXFx1MEQzQVxcdTBEM0RcXHUwRDRFXFx1MEQ1NC1cXHUwRDU2XFx1MEQ1Ri1cXHUwRDYxXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBFMDEtXFx1MEUzMFxcdTBFMzJcXHUwRTMzXFx1MEU0MC1cXHUwRTQ2XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjBcXHUwRUIyXFx1MEVCM1xcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGNDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGODgtXFx1MEY4Q1xcdTEwMDAtXFx1MTAyQVxcdTEwM0ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVBLVxcdTEwNURcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZFLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhFXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNVxcdTEzRjgtXFx1MTNGRFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3ODAtXFx1MTdCM1xcdTE3RDdcXHUxN0RDXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxODg0XFx1MTg4Ny1cXHUxOEE4XFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5NTAtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTFBMDAtXFx1MUExNlxcdTFBMjAtXFx1MUE1NFxcdTFBQTdcXHUxQjA1LVxcdTFCMzNcXHUxQjQ1LVxcdTFCNEJcXHUxQjgzLVxcdTFCQTBcXHUxQkFFXFx1MUJBRlxcdTFCQkEtXFx1MUJFNVxcdTFDMDAtXFx1MUMyM1xcdTFDNEQtXFx1MUM0RlxcdTFDNUEtXFx1MUM3RFxcdTFDODAtXFx1MUM4OFxcdTFDRTktXFx1MUNFQ1xcdTFDRUUtXFx1MUNGMVxcdTFDRjVcXHUxQ0Y2XFx1MUQwMC1cXHUxREJGXFx1MUUwMC1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEyRi1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNFRVxcdTJDRjJcXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ4MC1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MkUyRlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOUQtXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZENVxcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYxRlxcdUE2MkFcXHVBNjJCXFx1QTY0MC1cXHVBNjZFXFx1QTY3Ri1cXHVBNjlEXFx1QTZBMC1cXHVBNkVGXFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBN0FFXFx1QTdCMC1cXHVBN0I3XFx1QTdGNy1cXHVBODAxXFx1QTgwMy1cXHVBODA1XFx1QTgwNy1cXHVBODBBXFx1QTgwQy1cXHVBODIyXFx1QTg0MC1cXHVBODczXFx1QTg4Mi1cXHVBOEIzXFx1QThGMi1cXHVBOEY3XFx1QThGQlxcdUE4RkRcXHVBOTBBLVxcdUE5MjVcXHVBOTMwLVxcdUE5NDZcXHVBOTYwLVxcdUE5N0NcXHVBOTg0LVxcdUE5QjJcXHVBOUNGXFx1QTlFMC1cXHVBOUU0XFx1QTlFNi1cXHVBOUVGXFx1QTlGQS1cXHVBOUZFXFx1QUEwMC1cXHVBQTI4XFx1QUE0MC1cXHVBQTQyXFx1QUE0NC1cXHVBQTRCXFx1QUE2MC1cXHVBQTc2XFx1QUE3QVxcdUFBN0UtXFx1QUFBRlxcdUFBQjFcXHVBQUI1XFx1QUFCNlxcdUFBQjktXFx1QUFCRFxcdUFBQzBcXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVBXFx1QUFGMi1cXHVBQUY0XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjY1XFx1QUI3MC1cXHVBQkUyXFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRFxcdUZCMUYtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYyMS1cXHVGRjNBXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXS8sXG4gICAgICAgIC8vIEVDTUFTY3JpcHQgNS4xL1VuaWNvZGUgdjkuMC4wIE5vbkFzY2lpSWRlbnRpZmllclBhcnQ6XG4gICAgICAgIE5vbkFzY2lpSWRlbnRpZmllclBhcnQ6IC9bXFx4QUFcXHhCNVxceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzMDAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM3RlxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0Y1XFx1MDNGNy1cXHUwNDgxXFx1MDQ4My1cXHUwNDg3XFx1MDQ4QS1cXHUwNTJGXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1OTEtXFx1MDVCRFxcdTA1QkZcXHUwNUMxXFx1MDVDMlxcdTA1QzRcXHUwNUM1XFx1MDVDN1xcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGMlxcdTA2MTAtXFx1MDYxQVxcdTA2MjAtXFx1MDY2OVxcdTA2NkUtXFx1MDZEM1xcdTA2RDUtXFx1MDZEQ1xcdTA2REYtXFx1MDZFOFxcdTA2RUEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwLVxcdTA3NEFcXHUwNzRELVxcdTA3QjFcXHUwN0MwLVxcdTA3RjVcXHUwN0ZBXFx1MDgwMC1cXHUwODJEXFx1MDg0MC1cXHUwODVCXFx1MDhBMC1cXHUwOEI0XFx1MDhCNi1cXHUwOEJEXFx1MDhENC1cXHUwOEUxXFx1MDhFMy1cXHUwOTYzXFx1MDk2Ni1cXHUwOTZGXFx1MDk3MS1cXHUwOTgzXFx1MDk4NS1cXHUwOThDXFx1MDk4RlxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjBcXHUwOUIyXFx1MDlCNi1cXHUwOUI5XFx1MDlCQy1cXHUwOUM0XFx1MDlDN1xcdTA5QzhcXHUwOUNCLVxcdTA5Q0VcXHUwOUQ3XFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTNcXHUwOUU2LVxcdTA5RjFcXHUwQTAxLVxcdTBBMDNcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBM0NcXHUwQTNFLVxcdTBBNDJcXHUwQTQ3XFx1MEE0OFxcdTBBNEItXFx1MEE0RFxcdTBBNTFcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE2Ni1cXHUwQTc1XFx1MEE4MS1cXHUwQTgzXFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJDLVxcdTBBQzVcXHUwQUM3LVxcdTBBQzlcXHUwQUNCLVxcdTBBQ0RcXHUwQUQwXFx1MEFFMC1cXHUwQUUzXFx1MEFFNi1cXHUwQUVGXFx1MEFGOVxcdTBCMDEtXFx1MEIwM1xcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNDLVxcdTBCNDRcXHUwQjQ3XFx1MEI0OFxcdTBCNEItXFx1MEI0RFxcdTBCNTZcXHUwQjU3XFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjNcXHUwQjY2LVxcdTBCNkZcXHUwQjcxXFx1MEI4MlxcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJCRS1cXHUwQkMyXFx1MEJDNi1cXHUwQkM4XFx1MEJDQS1cXHUwQkNEXFx1MEJEMFxcdTBCRDdcXHUwQkU2LVxcdTBCRUZcXHUwQzAwLVxcdTBDMDNcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzlcXHUwQzNELVxcdTBDNDRcXHUwQzQ2LVxcdTBDNDhcXHUwQzRBLVxcdTBDNERcXHUwQzU1XFx1MEM1NlxcdTBDNTgtXFx1MEM1QVxcdTBDNjAtXFx1MEM2M1xcdTBDNjYtXFx1MEM2RlxcdTBDODAtXFx1MEM4M1xcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkMtXFx1MENDNFxcdTBDQzYtXFx1MENDOFxcdTBDQ0EtXFx1MENDRFxcdTBDRDVcXHUwQ0Q2XFx1MENERVxcdTBDRTAtXFx1MENFM1xcdTBDRTYtXFx1MENFRlxcdTBDRjFcXHUwQ0YyXFx1MEQwMS1cXHUwRDAzXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRC1cXHUwRDQ0XFx1MEQ0Ni1cXHUwRDQ4XFx1MEQ0QS1cXHUwRDRFXFx1MEQ1NC1cXHUwRDU3XFx1MEQ1Ri1cXHUwRDYzXFx1MEQ2Ni1cXHUwRDZGXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4MlxcdTBEODNcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MERDQVxcdTBEQ0YtXFx1MERENFxcdTBERDZcXHUwREQ4LVxcdTBEREZcXHUwREU2LVxcdTBERUZcXHUwREYyXFx1MERGM1xcdTBFMDEtXFx1MEUzQVxcdTBFNDAtXFx1MEU0RVxcdTBFNTAtXFx1MEU1OVxcdTBFODFcXHUwRTgyXFx1MEU4NFxcdTBFODdcXHUwRTg4XFx1MEU4QVxcdTBFOERcXHUwRTk0LVxcdTBFOTdcXHUwRTk5LVxcdTBFOUZcXHUwRUExLVxcdTBFQTNcXHUwRUE1XFx1MEVBN1xcdTBFQUFcXHUwRUFCXFx1MEVBRC1cXHUwRUI5XFx1MEVCQi1cXHUwRUJEXFx1MEVDMC1cXHUwRUM0XFx1MEVDNlxcdTBFQzgtXFx1MEVDRFxcdTBFRDAtXFx1MEVEOVxcdTBFREMtXFx1MEVERlxcdTBGMDBcXHUwRjE4XFx1MEYxOVxcdTBGMjAtXFx1MEYyOVxcdTBGMzVcXHUwRjM3XFx1MEYzOVxcdTBGM0UtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGNzEtXFx1MEY4NFxcdTBGODYtXFx1MEY5N1xcdTBGOTktXFx1MEZCQ1xcdTBGQzZcXHUxMDAwLVxcdTEwNDlcXHUxMDUwLVxcdTEwOURcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEwRDAtXFx1MTBGQVxcdTEwRkMtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM1RC1cXHUxMzVGXFx1MTM4MC1cXHUxMzhGXFx1MTNBMC1cXHUxM0Y1XFx1MTNGOC1cXHUxM0ZEXFx1MTQwMS1cXHUxNjZDXFx1MTY2Ri1cXHUxNjdGXFx1MTY4MS1cXHUxNjlBXFx1MTZBMC1cXHUxNkVBXFx1MTZFRS1cXHUxNkY4XFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzE0XFx1MTcyMC1cXHUxNzM0XFx1MTc0MC1cXHUxNzUzXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc3MlxcdTE3NzNcXHUxNzgwLVxcdTE3RDNcXHUxN0Q3XFx1MTdEQ1xcdTE3RERcXHUxN0UwLVxcdTE3RTlcXHUxODBCLVxcdTE4MERcXHUxODEwLVxcdTE4MTlcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4QUFcXHUxOEIwLVxcdTE4RjVcXHUxOTAwLVxcdTE5MUVcXHUxOTIwLVxcdTE5MkJcXHUxOTMwLVxcdTE5M0JcXHUxOTQ2LVxcdTE5NkRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5QUJcXHUxOUIwLVxcdTE5QzlcXHUxOUQwLVxcdTE5RDlcXHUxQTAwLVxcdTFBMUJcXHUxQTIwLVxcdTFBNUVcXHUxQTYwLVxcdTFBN0NcXHUxQTdGLVxcdTFBODlcXHUxQTkwLVxcdTFBOTlcXHUxQUE3XFx1MUFCMC1cXHUxQUJEXFx1MUIwMC1cXHUxQjRCXFx1MUI1MC1cXHUxQjU5XFx1MUI2Qi1cXHUxQjczXFx1MUI4MC1cXHUxQkYzXFx1MUMwMC1cXHUxQzM3XFx1MUM0MC1cXHUxQzQ5XFx1MUM0RC1cXHUxQzdEXFx1MUM4MC1cXHUxQzg4XFx1MUNEMC1cXHUxQ0QyXFx1MUNENC1cXHUxQ0Y2XFx1MUNGOFxcdTFDRjlcXHUxRDAwLVxcdTFERjVcXHUxREZCLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjAwQ1xcdTIwMERcXHUyMDNGXFx1MjA0MFxcdTIwNTRcXHUyMDcxXFx1MjA3RlxcdTIwOTAtXFx1MjA5Q1xcdTIwRDAtXFx1MjBEQ1xcdTIwRTFcXHUyMEU1LVxcdTIwRjBcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMkRcXHUyMTJGLVxcdTIxMzlcXHUyMTNDLVxcdTIxM0ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRFXFx1MjE2MC1cXHUyMTg4XFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ3Ri1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MkRFMC1cXHUyREZGXFx1MkUyRlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyRlxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOTlcXHUzMDlBXFx1MzA5RC1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkQ1XFx1QTAwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjJCXFx1QTY0MC1cXHVBNjZGXFx1QTY3NC1cXHVBNjdEXFx1QTY3Ri1cXHVBNkYxXFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBN0FFXFx1QTdCMC1cXHVBN0I3XFx1QTdGNy1cXHVBODI3XFx1QTg0MC1cXHVBODczXFx1QTg4MC1cXHVBOEM1XFx1QThEMC1cXHVBOEQ5XFx1QThFMC1cXHVBOEY3XFx1QThGQlxcdUE4RkRcXHVBOTAwLVxcdUE5MkRcXHVBOTMwLVxcdUE5NTNcXHVBOTYwLVxcdUE5N0NcXHVBOTgwLVxcdUE5QzBcXHVBOUNGLVxcdUE5RDlcXHVBOUUwLVxcdUE5RkVcXHVBQTAwLVxcdUFBMzZcXHVBQTQwLVxcdUFBNERcXHVBQTUwLVxcdUFBNTlcXHVBQTYwLVxcdUFBNzZcXHVBQTdBLVxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUZcXHVBQUYyLVxcdUFBRjZcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQjMwLVxcdUFCNUFcXHVBQjVDLVxcdUFCNjVcXHVBQjcwLVxcdUFCRUFcXHVBQkVDXFx1QUJFRFxcdUFCRjAtXFx1QUJGOVxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZCMUQtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkUwMC1cXHVGRTBGXFx1RkUyMC1cXHVGRTJGXFx1RkUzM1xcdUZFMzRcXHVGRTRELVxcdUZFNEZcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjEwLVxcdUZGMTlcXHVGRjIxLVxcdUZGM0FcXHVGRjNGXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXS9cbiAgICB9O1xuXG4gICAgRVM2UmVnZXggPSB7XG4gICAgICAgIC8vIEVDTUFTY3JpcHQgNi9Vbmljb2RlIHY5LjAuMCBOb25Bc2NpaUlkZW50aWZpZXJTdGFydDpcbiAgICAgICAgTm9uQXNjaWlJZGVudGlmaWVyU3RhcnQ6IC9bXFx4QUFcXHhCNVxceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM3RlxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0Y1XFx1MDNGNy1cXHUwNDgxXFx1MDQ4QS1cXHUwNTJGXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGMlxcdTA2MjAtXFx1MDY0QVxcdTA2NkVcXHUwNjZGXFx1MDY3MS1cXHUwNkQzXFx1MDZENVxcdTA2RTVcXHUwNkU2XFx1MDZFRVxcdTA2RUZcXHUwNkZBLVxcdTA2RkNcXHUwNkZGXFx1MDcxMFxcdTA3MTItXFx1MDcyRlxcdTA3NEQtXFx1MDdBNVxcdTA3QjFcXHUwN0NBLVxcdTA3RUFcXHUwN0Y0XFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MTVcXHUwODFBXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwOEEwLVxcdTA4QjRcXHUwOEI2LVxcdTA4QkRcXHUwOTA0LVxcdTA5MzlcXHUwOTNEXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk4MFxcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkRcXHUwOUNFXFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTFcXHUwOUYwXFx1MDlGMVxcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNzItXFx1MEE3NFxcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCRFxcdTBBRDBcXHUwQUUwXFx1MEFFMVxcdTBBRjlcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzRFxcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYxXFx1MEI3MVxcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJEMFxcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0RcXHUwQzU4LVxcdTBDNUFcXHUwQzYwXFx1MEM2MVxcdTBDODBcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JEXFx1MENERVxcdTBDRTBcXHUwQ0UxXFx1MENGMVxcdTBDRjJcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNEXFx1MEQ0RVxcdTBENTQtXFx1MEQ1NlxcdTBENUYtXFx1MEQ2MVxcdTBEN0EtXFx1MEQ3RlxcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwRTAxLVxcdTBFMzBcXHUwRTMyXFx1MEUzM1xcdTBFNDAtXFx1MEU0NlxcdTBFODFcXHUwRTgyXFx1MEU4NFxcdTBFODdcXHUwRTg4XFx1MEU4QVxcdTBFOERcXHUwRTk0LVxcdTBFOTdcXHUwRTk5LVxcdTBFOUZcXHUwRUExLVxcdTBFQTNcXHUwRUE1XFx1MEVBN1xcdTBFQUFcXHUwRUFCXFx1MEVBRC1cXHUwRUIwXFx1MEVCMlxcdTBFQjNcXHUwRUJEXFx1MEVDMC1cXHUwRUM0XFx1MEVDNlxcdTBFREMtXFx1MEVERlxcdTBGMDBcXHUwRjQwLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjg4LVxcdTBGOENcXHUxMDAwLVxcdTEwMkFcXHUxMDNGXFx1MTA1MC1cXHUxMDU1XFx1MTA1QS1cXHUxMDVEXFx1MTA2MVxcdTEwNjVcXHUxMDY2XFx1MTA2RS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4RVxcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTBEMC1cXHUxMEZBXFx1MTBGQy1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OFxcdTEyOEEtXFx1MTI4RFxcdTEyOTAtXFx1MTJCMFxcdTEyQjItXFx1MTJCNVxcdTEyQjgtXFx1MTJCRVxcdTEyQzBcXHUxMkMyLVxcdTEyQzVcXHUxMkM4LVxcdTEyRDZcXHUxMkQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzgwLVxcdTEzOEZcXHUxM0EwLVxcdTEzRjVcXHUxM0Y4LVxcdTEzRkRcXHUxNDAxLVxcdTE2NkNcXHUxNjZGLVxcdTE2N0ZcXHUxNjgxLVxcdTE2OUFcXHUxNkEwLVxcdTE2RUFcXHUxNkVFLVxcdTE2RjhcXHUxNzAwLVxcdTE3MENcXHUxNzBFLVxcdTE3MTFcXHUxNzIwLVxcdTE3MzFcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzgwLVxcdTE3QjNcXHUxN0Q3XFx1MTdEQ1xcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThBOFxcdTE4QUFcXHUxOEIwLVxcdTE4RjVcXHUxOTAwLVxcdTE5MUVcXHUxOTUwLVxcdTE5NkRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5QUJcXHUxOUIwLVxcdTE5QzlcXHUxQTAwLVxcdTFBMTZcXHUxQTIwLVxcdTFBNTRcXHUxQUE3XFx1MUIwNS1cXHUxQjMzXFx1MUI0NS1cXHUxQjRCXFx1MUI4My1cXHUxQkEwXFx1MUJBRVxcdTFCQUZcXHUxQkJBLVxcdTFCRTVcXHUxQzAwLVxcdTFDMjNcXHUxQzRELVxcdTFDNEZcXHUxQzVBLVxcdTFDN0RcXHUxQzgwLVxcdTFDODhcXHUxQ0U5LVxcdTFDRUNcXHUxQ0VFLVxcdTFDRjFcXHUxQ0Y1XFx1MUNGNlxcdTFEMDAtXFx1MURCRlxcdTFFMDAtXFx1MUYxNVxcdTFGMTgtXFx1MUYxRFxcdTFGMjAtXFx1MUY0NVxcdTFGNDgtXFx1MUY0RFxcdTFGNTAtXFx1MUY1N1xcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUYtXFx1MUY3RFxcdTFGODAtXFx1MUZCNFxcdTFGQjYtXFx1MUZCQ1xcdTFGQkVcXHUxRkMyLVxcdTFGQzRcXHUxRkM2LVxcdTFGQ0NcXHUxRkQwLVxcdTFGRDNcXHUxRkQ2LVxcdTFGREJcXHUxRkUwLVxcdTFGRUNcXHUxRkYyLVxcdTFGRjRcXHUxRkY2LVxcdTFGRkNcXHUyMDcxXFx1MjA3RlxcdTIwOTAtXFx1MjA5Q1xcdTIxMDJcXHUyMTA3XFx1MjEwQS1cXHUyMTEzXFx1MjExNVxcdTIxMTgtXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEzOVxcdTIxM0MtXFx1MjEzRlxcdTIxNDUtXFx1MjE0OVxcdTIxNEVcXHUyMTYwLVxcdTIxODhcXHUyQzAwLVxcdTJDMkVcXHUyQzMwLVxcdTJDNUVcXHUyQzYwLVxcdTJDRTRcXHUyQ0VCLVxcdTJDRUVcXHUyQ0YyXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1MkQzMC1cXHUyRDY3XFx1MkQ2RlxcdTJEODAtXFx1MkQ5NlxcdTJEQTAtXFx1MkRBNlxcdTJEQTgtXFx1MkRBRVxcdTJEQjAtXFx1MkRCNlxcdTJEQjgtXFx1MkRCRVxcdTJEQzAtXFx1MkRDNlxcdTJEQzgtXFx1MkRDRVxcdTJERDAtXFx1MkRENlxcdTJERDgtXFx1MkRERVxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOUItXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZENVxcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYxRlxcdUE2MkFcXHVBNjJCXFx1QTY0MC1cXHVBNjZFXFx1QTY3Ri1cXHVBNjlEXFx1QTZBMC1cXHVBNkVGXFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBN0FFXFx1QTdCMC1cXHVBN0I3XFx1QTdGNy1cXHVBODAxXFx1QTgwMy1cXHVBODA1XFx1QTgwNy1cXHVBODBBXFx1QTgwQy1cXHVBODIyXFx1QTg0MC1cXHVBODczXFx1QTg4Mi1cXHVBOEIzXFx1QThGMi1cXHVBOEY3XFx1QThGQlxcdUE4RkRcXHVBOTBBLVxcdUE5MjVcXHVBOTMwLVxcdUE5NDZcXHVBOTYwLVxcdUE5N0NcXHVBOTg0LVxcdUE5QjJcXHVBOUNGXFx1QTlFMC1cXHVBOUU0XFx1QTlFNi1cXHVBOUVGXFx1QTlGQS1cXHVBOUZFXFx1QUEwMC1cXHVBQTI4XFx1QUE0MC1cXHVBQTQyXFx1QUE0NC1cXHVBQTRCXFx1QUE2MC1cXHVBQTc2XFx1QUE3QVxcdUFBN0UtXFx1QUFBRlxcdUFBQjFcXHVBQUI1XFx1QUFCNlxcdUFBQjktXFx1QUFCRFxcdUFBQzBcXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVBXFx1QUFGMi1cXHVBQUY0XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjY1XFx1QUI3MC1cXHVBQkUyXFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRFxcdUZCMUYtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYyMS1cXHVGRjNBXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXXxcXHVEODAwW1xcdURDMDAtXFx1REMwQlxcdURDMEQtXFx1REMyNlxcdURDMjgtXFx1REMzQVxcdURDM0NcXHVEQzNEXFx1REMzRi1cXHVEQzREXFx1REM1MC1cXHVEQzVEXFx1REM4MC1cXHVEQ0ZBXFx1REQ0MC1cXHVERDc0XFx1REU4MC1cXHVERTlDXFx1REVBMC1cXHVERUQwXFx1REYwMC1cXHVERjFGXFx1REYzMC1cXHVERjRBXFx1REY1MC1cXHVERjc1XFx1REY4MC1cXHVERjlEXFx1REZBMC1cXHVERkMzXFx1REZDOC1cXHVERkNGXFx1REZEMS1cXHVERkQ1XXxcXHVEODAxW1xcdURDMDAtXFx1REM5RFxcdURDQjAtXFx1RENEM1xcdURDRDgtXFx1RENGQlxcdUREMDAtXFx1REQyN1xcdUREMzAtXFx1REQ2M1xcdURFMDAtXFx1REYzNlxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY2N118XFx1RDgwMltcXHVEQzAwLVxcdURDMDVcXHVEQzA4XFx1REMwQS1cXHVEQzM1XFx1REMzN1xcdURDMzhcXHVEQzNDXFx1REMzRi1cXHVEQzU1XFx1REM2MC1cXHVEQzc2XFx1REM4MC1cXHVEQzlFXFx1RENFMC1cXHVEQ0YyXFx1RENGNFxcdURDRjVcXHVERDAwLVxcdUREMTVcXHVERDIwLVxcdUREMzlcXHVERDgwLVxcdUREQjdcXHVEREJFXFx1RERCRlxcdURFMDBcXHVERTEwLVxcdURFMTNcXHVERTE1LVxcdURFMTdcXHVERTE5LVxcdURFMzNcXHVERTYwLVxcdURFN0NcXHVERTgwLVxcdURFOUNcXHVERUMwLVxcdURFQzdcXHVERUM5LVxcdURFRTRcXHVERjAwLVxcdURGMzVcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNzJcXHVERjgwLVxcdURGOTFdfFxcdUQ4MDNbXFx1REMwMC1cXHVEQzQ4XFx1REM4MC1cXHVEQ0IyXFx1RENDMC1cXHVEQ0YyXXxcXHVEODA0W1xcdURDMDMtXFx1REMzN1xcdURDODMtXFx1RENBRlxcdURDRDAtXFx1RENFOFxcdUREMDMtXFx1REQyNlxcdURENTAtXFx1REQ3MlxcdURENzZcXHVERDgzLVxcdUREQjJcXHVEREMxLVxcdUREQzRcXHVERERBXFx1REREQ1xcdURFMDAtXFx1REUxMVxcdURFMTMtXFx1REUyQlxcdURFODAtXFx1REU4NlxcdURFODhcXHVERThBLVxcdURFOERcXHVERThGLVxcdURFOURcXHVERTlGLVxcdURFQThcXHVERUIwLVxcdURFREVcXHVERjA1LVxcdURGMENcXHVERjBGXFx1REYxMFxcdURGMTMtXFx1REYyOFxcdURGMkEtXFx1REYzMFxcdURGMzJcXHVERjMzXFx1REYzNS1cXHVERjM5XFx1REYzRFxcdURGNTBcXHVERjVELVxcdURGNjFdfFxcdUQ4MDVbXFx1REMwMC1cXHVEQzM0XFx1REM0Ny1cXHVEQzRBXFx1REM4MC1cXHVEQ0FGXFx1RENDNFxcdURDQzVcXHVEQ0M3XFx1REQ4MC1cXHVEREFFXFx1REREOC1cXHVERERCXFx1REUwMC1cXHVERTJGXFx1REU0NFxcdURFODAtXFx1REVBQVxcdURGMDAtXFx1REYxOV18XFx1RDgwNltcXHVEQ0EwLVxcdURDREZcXHVEQ0ZGXFx1REVDMC1cXHVERUY4XXxcXHVEODA3W1xcdURDMDAtXFx1REMwOFxcdURDMEEtXFx1REMyRVxcdURDNDBcXHVEQzcyLVxcdURDOEZdfFxcdUQ4MDhbXFx1REMwMC1cXHVERjk5XXxcXHVEODA5W1xcdURDMDAtXFx1REM2RVxcdURDODAtXFx1REQ0M118W1xcdUQ4MENcXHVEODFDLVxcdUQ4MjBcXHVEODQwLVxcdUQ4NjhcXHVEODZBLVxcdUQ4NkNcXHVEODZGLVxcdUQ4NzJdW1xcdURDMDAtXFx1REZGRl18XFx1RDgwRFtcXHVEQzAwLVxcdURDMkVdfFxcdUQ4MTFbXFx1REMwMC1cXHVERTQ2XXxcXHVEODFBW1xcdURDMDAtXFx1REUzOFxcdURFNDAtXFx1REU1RVxcdURFRDAtXFx1REVFRFxcdURGMDAtXFx1REYyRlxcdURGNDAtXFx1REY0M1xcdURGNjMtXFx1REY3N1xcdURGN0QtXFx1REY4Rl18XFx1RDgxQltcXHVERjAwLVxcdURGNDRcXHVERjUwXFx1REY5My1cXHVERjlGXFx1REZFMF18XFx1RDgyMVtcXHVEQzAwLVxcdURGRUNdfFxcdUQ4MjJbXFx1REMwMC1cXHVERUYyXXxcXHVEODJDW1xcdURDMDBcXHVEQzAxXXxcXHVEODJGW1xcdURDMDAtXFx1REM2QVxcdURDNzAtXFx1REM3Q1xcdURDODAtXFx1REM4OFxcdURDOTAtXFx1REM5OV18XFx1RDgzNVtcXHVEQzAwLVxcdURDNTRcXHVEQzU2LVxcdURDOUNcXHVEQzlFXFx1REM5RlxcdURDQTJcXHVEQ0E1XFx1RENBNlxcdURDQTktXFx1RENBQ1xcdURDQUUtXFx1RENCOVxcdURDQkJcXHVEQ0JELVxcdURDQzNcXHVEQ0M1LVxcdUREMDVcXHVERDA3LVxcdUREMEFcXHVERDBELVxcdUREMTRcXHVERDE2LVxcdUREMUNcXHVERDFFLVxcdUREMzlcXHVERDNCLVxcdUREM0VcXHVERDQwLVxcdURENDRcXHVERDQ2XFx1REQ0QS1cXHVERDUwXFx1REQ1Mi1cXHVERUE1XFx1REVBOC1cXHVERUMwXFx1REVDMi1cXHVERURBXFx1REVEQy1cXHVERUZBXFx1REVGQy1cXHVERjE0XFx1REYxNi1cXHVERjM0XFx1REYzNi1cXHVERjRFXFx1REY1MC1cXHVERjZFXFx1REY3MC1cXHVERjg4XFx1REY4QS1cXHVERkE4XFx1REZBQS1cXHVERkMyXFx1REZDNC1cXHVERkNCXXxcXHVEODNBW1xcdURDMDAtXFx1RENDNFxcdUREMDAtXFx1REQ0M118XFx1RDgzQltcXHVERTAwLVxcdURFMDNcXHVERTA1LVxcdURFMUZcXHVERTIxXFx1REUyMlxcdURFMjRcXHVERTI3XFx1REUyOS1cXHVERTMyXFx1REUzNC1cXHVERTM3XFx1REUzOVxcdURFM0JcXHVERTQyXFx1REU0N1xcdURFNDlcXHVERTRCXFx1REU0RC1cXHVERTRGXFx1REU1MVxcdURFNTJcXHVERTU0XFx1REU1N1xcdURFNTlcXHVERTVCXFx1REU1RFxcdURFNUZcXHVERTYxXFx1REU2MlxcdURFNjRcXHVERTY3LVxcdURFNkFcXHVERTZDLVxcdURFNzJcXHVERTc0LVxcdURFNzdcXHVERTc5LVxcdURFN0NcXHVERTdFXFx1REU4MC1cXHVERTg5XFx1REU4Qi1cXHVERTlCXFx1REVBMS1cXHVERUEzXFx1REVBNS1cXHVERUE5XFx1REVBQi1cXHVERUJCXXxcXHVEODY5W1xcdURDMDAtXFx1REVENlxcdURGMDAtXFx1REZGRl18XFx1RDg2RFtcXHVEQzAwLVxcdURGMzRcXHVERjQwLVxcdURGRkZdfFxcdUQ4NkVbXFx1REMwMC1cXHVEQzFEXFx1REMyMC1cXHVERkZGXXxcXHVEODczW1xcdURDMDAtXFx1REVBMV18XFx1RDg3RVtcXHVEQzAwLVxcdURFMURdLyxcbiAgICAgICAgLy8gRUNNQVNjcmlwdCA2L1VuaWNvZGUgdjkuMC4wIE5vbkFzY2lpSWRlbnRpZmllclBhcnQ6XG4gICAgICAgIE5vbkFzY2lpSWRlbnRpZmllclBhcnQ6IC9bXFx4QUFcXHhCNVxceEI3XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDMwMC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzdGXFx1MDM4Ni1cXHUwMzhBXFx1MDM4Q1xcdTAzOEUtXFx1MDNBMVxcdTAzQTMtXFx1MDNGNVxcdTAzRjctXFx1MDQ4MVxcdTA0ODMtXFx1MDQ4N1xcdTA0OEEtXFx1MDUyRlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNTkxLVxcdTA1QkRcXHUwNUJGXFx1MDVDMVxcdTA1QzJcXHUwNUM0XFx1MDVDNVxcdTA1QzdcXHUwNUQwLVxcdTA1RUFcXHUwNUYwLVxcdTA1RjJcXHUwNjEwLVxcdTA2MUFcXHUwNjIwLVxcdTA2NjlcXHUwNjZFLVxcdTA2RDNcXHUwNkQ1LVxcdTA2RENcXHUwNkRGLVxcdTA2RThcXHUwNkVBLVxcdTA2RkNcXHUwNkZGXFx1MDcxMC1cXHUwNzRBXFx1MDc0RC1cXHUwN0IxXFx1MDdDMC1cXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgyRFxcdTA4NDAtXFx1MDg1QlxcdTA4QTAtXFx1MDhCNFxcdTA4QjYtXFx1MDhCRFxcdTA4RDQtXFx1MDhFMVxcdTA4RTMtXFx1MDk2M1xcdTA5NjYtXFx1MDk2RlxcdTA5NzEtXFx1MDk4M1xcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkMtXFx1MDlDNFxcdTA5QzdcXHUwOUM4XFx1MDlDQi1cXHUwOUNFXFx1MDlEN1xcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUzXFx1MDlFNi1cXHUwOUYxXFx1MEEwMS1cXHUwQTAzXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTNDXFx1MEEzRS1cXHUwQTQyXFx1MEE0N1xcdTBBNDhcXHUwQTRCLVxcdTBBNERcXHUwQTUxXFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNjYtXFx1MEE3NVxcdTBBODEtXFx1MEE4M1xcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCQy1cXHUwQUM1XFx1MEFDNy1cXHUwQUM5XFx1MEFDQi1cXHUwQUNEXFx1MEFEMFxcdTBBRTAtXFx1MEFFM1xcdTBBRTYtXFx1MEFFRlxcdTBBRjlcXHUwQjAxLVxcdTBCMDNcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzQy1cXHUwQjQ0XFx1MEI0N1xcdTBCNDhcXHUwQjRCLVxcdTBCNERcXHUwQjU2XFx1MEI1N1xcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYzXFx1MEI2Ni1cXHUwQjZGXFx1MEI3MVxcdTBCODJcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCQkUtXFx1MEJDMlxcdTBCQzYtXFx1MEJDOFxcdTBCQ0EtXFx1MEJDRFxcdTBCRDBcXHUwQkQ3XFx1MEJFNi1cXHUwQkVGXFx1MEMwMC1cXHUwQzAzXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRC1cXHUwQzQ0XFx1MEM0Ni1cXHUwQzQ4XFx1MEM0QS1cXHUwQzREXFx1MEM1NVxcdTBDNTZcXHUwQzU4LVxcdTBDNUFcXHUwQzYwLVxcdTBDNjNcXHUwQzY2LVxcdTBDNkZcXHUwQzgwLVxcdTBDODNcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JDLVxcdTBDQzRcXHUwQ0M2LVxcdTBDQzhcXHUwQ0NBLVxcdTBDQ0RcXHUwQ0Q1XFx1MENENlxcdTBDREVcXHUwQ0UwLVxcdTBDRTNcXHUwQ0U2LVxcdTBDRUZcXHUwQ0YxXFx1MENGMlxcdTBEMDEtXFx1MEQwM1xcdTBEMDUtXFx1MEQwQ1xcdTBEMEUtXFx1MEQxMFxcdTBEMTItXFx1MEQzQVxcdTBEM0QtXFx1MEQ0NFxcdTBENDYtXFx1MEQ0OFxcdTBENEEtXFx1MEQ0RVxcdTBENTQtXFx1MEQ1N1xcdTBENUYtXFx1MEQ2M1xcdTBENjYtXFx1MEQ2RlxcdTBEN0EtXFx1MEQ3RlxcdTBEODJcXHUwRDgzXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBEQ0FcXHUwRENGLVxcdTBERDRcXHUwREQ2XFx1MEREOC1cXHUwRERGXFx1MERFNi1cXHUwREVGXFx1MERGMlxcdTBERjNcXHUwRTAxLVxcdTBFM0FcXHUwRTQwLVxcdTBFNEVcXHUwRTUwLVxcdTBFNTlcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCOVxcdTBFQkItXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFQzZcXHUwRUM4LVxcdTBFQ0RcXHUwRUQwLVxcdTBFRDlcXHUwRURDLVxcdTBFREZcXHUwRjAwXFx1MEYxOFxcdTBGMTlcXHUwRjIwLVxcdTBGMjlcXHUwRjM1XFx1MEYzN1xcdTBGMzlcXHUwRjNFLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjcxLVxcdTBGODRcXHUwRjg2LVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUwRkM2XFx1MTAwMC1cXHUxMDQ5XFx1MTA1MC1cXHUxMDlEXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzNUQtXFx1MTM1RlxcdTEzNjktXFx1MTM3MVxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNVxcdTEzRjgtXFx1MTNGRFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxNFxcdTE3MjAtXFx1MTczNFxcdTE3NDAtXFx1MTc1M1xcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3NzJcXHUxNzczXFx1MTc4MC1cXHUxN0QzXFx1MTdEN1xcdTE3RENcXHUxN0REXFx1MTdFMC1cXHUxN0U5XFx1MTgwQi1cXHUxODBEXFx1MTgxMC1cXHUxODE5XFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFFXFx1MTkyMC1cXHUxOTJCXFx1MTkzMC1cXHUxOTNCXFx1MTk0Ni1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlCMC1cXHUxOUM5XFx1MTlEMC1cXHUxOURBXFx1MUEwMC1cXHUxQTFCXFx1MUEyMC1cXHUxQTVFXFx1MUE2MC1cXHUxQTdDXFx1MUE3Ri1cXHUxQTg5XFx1MUE5MC1cXHUxQTk5XFx1MUFBN1xcdTFBQjAtXFx1MUFCRFxcdTFCMDAtXFx1MUI0QlxcdTFCNTAtXFx1MUI1OVxcdTFCNkItXFx1MUI3M1xcdTFCODAtXFx1MUJGM1xcdTFDMDAtXFx1MUMzN1xcdTFDNDAtXFx1MUM0OVxcdTFDNEQtXFx1MUM3RFxcdTFDODAtXFx1MUM4OFxcdTFDRDAtXFx1MUNEMlxcdTFDRDQtXFx1MUNGNlxcdTFDRjhcXHUxQ0Y5XFx1MUQwMC1cXHUxREY1XFx1MURGQi1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwMENcXHUyMDBEXFx1MjAzRlxcdTIwNDBcXHUyMDU0XFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMEQwLVxcdTIwRENcXHUyMEUxXFx1MjBFNS1cXHUyMEYwXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOC1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1MkQzMC1cXHUyRDY3XFx1MkQ2RlxcdTJEN0YtXFx1MkQ5NlxcdTJEQTAtXFx1MkRBNlxcdTJEQTgtXFx1MkRBRVxcdTJEQjAtXFx1MkRCNlxcdTJEQjgtXFx1MkRCRVxcdTJEQzAtXFx1MkRDNlxcdTJEQzgtXFx1MkRDRVxcdTJERDAtXFx1MkRENlxcdTJERDgtXFx1MkRERVxcdTJERTAtXFx1MkRGRlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyRlxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOTktXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZENVxcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYyQlxcdUE2NDAtXFx1QTY2RlxcdUE2NzQtXFx1QTY3RFxcdUE2N0YtXFx1QTZGMVxcdUE3MTctXFx1QTcxRlxcdUE3MjItXFx1QTc4OFxcdUE3OEItXFx1QTdBRVxcdUE3QjAtXFx1QTdCN1xcdUE3RjctXFx1QTgyN1xcdUE4NDAtXFx1QTg3M1xcdUE4ODAtXFx1QThDNVxcdUE4RDAtXFx1QThEOVxcdUE4RTAtXFx1QThGN1xcdUE4RkJcXHVBOEZEXFx1QTkwMC1cXHVBOTJEXFx1QTkzMC1cXHVBOTUzXFx1QTk2MC1cXHVBOTdDXFx1QTk4MC1cXHVBOUMwXFx1QTlDRi1cXHVBOUQ5XFx1QTlFMC1cXHVBOUZFXFx1QUEwMC1cXHVBQTM2XFx1QUE0MC1cXHVBQTREXFx1QUE1MC1cXHVBQTU5XFx1QUE2MC1cXHVBQTc2XFx1QUE3QS1cXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVGXFx1QUFGMi1cXHVBQUY2XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjY1XFx1QUI3MC1cXHVBQkVBXFx1QUJFQ1xcdUFCRURcXHVBQkYwLVxcdUFCRjlcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFELVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFMDAtXFx1RkUwRlxcdUZFMjAtXFx1RkUyRlxcdUZFMzNcXHVGRTM0XFx1RkU0RC1cXHVGRTRGXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYxMC1cXHVGRjE5XFx1RkYyMS1cXHVGRjNBXFx1RkYzRlxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ118XFx1RDgwMFtcXHVEQzAwLVxcdURDMEJcXHVEQzBELVxcdURDMjZcXHVEQzI4LVxcdURDM0FcXHVEQzNDXFx1REMzRFxcdURDM0YtXFx1REM0RFxcdURDNTAtXFx1REM1RFxcdURDODAtXFx1RENGQVxcdURENDAtXFx1REQ3NFxcdURERkRcXHVERTgwLVxcdURFOUNcXHVERUEwLVxcdURFRDBcXHVERUUwXFx1REYwMC1cXHVERjFGXFx1REYzMC1cXHVERjRBXFx1REY1MC1cXHVERjdBXFx1REY4MC1cXHVERjlEXFx1REZBMC1cXHVERkMzXFx1REZDOC1cXHVERkNGXFx1REZEMS1cXHVERkQ1XXxcXHVEODAxW1xcdURDMDAtXFx1REM5RFxcdURDQTAtXFx1RENBOVxcdURDQjAtXFx1RENEM1xcdURDRDgtXFx1RENGQlxcdUREMDAtXFx1REQyN1xcdUREMzAtXFx1REQ2M1xcdURFMDAtXFx1REYzNlxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY2N118XFx1RDgwMltcXHVEQzAwLVxcdURDMDVcXHVEQzA4XFx1REMwQS1cXHVEQzM1XFx1REMzN1xcdURDMzhcXHVEQzNDXFx1REMzRi1cXHVEQzU1XFx1REM2MC1cXHVEQzc2XFx1REM4MC1cXHVEQzlFXFx1RENFMC1cXHVEQ0YyXFx1RENGNFxcdURDRjVcXHVERDAwLVxcdUREMTVcXHVERDIwLVxcdUREMzlcXHVERDgwLVxcdUREQjdcXHVEREJFXFx1RERCRlxcdURFMDAtXFx1REUwM1xcdURFMDVcXHVERTA2XFx1REUwQy1cXHVERTEzXFx1REUxNS1cXHVERTE3XFx1REUxOS1cXHVERTMzXFx1REUzOC1cXHVERTNBXFx1REUzRlxcdURFNjAtXFx1REU3Q1xcdURFODAtXFx1REU5Q1xcdURFQzAtXFx1REVDN1xcdURFQzktXFx1REVFNlxcdURGMDAtXFx1REYzNVxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY3MlxcdURGODAtXFx1REY5MV18XFx1RDgwM1tcXHVEQzAwLVxcdURDNDhcXHVEQzgwLVxcdURDQjJcXHVEQ0MwLVxcdURDRjJdfFxcdUQ4MDRbXFx1REMwMC1cXHVEQzQ2XFx1REM2Ni1cXHVEQzZGXFx1REM3Ri1cXHVEQ0JBXFx1RENEMC1cXHVEQ0U4XFx1RENGMC1cXHVEQ0Y5XFx1REQwMC1cXHVERDM0XFx1REQzNi1cXHVERDNGXFx1REQ1MC1cXHVERDczXFx1REQ3NlxcdUREODAtXFx1RERDNFxcdUREQ0EtXFx1RERDQ1xcdURERDAtXFx1REREQVxcdURERENcXHVERTAwLVxcdURFMTFcXHVERTEzLVxcdURFMzdcXHVERTNFXFx1REU4MC1cXHVERTg2XFx1REU4OFxcdURFOEEtXFx1REU4RFxcdURFOEYtXFx1REU5RFxcdURFOUYtXFx1REVBOFxcdURFQjAtXFx1REVFQVxcdURFRjAtXFx1REVGOVxcdURGMDAtXFx1REYwM1xcdURGMDUtXFx1REYwQ1xcdURGMEZcXHVERjEwXFx1REYxMy1cXHVERjI4XFx1REYyQS1cXHVERjMwXFx1REYzMlxcdURGMzNcXHVERjM1LVxcdURGMzlcXHVERjNDLVxcdURGNDRcXHVERjQ3XFx1REY0OFxcdURGNEItXFx1REY0RFxcdURGNTBcXHVERjU3XFx1REY1RC1cXHVERjYzXFx1REY2Ni1cXHVERjZDXFx1REY3MC1cXHVERjc0XXxcXHVEODA1W1xcdURDMDAtXFx1REM0QVxcdURDNTAtXFx1REM1OVxcdURDODAtXFx1RENDNVxcdURDQzdcXHVEQ0QwLVxcdURDRDlcXHVERDgwLVxcdUREQjVcXHVEREI4LVxcdUREQzBcXHVEREQ4LVxcdURERERcXHVERTAwLVxcdURFNDBcXHVERTQ0XFx1REU1MC1cXHVERTU5XFx1REU4MC1cXHVERUI3XFx1REVDMC1cXHVERUM5XFx1REYwMC1cXHVERjE5XFx1REYxRC1cXHVERjJCXFx1REYzMC1cXHVERjM5XXxcXHVEODA2W1xcdURDQTAtXFx1RENFOVxcdURDRkZcXHVERUMwLVxcdURFRjhdfFxcdUQ4MDdbXFx1REMwMC1cXHVEQzA4XFx1REMwQS1cXHVEQzM2XFx1REMzOC1cXHVEQzQwXFx1REM1MC1cXHVEQzU5XFx1REM3Mi1cXHVEQzhGXFx1REM5Mi1cXHVEQ0E3XFx1RENBOS1cXHVEQ0I2XXxcXHVEODA4W1xcdURDMDAtXFx1REY5OV18XFx1RDgwOVtcXHVEQzAwLVxcdURDNkVcXHVEQzgwLVxcdURENDNdfFtcXHVEODBDXFx1RDgxQy1cXHVEODIwXFx1RDg0MC1cXHVEODY4XFx1RDg2QS1cXHVEODZDXFx1RDg2Ri1cXHVEODcyXVtcXHVEQzAwLVxcdURGRkZdfFxcdUQ4MERbXFx1REMwMC1cXHVEQzJFXXxcXHVEODExW1xcdURDMDAtXFx1REU0Nl18XFx1RDgxQVtcXHVEQzAwLVxcdURFMzhcXHVERTQwLVxcdURFNUVcXHVERTYwLVxcdURFNjlcXHVERUQwLVxcdURFRURcXHVERUYwLVxcdURFRjRcXHVERjAwLVxcdURGMzZcXHVERjQwLVxcdURGNDNcXHVERjUwLVxcdURGNTlcXHVERjYzLVxcdURGNzdcXHVERjdELVxcdURGOEZdfFxcdUQ4MUJbXFx1REYwMC1cXHVERjQ0XFx1REY1MC1cXHVERjdFXFx1REY4Ri1cXHVERjlGXFx1REZFMF18XFx1RDgyMVtcXHVEQzAwLVxcdURGRUNdfFxcdUQ4MjJbXFx1REMwMC1cXHVERUYyXXxcXHVEODJDW1xcdURDMDBcXHVEQzAxXXxcXHVEODJGW1xcdURDMDAtXFx1REM2QVxcdURDNzAtXFx1REM3Q1xcdURDODAtXFx1REM4OFxcdURDOTAtXFx1REM5OVxcdURDOURcXHVEQzlFXXxcXHVEODM0W1xcdURENjUtXFx1REQ2OVxcdURENkQtXFx1REQ3MlxcdUREN0ItXFx1REQ4MlxcdUREODUtXFx1REQ4QlxcdUREQUEtXFx1RERBRFxcdURFNDItXFx1REU0NF18XFx1RDgzNVtcXHVEQzAwLVxcdURDNTRcXHVEQzU2LVxcdURDOUNcXHVEQzlFXFx1REM5RlxcdURDQTJcXHVEQ0E1XFx1RENBNlxcdURDQTktXFx1RENBQ1xcdURDQUUtXFx1RENCOVxcdURDQkJcXHVEQ0JELVxcdURDQzNcXHVEQ0M1LVxcdUREMDVcXHVERDA3LVxcdUREMEFcXHVERDBELVxcdUREMTRcXHVERDE2LVxcdUREMUNcXHVERDFFLVxcdUREMzlcXHVERDNCLVxcdUREM0VcXHVERDQwLVxcdURENDRcXHVERDQ2XFx1REQ0QS1cXHVERDUwXFx1REQ1Mi1cXHVERUE1XFx1REVBOC1cXHVERUMwXFx1REVDMi1cXHVERURBXFx1REVEQy1cXHVERUZBXFx1REVGQy1cXHVERjE0XFx1REYxNi1cXHVERjM0XFx1REYzNi1cXHVERjRFXFx1REY1MC1cXHVERjZFXFx1REY3MC1cXHVERjg4XFx1REY4QS1cXHVERkE4XFx1REZBQS1cXHVERkMyXFx1REZDNC1cXHVERkNCXFx1REZDRS1cXHVERkZGXXxcXHVEODM2W1xcdURFMDAtXFx1REUzNlxcdURFM0ItXFx1REU2Q1xcdURFNzVcXHVERTg0XFx1REU5Qi1cXHVERTlGXFx1REVBMS1cXHVERUFGXXxcXHVEODM4W1xcdURDMDAtXFx1REMwNlxcdURDMDgtXFx1REMxOFxcdURDMUItXFx1REMyMVxcdURDMjNcXHVEQzI0XFx1REMyNi1cXHVEQzJBXXxcXHVEODNBW1xcdURDMDAtXFx1RENDNFxcdURDRDAtXFx1RENENlxcdUREMDAtXFx1REQ0QVxcdURENTAtXFx1REQ1OV18XFx1RDgzQltcXHVERTAwLVxcdURFMDNcXHVERTA1LVxcdURFMUZcXHVERTIxXFx1REUyMlxcdURFMjRcXHVERTI3XFx1REUyOS1cXHVERTMyXFx1REUzNC1cXHVERTM3XFx1REUzOVxcdURFM0JcXHVERTQyXFx1REU0N1xcdURFNDlcXHVERTRCXFx1REU0RC1cXHVERTRGXFx1REU1MVxcdURFNTJcXHVERTU0XFx1REU1N1xcdURFNTlcXHVERTVCXFx1REU1RFxcdURFNUZcXHVERTYxXFx1REU2MlxcdURFNjRcXHVERTY3LVxcdURFNkFcXHVERTZDLVxcdURFNzJcXHVERTc0LVxcdURFNzdcXHVERTc5LVxcdURFN0NcXHVERTdFXFx1REU4MC1cXHVERTg5XFx1REU4Qi1cXHVERTlCXFx1REVBMS1cXHVERUEzXFx1REVBNS1cXHVERUE5XFx1REVBQi1cXHVERUJCXXxcXHVEODY5W1xcdURDMDAtXFx1REVENlxcdURGMDAtXFx1REZGRl18XFx1RDg2RFtcXHVEQzAwLVxcdURGMzRcXHVERjQwLVxcdURGRkZdfFxcdUQ4NkVbXFx1REMwMC1cXHVEQzFEXFx1REMyMC1cXHVERkZGXXxcXHVEODczW1xcdURDMDAtXFx1REVBMV18XFx1RDg3RVtcXHVEQzAwLVxcdURFMURdfFxcdURCNDBbXFx1REQwMC1cXHVEREVGXS9cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaXNEZWNpbWFsRGlnaXQoY2gpIHtcbiAgICAgICAgcmV0dXJuIDB4MzAgPD0gY2ggJiYgY2ggPD0gMHgzOTsgIC8vIDAuLjlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0hleERpZ2l0KGNoKSB7XG4gICAgICAgIHJldHVybiAweDMwIDw9IGNoICYmIGNoIDw9IDB4MzkgfHwgIC8vIDAuLjlcbiAgICAgICAgICAgIDB4NjEgPD0gY2ggJiYgY2ggPD0gMHg2NiB8fCAgICAgLy8gYS4uZlxuICAgICAgICAgICAgMHg0MSA8PSBjaCAmJiBjaCA8PSAweDQ2OyAgICAgICAvLyBBLi5GXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNPY3RhbERpZ2l0KGNoKSB7XG4gICAgICAgIHJldHVybiBjaCA+PSAweDMwICYmIGNoIDw9IDB4Mzc7ICAvLyAwLi43XG4gICAgfVxuXG4gICAgLy8gNy4yIFdoaXRlIFNwYWNlXG5cbiAgICBOT05fQVNDSUlfV0hJVEVTUEFDRVMgPSBbXG4gICAgICAgIDB4MTY4MCxcbiAgICAgICAgMHgyMDAwLCAweDIwMDEsIDB4MjAwMiwgMHgyMDAzLCAweDIwMDQsIDB4MjAwNSwgMHgyMDA2LCAweDIwMDcsIDB4MjAwOCwgMHgyMDA5LCAweDIwMEEsXG4gICAgICAgIDB4MjAyRiwgMHgyMDVGLFxuICAgICAgICAweDMwMDAsXG4gICAgICAgIDB4RkVGRlxuICAgIF07XG5cbiAgICBmdW5jdGlvbiBpc1doaXRlU3BhY2UoY2gpIHtcbiAgICAgICAgcmV0dXJuIGNoID09PSAweDIwIHx8IGNoID09PSAweDA5IHx8IGNoID09PSAweDBCIHx8IGNoID09PSAweDBDIHx8IGNoID09PSAweEEwIHx8XG4gICAgICAgICAgICBjaCA+PSAweDE2ODAgJiYgTk9OX0FTQ0lJX1dISVRFU1BBQ0VTLmluZGV4T2YoY2gpID49IDA7XG4gICAgfVxuXG4gICAgLy8gNy4zIExpbmUgVGVybWluYXRvcnNcblxuICAgIGZ1bmN0aW9uIGlzTGluZVRlcm1pbmF0b3IoY2gpIHtcbiAgICAgICAgcmV0dXJuIGNoID09PSAweDBBIHx8IGNoID09PSAweDBEIHx8IGNoID09PSAweDIwMjggfHwgY2ggPT09IDB4MjAyOTtcbiAgICB9XG5cbiAgICAvLyA3LjYgSWRlbnRpZmllciBOYW1lcyBhbmQgSWRlbnRpZmllcnNcblxuICAgIGZ1bmN0aW9uIGZyb21Db2RlUG9pbnQoY3ApIHtcbiAgICAgICAgaWYgKGNwIDw9IDB4RkZGRikgeyByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjcCk7IH1cbiAgICAgICAgdmFyIGN1MSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoTWF0aC5mbG9vcigoY3AgLSAweDEwMDAwKSAvIDB4NDAwKSArIDB4RDgwMCk7XG4gICAgICAgIHZhciBjdTIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoY3AgLSAweDEwMDAwKSAlIDB4NDAwKSArIDB4REMwMCk7XG4gICAgICAgIHJldHVybiBjdTEgKyBjdTI7XG4gICAgfVxuXG4gICAgSURFTlRJRklFUl9TVEFSVCA9IG5ldyBBcnJheSgweDgwKTtcbiAgICBmb3IoY2ggPSAwOyBjaCA8IDB4ODA7ICsrY2gpIHtcbiAgICAgICAgSURFTlRJRklFUl9TVEFSVFtjaF0gPVxuICAgICAgICAgICAgY2ggPj0gMHg2MSAmJiBjaCA8PSAweDdBIHx8ICAvLyBhLi56XG4gICAgICAgICAgICBjaCA+PSAweDQxICYmIGNoIDw9IDB4NUEgfHwgIC8vIEEuLlpcbiAgICAgICAgICAgIGNoID09PSAweDI0IHx8IGNoID09PSAweDVGOyAgLy8gJCAoZG9sbGFyKSBhbmQgXyAodW5kZXJzY29yZSlcbiAgICB9XG5cbiAgICBJREVOVElGSUVSX1BBUlQgPSBuZXcgQXJyYXkoMHg4MCk7XG4gICAgZm9yKGNoID0gMDsgY2ggPCAweDgwOyArK2NoKSB7XG4gICAgICAgIElERU5USUZJRVJfUEFSVFtjaF0gPVxuICAgICAgICAgICAgY2ggPj0gMHg2MSAmJiBjaCA8PSAweDdBIHx8ICAvLyBhLi56XG4gICAgICAgICAgICBjaCA+PSAweDQxICYmIGNoIDw9IDB4NUEgfHwgIC8vIEEuLlpcbiAgICAgICAgICAgIGNoID49IDB4MzAgJiYgY2ggPD0gMHgzOSB8fCAgLy8gMC4uOVxuICAgICAgICAgICAgY2ggPT09IDB4MjQgfHwgY2ggPT09IDB4NUY7ICAvLyAkIChkb2xsYXIpIGFuZCBfICh1bmRlcnNjb3JlKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSWRlbnRpZmllclN0YXJ0RVM1KGNoKSB7XG4gICAgICAgIHJldHVybiBjaCA8IDB4ODAgPyBJREVOVElGSUVSX1NUQVJUW2NoXSA6IEVTNVJlZ2V4Lk5vbkFzY2lpSWRlbnRpZmllclN0YXJ0LnRlc3QoZnJvbUNvZGVQb2ludChjaCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSWRlbnRpZmllclBhcnRFUzUoY2gpIHtcbiAgICAgICAgcmV0dXJuIGNoIDwgMHg4MCA/IElERU5USUZJRVJfUEFSVFtjaF0gOiBFUzVSZWdleC5Ob25Bc2NpaUlkZW50aWZpZXJQYXJ0LnRlc3QoZnJvbUNvZGVQb2ludChjaCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSWRlbnRpZmllclN0YXJ0RVM2KGNoKSB7XG4gICAgICAgIHJldHVybiBjaCA8IDB4ODAgPyBJREVOVElGSUVSX1NUQVJUW2NoXSA6IEVTNlJlZ2V4Lk5vbkFzY2lpSWRlbnRpZmllclN0YXJ0LnRlc3QoZnJvbUNvZGVQb2ludChjaCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSWRlbnRpZmllclBhcnRFUzYoY2gpIHtcbiAgICAgICAgcmV0dXJuIGNoIDwgMHg4MCA/IElERU5USUZJRVJfUEFSVFtjaF0gOiBFUzZSZWdleC5Ob25Bc2NpaUlkZW50aWZpZXJQYXJ0LnRlc3QoZnJvbUNvZGVQb2ludChjaCkpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBpc0RlY2ltYWxEaWdpdDogaXNEZWNpbWFsRGlnaXQsXG4gICAgICAgIGlzSGV4RGlnaXQ6IGlzSGV4RGlnaXQsXG4gICAgICAgIGlzT2N0YWxEaWdpdDogaXNPY3RhbERpZ2l0LFxuICAgICAgICBpc1doaXRlU3BhY2U6IGlzV2hpdGVTcGFjZSxcbiAgICAgICAgaXNMaW5lVGVybWluYXRvcjogaXNMaW5lVGVybWluYXRvcixcbiAgICAgICAgaXNJZGVudGlmaWVyU3RhcnRFUzU6IGlzSWRlbnRpZmllclN0YXJ0RVM1LFxuICAgICAgICBpc0lkZW50aWZpZXJQYXJ0RVM1OiBpc0lkZW50aWZpZXJQYXJ0RVM1LFxuICAgICAgICBpc0lkZW50aWZpZXJTdGFydEVTNjogaXNJZGVudGlmaWVyU3RhcnRFUzYsXG4gICAgICAgIGlzSWRlbnRpZmllclBhcnRFUzY6IGlzSWRlbnRpZmllclBhcnRFUzZcbiAgICB9O1xufSgpKTtcbi8qIHZpbTogc2V0IHN3PTQgdHM9NCBldCB0dz04MCA6ICovXG4iLCIvKlxuICBDb3B5cmlnaHQgKEMpIDIwMTMgWXVzdWtlIFN1enVraSA8dXRhdGFuZS50ZWFAZ21haWwuY29tPlxuXG4gIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxuICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcbiAgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5cbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIGNvZGUgPSByZXF1aXJlKCcuL2NvZGUnKTtcblxuICAgIGZ1bmN0aW9uIGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZEVTNihpZCkge1xuICAgICAgICBzd2l0Y2ggKGlkKSB7XG4gICAgICAgIGNhc2UgJ2ltcGxlbWVudHMnOlxuICAgICAgICBjYXNlICdpbnRlcmZhY2UnOlxuICAgICAgICBjYXNlICdwYWNrYWdlJzpcbiAgICAgICAgY2FzZSAncHJpdmF0ZSc6XG4gICAgICAgIGNhc2UgJ3Byb3RlY3RlZCc6XG4gICAgICAgIGNhc2UgJ3B1YmxpYyc6XG4gICAgICAgIGNhc2UgJ3N0YXRpYyc6XG4gICAgICAgIGNhc2UgJ2xldCc6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzS2V5d29yZEVTNShpZCwgc3RyaWN0KSB7XG4gICAgICAgIC8vIHlpZWxkIHNob3VsZCBub3QgYmUgdHJlYXRlZCBhcyBrZXl3b3JkIHVuZGVyIG5vbi1zdHJpY3QgbW9kZS5cbiAgICAgICAgaWYgKCFzdHJpY3QgJiYgaWQgPT09ICd5aWVsZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNLZXl3b3JkRVM2KGlkLCBzdHJpY3QpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzS2V5d29yZEVTNihpZCwgc3RyaWN0KSB7XG4gICAgICAgIGlmIChzdHJpY3QgJiYgaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkRVM2KGlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKGlkLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gKGlkID09PSAnaWYnKSB8fCAoaWQgPT09ICdpbicpIHx8IChpZCA9PT0gJ2RvJyk7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICd2YXInKSB8fCAoaWQgPT09ICdmb3InKSB8fCAoaWQgPT09ICduZXcnKSB8fCAoaWQgPT09ICd0cnknKTtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ3RoaXMnKSB8fCAoaWQgPT09ICdlbHNlJykgfHwgKGlkID09PSAnY2FzZScpIHx8XG4gICAgICAgICAgICAgICAgKGlkID09PSAndm9pZCcpIHx8IChpZCA9PT0gJ3dpdGgnKSB8fCAoaWQgPT09ICdlbnVtJyk7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICd3aGlsZScpIHx8IChpZCA9PT0gJ2JyZWFrJykgfHwgKGlkID09PSAnY2F0Y2gnKSB8fFxuICAgICAgICAgICAgICAgIChpZCA9PT0gJ3Rocm93JykgfHwgKGlkID09PSAnY29uc3QnKSB8fCAoaWQgPT09ICd5aWVsZCcpIHx8XG4gICAgICAgICAgICAgICAgKGlkID09PSAnY2xhc3MnKSB8fCAoaWQgPT09ICdzdXBlcicpO1xuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICByZXR1cm4gKGlkID09PSAncmV0dXJuJykgfHwgKGlkID09PSAndHlwZW9mJykgfHwgKGlkID09PSAnZGVsZXRlJykgfHxcbiAgICAgICAgICAgICAgICAoaWQgPT09ICdzd2l0Y2gnKSB8fCAoaWQgPT09ICdleHBvcnQnKSB8fCAoaWQgPT09ICdpbXBvcnQnKTtcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2RlZmF1bHQnKSB8fCAoaWQgPT09ICdmaW5hbGx5JykgfHwgKGlkID09PSAnZXh0ZW5kcycpO1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICByZXR1cm4gKGlkID09PSAnZnVuY3Rpb24nKSB8fCAoaWQgPT09ICdjb250aW51ZScpIHx8IChpZCA9PT0gJ2RlYnVnZ2VyJyk7XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICByZXR1cm4gKGlkID09PSAnaW5zdGFuY2VvZicpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNSZXNlcnZlZFdvcmRFUzUoaWQsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4gaWQgPT09ICdudWxsJyB8fCBpZCA9PT0gJ3RydWUnIHx8IGlkID09PSAnZmFsc2UnIHx8IGlzS2V5d29yZEVTNShpZCwgc3RyaWN0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1Jlc2VydmVkV29yZEVTNihpZCwgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiBpZCA9PT0gJ251bGwnIHx8IGlkID09PSAndHJ1ZScgfHwgaWQgPT09ICdmYWxzZScgfHwgaXNLZXl3b3JkRVM2KGlkLCBzdHJpY3QpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzUmVzdHJpY3RlZFdvcmQoaWQpIHtcbiAgICAgICAgcmV0dXJuIGlkID09PSAnZXZhbCcgfHwgaWQgPT09ICdhcmd1bWVudHMnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSWRlbnRpZmllck5hbWVFUzUoaWQpIHtcbiAgICAgICAgdmFyIGksIGl6LCBjaDtcblxuICAgICAgICBpZiAoaWQubGVuZ3RoID09PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgICAgIGNoID0gaWQuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgaWYgKCFjb2RlLmlzSWRlbnRpZmllclN0YXJ0RVM1KGNoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMSwgaXogPSBpZC5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICBjaCA9IGlkLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBpZiAoIWNvZGUuaXNJZGVudGlmaWVyUGFydEVTNShjaCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVjb2RlVXRmMTYobGVhZCwgdHJhaWwpIHtcbiAgICAgICAgcmV0dXJuIChsZWFkIC0gMHhEODAwKSAqIDB4NDAwICsgKHRyYWlsIC0gMHhEQzAwKSArIDB4MTAwMDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNJZGVudGlmaWVyTmFtZUVTNihpZCkge1xuICAgICAgICB2YXIgaSwgaXosIGNoLCBsb3dDaCwgY2hlY2s7XG5cbiAgICAgICAgaWYgKGlkLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgICAgICBjaGVjayA9IGNvZGUuaXNJZGVudGlmaWVyU3RhcnRFUzY7XG4gICAgICAgIGZvciAoaSA9IDAsIGl6ID0gaWQubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgY2ggPSBpZC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgaWYgKDB4RDgwMCA8PSBjaCAmJiBjaCA8PSAweERCRkYpIHtcbiAgICAgICAgICAgICAgICArK2k7XG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gaXopIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgICAgICAgICAgbG93Q2ggPSBpZC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgICAgIGlmICghKDB4REMwMCA8PSBsb3dDaCAmJiBsb3dDaCA8PSAweERGRkYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2ggPSBkZWNvZGVVdGYxNihjaCwgbG93Q2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjaGVjayhjaCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGVjayA9IGNvZGUuaXNJZGVudGlmaWVyUGFydEVTNjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0lkZW50aWZpZXJFUzUoaWQsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4gaXNJZGVudGlmaWVyTmFtZUVTNShpZCkgJiYgIWlzUmVzZXJ2ZWRXb3JkRVM1KGlkLCBzdHJpY3QpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSWRlbnRpZmllckVTNihpZCwgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiBpc0lkZW50aWZpZXJOYW1lRVM2KGlkKSAmJiAhaXNSZXNlcnZlZFdvcmRFUzYoaWQsIHN0cmljdCk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGlzS2V5d29yZEVTNTogaXNLZXl3b3JkRVM1LFxuICAgICAgICBpc0tleXdvcmRFUzY6IGlzS2V5d29yZEVTNixcbiAgICAgICAgaXNSZXNlcnZlZFdvcmRFUzU6IGlzUmVzZXJ2ZWRXb3JkRVM1LFxuICAgICAgICBpc1Jlc2VydmVkV29yZEVTNjogaXNSZXNlcnZlZFdvcmRFUzYsXG4gICAgICAgIGlzUmVzdHJpY3RlZFdvcmQ6IGlzUmVzdHJpY3RlZFdvcmQsXG4gICAgICAgIGlzSWRlbnRpZmllck5hbWVFUzU6IGlzSWRlbnRpZmllck5hbWVFUzUsXG4gICAgICAgIGlzSWRlbnRpZmllck5hbWVFUzY6IGlzSWRlbnRpZmllck5hbWVFUzYsXG4gICAgICAgIGlzSWRlbnRpZmllckVTNTogaXNJZGVudGlmaWVyRVM1LFxuICAgICAgICBpc0lkZW50aWZpZXJFUzY6IGlzSWRlbnRpZmllckVTNlxuICAgIH07XG59KCkpO1xuLyogdmltOiBzZXQgc3c9NCB0cz00IGV0IHR3PTgwIDogKi9cbiIsIi8qXG4gIENvcHlyaWdodCAoQykgMjAxMyBZdXN1a2UgU3V6dWtpIDx1dGF0YW5lLnRlYUBnbWFpbC5jb20+XG5cbiAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgPENPUFlSSUdIVCBIT0xERVI+IEJFIExJQUJMRSBGT1IgQU5ZXG4gIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4gIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbiAgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EXG4gIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRlxuICBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cblxuXG4oZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGV4cG9ydHMuYXN0ID0gcmVxdWlyZSgnLi9hc3QnKTtcbiAgICBleHBvcnRzLmNvZGUgPSByZXF1aXJlKCcuL2NvZGUnKTtcbiAgICBleHBvcnRzLmtleXdvcmQgPSByZXF1aXJlKCcuL2tleXdvcmQnKTtcbn0oKSk7XG4vKiB2aW06IHNldCBzdz00IHRzPTQgZXQgdHc9ODAgOiAqL1xuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwiLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKiBnbG9iYWxzIGRlZmluZSAqL1xuLypcbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuVGhlIGZvbGxvd2luZyBiYXRjaGVzIGFyZSBlcXVpdmFsZW50OlxuXG52YXIgYmVhdXRpZnlfanMgPSByZXF1aXJlKCdqcy1iZWF1dGlmeScpO1xudmFyIGJlYXV0aWZ5X2pzID0gcmVxdWlyZSgnanMtYmVhdXRpZnknKS5qcztcbnZhciBiZWF1dGlmeV9qcyA9IHJlcXVpcmUoJ2pzLWJlYXV0aWZ5JykuanNfYmVhdXRpZnk7XG5cbnZhciBiZWF1dGlmeV9jc3MgPSByZXF1aXJlKCdqcy1iZWF1dGlmeScpLmNzcztcbnZhciBiZWF1dGlmeV9jc3MgPSByZXF1aXJlKCdqcy1iZWF1dGlmeScpLmNzc19iZWF1dGlmeTtcblxudmFyIGJlYXV0aWZ5X2h0bWwgPSByZXF1aXJlKCdqcy1iZWF1dGlmeScpLmh0bWw7XG52YXIgYmVhdXRpZnlfaHRtbCA9IHJlcXVpcmUoJ2pzLWJlYXV0aWZ5JykuaHRtbF9iZWF1dGlmeTtcblxuQWxsIG1ldGhvZHMgcmV0dXJuZWQgYWNjZXB0IHR3byBhcmd1bWVudHMsIHRoZSBzb3VyY2Ugc3RyaW5nIGFuZCBhbiBvcHRpb25zIG9iamVjdC5cbioqL1xuXG5mdW5jdGlvbiBnZXRfYmVhdXRpZnkoanNfYmVhdXRpZnksIGNzc19iZWF1dGlmeSwgaHRtbF9iZWF1dGlmeSkge1xuICAvLyB0aGUgZGVmYXVsdCBpcyBqc1xuICB2YXIgYmVhdXRpZnkgPSBmdW5jdGlvbihzcmMsIGNvbmZpZykge1xuICAgIHJldHVybiBqc19iZWF1dGlmeS5qc19iZWF1dGlmeShzcmMsIGNvbmZpZyk7XG4gIH07XG5cbiAgLy8gc2hvcnQgYWxpYXNlc1xuICBiZWF1dGlmeS5qcyA9IGpzX2JlYXV0aWZ5LmpzX2JlYXV0aWZ5O1xuICBiZWF1dGlmeS5jc3MgPSBjc3NfYmVhdXRpZnkuY3NzX2JlYXV0aWZ5O1xuICBiZWF1dGlmeS5odG1sID0gaHRtbF9iZWF1dGlmeS5odG1sX2JlYXV0aWZ5O1xuXG4gIC8vIGxlZ2FjeSBhbGlhc2VzXG4gIGJlYXV0aWZ5LmpzX2JlYXV0aWZ5ID0ganNfYmVhdXRpZnkuanNfYmVhdXRpZnk7XG4gIGJlYXV0aWZ5LmNzc19iZWF1dGlmeSA9IGNzc19iZWF1dGlmeS5jc3NfYmVhdXRpZnk7XG4gIGJlYXV0aWZ5Lmh0bWxfYmVhdXRpZnkgPSBodG1sX2JlYXV0aWZ5Lmh0bWxfYmVhdXRpZnk7XG5cbiAgcmV0dXJuIGJlYXV0aWZ5O1xufVxuXG5pZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgLy8gQWRkIHN1cHBvcnQgZm9yIEFNRCAoIGh0dHBzOi8vZ2l0aHViLmNvbS9hbWRqcy9hbWRqcy1hcGkvd2lraS9BTUQjZGVmaW5lYW1kLXByb3BlcnR5LSApXG4gIGRlZmluZShbXG4gICAgXCIuL2xpYi9iZWF1dGlmeVwiLFxuICAgIFwiLi9saWIvYmVhdXRpZnktY3NzXCIsXG4gICAgXCIuL2xpYi9iZWF1dGlmeS1odG1sXCJcbiAgXSwgZnVuY3Rpb24oanNfYmVhdXRpZnksIGNzc19iZWF1dGlmeSwgaHRtbF9iZWF1dGlmeSkge1xuICAgIHJldHVybiBnZXRfYmVhdXRpZnkoanNfYmVhdXRpZnksIGNzc19iZWF1dGlmeSwgaHRtbF9iZWF1dGlmeSk7XG4gIH0pO1xufSBlbHNlIHtcbiAgKGZ1bmN0aW9uKG1vZCkge1xuICAgIHZhciBiZWF1dGlmaWVyID0gcmVxdWlyZSgnLi9zcmMvaW5kZXgnKTtcbiAgICBiZWF1dGlmaWVyLmpzX2JlYXV0aWZ5ID0gYmVhdXRpZmllci5qcztcbiAgICBiZWF1dGlmaWVyLmNzc19iZWF1dGlmeSA9IGJlYXV0aWZpZXIuY3NzO1xuICAgIGJlYXV0aWZpZXIuaHRtbF9iZWF1dGlmeSA9IGJlYXV0aWZpZXIuaHRtbDtcblxuICAgIG1vZC5leHBvcnRzID0gZ2V0X2JlYXV0aWZ5KGJlYXV0aWZpZXIsIGJlYXV0aWZpZXIsIGJlYXV0aWZpZXIpO1xuXG4gIH0pKG1vZHVsZSk7XG59IiwiLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gRGlyZWN0aXZlcyhzdGFydF9ibG9ja19wYXR0ZXJuLCBlbmRfYmxvY2tfcGF0dGVybikge1xuICBzdGFydF9ibG9ja19wYXR0ZXJuID0gdHlwZW9mIHN0YXJ0X2Jsb2NrX3BhdHRlcm4gPT09ICdzdHJpbmcnID8gc3RhcnRfYmxvY2tfcGF0dGVybiA6IHN0YXJ0X2Jsb2NrX3BhdHRlcm4uc291cmNlO1xuICBlbmRfYmxvY2tfcGF0dGVybiA9IHR5cGVvZiBlbmRfYmxvY2tfcGF0dGVybiA9PT0gJ3N0cmluZycgPyBlbmRfYmxvY2tfcGF0dGVybiA6IGVuZF9ibG9ja19wYXR0ZXJuLnNvdXJjZTtcbiAgdGhpcy5fX2RpcmVjdGl2ZXNfYmxvY2tfcGF0dGVybiA9IG5ldyBSZWdFeHAoc3RhcnRfYmxvY2tfcGF0dGVybiArIC8gYmVhdXRpZnkoIFxcdytbOl1cXHcrKSsgLy5zb3VyY2UgKyBlbmRfYmxvY2tfcGF0dGVybiwgJ2cnKTtcbiAgdGhpcy5fX2RpcmVjdGl2ZV9wYXR0ZXJuID0gLyAoXFx3KylbOl0oXFx3KykvZztcblxuICB0aGlzLl9fZGlyZWN0aXZlc19lbmRfaWdub3JlX3BhdHRlcm4gPSBuZXcgUmVnRXhwKHN0YXJ0X2Jsb2NrX3BhdHRlcm4gKyAvXFxzYmVhdXRpZnlcXHNpZ25vcmU6ZW5kXFxzLy5zb3VyY2UgKyBlbmRfYmxvY2tfcGF0dGVybiwgJ2cnKTtcbn1cblxuRGlyZWN0aXZlcy5wcm90b3R5cGUuZ2V0X2RpcmVjdGl2ZXMgPSBmdW5jdGlvbih0ZXh0KSB7XG4gIGlmICghdGV4dC5tYXRjaCh0aGlzLl9fZGlyZWN0aXZlc19ibG9ja19wYXR0ZXJuKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGRpcmVjdGl2ZXMgPSB7fTtcbiAgdGhpcy5fX2RpcmVjdGl2ZV9wYXR0ZXJuLmxhc3RJbmRleCA9IDA7XG4gIHZhciBkaXJlY3RpdmVfbWF0Y2ggPSB0aGlzLl9fZGlyZWN0aXZlX3BhdHRlcm4uZXhlYyh0ZXh0KTtcblxuICB3aGlsZSAoZGlyZWN0aXZlX21hdGNoKSB7XG4gICAgZGlyZWN0aXZlc1tkaXJlY3RpdmVfbWF0Y2hbMV1dID0gZGlyZWN0aXZlX21hdGNoWzJdO1xuICAgIGRpcmVjdGl2ZV9tYXRjaCA9IHRoaXMuX19kaXJlY3RpdmVfcGF0dGVybi5leGVjKHRleHQpO1xuICB9XG5cbiAgcmV0dXJuIGRpcmVjdGl2ZXM7XG59O1xuXG5EaXJlY3RpdmVzLnByb3RvdHlwZS5yZWFkSWdub3JlZCA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIHJldHVybiBpbnB1dC5yZWFkVW50aWxBZnRlcih0aGlzLl9fZGlyZWN0aXZlc19lbmRfaWdub3JlX3BhdHRlcm4pO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cy5EaXJlY3RpdmVzID0gRGlyZWN0aXZlcztcbiIsIi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciByZWdleHBfaGFzX3N0aWNreSA9IFJlZ0V4cC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ3N0aWNreScpO1xuXG5mdW5jdGlvbiBJbnB1dFNjYW5uZXIoaW5wdXRfc3RyaW5nKSB7XG4gIHRoaXMuX19pbnB1dCA9IGlucHV0X3N0cmluZyB8fCAnJztcbiAgdGhpcy5fX2lucHV0X2xlbmd0aCA9IHRoaXMuX19pbnB1dC5sZW5ndGg7XG4gIHRoaXMuX19wb3NpdGlvbiA9IDA7XG59XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUucmVzdGFydCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9fcG9zaXRpb24gPSAwO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5iYWNrID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9fcG9zaXRpb24gPiAwKSB7XG4gICAgdGhpcy5fX3Bvc2l0aW9uIC09IDE7XG4gIH1cbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUuaGFzTmV4dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fX3Bvc2l0aW9uIDwgdGhpcy5fX2lucHV0X2xlbmd0aDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdmFsID0gbnVsbDtcbiAgaWYgKHRoaXMuaGFzTmV4dCgpKSB7XG4gICAgdmFsID0gdGhpcy5fX2lucHV0LmNoYXJBdCh0aGlzLl9fcG9zaXRpb24pO1xuICAgIHRoaXMuX19wb3NpdGlvbiArPSAxO1xuICB9XG4gIHJldHVybiB2YWw7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbihpbmRleCkge1xuICB2YXIgdmFsID0gbnVsbDtcbiAgaW5kZXggPSBpbmRleCB8fCAwO1xuICBpbmRleCArPSB0aGlzLl9fcG9zaXRpb247XG4gIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5fX2lucHV0X2xlbmd0aCkge1xuICAgIHZhbCA9IHRoaXMuX19pbnB1dC5jaGFyQXQoaW5kZXgpO1xuICB9XG4gIHJldHVybiB2YWw7XG59O1xuXG4vLyBUaGlzIGlzIGEgSmF2YVNjcmlwdCBvbmx5IGhlbHBlciBmdW5jdGlvbiAobm90IGluIHB5dGhvbilcbi8vIEphdmFzY3JpcHQgZG9lc24ndCBoYXZlIGEgbWF0Y2ggbWV0aG9kXG4vLyBhbmQgbm90IGFsbCBpbXBsZW1lbnRhdGlvbiBzdXBwb3J0IFwic3RpY2t5XCIgZmxhZy5cbi8vIElmIHRoZXkgZG8gbm90IHN1cHBvcnQgc3RpY2t5IHRoZW4gYm90aCB0aGlzLm1hdGNoKCkgYW5kIHRoaXMudGVzdCgpIG1ldGhvZFxuLy8gbXVzdCBnZXQgdGhlIG1hdGNoIGFuZCBjaGVjayB0aGUgaW5kZXggb2YgdGhlIG1hdGNoLlxuLy8gSWYgc3RpY2t5IGlzIHN1cHBvcnRlZCBhbmQgc2V0LCB0aGlzIG1ldGhvZCB3aWxsIHVzZSBpdC5cbi8vIE90aGVyd2lzZSBpdCB3aWxsIGNoZWNrIHRoYXQgZ2xvYmFsIGlzIHNldCwgYW5kIGZhbGwgYmFjayB0byB0aGUgc2xvd2VyIG1ldGhvZC5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUuX19tYXRjaCA9IGZ1bmN0aW9uKHBhdHRlcm4sIGluZGV4KSB7XG4gIHBhdHRlcm4ubGFzdEluZGV4ID0gaW5kZXg7XG4gIHZhciBwYXR0ZXJuX21hdGNoID0gcGF0dGVybi5leGVjKHRoaXMuX19pbnB1dCk7XG5cbiAgaWYgKHBhdHRlcm5fbWF0Y2ggJiYgIShyZWdleHBfaGFzX3N0aWNreSAmJiBwYXR0ZXJuLnN0aWNreSkpIHtcbiAgICBpZiAocGF0dGVybl9tYXRjaC5pbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgIHBhdHRlcm5fbWF0Y2ggPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXR0ZXJuX21hdGNoO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS50ZXN0ID0gZnVuY3Rpb24ocGF0dGVybiwgaW5kZXgpIHtcbiAgaW5kZXggPSBpbmRleCB8fCAwO1xuICBpbmRleCArPSB0aGlzLl9fcG9zaXRpb247XG5cbiAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLl9faW5wdXRfbGVuZ3RoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fX21hdGNoKHBhdHRlcm4sIGluZGV4KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUudGVzdENoYXIgPSBmdW5jdGlvbihwYXR0ZXJuLCBpbmRleCkge1xuICAvLyB0ZXN0IG9uZSBjaGFyYWN0ZXIgcmVnZXggbWF0Y2hcbiAgdmFyIHZhbCA9IHRoaXMucGVlayhpbmRleCk7XG4gIHBhdHRlcm4ubGFzdEluZGV4ID0gMDtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiBwYXR0ZXJuLnRlc3QodmFsKTtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gIHZhciBwYXR0ZXJuX21hdGNoID0gdGhpcy5fX21hdGNoKHBhdHRlcm4sIHRoaXMuX19wb3NpdGlvbik7XG4gIGlmIChwYXR0ZXJuX21hdGNoKSB7XG4gICAgdGhpcy5fX3Bvc2l0aW9uICs9IHBhdHRlcm5fbWF0Y2hbMF0ubGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgIHBhdHRlcm5fbWF0Y2ggPSBudWxsO1xuICB9XG4gIHJldHVybiBwYXR0ZXJuX21hdGNoO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24oc3RhcnRpbmdfcGF0dGVybiwgdW50aWxfcGF0dGVybiwgdW50aWxfYWZ0ZXIpIHtcbiAgdmFyIHZhbCA9ICcnO1xuICB2YXIgbWF0Y2g7XG4gIGlmIChzdGFydGluZ19wYXR0ZXJuKSB7XG4gICAgbWF0Y2ggPSB0aGlzLm1hdGNoKHN0YXJ0aW5nX3BhdHRlcm4pO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgdmFsICs9IG1hdGNoWzBdO1xuICAgIH1cbiAgfVxuICBpZiAodW50aWxfcGF0dGVybiAmJiAobWF0Y2ggfHwgIXN0YXJ0aW5nX3BhdHRlcm4pKSB7XG4gICAgdmFsICs9IHRoaXMucmVhZFVudGlsKHVudGlsX3BhdHRlcm4sIHVudGlsX2FmdGVyKTtcbiAgfVxuICByZXR1cm4gdmFsO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5yZWFkVW50aWwgPSBmdW5jdGlvbihwYXR0ZXJuLCB1bnRpbF9hZnRlcikge1xuICB2YXIgdmFsID0gJyc7XG4gIHZhciBtYXRjaF9pbmRleCA9IHRoaXMuX19wb3NpdGlvbjtcbiAgcGF0dGVybi5sYXN0SW5kZXggPSB0aGlzLl9fcG9zaXRpb247XG4gIHZhciBwYXR0ZXJuX21hdGNoID0gcGF0dGVybi5leGVjKHRoaXMuX19pbnB1dCk7XG4gIGlmIChwYXR0ZXJuX21hdGNoKSB7XG4gICAgbWF0Y2hfaW5kZXggPSBwYXR0ZXJuX21hdGNoLmluZGV4O1xuICAgIGlmICh1bnRpbF9hZnRlcikge1xuICAgICAgbWF0Y2hfaW5kZXggKz0gcGF0dGVybl9tYXRjaFswXS5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG1hdGNoX2luZGV4ID0gdGhpcy5fX2lucHV0X2xlbmd0aDtcbiAgfVxuXG4gIHZhbCA9IHRoaXMuX19pbnB1dC5zdWJzdHJpbmcodGhpcy5fX3Bvc2l0aW9uLCBtYXRjaF9pbmRleCk7XG4gIHRoaXMuX19wb3NpdGlvbiA9IG1hdGNoX2luZGV4O1xuICByZXR1cm4gdmFsO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5yZWFkVW50aWxBZnRlciA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgcmV0dXJuIHRoaXMucmVhZFVudGlsKHBhdHRlcm4sIHRydWUpO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5nZXRfcmVnZXhwID0gZnVuY3Rpb24ocGF0dGVybiwgbWF0Y2hfZnJvbSkge1xuICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgdmFyIGZsYWdzID0gJ2cnO1xuICBpZiAobWF0Y2hfZnJvbSAmJiByZWdleHBfaGFzX3N0aWNreSkge1xuICAgIGZsYWdzID0gJ3knO1xuICB9XG4gIC8vIHN0cmluZ3MgYXJlIGNvbnZlcnRlZCB0byByZWdleHBcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSBcInN0cmluZ1wiICYmIHBhdHRlcm4gIT09ICcnKSB7XG4gICAgLy8gcmVzdWx0ID0gbmV3IFJlZ0V4cChwYXR0ZXJuLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpLCBmbGFncyk7XG4gICAgcmVzdWx0ID0gbmV3IFJlZ0V4cChwYXR0ZXJuLCBmbGFncyk7XG4gIH0gZWxzZSBpZiAocGF0dGVybikge1xuICAgIHJlc3VsdCA9IG5ldyBSZWdFeHAocGF0dGVybi5zb3VyY2UsIGZsYWdzKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5nZXRfbGl0ZXJhbF9yZWdleHAgPSBmdW5jdGlvbihsaXRlcmFsX3N0cmluZykge1xuICByZXR1cm4gUmVnRXhwKGxpdGVyYWxfc3RyaW5nLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpKTtcbn07XG5cbi8qIGNzcyBiZWF1dGlmaWVyIGxlZ2FjeSBoZWxwZXJzICovXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLnBlZWtVbnRpbEFmdGVyID0gZnVuY3Rpb24ocGF0dGVybikge1xuICB2YXIgc3RhcnQgPSB0aGlzLl9fcG9zaXRpb247XG4gIHZhciB2YWwgPSB0aGlzLnJlYWRVbnRpbEFmdGVyKHBhdHRlcm4pO1xuICB0aGlzLl9fcG9zaXRpb24gPSBzdGFydDtcbiAgcmV0dXJuIHZhbDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUubG9va0JhY2sgPSBmdW5jdGlvbih0ZXN0VmFsKSB7XG4gIHZhciBzdGFydCA9IHRoaXMuX19wb3NpdGlvbiAtIDE7XG4gIHJldHVybiBzdGFydCA+PSB0ZXN0VmFsLmxlbmd0aCAmJiB0aGlzLl9faW5wdXQuc3Vic3RyaW5nKHN0YXJ0IC0gdGVzdFZhbC5sZW5ndGgsIHN0YXJ0KVxuICAgIC50b0xvd2VyQ2FzZSgpID09PSB0ZXN0VmFsO1xufTtcblxubW9kdWxlLmV4cG9ydHMuSW5wdXRTY2FubmVyID0gSW5wdXRTY2FubmVyO1xuIiwiLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gT3B0aW9ucyhvcHRpb25zLCBtZXJnZV9jaGlsZF9maWVsZCkge1xuICB0aGlzLnJhd19vcHRpb25zID0gX21lcmdlT3B0cyhvcHRpb25zLCBtZXJnZV9jaGlsZF9maWVsZCk7XG5cbiAgLy8gU3VwcG9ydCBwYXNzaW5nIHRoZSBzb3VyY2UgdGV4dCBiYWNrIHdpdGggbm8gY2hhbmdlXG4gIHRoaXMuZGlzYWJsZWQgPSB0aGlzLl9nZXRfYm9vbGVhbignZGlzYWJsZWQnKTtcblxuICB0aGlzLmVvbCA9IHRoaXMuX2dldF9jaGFyYWN0ZXJzKCdlb2wnLCAnYXV0bycpO1xuICB0aGlzLmVuZF93aXRoX25ld2xpbmUgPSB0aGlzLl9nZXRfYm9vbGVhbignZW5kX3dpdGhfbmV3bGluZScpO1xuICB0aGlzLmluZGVudF9zaXplID0gdGhpcy5fZ2V0X251bWJlcignaW5kZW50X3NpemUnLCA0KTtcbiAgdGhpcy5pbmRlbnRfY2hhciA9IHRoaXMuX2dldF9jaGFyYWN0ZXJzKCdpbmRlbnRfY2hhcicsICcgJyk7XG4gIHRoaXMuaW5kZW50X2xldmVsID0gdGhpcy5fZ2V0X251bWJlcignaW5kZW50X2xldmVsJyk7XG5cbiAgdGhpcy5wcmVzZXJ2ZV9uZXdsaW5lcyA9IHRoaXMuX2dldF9ib29sZWFuKCdwcmVzZXJ2ZV9uZXdsaW5lcycsIHRydWUpO1xuICB0aGlzLm1heF9wcmVzZXJ2ZV9uZXdsaW5lcyA9IHRoaXMuX2dldF9udW1iZXIoJ21heF9wcmVzZXJ2ZV9uZXdsaW5lcycsIDMyNzg2KTtcbiAgaWYgKCF0aGlzLnByZXNlcnZlX25ld2xpbmVzKSB7XG4gICAgdGhpcy5tYXhfcHJlc2VydmVfbmV3bGluZXMgPSAwO1xuICB9XG5cbiAgdGhpcy5pbmRlbnRfd2l0aF90YWJzID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ2luZGVudF93aXRoX3RhYnMnLCB0aGlzLmluZGVudF9jaGFyID09PSAnXFx0Jyk7XG4gIGlmICh0aGlzLmluZGVudF93aXRoX3RhYnMpIHtcbiAgICB0aGlzLmluZGVudF9jaGFyID0gJ1xcdCc7XG5cbiAgICAvLyBpbmRlbnRfc2l6ZSBiZWhhdmlvciBjaGFuZ2VkIGFmdGVyIDEuOC42XG4gICAgLy8gSXQgdXNlZCB0byBiZSB0aGF0IGluZGVudF9zaXplIHdvdWxkIGJlXG4gICAgLy8gc2V0IHRvIDEgZm9yIGluZGVudF93aXRoX3RhYnMuIFRoYXQgaXMgbm8gbG9uZ2VyIG5lZWRlZCBhbmRcbiAgICAvLyBhY3R1YWxseSBkb2Vzbid0IG1ha2Ugc2Vuc2UgLSB3aHkgbm90IHVzZSBzcGFjZXM/IEZ1cnRoZXIsXG4gICAgLy8gdGhhdCBtaWdodCBwcm9kdWNlIHVuZXhwZWN0ZWQgYmVoYXZpb3IgLSB0YWJzIGJlaW5nIHVzZWRcbiAgICAvLyBmb3Igc2luZ2xlLWNvbHVtbiBhbGlnbm1lbnQuIFNvLCB3aGVuIGluZGVudF93aXRoX3RhYnMgaXMgdHJ1ZVxuICAgIC8vIGFuZCBpbmRlbnRfc2l6ZSBpcyAxLCByZXNldCBpbmRlbnRfc2l6ZSB0byA0LlxuICAgIGlmICh0aGlzLmluZGVudF9zaXplID09PSAxKSB7XG4gICAgICB0aGlzLmluZGVudF9zaXplID0gNDtcbiAgICB9XG4gIH1cblxuICAvLyBCYWNrd2FyZHMgY29tcGF0IHdpdGggMS4zLnhcbiAgdGhpcy53cmFwX2xpbmVfbGVuZ3RoID0gdGhpcy5fZ2V0X251bWJlcignd3JhcF9saW5lX2xlbmd0aCcsIHRoaXMuX2dldF9udW1iZXIoJ21heF9jaGFyJykpO1xuXG4gIHRoaXMuaW5kZW50X2VtcHR5X2xpbmVzID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ2luZGVudF9lbXB0eV9saW5lcycpO1xuXG4gIC8vIHZhbGlkIHRlbXBsYXRpbmcgbGFuZ3VhZ2VzIFsnZGphbmdvJywgJ2VyYicsICdoYW5kbGViYXJzJywgJ3BocCddXG4gIC8vIEZvciBub3csICdhdXRvJyA9IGFsbCBvZmYgZm9yIGphdmFzY3JpcHQsIGFsbCBvbiBmb3IgaHRtbCAoYW5kIGlubGluZSBqYXZhc2NyaXB0KS5cbiAgLy8gb3RoZXIgdmFsdWVzIGlnbm9yZWRcbiAgdGhpcy50ZW1wbGF0aW5nID0gdGhpcy5fZ2V0X3NlbGVjdGlvbl9saXN0KCd0ZW1wbGF0aW5nJywgWydhdXRvJywgJ25vbmUnLCAnZGphbmdvJywgJ2VyYicsICdoYW5kbGViYXJzJywgJ3BocCddLCBbJ2F1dG8nXSk7XG59XG5cbk9wdGlvbnMucHJvdG90eXBlLl9nZXRfYXJyYXkgPSBmdW5jdGlvbihuYW1lLCBkZWZhdWx0X3ZhbHVlKSB7XG4gIHZhciBvcHRpb25fdmFsdWUgPSB0aGlzLnJhd19vcHRpb25zW25hbWVdO1xuICB2YXIgcmVzdWx0ID0gZGVmYXVsdF92YWx1ZSB8fCBbXTtcbiAgaWYgKHR5cGVvZiBvcHRpb25fdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKG9wdGlvbl92YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2Ygb3B0aW9uX3ZhbHVlLmNvbmNhdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVzdWx0ID0gb3B0aW9uX3ZhbHVlLmNvbmNhdCgpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9uX3ZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJlc3VsdCA9IG9wdGlvbl92YWx1ZS5zcGxpdCgvW15hLXpBLVowLTlfXFwvXFwtXSsvKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuT3B0aW9ucy5wcm90b3R5cGUuX2dldF9ib29sZWFuID0gZnVuY3Rpb24obmFtZSwgZGVmYXVsdF92YWx1ZSkge1xuICB2YXIgb3B0aW9uX3ZhbHVlID0gdGhpcy5yYXdfb3B0aW9uc1tuYW1lXTtcbiAgdmFyIHJlc3VsdCA9IG9wdGlvbl92YWx1ZSA9PT0gdW5kZWZpbmVkID8gISFkZWZhdWx0X3ZhbHVlIDogISFvcHRpb25fdmFsdWU7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5PcHRpb25zLnByb3RvdHlwZS5fZ2V0X2NoYXJhY3RlcnMgPSBmdW5jdGlvbihuYW1lLCBkZWZhdWx0X3ZhbHVlKSB7XG4gIHZhciBvcHRpb25fdmFsdWUgPSB0aGlzLnJhd19vcHRpb25zW25hbWVdO1xuICB2YXIgcmVzdWx0ID0gZGVmYXVsdF92YWx1ZSB8fCAnJztcbiAgaWYgKHR5cGVvZiBvcHRpb25fdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmVzdWx0ID0gb3B0aW9uX3ZhbHVlLnJlcGxhY2UoL1xcXFxyLywgJ1xccicpLnJlcGxhY2UoL1xcXFxuLywgJ1xcbicpLnJlcGxhY2UoL1xcXFx0LywgJ1xcdCcpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5PcHRpb25zLnByb3RvdHlwZS5fZ2V0X251bWJlciA9IGZ1bmN0aW9uKG5hbWUsIGRlZmF1bHRfdmFsdWUpIHtcbiAgdmFyIG9wdGlvbl92YWx1ZSA9IHRoaXMucmF3X29wdGlvbnNbbmFtZV07XG4gIGRlZmF1bHRfdmFsdWUgPSBwYXJzZUludChkZWZhdWx0X3ZhbHVlLCAxMCk7XG4gIGlmIChpc05hTihkZWZhdWx0X3ZhbHVlKSkge1xuICAgIGRlZmF1bHRfdmFsdWUgPSAwO1xuICB9XG4gIHZhciByZXN1bHQgPSBwYXJzZUludChvcHRpb25fdmFsdWUsIDEwKTtcbiAgaWYgKGlzTmFOKHJlc3VsdCkpIHtcbiAgICByZXN1bHQgPSBkZWZhdWx0X3ZhbHVlO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5PcHRpb25zLnByb3RvdHlwZS5fZ2V0X3NlbGVjdGlvbiA9IGZ1bmN0aW9uKG5hbWUsIHNlbGVjdGlvbl9saXN0LCBkZWZhdWx0X3ZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9nZXRfc2VsZWN0aW9uX2xpc3QobmFtZSwgc2VsZWN0aW9uX2xpc3QsIGRlZmF1bHRfdmFsdWUpO1xuICBpZiAocmVzdWx0Lmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiSW52YWxpZCBPcHRpb24gVmFsdWU6IFRoZSBvcHRpb24gJ1wiICsgbmFtZSArIFwiJyBjYW4gb25seSBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZyB2YWx1ZXM6XFxuXCIgK1xuICAgICAgc2VsZWN0aW9uX2xpc3QgKyBcIlxcbllvdSBwYXNzZWQgaW46ICdcIiArIHRoaXMucmF3X29wdGlvbnNbbmFtZV0gKyBcIidcIik7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0WzBdO1xufTtcblxuXG5PcHRpb25zLnByb3RvdHlwZS5fZ2V0X3NlbGVjdGlvbl9saXN0ID0gZnVuY3Rpb24obmFtZSwgc2VsZWN0aW9uX2xpc3QsIGRlZmF1bHRfdmFsdWUpIHtcbiAgaWYgKCFzZWxlY3Rpb25fbGlzdCB8fCBzZWxlY3Rpb25fbGlzdC5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZWxlY3Rpb24gbGlzdCBjYW5ub3QgYmUgZW1wdHkuXCIpO1xuICB9XG5cbiAgZGVmYXVsdF92YWx1ZSA9IGRlZmF1bHRfdmFsdWUgfHwgW3NlbGVjdGlvbl9saXN0WzBdXTtcbiAgaWYgKCF0aGlzLl9pc192YWxpZF9zZWxlY3Rpb24oZGVmYXVsdF92YWx1ZSwgc2VsZWN0aW9uX2xpc3QpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBEZWZhdWx0IFZhbHVlIVwiKTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSB0aGlzLl9nZXRfYXJyYXkobmFtZSwgZGVmYXVsdF92YWx1ZSk7XG4gIGlmICghdGhpcy5faXNfdmFsaWRfc2VsZWN0aW9uKHJlc3VsdCwgc2VsZWN0aW9uX2xpc3QpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJJbnZhbGlkIE9wdGlvbiBWYWx1ZTogVGhlIG9wdGlvbiAnXCIgKyBuYW1lICsgXCInIGNhbiBjb250YWluIG9ubHkgdGhlIGZvbGxvd2luZyB2YWx1ZXM6XFxuXCIgK1xuICAgICAgc2VsZWN0aW9uX2xpc3QgKyBcIlxcbllvdSBwYXNzZWQgaW46ICdcIiArIHRoaXMucmF3X29wdGlvbnNbbmFtZV0gKyBcIidcIik7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuT3B0aW9ucy5wcm90b3R5cGUuX2lzX3ZhbGlkX3NlbGVjdGlvbiA9IGZ1bmN0aW9uKHJlc3VsdCwgc2VsZWN0aW9uX2xpc3QpIHtcbiAgcmV0dXJuIHJlc3VsdC5sZW5ndGggJiYgc2VsZWN0aW9uX2xpc3QubGVuZ3RoICYmXG4gICAgIXJlc3VsdC5zb21lKGZ1bmN0aW9uKGl0ZW0pIHsgcmV0dXJuIHNlbGVjdGlvbl9saXN0LmluZGV4T2YoaXRlbSkgPT09IC0xOyB9KTtcbn07XG5cblxuLy8gbWVyZ2VzIGNoaWxkIG9wdGlvbnMgdXAgd2l0aCB0aGUgcGFyZW50IG9wdGlvbnMgb2JqZWN0XG4vLyBFeGFtcGxlOiBvYmogPSB7YTogMSwgYjoge2E6IDJ9fVxuLy8gICAgICAgICAgbWVyZ2VPcHRzKG9iaiwgJ2InKVxuLy9cbi8vICAgICAgICAgIFJldHVybnM6IHthOiAyfVxuZnVuY3Rpb24gX21lcmdlT3B0cyhhbGxPcHRpb25zLCBjaGlsZEZpZWxkTmFtZSkge1xuICB2YXIgZmluYWxPcHRzID0ge307XG4gIGFsbE9wdGlvbnMgPSBfbm9ybWFsaXplT3B0cyhhbGxPcHRpb25zKTtcbiAgdmFyIG5hbWU7XG5cbiAgZm9yIChuYW1lIGluIGFsbE9wdGlvbnMpIHtcbiAgICBpZiAobmFtZSAhPT0gY2hpbGRGaWVsZE5hbWUpIHtcbiAgICAgIGZpbmFsT3B0c1tuYW1lXSA9IGFsbE9wdGlvbnNbbmFtZV07XG4gICAgfVxuICB9XG5cbiAgLy9tZXJnZSBpbiB0aGUgcGVyIHR5cGUgc2V0dGluZ3MgZm9yIHRoZSBjaGlsZEZpZWxkTmFtZVxuICBpZiAoY2hpbGRGaWVsZE5hbWUgJiYgYWxsT3B0aW9uc1tjaGlsZEZpZWxkTmFtZV0pIHtcbiAgICBmb3IgKG5hbWUgaW4gYWxsT3B0aW9uc1tjaGlsZEZpZWxkTmFtZV0pIHtcbiAgICAgIGZpbmFsT3B0c1tuYW1lXSA9IGFsbE9wdGlvbnNbY2hpbGRGaWVsZE5hbWVdW25hbWVdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmluYWxPcHRzO1xufVxuXG5mdW5jdGlvbiBfbm9ybWFsaXplT3B0cyhvcHRpb25zKSB7XG4gIHZhciBjb252ZXJ0ZWRPcHRzID0ge307XG4gIHZhciBrZXk7XG5cbiAgZm9yIChrZXkgaW4gb3B0aW9ucykge1xuICAgIHZhciBuZXdLZXkgPSBrZXkucmVwbGFjZSgvLS9nLCBcIl9cIik7XG4gICAgY29udmVydGVkT3B0c1tuZXdLZXldID0gb3B0aW9uc1trZXldO1xuICB9XG4gIHJldHVybiBjb252ZXJ0ZWRPcHRzO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5PcHRpb25zID0gT3B0aW9ucztcbm1vZHVsZS5leHBvcnRzLm5vcm1hbGl6ZU9wdHMgPSBfbm9ybWFsaXplT3B0cztcbm1vZHVsZS5leHBvcnRzLm1lcmdlT3B0cyA9IF9tZXJnZU9wdHM7XG4iLCIvKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gT3V0cHV0TGluZShwYXJlbnQpIHtcbiAgdGhpcy5fX3BhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCA9IDA7XG4gIC8vIHVzZSBpbmRlbnRfY291bnQgYXMgYSBtYXJrZXIgZm9yIHRoaXMuX19saW5lcyB0aGF0IGhhdmUgcHJlc2VydmVkIGluZGVudGF0aW9uXG4gIHRoaXMuX19pbmRlbnRfY291bnQgPSAtMTtcbiAgdGhpcy5fX2FsaWdubWVudF9jb3VudCA9IDA7XG4gIHRoaXMuX193cmFwX3BvaW50X2luZGV4ID0gMDtcbiAgdGhpcy5fX3dyYXBfcG9pbnRfY2hhcmFjdGVyX2NvdW50ID0gMDtcbiAgdGhpcy5fX3dyYXBfcG9pbnRfaW5kZW50X2NvdW50ID0gLTE7XG4gIHRoaXMuX193cmFwX3BvaW50X2FsaWdubWVudF9jb3VudCA9IDA7XG5cbiAgdGhpcy5fX2l0ZW1zID0gW107XG59XG5cbk91dHB1dExpbmUucHJvdG90eXBlLmNsb25lX2VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBsaW5lID0gbmV3IE91dHB1dExpbmUodGhpcy5fX3BhcmVudCk7XG4gIGxpbmUuc2V0X2luZGVudCh0aGlzLl9faW5kZW50X2NvdW50LCB0aGlzLl9fYWxpZ25tZW50X2NvdW50KTtcbiAgcmV0dXJuIGxpbmU7XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5pdGVtID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiB0aGlzLl9faXRlbXNbdGhpcy5fX2l0ZW1zLmxlbmd0aCArIGluZGV4XTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5fX2l0ZW1zW2luZGV4XTtcbiAgfVxufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUuaGFzX21hdGNoID0gZnVuY3Rpb24ocGF0dGVybikge1xuICBmb3IgKHZhciBsYXN0Q2hlY2tlZE91dHB1dCA9IHRoaXMuX19pdGVtcy5sZW5ndGggLSAxOyBsYXN0Q2hlY2tlZE91dHB1dCA+PSAwOyBsYXN0Q2hlY2tlZE91dHB1dC0tKSB7XG4gICAgaWYgKHRoaXMuX19pdGVtc1tsYXN0Q2hlY2tlZE91dHB1dF0ubWF0Y2gocGF0dGVybikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5zZXRfaW5kZW50ID0gZnVuY3Rpb24oaW5kZW50LCBhbGlnbm1lbnQpIHtcbiAgaWYgKHRoaXMuaXNfZW1wdHkoKSkge1xuICAgIHRoaXMuX19pbmRlbnRfY291bnQgPSBpbmRlbnQgfHwgMDtcbiAgICB0aGlzLl9fYWxpZ25tZW50X2NvdW50ID0gYWxpZ25tZW50IHx8IDA7XG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCA9IHRoaXMuX19wYXJlbnQuZ2V0X2luZGVudF9zaXplKHRoaXMuX19pbmRlbnRfY291bnQsIHRoaXMuX19hbGlnbm1lbnRfY291bnQpO1xuICB9XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5fc2V0X3dyYXBfcG9pbnQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX19wYXJlbnQud3JhcF9saW5lX2xlbmd0aCkge1xuICAgIHRoaXMuX193cmFwX3BvaW50X2luZGV4ID0gdGhpcy5fX2l0ZW1zLmxlbmd0aDtcbiAgICB0aGlzLl9fd3JhcF9wb2ludF9jaGFyYWN0ZXJfY291bnQgPSB0aGlzLl9fY2hhcmFjdGVyX2NvdW50O1xuICAgIHRoaXMuX193cmFwX3BvaW50X2luZGVudF9jb3VudCA9IHRoaXMuX19wYXJlbnQubmV4dF9saW5lLl9faW5kZW50X2NvdW50O1xuICAgIHRoaXMuX193cmFwX3BvaW50X2FsaWdubWVudF9jb3VudCA9IHRoaXMuX19wYXJlbnQubmV4dF9saW5lLl9fYWxpZ25tZW50X2NvdW50O1xuICB9XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5fc2hvdWxkX3dyYXAgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX193cmFwX3BvaW50X2luZGV4ICYmXG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCA+IHRoaXMuX19wYXJlbnQud3JhcF9saW5lX2xlbmd0aCAmJlxuICAgIHRoaXMuX193cmFwX3BvaW50X2NoYXJhY3Rlcl9jb3VudCA+IHRoaXMuX19wYXJlbnQubmV4dF9saW5lLl9fY2hhcmFjdGVyX2NvdW50O1xufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUuX2FsbG93X3dyYXAgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX3Nob3VsZF93cmFwKCkpIHtcbiAgICB0aGlzLl9fcGFyZW50LmFkZF9uZXdfbGluZSgpO1xuICAgIHZhciBuZXh0ID0gdGhpcy5fX3BhcmVudC5jdXJyZW50X2xpbmU7XG4gICAgbmV4dC5zZXRfaW5kZW50KHRoaXMuX193cmFwX3BvaW50X2luZGVudF9jb3VudCwgdGhpcy5fX3dyYXBfcG9pbnRfYWxpZ25tZW50X2NvdW50KTtcbiAgICBuZXh0Ll9faXRlbXMgPSB0aGlzLl9faXRlbXMuc2xpY2UodGhpcy5fX3dyYXBfcG9pbnRfaW5kZXgpO1xuICAgIHRoaXMuX19pdGVtcyA9IHRoaXMuX19pdGVtcy5zbGljZSgwLCB0aGlzLl9fd3JhcF9wb2ludF9pbmRleCk7XG5cbiAgICBuZXh0Ll9fY2hhcmFjdGVyX2NvdW50ICs9IHRoaXMuX19jaGFyYWN0ZXJfY291bnQgLSB0aGlzLl9fd3JhcF9wb2ludF9jaGFyYWN0ZXJfY291bnQ7XG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCA9IHRoaXMuX193cmFwX3BvaW50X2NoYXJhY3Rlcl9jb3VudDtcblxuICAgIGlmIChuZXh0Ll9faXRlbXNbMF0gPT09IFwiIFwiKSB7XG4gICAgICBuZXh0Ll9faXRlbXMuc3BsaWNlKDAsIDEpO1xuICAgICAgbmV4dC5fX2NoYXJhY3Rlcl9jb3VudCAtPSAxO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5pc19lbXB0eSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fX2l0ZW1zLmxlbmd0aCA9PT0gMDtcbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLmxhc3QgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmlzX2VtcHR5KCkpIHtcbiAgICByZXR1cm4gdGhpcy5fX2l0ZW1zW3RoaXMuX19pdGVtcy5sZW5ndGggLSAxXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgdGhpcy5fX2l0ZW1zLnB1c2goaXRlbSk7XG4gIHZhciBsYXN0X25ld2xpbmVfaW5kZXggPSBpdGVtLmxhc3RJbmRleE9mKCdcXG4nKTtcbiAgaWYgKGxhc3RfbmV3bGluZV9pbmRleCAhPT0gLTEpIHtcbiAgICB0aGlzLl9fY2hhcmFjdGVyX2NvdW50ID0gaXRlbS5sZW5ndGggLSBsYXN0X25ld2xpbmVfaW5kZXg7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCArPSBpdGVtLmxlbmd0aDtcbiAgfVxufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpdGVtID0gbnVsbDtcbiAgaWYgKCF0aGlzLmlzX2VtcHR5KCkpIHtcbiAgICBpdGVtID0gdGhpcy5fX2l0ZW1zLnBvcCgpO1xuICAgIHRoaXMuX19jaGFyYWN0ZXJfY291bnQgLT0gaXRlbS5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59O1xuXG5cbk91dHB1dExpbmUucHJvdG90eXBlLl9yZW1vdmVfaW5kZW50ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9faW5kZW50X2NvdW50ID4gMCkge1xuICAgIHRoaXMuX19pbmRlbnRfY291bnQgLT0gMTtcbiAgICB0aGlzLl9fY2hhcmFjdGVyX2NvdW50IC09IHRoaXMuX19wYXJlbnQuaW5kZW50X3NpemU7XG4gIH1cbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLl9yZW1vdmVfd3JhcF9pbmRlbnQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX193cmFwX3BvaW50X2luZGVudF9jb3VudCA+IDApIHtcbiAgICB0aGlzLl9fd3JhcF9wb2ludF9pbmRlbnRfY291bnQgLT0gMTtcbiAgfVxufTtcbk91dHB1dExpbmUucHJvdG90eXBlLnRyaW0gPSBmdW5jdGlvbigpIHtcbiAgd2hpbGUgKHRoaXMubGFzdCgpID09PSAnICcpIHtcbiAgICB0aGlzLl9faXRlbXMucG9wKCk7XG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCAtPSAxO1xuICB9XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICh0aGlzLmlzX2VtcHR5KCkpIHtcbiAgICBpZiAodGhpcy5fX3BhcmVudC5pbmRlbnRfZW1wdHlfbGluZXMpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMuX19wYXJlbnQuZ2V0X2luZGVudF9zdHJpbmcodGhpcy5fX2luZGVudF9jb3VudCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IHRoaXMuX19wYXJlbnQuZ2V0X2luZGVudF9zdHJpbmcodGhpcy5fX2luZGVudF9jb3VudCwgdGhpcy5fX2FsaWdubWVudF9jb3VudCk7XG4gICAgcmVzdWx0ICs9IHRoaXMuX19pdGVtcy5qb2luKCcnKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZnVuY3Rpb24gSW5kZW50U3RyaW5nQ2FjaGUob3B0aW9ucywgYmFzZUluZGVudFN0cmluZykge1xuICB0aGlzLl9fY2FjaGUgPSBbJyddO1xuICB0aGlzLl9faW5kZW50X3NpemUgPSBvcHRpb25zLmluZGVudF9zaXplO1xuICB0aGlzLl9faW5kZW50X3N0cmluZyA9IG9wdGlvbnMuaW5kZW50X2NoYXI7XG4gIGlmICghb3B0aW9ucy5pbmRlbnRfd2l0aF90YWJzKSB7XG4gICAgdGhpcy5fX2luZGVudF9zdHJpbmcgPSBuZXcgQXJyYXkob3B0aW9ucy5pbmRlbnRfc2l6ZSArIDEpLmpvaW4ob3B0aW9ucy5pbmRlbnRfY2hhcik7XG4gIH1cblxuICAvLyBTZXQgdG8gbnVsbCB0byBjb250aW51ZSBzdXBwb3J0IGZvciBhdXRvIGRldGVjdGlvbiBvZiBiYXNlIGluZGVudFxuICBiYXNlSW5kZW50U3RyaW5nID0gYmFzZUluZGVudFN0cmluZyB8fCAnJztcbiAgaWYgKG9wdGlvbnMuaW5kZW50X2xldmVsID4gMCkge1xuICAgIGJhc2VJbmRlbnRTdHJpbmcgPSBuZXcgQXJyYXkob3B0aW9ucy5pbmRlbnRfbGV2ZWwgKyAxKS5qb2luKHRoaXMuX19pbmRlbnRfc3RyaW5nKTtcbiAgfVxuXG4gIHRoaXMuX19iYXNlX3N0cmluZyA9IGJhc2VJbmRlbnRTdHJpbmc7XG4gIHRoaXMuX19iYXNlX3N0cmluZ19sZW5ndGggPSBiYXNlSW5kZW50U3RyaW5nLmxlbmd0aDtcbn1cblxuSW5kZW50U3RyaW5nQ2FjaGUucHJvdG90eXBlLmdldF9pbmRlbnRfc2l6ZSA9IGZ1bmN0aW9uKGluZGVudCwgY29sdW1uKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9fYmFzZV9zdHJpbmdfbGVuZ3RoO1xuICBjb2x1bW4gPSBjb2x1bW4gfHwgMDtcbiAgaWYgKGluZGVudCA8IDApIHtcbiAgICByZXN1bHQgPSAwO1xuICB9XG4gIHJlc3VsdCArPSBpbmRlbnQgKiB0aGlzLl9faW5kZW50X3NpemU7XG4gIHJlc3VsdCArPSBjb2x1bW47XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5JbmRlbnRTdHJpbmdDYWNoZS5wcm90b3R5cGUuZ2V0X2luZGVudF9zdHJpbmcgPSBmdW5jdGlvbihpbmRlbnRfbGV2ZWwsIGNvbHVtbikge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fX2Jhc2Vfc3RyaW5nO1xuICBjb2x1bW4gPSBjb2x1bW4gfHwgMDtcbiAgaWYgKGluZGVudF9sZXZlbCA8IDApIHtcbiAgICBpbmRlbnRfbGV2ZWwgPSAwO1xuICAgIHJlc3VsdCA9ICcnO1xuICB9XG4gIGNvbHVtbiArPSBpbmRlbnRfbGV2ZWwgKiB0aGlzLl9faW5kZW50X3NpemU7XG4gIHRoaXMuX19lbnN1cmVfY2FjaGUoY29sdW1uKTtcbiAgcmVzdWx0ICs9IHRoaXMuX19jYWNoZVtjb2x1bW5dO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuSW5kZW50U3RyaW5nQ2FjaGUucHJvdG90eXBlLl9fZW5zdXJlX2NhY2hlID0gZnVuY3Rpb24oY29sdW1uKSB7XG4gIHdoaWxlIChjb2x1bW4gPj0gdGhpcy5fX2NhY2hlLmxlbmd0aCkge1xuICAgIHRoaXMuX19hZGRfY29sdW1uKCk7XG4gIH1cbn07XG5cbkluZGVudFN0cmluZ0NhY2hlLnByb3RvdHlwZS5fX2FkZF9jb2x1bW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNvbHVtbiA9IHRoaXMuX19jYWNoZS5sZW5ndGg7XG4gIHZhciBpbmRlbnQgPSAwO1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICh0aGlzLl9faW5kZW50X3NpemUgJiYgY29sdW1uID49IHRoaXMuX19pbmRlbnRfc2l6ZSkge1xuICAgIGluZGVudCA9IE1hdGguZmxvb3IoY29sdW1uIC8gdGhpcy5fX2luZGVudF9zaXplKTtcbiAgICBjb2x1bW4gLT0gaW5kZW50ICogdGhpcy5fX2luZGVudF9zaXplO1xuICAgIHJlc3VsdCA9IG5ldyBBcnJheShpbmRlbnQgKyAxKS5qb2luKHRoaXMuX19pbmRlbnRfc3RyaW5nKTtcbiAgfVxuICBpZiAoY29sdW1uKSB7XG4gICAgcmVzdWx0ICs9IG5ldyBBcnJheShjb2x1bW4gKyAxKS5qb2luKCcgJyk7XG4gIH1cblxuICB0aGlzLl9fY2FjaGUucHVzaChyZXN1bHQpO1xufTtcblxuZnVuY3Rpb24gT3V0cHV0KG9wdGlvbnMsIGJhc2VJbmRlbnRTdHJpbmcpIHtcbiAgdGhpcy5fX2luZGVudF9jYWNoZSA9IG5ldyBJbmRlbnRTdHJpbmdDYWNoZShvcHRpb25zLCBiYXNlSW5kZW50U3RyaW5nKTtcbiAgdGhpcy5yYXcgPSBmYWxzZTtcbiAgdGhpcy5fZW5kX3dpdGhfbmV3bGluZSA9IG9wdGlvbnMuZW5kX3dpdGhfbmV3bGluZTtcbiAgdGhpcy5pbmRlbnRfc2l6ZSA9IG9wdGlvbnMuaW5kZW50X3NpemU7XG4gIHRoaXMud3JhcF9saW5lX2xlbmd0aCA9IG9wdGlvbnMud3JhcF9saW5lX2xlbmd0aDtcbiAgdGhpcy5pbmRlbnRfZW1wdHlfbGluZXMgPSBvcHRpb25zLmluZGVudF9lbXB0eV9saW5lcztcbiAgdGhpcy5fX2xpbmVzID0gW107XG4gIHRoaXMucHJldmlvdXNfbGluZSA9IG51bGw7XG4gIHRoaXMuY3VycmVudF9saW5lID0gbnVsbDtcbiAgdGhpcy5uZXh0X2xpbmUgPSBuZXcgT3V0cHV0TGluZSh0aGlzKTtcbiAgdGhpcy5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcbiAgdGhpcy5ub25fYnJlYWtpbmdfc3BhY2UgPSBmYWxzZTtcbiAgdGhpcy5wcmV2aW91c190b2tlbl93cmFwcGVkID0gZmFsc2U7XG4gIC8vIGluaXRpYWxpemVcbiAgdGhpcy5fX2FkZF9vdXRwdXRsaW5lKCk7XG59XG5cbk91dHB1dC5wcm90b3R5cGUuX19hZGRfb3V0cHV0bGluZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnByZXZpb3VzX2xpbmUgPSB0aGlzLmN1cnJlbnRfbGluZTtcbiAgdGhpcy5jdXJyZW50X2xpbmUgPSB0aGlzLm5leHRfbGluZS5jbG9uZV9lbXB0eSgpO1xuICB0aGlzLl9fbGluZXMucHVzaCh0aGlzLmN1cnJlbnRfbGluZSk7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmdldF9saW5lX251bWJlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fX2xpbmVzLmxlbmd0aDtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuZ2V0X2luZGVudF9zdHJpbmcgPSBmdW5jdGlvbihpbmRlbnQsIGNvbHVtbikge1xuICByZXR1cm4gdGhpcy5fX2luZGVudF9jYWNoZS5nZXRfaW5kZW50X3N0cmluZyhpbmRlbnQsIGNvbHVtbik7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmdldF9pbmRlbnRfc2l6ZSA9IGZ1bmN0aW9uKGluZGVudCwgY29sdW1uKSB7XG4gIHJldHVybiB0aGlzLl9faW5kZW50X2NhY2hlLmdldF9pbmRlbnRfc2l6ZShpbmRlbnQsIGNvbHVtbik7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmlzX2VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhdGhpcy5wcmV2aW91c19saW5lICYmIHRoaXMuY3VycmVudF9saW5lLmlzX2VtcHR5KCk7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmFkZF9uZXdfbGluZSA9IGZ1bmN0aW9uKGZvcmNlX25ld2xpbmUpIHtcbiAgLy8gbmV2ZXIgbmV3bGluZSBhdCB0aGUgc3RhcnQgb2YgZmlsZVxuICAvLyBvdGhlcndpc2UsIG5ld2xpbmUgb25seSBpZiB3ZSBkaWRuJ3QganVzdCBhZGQgb25lIG9yIHdlJ3JlIGZvcmNlZFxuICBpZiAodGhpcy5pc19lbXB0eSgpIHx8XG4gICAgKCFmb3JjZV9uZXdsaW5lICYmIHRoaXMuanVzdF9hZGRlZF9uZXdsaW5lKCkpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gaWYgcmF3IG91dHB1dCBpcyBlbmFibGVkLCBkb24ndCBwcmludCBhZGRpdGlvbmFsIG5ld2xpbmVzLFxuICAvLyBidXQgc3RpbGwgcmV0dXJuIFRydWUgYXMgdGhvdWdoIHlvdSBoYWRcbiAgaWYgKCF0aGlzLnJhdykge1xuICAgIHRoaXMuX19hZGRfb3V0cHV0bGluZSgpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5nZXRfY29kZSA9IGZ1bmN0aW9uKGVvbCkge1xuICB0aGlzLnRyaW0odHJ1ZSk7XG5cbiAgLy8gaGFuZGxlIHNvbWUgZWRnZSBjYXNlcyB3aGVyZSB0aGUgbGFzdCB0b2tlbnNcbiAgLy8gaGFzIHRleHQgdGhhdCBlbmRzIHdpdGggbmV3bGluZShzKVxuICB2YXIgbGFzdF9pdGVtID0gdGhpcy5jdXJyZW50X2xpbmUucG9wKCk7XG4gIGlmIChsYXN0X2l0ZW0pIHtcbiAgICBpZiAobGFzdF9pdGVtW2xhc3RfaXRlbS5sZW5ndGggLSAxXSA9PT0gJ1xcbicpIHtcbiAgICAgIGxhc3RfaXRlbSA9IGxhc3RfaXRlbS5yZXBsYWNlKC9cXG4rJC9nLCAnJyk7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudF9saW5lLnB1c2gobGFzdF9pdGVtKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9lbmRfd2l0aF9uZXdsaW5lKSB7XG4gICAgdGhpcy5fX2FkZF9vdXRwdXRsaW5lKCk7XG4gIH1cblxuICB2YXIgc3dlZXRfY29kZSA9IHRoaXMuX19saW5lcy5qb2luKCdcXG4nKTtcblxuICBpZiAoZW9sICE9PSAnXFxuJykge1xuICAgIHN3ZWV0X2NvZGUgPSBzd2VldF9jb2RlLnJlcGxhY2UoL1tcXG5dL2csIGVvbCk7XG4gIH1cbiAgcmV0dXJuIHN3ZWV0X2NvZGU7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLnNldF93cmFwX3BvaW50ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY3VycmVudF9saW5lLl9zZXRfd3JhcF9wb2ludCgpO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5zZXRfaW5kZW50ID0gZnVuY3Rpb24oaW5kZW50LCBhbGlnbm1lbnQpIHtcbiAgaW5kZW50ID0gaW5kZW50IHx8IDA7XG4gIGFsaWdubWVudCA9IGFsaWdubWVudCB8fCAwO1xuXG4gIC8vIE5leHQgbGluZSBzdG9yZXMgYWxpZ25tZW50IHZhbHVlc1xuICB0aGlzLm5leHRfbGluZS5zZXRfaW5kZW50KGluZGVudCwgYWxpZ25tZW50KTtcblxuICAvLyBOZXZlciBpbmRlbnQgeW91ciBmaXJzdCBvdXRwdXQgaW5kZW50IGF0IHRoZSBzdGFydCBvZiB0aGUgZmlsZVxuICBpZiAodGhpcy5fX2xpbmVzLmxlbmd0aCA+IDEpIHtcbiAgICB0aGlzLmN1cnJlbnRfbGluZS5zZXRfaW5kZW50KGluZGVudCwgYWxpZ25tZW50KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMuY3VycmVudF9saW5lLnNldF9pbmRlbnQoKTtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5hZGRfcmF3X3Rva2VuID0gZnVuY3Rpb24odG9rZW4pIHtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCB0b2tlbi5uZXdsaW5lczsgeCsrKSB7XG4gICAgdGhpcy5fX2FkZF9vdXRwdXRsaW5lKCk7XG4gIH1cbiAgdGhpcy5jdXJyZW50X2xpbmUuc2V0X2luZGVudCgtMSk7XG4gIHRoaXMuY3VycmVudF9saW5lLnB1c2godG9rZW4ud2hpdGVzcGFjZV9iZWZvcmUpO1xuICB0aGlzLmN1cnJlbnRfbGluZS5wdXNoKHRva2VuLnRleHQpO1xuICB0aGlzLnNwYWNlX2JlZm9yZV90b2tlbiA9IGZhbHNlO1xuICB0aGlzLm5vbl9icmVha2luZ19zcGFjZSA9IGZhbHNlO1xuICB0aGlzLnByZXZpb3VzX3Rva2VuX3dyYXBwZWQgPSBmYWxzZTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuYWRkX3Rva2VuID0gZnVuY3Rpb24ocHJpbnRhYmxlX3Rva2VuKSB7XG4gIHRoaXMuX19hZGRfc3BhY2VfYmVmb3JlX3Rva2VuKCk7XG4gIHRoaXMuY3VycmVudF9saW5lLnB1c2gocHJpbnRhYmxlX3Rva2VuKTtcbiAgdGhpcy5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcbiAgdGhpcy5ub25fYnJlYWtpbmdfc3BhY2UgPSBmYWxzZTtcbiAgdGhpcy5wcmV2aW91c190b2tlbl93cmFwcGVkID0gdGhpcy5jdXJyZW50X2xpbmUuX2FsbG93X3dyYXAoKTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuX19hZGRfc3BhY2VfYmVmb3JlX3Rva2VuID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnNwYWNlX2JlZm9yZV90b2tlbiAmJiAhdGhpcy5qdXN0X2FkZGVkX25ld2xpbmUoKSkge1xuICAgIGlmICghdGhpcy5ub25fYnJlYWtpbmdfc3BhY2UpIHtcbiAgICAgIHRoaXMuc2V0X3dyYXBfcG9pbnQoKTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50X2xpbmUucHVzaCgnICcpO1xuICB9XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLnJlbW92ZV9pbmRlbnQgPSBmdW5jdGlvbihpbmRleCkge1xuICB2YXIgb3V0cHV0X2xlbmd0aCA9IHRoaXMuX19saW5lcy5sZW5ndGg7XG4gIHdoaWxlIChpbmRleCA8IG91dHB1dF9sZW5ndGgpIHtcbiAgICB0aGlzLl9fbGluZXNbaW5kZXhdLl9yZW1vdmVfaW5kZW50KCk7XG4gICAgaW5kZXgrKztcbiAgfVxuICB0aGlzLmN1cnJlbnRfbGluZS5fcmVtb3ZlX3dyYXBfaW5kZW50KCk7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLnRyaW0gPSBmdW5jdGlvbihlYXRfbmV3bGluZXMpIHtcbiAgZWF0X25ld2xpbmVzID0gKGVhdF9uZXdsaW5lcyA9PT0gdW5kZWZpbmVkKSA/IGZhbHNlIDogZWF0X25ld2xpbmVzO1xuXG4gIHRoaXMuY3VycmVudF9saW5lLnRyaW0oKTtcblxuICB3aGlsZSAoZWF0X25ld2xpbmVzICYmIHRoaXMuX19saW5lcy5sZW5ndGggPiAxICYmXG4gICAgdGhpcy5jdXJyZW50X2xpbmUuaXNfZW1wdHkoKSkge1xuICAgIHRoaXMuX19saW5lcy5wb3AoKTtcbiAgICB0aGlzLmN1cnJlbnRfbGluZSA9IHRoaXMuX19saW5lc1t0aGlzLl9fbGluZXMubGVuZ3RoIC0gMV07XG4gICAgdGhpcy5jdXJyZW50X2xpbmUudHJpbSgpO1xuICB9XG5cbiAgdGhpcy5wcmV2aW91c19saW5lID0gdGhpcy5fX2xpbmVzLmxlbmd0aCA+IDEgP1xuICAgIHRoaXMuX19saW5lc1t0aGlzLl9fbGluZXMubGVuZ3RoIC0gMl0gOiBudWxsO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5qdXN0X2FkZGVkX25ld2xpbmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuY3VycmVudF9saW5lLmlzX2VtcHR5KCk7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmp1c3RfYWRkZWRfYmxhbmtsaW5lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmlzX2VtcHR5KCkgfHxcbiAgICAodGhpcy5jdXJyZW50X2xpbmUuaXNfZW1wdHkoKSAmJiB0aGlzLnByZXZpb3VzX2xpbmUuaXNfZW1wdHkoKSk7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmVuc3VyZV9lbXB0eV9saW5lX2Fib3ZlID0gZnVuY3Rpb24oc3RhcnRzX3dpdGgsIGVuZHNfd2l0aCkge1xuICB2YXIgaW5kZXggPSB0aGlzLl9fbGluZXMubGVuZ3RoIC0gMjtcbiAgd2hpbGUgKGluZGV4ID49IDApIHtcbiAgICB2YXIgcG90ZW50aWFsRW1wdHlMaW5lID0gdGhpcy5fX2xpbmVzW2luZGV4XTtcbiAgICBpZiAocG90ZW50aWFsRW1wdHlMaW5lLmlzX2VtcHR5KCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSBpZiAocG90ZW50aWFsRW1wdHlMaW5lLml0ZW0oMCkuaW5kZXhPZihzdGFydHNfd2l0aCkgIT09IDAgJiZcbiAgICAgIHBvdGVudGlhbEVtcHR5TGluZS5pdGVtKC0xKSAhPT0gZW5kc193aXRoKSB7XG4gICAgICB0aGlzLl9fbGluZXMuc3BsaWNlKGluZGV4ICsgMSwgMCwgbmV3IE91dHB1dExpbmUodGhpcykpO1xuICAgICAgdGhpcy5wcmV2aW91c19saW5lID0gdGhpcy5fX2xpbmVzW3RoaXMuX19saW5lcy5sZW5ndGggLSAyXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpbmRleC0tO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5PdXRwdXQgPSBPdXRwdXQ7XG4iLCIvKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBQYXR0ZXJuKGlucHV0X3NjYW5uZXIsIHBhcmVudCkge1xuICB0aGlzLl9pbnB1dCA9IGlucHV0X3NjYW5uZXI7XG4gIHRoaXMuX3N0YXJ0aW5nX3BhdHRlcm4gPSBudWxsO1xuICB0aGlzLl9tYXRjaF9wYXR0ZXJuID0gbnVsbDtcbiAgdGhpcy5fdW50aWxfcGF0dGVybiA9IG51bGw7XG4gIHRoaXMuX3VudGlsX2FmdGVyID0gZmFsc2U7XG5cbiAgaWYgKHBhcmVudCkge1xuICAgIHRoaXMuX3N0YXJ0aW5nX3BhdHRlcm4gPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKHBhcmVudC5fc3RhcnRpbmdfcGF0dGVybiwgdHJ1ZSk7XG4gICAgdGhpcy5fbWF0Y2hfcGF0dGVybiA9IHRoaXMuX2lucHV0LmdldF9yZWdleHAocGFyZW50Ll9tYXRjaF9wYXR0ZXJuLCB0cnVlKTtcbiAgICB0aGlzLl91bnRpbF9wYXR0ZXJuID0gdGhpcy5faW5wdXQuZ2V0X3JlZ2V4cChwYXJlbnQuX3VudGlsX3BhdHRlcm4pO1xuICAgIHRoaXMuX3VudGlsX2FmdGVyID0gcGFyZW50Ll91bnRpbF9hZnRlcjtcbiAgfVxufVxuXG5QYXR0ZXJuLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9pbnB1dC5yZWFkKHRoaXMuX3N0YXJ0aW5nX3BhdHRlcm4pO1xuICBpZiAoIXRoaXMuX3N0YXJ0aW5nX3BhdHRlcm4gfHwgcmVzdWx0KSB7XG4gICAgcmVzdWx0ICs9IHRoaXMuX2lucHV0LnJlYWQodGhpcy5fbWF0Y2hfcGF0dGVybiwgdGhpcy5fdW50aWxfcGF0dGVybiwgdGhpcy5fdW50aWxfYWZ0ZXIpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5QYXR0ZXJuLnByb3RvdHlwZS5yZWFkX21hdGNoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9pbnB1dC5tYXRjaCh0aGlzLl9tYXRjaF9wYXR0ZXJuKTtcbn07XG5cblBhdHRlcm4ucHJvdG90eXBlLnVudGlsX2FmdGVyID0gZnVuY3Rpb24ocGF0dGVybikge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fY3JlYXRlKCk7XG4gIHJlc3VsdC5fdW50aWxfYWZ0ZXIgPSB0cnVlO1xuICByZXN1bHQuX3VudGlsX3BhdHRlcm4gPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKHBhdHRlcm4pO1xuICByZXN1bHQuX3VwZGF0ZSgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuUGF0dGVybi5wcm90b3R5cGUudW50aWwgPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9jcmVhdGUoKTtcbiAgcmVzdWx0Ll91bnRpbF9hZnRlciA9IGZhbHNlO1xuICByZXN1bHQuX3VudGlsX3BhdHRlcm4gPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKHBhdHRlcm4pO1xuICByZXN1bHQuX3VwZGF0ZSgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuUGF0dGVybi5wcm90b3R5cGUuc3RhcnRpbmdfd2l0aCA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuX2NyZWF0ZSgpO1xuICByZXN1bHQuX3N0YXJ0aW5nX3BhdHRlcm4gPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKHBhdHRlcm4sIHRydWUpO1xuICByZXN1bHQuX3VwZGF0ZSgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuUGF0dGVybi5wcm90b3R5cGUubWF0Y2hpbmcgPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9jcmVhdGUoKTtcbiAgcmVzdWx0Ll9tYXRjaF9wYXR0ZXJuID0gdGhpcy5faW5wdXQuZ2V0X3JlZ2V4cChwYXR0ZXJuLCB0cnVlKTtcbiAgcmVzdWx0Ll91cGRhdGUoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblBhdHRlcm4ucHJvdG90eXBlLl9jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBQYXR0ZXJuKHRoaXMuX2lucHV0LCB0aGlzKTtcbn07XG5cblBhdHRlcm4ucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbigpIHt9O1xuXG5tb2R1bGUuZXhwb3J0cy5QYXR0ZXJuID0gUGF0dGVybjtcbiIsIi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBQYXR0ZXJuID0gcmVxdWlyZSgnLi9wYXR0ZXJuJykuUGF0dGVybjtcblxuXG52YXIgdGVtcGxhdGVfbmFtZXMgPSB7XG4gIGRqYW5nbzogZmFsc2UsXG4gIGVyYjogZmFsc2UsXG4gIGhhbmRsZWJhcnM6IGZhbHNlLFxuICBwaHA6IGZhbHNlXG59O1xuXG4vLyBUaGlzIGxldHMgdGVtcGxhdGVzIGFwcGVhciBhbnl3aGVyZSB3ZSB3b3VsZCBkbyBhIHJlYWRVbnRpbFxuLy8gVGhlIGNvc3QgaXMgaGlnaGVyIGJ1dCBpdCBpcyBwYXkgdG8gcGxheS5cbmZ1bmN0aW9uIFRlbXBsYXRhYmxlUGF0dGVybihpbnB1dF9zY2FubmVyLCBwYXJlbnQpIHtcbiAgUGF0dGVybi5jYWxsKHRoaXMsIGlucHV0X3NjYW5uZXIsIHBhcmVudCk7XG4gIHRoaXMuX190ZW1wbGF0ZV9wYXR0ZXJuID0gbnVsbDtcbiAgdGhpcy5fZGlzYWJsZWQgPSBPYmplY3QuYXNzaWduKHt9LCB0ZW1wbGF0ZV9uYW1lcyk7XG4gIHRoaXMuX2V4Y2x1ZGVkID0gT2JqZWN0LmFzc2lnbih7fSwgdGVtcGxhdGVfbmFtZXMpO1xuXG4gIGlmIChwYXJlbnQpIHtcbiAgICB0aGlzLl9fdGVtcGxhdGVfcGF0dGVybiA9IHRoaXMuX2lucHV0LmdldF9yZWdleHAocGFyZW50Ll9fdGVtcGxhdGVfcGF0dGVybik7XG4gICAgdGhpcy5fZXhjbHVkZWQgPSBPYmplY3QuYXNzaWduKHRoaXMuX2V4Y2x1ZGVkLCBwYXJlbnQuX2V4Y2x1ZGVkKTtcbiAgICB0aGlzLl9kaXNhYmxlZCA9IE9iamVjdC5hc3NpZ24odGhpcy5fZGlzYWJsZWQsIHBhcmVudC5fZGlzYWJsZWQpO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gbmV3IFBhdHRlcm4oaW5wdXRfc2Nhbm5lcik7XG4gIHRoaXMuX19wYXR0ZXJucyA9IHtcbiAgICBoYW5kbGViYXJzX2NvbW1lbnQ6IHBhdHRlcm4uc3RhcnRpbmdfd2l0aCgve3shLS0vKS51bnRpbF9hZnRlcigvLS19fS8pLFxuICAgIGhhbmRsZWJhcnNfdW5lc2NhcGVkOiBwYXR0ZXJuLnN0YXJ0aW5nX3dpdGgoL3t7ey8pLnVudGlsX2FmdGVyKC99fX0vKSxcbiAgICBoYW5kbGViYXJzOiBwYXR0ZXJuLnN0YXJ0aW5nX3dpdGgoL3t7LykudW50aWxfYWZ0ZXIoL319LyksXG4gICAgcGhwOiBwYXR0ZXJuLnN0YXJ0aW5nX3dpdGgoLzxcXD8oPzpbPV18cGhwKS8pLnVudGlsX2FmdGVyKC9cXD8+LyksXG4gICAgZXJiOiBwYXR0ZXJuLnN0YXJ0aW5nX3dpdGgoLzwlW14lXS8pLnVudGlsX2FmdGVyKC9bXiVdJT4vKSxcbiAgICAvLyBkamFuZ28gY29mbGljdHMgd2l0aCBoYW5kbGViYXJzIGEgYml0LlxuICAgIGRqYW5nbzogcGF0dGVybi5zdGFydGluZ193aXRoKC97JS8pLnVudGlsX2FmdGVyKC8lfS8pLFxuICAgIGRqYW5nb192YWx1ZTogcGF0dGVybi5zdGFydGluZ193aXRoKC97ey8pLnVudGlsX2FmdGVyKC99fS8pLFxuICAgIGRqYW5nb19jb21tZW50OiBwYXR0ZXJuLnN0YXJ0aW5nX3dpdGgoL3sjLykudW50aWxfYWZ0ZXIoLyN9LylcbiAgfTtcbn1cblRlbXBsYXRhYmxlUGF0dGVybi5wcm90b3R5cGUgPSBuZXcgUGF0dGVybigpO1xuXG5UZW1wbGF0YWJsZVBhdHRlcm4ucHJvdG90eXBlLl9jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUZW1wbGF0YWJsZVBhdHRlcm4odGhpcy5faW5wdXQsIHRoaXMpO1xufTtcblxuVGVtcGxhdGFibGVQYXR0ZXJuLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX19zZXRfdGVtcGxhdGVkX3BhdHRlcm4oKTtcbn07XG5cblRlbXBsYXRhYmxlUGF0dGVybi5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uKGxhbmd1YWdlKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9jcmVhdGUoKTtcbiAgcmVzdWx0Ll9kaXNhYmxlZFtsYW5ndWFnZV0gPSB0cnVlO1xuICByZXN1bHQuX3VwZGF0ZSgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVGVtcGxhdGFibGVQYXR0ZXJuLnByb3RvdHlwZS5yZWFkX29wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9jcmVhdGUoKTtcbiAgZm9yICh2YXIgbGFuZ3VhZ2UgaW4gdGVtcGxhdGVfbmFtZXMpIHtcbiAgICByZXN1bHQuX2Rpc2FibGVkW2xhbmd1YWdlXSA9IG9wdGlvbnMudGVtcGxhdGluZy5pbmRleE9mKGxhbmd1YWdlKSA9PT0gLTE7XG4gIH1cbiAgcmVzdWx0Ll91cGRhdGUoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblRlbXBsYXRhYmxlUGF0dGVybi5wcm90b3R5cGUuZXhjbHVkZSA9IGZ1bmN0aW9uKGxhbmd1YWdlKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9jcmVhdGUoKTtcbiAgcmVzdWx0Ll9leGNsdWRlZFtsYW5ndWFnZV0gPSB0cnVlO1xuICByZXN1bHQuX3VwZGF0ZSgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVGVtcGxhdGFibGVQYXR0ZXJuLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgaWYgKHRoaXMuX21hdGNoX3BhdHRlcm4pIHtcbiAgICByZXN1bHQgPSB0aGlzLl9pbnB1dC5yZWFkKHRoaXMuX3N0YXJ0aW5nX3BhdHRlcm4pO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IHRoaXMuX2lucHV0LnJlYWQodGhpcy5fc3RhcnRpbmdfcGF0dGVybiwgdGhpcy5fX3RlbXBsYXRlX3BhdHRlcm4pO1xuICB9XG4gIHZhciBuZXh0ID0gdGhpcy5fcmVhZF90ZW1wbGF0ZSgpO1xuICB3aGlsZSAobmV4dCkge1xuICAgIGlmICh0aGlzLl9tYXRjaF9wYXR0ZXJuKSB7XG4gICAgICBuZXh0ICs9IHRoaXMuX2lucHV0LnJlYWQodGhpcy5fbWF0Y2hfcGF0dGVybik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHQgKz0gdGhpcy5faW5wdXQucmVhZFVudGlsKHRoaXMuX190ZW1wbGF0ZV9wYXR0ZXJuKTtcbiAgICB9XG4gICAgcmVzdWx0ICs9IG5leHQ7XG4gICAgbmV4dCA9IHRoaXMuX3JlYWRfdGVtcGxhdGUoKTtcbiAgfVxuXG4gIGlmICh0aGlzLl91bnRpbF9hZnRlcikge1xuICAgIHJlc3VsdCArPSB0aGlzLl9pbnB1dC5yZWFkVW50aWxBZnRlcih0aGlzLl91bnRpbF9wYXR0ZXJuKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVGVtcGxhdGFibGVQYXR0ZXJuLnByb3RvdHlwZS5fX3NldF90ZW1wbGF0ZWRfcGF0dGVybiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXRlbXMgPSBbXTtcblxuICBpZiAoIXRoaXMuX2Rpc2FibGVkLnBocCkge1xuICAgIGl0ZW1zLnB1c2godGhpcy5fX3BhdHRlcm5zLnBocC5fc3RhcnRpbmdfcGF0dGVybi5zb3VyY2UpO1xuICB9XG4gIGlmICghdGhpcy5fZGlzYWJsZWQuaGFuZGxlYmFycykge1xuICAgIGl0ZW1zLnB1c2godGhpcy5fX3BhdHRlcm5zLmhhbmRsZWJhcnMuX3N0YXJ0aW5nX3BhdHRlcm4uc291cmNlKTtcbiAgfVxuICBpZiAoIXRoaXMuX2Rpc2FibGVkLmVyYikge1xuICAgIGl0ZW1zLnB1c2godGhpcy5fX3BhdHRlcm5zLmVyYi5fc3RhcnRpbmdfcGF0dGVybi5zb3VyY2UpO1xuICB9XG4gIGlmICghdGhpcy5fZGlzYWJsZWQuZGphbmdvKSB7XG4gICAgaXRlbXMucHVzaCh0aGlzLl9fcGF0dGVybnMuZGphbmdvLl9zdGFydGluZ19wYXR0ZXJuLnNvdXJjZSk7XG4gICAgaXRlbXMucHVzaCh0aGlzLl9fcGF0dGVybnMuZGphbmdvX3ZhbHVlLl9zdGFydGluZ19wYXR0ZXJuLnNvdXJjZSk7XG4gICAgaXRlbXMucHVzaCh0aGlzLl9fcGF0dGVybnMuZGphbmdvX2NvbW1lbnQuX3N0YXJ0aW5nX3BhdHRlcm4uc291cmNlKTtcbiAgfVxuXG4gIGlmICh0aGlzLl91bnRpbF9wYXR0ZXJuKSB7XG4gICAgaXRlbXMucHVzaCh0aGlzLl91bnRpbF9wYXR0ZXJuLnNvdXJjZSk7XG4gIH1cbiAgdGhpcy5fX3RlbXBsYXRlX3BhdHRlcm4gPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKCcoPzonICsgaXRlbXMuam9pbignfCcpICsgJyknKTtcbn07XG5cblRlbXBsYXRhYmxlUGF0dGVybi5wcm90b3R5cGUuX3JlYWRfdGVtcGxhdGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc3VsdGluZ19zdHJpbmcgPSAnJztcbiAgdmFyIGMgPSB0aGlzLl9pbnB1dC5wZWVrKCk7XG4gIGlmIChjID09PSAnPCcpIHtcbiAgICB2YXIgcGVlazEgPSB0aGlzLl9pbnB1dC5wZWVrKDEpO1xuICAgIC8vaWYgd2UncmUgaW4gYSBjb21tZW50LCBkbyBzb21ldGhpbmcgc3BlY2lhbFxuICAgIC8vIFdlIHRyZWF0IGFsbCBjb21tZW50cyBhcyBsaXRlcmFscywgZXZlbiBtb3JlIHRoYW4gcHJlZm9ybWF0dGVkIHRhZ3NcbiAgICAvLyB3ZSBqdXN0IGxvb2sgZm9yIHRoZSBhcHByb3ByaWF0ZSBjbG9zZSB0YWdcbiAgICBpZiAoIXRoaXMuX2Rpc2FibGVkLnBocCAmJiAhdGhpcy5fZXhjbHVkZWQucGhwICYmIHBlZWsxID09PSAnPycpIHtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSByZXN1bHRpbmdfc3RyaW5nIHx8XG4gICAgICAgIHRoaXMuX19wYXR0ZXJucy5waHAucmVhZCgpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2Rpc2FibGVkLmVyYiAmJiAhdGhpcy5fZXhjbHVkZWQuZXJiICYmIHBlZWsxID09PSAnJScpIHtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSByZXN1bHRpbmdfc3RyaW5nIHx8XG4gICAgICAgIHRoaXMuX19wYXR0ZXJucy5lcmIucmVhZCgpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChjID09PSAneycpIHtcbiAgICBpZiAoIXRoaXMuX2Rpc2FibGVkLmhhbmRsZWJhcnMgJiYgIXRoaXMuX2V4Y2x1ZGVkLmhhbmRsZWJhcnMpIHtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSByZXN1bHRpbmdfc3RyaW5nIHx8XG4gICAgICAgIHRoaXMuX19wYXR0ZXJucy5oYW5kbGViYXJzX2NvbW1lbnQucmVhZCgpO1xuICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHJlc3VsdGluZ19zdHJpbmcgfHxcbiAgICAgICAgdGhpcy5fX3BhdHRlcm5zLmhhbmRsZWJhcnNfdW5lc2NhcGVkLnJlYWQoKTtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSByZXN1bHRpbmdfc3RyaW5nIHx8XG4gICAgICAgIHRoaXMuX19wYXR0ZXJucy5oYW5kbGViYXJzLnJlYWQoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9kaXNhYmxlZC5kamFuZ28pIHtcbiAgICAgIC8vIGRqYW5nbyBjb2ZsaWN0cyB3aXRoIGhhbmRsZWJhcnMgYSBiaXQuXG4gICAgICBpZiAoIXRoaXMuX2V4Y2x1ZGVkLmRqYW5nbyAmJiAhdGhpcy5fZXhjbHVkZWQuaGFuZGxlYmFycykge1xuICAgICAgICByZXN1bHRpbmdfc3RyaW5nID0gcmVzdWx0aW5nX3N0cmluZyB8fFxuICAgICAgICAgIHRoaXMuX19wYXR0ZXJucy5kamFuZ29fdmFsdWUucmVhZCgpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9leGNsdWRlZC5kamFuZ28pIHtcbiAgICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHJlc3VsdGluZ19zdHJpbmcgfHxcbiAgICAgICAgICB0aGlzLl9fcGF0dGVybnMuZGphbmdvX2NvbW1lbnQucmVhZCgpO1xuICAgICAgICByZXN1bHRpbmdfc3RyaW5nID0gcmVzdWx0aW5nX3N0cmluZyB8fFxuICAgICAgICAgIHRoaXMuX19wYXR0ZXJucy5kamFuZ28ucmVhZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0aW5nX3N0cmluZztcbn07XG5cblxubW9kdWxlLmV4cG9ydHMuVGVtcGxhdGFibGVQYXR0ZXJuID0gVGVtcGxhdGFibGVQYXR0ZXJuO1xuIiwiLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gVG9rZW4odHlwZSwgdGV4dCwgbmV3bGluZXMsIHdoaXRlc3BhY2VfYmVmb3JlKSB7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIHRoaXMudGV4dCA9IHRleHQ7XG5cbiAgLy8gY29tbWVudHNfYmVmb3JlIGFyZVxuICAvLyBjb21tZW50cyB0aGF0IGhhdmUgYSBuZXcgbGluZSBiZWZvcmUgdGhlbVxuICAvLyBhbmQgbWF5IG9yIG1heSBub3QgaGF2ZSBhIG5ld2xpbmUgYWZ0ZXJcbiAgLy8gdGhpcyBpcyBhIHNldCBvZiBjb21tZW50cyBiZWZvcmVcbiAgdGhpcy5jb21tZW50c19iZWZvcmUgPSBudWxsOyAvKiBpbmxpbmUgY29tbWVudCovXG5cblxuICAvLyB0aGlzLmNvbW1lbnRzX2FmdGVyID0gIG5ldyBUb2tlblN0cmVhbSgpOyAvLyBubyBuZXcgbGluZSBiZWZvcmUgYW5kIG5ld2xpbmUgYWZ0ZXJcbiAgdGhpcy5uZXdsaW5lcyA9IG5ld2xpbmVzIHx8IDA7XG4gIHRoaXMud2hpdGVzcGFjZV9iZWZvcmUgPSB3aGl0ZXNwYWNlX2JlZm9yZSB8fCAnJztcbiAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLnByZXZpb3VzID0gbnVsbDtcbiAgdGhpcy5vcGVuZWQgPSBudWxsO1xuICB0aGlzLmNsb3NlZCA9IG51bGw7XG4gIHRoaXMuZGlyZWN0aXZlcyA9IG51bGw7XG59XG5cblxubW9kdWxlLmV4cG9ydHMuVG9rZW4gPSBUb2tlbjtcbiIsIi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBJbnB1dFNjYW5uZXIgPSByZXF1aXJlKCcuLi9jb3JlL2lucHV0c2Nhbm5lcicpLklucHV0U2Nhbm5lcjtcbnZhciBUb2tlbiA9IHJlcXVpcmUoJy4uL2NvcmUvdG9rZW4nKS5Ub2tlbjtcbnZhciBUb2tlblN0cmVhbSA9IHJlcXVpcmUoJy4uL2NvcmUvdG9rZW5zdHJlYW0nKS5Ub2tlblN0cmVhbTtcbnZhciBXaGl0ZXNwYWNlUGF0dGVybiA9IHJlcXVpcmUoJy4vd2hpdGVzcGFjZXBhdHRlcm4nKS5XaGl0ZXNwYWNlUGF0dGVybjtcblxudmFyIFRPS0VOID0ge1xuICBTVEFSVDogJ1RLX1NUQVJUJyxcbiAgUkFXOiAnVEtfUkFXJyxcbiAgRU9GOiAnVEtfRU9GJ1xufTtcblxudmFyIFRva2VuaXplciA9IGZ1bmN0aW9uKGlucHV0X3N0cmluZywgb3B0aW9ucykge1xuICB0aGlzLl9pbnB1dCA9IG5ldyBJbnB1dFNjYW5uZXIoaW5wdXRfc3RyaW5nKTtcbiAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMuX190b2tlbnMgPSBudWxsO1xuXG4gIHRoaXMuX3BhdHRlcm5zID0ge307XG4gIHRoaXMuX3BhdHRlcm5zLndoaXRlc3BhY2UgPSBuZXcgV2hpdGVzcGFjZVBhdHRlcm4odGhpcy5faW5wdXQpO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS50b2tlbml6ZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9pbnB1dC5yZXN0YXJ0KCk7XG4gIHRoaXMuX190b2tlbnMgPSBuZXcgVG9rZW5TdHJlYW0oKTtcblxuICB0aGlzLl9yZXNldCgpO1xuXG4gIHZhciBjdXJyZW50O1xuICB2YXIgcHJldmlvdXMgPSBuZXcgVG9rZW4oVE9LRU4uU1RBUlQsICcnKTtcbiAgdmFyIG9wZW5fdG9rZW4gPSBudWxsO1xuICB2YXIgb3Blbl9zdGFjayA9IFtdO1xuICB2YXIgY29tbWVudHMgPSBuZXcgVG9rZW5TdHJlYW0oKTtcblxuICB3aGlsZSAocHJldmlvdXMudHlwZSAhPT0gVE9LRU4uRU9GKSB7XG4gICAgY3VycmVudCA9IHRoaXMuX2dldF9uZXh0X3Rva2VuKHByZXZpb3VzLCBvcGVuX3Rva2VuKTtcbiAgICB3aGlsZSAodGhpcy5faXNfY29tbWVudChjdXJyZW50KSkge1xuICAgICAgY29tbWVudHMuYWRkKGN1cnJlbnQpO1xuICAgICAgY3VycmVudCA9IHRoaXMuX2dldF9uZXh0X3Rva2VuKHByZXZpb3VzLCBvcGVuX3Rva2VuKTtcbiAgICB9XG5cbiAgICBpZiAoIWNvbW1lbnRzLmlzRW1wdHkoKSkge1xuICAgICAgY3VycmVudC5jb21tZW50c19iZWZvcmUgPSBjb21tZW50cztcbiAgICAgIGNvbW1lbnRzID0gbmV3IFRva2VuU3RyZWFtKCk7XG4gICAgfVxuXG4gICAgY3VycmVudC5wYXJlbnQgPSBvcGVuX3Rva2VuO1xuXG4gICAgaWYgKHRoaXMuX2lzX29wZW5pbmcoY3VycmVudCkpIHtcbiAgICAgIG9wZW5fc3RhY2sucHVzaChvcGVuX3Rva2VuKTtcbiAgICAgIG9wZW5fdG9rZW4gPSBjdXJyZW50O1xuICAgIH0gZWxzZSBpZiAob3Blbl90b2tlbiAmJiB0aGlzLl9pc19jbG9zaW5nKGN1cnJlbnQsIG9wZW5fdG9rZW4pKSB7XG4gICAgICBjdXJyZW50Lm9wZW5lZCA9IG9wZW5fdG9rZW47XG4gICAgICBvcGVuX3Rva2VuLmNsb3NlZCA9IGN1cnJlbnQ7XG4gICAgICBvcGVuX3Rva2VuID0gb3Blbl9zdGFjay5wb3AoKTtcbiAgICAgIGN1cnJlbnQucGFyZW50ID0gb3Blbl90b2tlbjtcbiAgICB9XG5cbiAgICBjdXJyZW50LnByZXZpb3VzID0gcHJldmlvdXM7XG4gICAgcHJldmlvdXMubmV4dCA9IGN1cnJlbnQ7XG5cbiAgICB0aGlzLl9fdG9rZW5zLmFkZChjdXJyZW50KTtcbiAgICBwcmV2aW91cyA9IGN1cnJlbnQ7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fX3Rva2Vucztcbn07XG5cblxuVG9rZW5pemVyLnByb3RvdHlwZS5faXNfZmlyc3RfdG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX190b2tlbnMuaXNFbXB0eSgpO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fcmVzZXQgPSBmdW5jdGlvbigpIHt9O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9nZXRfbmV4dF90b2tlbiA9IGZ1bmN0aW9uKHByZXZpb3VzX3Rva2VuLCBvcGVuX3Rva2VuKSB7IC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbiAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcbiAgdmFyIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9pbnB1dC5yZWFkKC8uKy9nKTtcbiAgaWYgKHJlc3VsdGluZ19zdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLlJBVywgcmVzdWx0aW5nX3N0cmluZyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5FT0YsICcnKTtcbiAgfVxufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5faXNfY29tbWVudCA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4pIHsgLy8ganNoaW50IHVudXNlZDpmYWxzZVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9pc19vcGVuaW5nID0gZnVuY3Rpb24oY3VycmVudF90b2tlbikgeyAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG4gIHJldHVybiBmYWxzZTtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2lzX2Nsb3NpbmcgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuLCBvcGVuX3Rva2VuKSB7IC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fY3JlYXRlX3Rva2VuID0gZnVuY3Rpb24odHlwZSwgdGV4dCkge1xuICB2YXIgdG9rZW4gPSBuZXcgVG9rZW4odHlwZSwgdGV4dCxcbiAgICB0aGlzLl9wYXR0ZXJucy53aGl0ZXNwYWNlLm5ld2xpbmVfY291bnQsXG4gICAgdGhpcy5fcGF0dGVybnMud2hpdGVzcGFjZS53aGl0ZXNwYWNlX2JlZm9yZV90b2tlbik7XG4gIHJldHVybiB0b2tlbjtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3JlYWRXaGl0ZXNwYWNlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9wYXR0ZXJucy53aGl0ZXNwYWNlLnJlYWQoKTtcbn07XG5cblxuXG5tb2R1bGUuZXhwb3J0cy5Ub2tlbml6ZXIgPSBUb2tlbml6ZXI7XG5tb2R1bGUuZXhwb3J0cy5UT0tFTiA9IFRPS0VOO1xuIiwiLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gVG9rZW5TdHJlYW0ocGFyZW50X3Rva2VuKSB7XG4gIC8vIHByaXZhdGVcbiAgdGhpcy5fX3Rva2VucyA9IFtdO1xuICB0aGlzLl9fdG9rZW5zX2xlbmd0aCA9IHRoaXMuX190b2tlbnMubGVuZ3RoO1xuICB0aGlzLl9fcG9zaXRpb24gPSAwO1xuICB0aGlzLl9fcGFyZW50X3Rva2VuID0gcGFyZW50X3Rva2VuO1xufVxuXG5Ub2tlblN0cmVhbS5wcm90b3R5cGUucmVzdGFydCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9fcG9zaXRpb24gPSAwO1xufTtcblxuVG9rZW5TdHJlYW0ucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX190b2tlbnNfbGVuZ3RoID09PSAwO1xufTtcblxuVG9rZW5TdHJlYW0ucHJvdG90eXBlLmhhc05leHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX19wb3NpdGlvbiA8IHRoaXMuX190b2tlbnNfbGVuZ3RoO1xufTtcblxuVG9rZW5TdHJlYW0ucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHZhbCA9IG51bGw7XG4gIGlmICh0aGlzLmhhc05leHQoKSkge1xuICAgIHZhbCA9IHRoaXMuX190b2tlbnNbdGhpcy5fX3Bvc2l0aW9uXTtcbiAgICB0aGlzLl9fcG9zaXRpb24gKz0gMTtcbiAgfVxuICByZXR1cm4gdmFsO1xufTtcblxuVG9rZW5TdHJlYW0ucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbihpbmRleCkge1xuICB2YXIgdmFsID0gbnVsbDtcbiAgaW5kZXggPSBpbmRleCB8fCAwO1xuICBpbmRleCArPSB0aGlzLl9fcG9zaXRpb247XG4gIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5fX3Rva2Vuc19sZW5ndGgpIHtcbiAgICB2YWwgPSB0aGlzLl9fdG9rZW5zW2luZGV4XTtcbiAgfVxuICByZXR1cm4gdmFsO1xufTtcblxuVG9rZW5TdHJlYW0ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKHRva2VuKSB7XG4gIGlmICh0aGlzLl9fcGFyZW50X3Rva2VuKSB7XG4gICAgdG9rZW4ucGFyZW50ID0gdGhpcy5fX3BhcmVudF90b2tlbjtcbiAgfVxuICB0aGlzLl9fdG9rZW5zLnB1c2godG9rZW4pO1xuICB0aGlzLl9fdG9rZW5zX2xlbmd0aCArPSAxO1xufTtcblxubW9kdWxlLmV4cG9ydHMuVG9rZW5TdHJlYW0gPSBUb2tlblN0cmVhbTtcbiIsIi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBQYXR0ZXJuID0gcmVxdWlyZSgnLi4vY29yZS9wYXR0ZXJuJykuUGF0dGVybjtcblxuZnVuY3Rpb24gV2hpdGVzcGFjZVBhdHRlcm4oaW5wdXRfc2Nhbm5lciwgcGFyZW50KSB7XG4gIFBhdHRlcm4uY2FsbCh0aGlzLCBpbnB1dF9zY2FubmVyLCBwYXJlbnQpO1xuICBpZiAocGFyZW50KSB7XG4gICAgdGhpcy5fbGluZV9yZWdleHAgPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKHBhcmVudC5fbGluZV9yZWdleHApO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX19zZXRfd2hpdGVzcGFjZV9wYXR0ZXJucygnJywgJycpO1xuICB9XG5cbiAgdGhpcy5uZXdsaW5lX2NvdW50ID0gMDtcbiAgdGhpcy53aGl0ZXNwYWNlX2JlZm9yZV90b2tlbiA9ICcnO1xufVxuV2hpdGVzcGFjZVBhdHRlcm4ucHJvdG90eXBlID0gbmV3IFBhdHRlcm4oKTtcblxuV2hpdGVzcGFjZVBhdHRlcm4ucHJvdG90eXBlLl9fc2V0X3doaXRlc3BhY2VfcGF0dGVybnMgPSBmdW5jdGlvbih3aGl0ZXNwYWNlX2NoYXJzLCBuZXdsaW5lX2NoYXJzKSB7XG4gIHdoaXRlc3BhY2VfY2hhcnMgKz0gJ1xcXFx0ICc7XG4gIG5ld2xpbmVfY2hhcnMgKz0gJ1xcXFxuXFxcXHInO1xuXG4gIHRoaXMuX21hdGNoX3BhdHRlcm4gPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKFxuICAgICdbJyArIHdoaXRlc3BhY2VfY2hhcnMgKyBuZXdsaW5lX2NoYXJzICsgJ10rJywgdHJ1ZSk7XG4gIHRoaXMuX25ld2xpbmVfcmVnZXhwID0gdGhpcy5faW5wdXQuZ2V0X3JlZ2V4cChcbiAgICAnXFxcXHJcXFxcbnxbJyArIG5ld2xpbmVfY2hhcnMgKyAnXScpO1xufTtcblxuV2hpdGVzcGFjZVBhdHRlcm4ucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5uZXdsaW5lX2NvdW50ID0gMDtcbiAgdGhpcy53aGl0ZXNwYWNlX2JlZm9yZV90b2tlbiA9ICcnO1xuXG4gIHZhciByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5faW5wdXQucmVhZCh0aGlzLl9tYXRjaF9wYXR0ZXJuKTtcbiAgaWYgKHJlc3VsdGluZ19zdHJpbmcgPT09ICcgJykge1xuICAgIHRoaXMud2hpdGVzcGFjZV9iZWZvcmVfdG9rZW4gPSAnICc7XG4gIH0gZWxzZSBpZiAocmVzdWx0aW5nX3N0cmluZykge1xuICAgIHZhciBtYXRjaGVzID0gdGhpcy5fX3NwbGl0KHRoaXMuX25ld2xpbmVfcmVnZXhwLCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgICB0aGlzLm5ld2xpbmVfY291bnQgPSBtYXRjaGVzLmxlbmd0aCAtIDE7XG4gICAgdGhpcy53aGl0ZXNwYWNlX2JlZm9yZV90b2tlbiA9IG1hdGNoZXNbdGhpcy5uZXdsaW5lX2NvdW50XTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHRpbmdfc3RyaW5nO1xufTtcblxuV2hpdGVzcGFjZVBhdHRlcm4ucHJvdG90eXBlLm1hdGNoaW5nID0gZnVuY3Rpb24od2hpdGVzcGFjZV9jaGFycywgbmV3bGluZV9jaGFycykge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fY3JlYXRlKCk7XG4gIHJlc3VsdC5fX3NldF93aGl0ZXNwYWNlX3BhdHRlcm5zKHdoaXRlc3BhY2VfY2hhcnMsIG5ld2xpbmVfY2hhcnMpO1xuICByZXN1bHQuX3VwZGF0ZSgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuV2hpdGVzcGFjZVBhdHRlcm4ucHJvdG90eXBlLl9jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBXaGl0ZXNwYWNlUGF0dGVybih0aGlzLl9pbnB1dCwgdGhpcyk7XG59O1xuXG5XaGl0ZXNwYWNlUGF0dGVybi5wcm90b3R5cGUuX19zcGxpdCA9IGZ1bmN0aW9uKHJlZ2V4cCwgaW5wdXRfc3RyaW5nKSB7XG4gIHJlZ2V4cC5sYXN0SW5kZXggPSAwO1xuICB2YXIgc3RhcnRfaW5kZXggPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBuZXh0X21hdGNoID0gcmVnZXhwLmV4ZWMoaW5wdXRfc3RyaW5nKTtcbiAgd2hpbGUgKG5leHRfbWF0Y2gpIHtcbiAgICByZXN1bHQucHVzaChpbnB1dF9zdHJpbmcuc3Vic3RyaW5nKHN0YXJ0X2luZGV4LCBuZXh0X21hdGNoLmluZGV4KSk7XG4gICAgc3RhcnRfaW5kZXggPSBuZXh0X21hdGNoLmluZGV4ICsgbmV4dF9tYXRjaFswXS5sZW5ndGg7XG4gICAgbmV4dF9tYXRjaCA9IHJlZ2V4cC5leGVjKGlucHV0X3N0cmluZyk7XG4gIH1cblxuICBpZiAoc3RhcnRfaW5kZXggPCBpbnB1dF9zdHJpbmcubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnB1c2goaW5wdXRfc3RyaW5nLnN1YnN0cmluZyhzdGFydF9pbmRleCwgaW5wdXRfc3RyaW5nLmxlbmd0aCkpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxubW9kdWxlLmV4cG9ydHMuV2hpdGVzcGFjZVBhdHRlcm4gPSBXaGl0ZXNwYWNlUGF0dGVybjtcbiIsIi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBPcHRpb25zID0gcmVxdWlyZSgnLi9vcHRpb25zJykuT3B0aW9ucztcbnZhciBPdXRwdXQgPSByZXF1aXJlKCcuLi9jb3JlL291dHB1dCcpLk91dHB1dDtcbnZhciBJbnB1dFNjYW5uZXIgPSByZXF1aXJlKCcuLi9jb3JlL2lucHV0c2Nhbm5lcicpLklucHV0U2Nhbm5lcjtcbnZhciBEaXJlY3RpdmVzID0gcmVxdWlyZSgnLi4vY29yZS9kaXJlY3RpdmVzJykuRGlyZWN0aXZlcztcblxudmFyIGRpcmVjdGl2ZXNfY29yZSA9IG5ldyBEaXJlY3RpdmVzKC9cXC9cXCovLCAvXFwqXFwvLyk7XG5cbnZhciBsaW5lQnJlYWsgPSAvXFxyXFxufFtcXHJcXG5dLztcbnZhciBhbGxMaW5lQnJlYWtzID0gL1xcclxcbnxbXFxyXFxuXS9nO1xuXG4vLyB0b2tlbml6ZXJcbnZhciB3aGl0ZXNwYWNlQ2hhciA9IC9cXHMvO1xudmFyIHdoaXRlc3BhY2VQYXR0ZXJuID0gLyg/Olxcc3xcXG4pKy9nO1xudmFyIGJsb2NrX2NvbW1lbnRfcGF0dGVybiA9IC9cXC9cXCooPzpbXFxzXFxTXSo/KSgoPzpcXCpcXC8pfCQpL2c7XG52YXIgY29tbWVudF9wYXR0ZXJuID0gL1xcL1xcLyg/OlteXFxuXFxyXFx1MjAyOFxcdTIwMjldKikvZztcblxuZnVuY3Rpb24gQmVhdXRpZmllcihzb3VyY2VfdGV4dCwgb3B0aW9ucykge1xuICB0aGlzLl9zb3VyY2VfdGV4dCA9IHNvdXJjZV90ZXh0IHx8ICcnO1xuICAvLyBBbGxvdyB0aGUgc2V0dGluZyBvZiBsYW5ndWFnZS9maWxlLXR5cGUgc3BlY2lmaWMgb3B0aW9uc1xuICAvLyB3aXRoIGluaGVyaXRhbmNlIG9mIG92ZXJhbGwgc2V0dGluZ3NcbiAgdGhpcy5fb3B0aW9ucyA9IG5ldyBPcHRpb25zKG9wdGlvbnMpO1xuICB0aGlzLl9jaCA9IG51bGw7XG4gIHRoaXMuX2lucHV0ID0gbnVsbDtcblxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQXQtcnVsZVxuICB0aGlzLk5FU1RFRF9BVF9SVUxFID0ge1xuICAgIFwiQHBhZ2VcIjogdHJ1ZSxcbiAgICBcIkBmb250LWZhY2VcIjogdHJ1ZSxcbiAgICBcIkBrZXlmcmFtZXNcIjogdHJ1ZSxcbiAgICAvLyBhbHNvIGluIENPTkRJVElPTkFMX0dST1VQX1JVTEUgYmVsb3dcbiAgICBcIkBtZWRpYVwiOiB0cnVlLFxuICAgIFwiQHN1cHBvcnRzXCI6IHRydWUsXG4gICAgXCJAZG9jdW1lbnRcIjogdHJ1ZVxuICB9O1xuICB0aGlzLkNPTkRJVElPTkFMX0dST1VQX1JVTEUgPSB7XG4gICAgXCJAbWVkaWFcIjogdHJ1ZSxcbiAgICBcIkBzdXBwb3J0c1wiOiB0cnVlLFxuICAgIFwiQGRvY3VtZW50XCI6IHRydWVcbiAgfTtcblxufVxuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5lYXRTdHJpbmcgPSBmdW5jdGlvbihlbmRDaGFycykge1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIHRoaXMuX2NoID0gdGhpcy5faW5wdXQubmV4dCgpO1xuICB3aGlsZSAodGhpcy5fY2gpIHtcbiAgICByZXN1bHQgKz0gdGhpcy5fY2g7XG4gICAgaWYgKHRoaXMuX2NoID09PSBcIlxcXFxcIikge1xuICAgICAgcmVzdWx0ICs9IHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICB9IGVsc2UgaWYgKGVuZENoYXJzLmluZGV4T2YodGhpcy5fY2gpICE9PSAtMSB8fCB0aGlzLl9jaCA9PT0gXCJcXG5cIikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuX2NoID0gdGhpcy5faW5wdXQubmV4dCgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBTa2lwcyBhbnkgd2hpdGUgc3BhY2UgaW4gdGhlIHNvdXJjZSB0ZXh0IGZyb20gdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4vLyBXaGVuIGFsbG93QXRMZWFzdE9uZU5ld0xpbmUgaXMgdHJ1ZSwgd2lsbCBvdXRwdXQgbmV3IGxpbmVzIGZvciBlYWNoXG4vLyBuZXdsaW5lIGNoYXJhY3RlciBmb3VuZDsgaWYgdGhlIHVzZXIgaGFzIHByZXNlcnZlX25ld2xpbmVzIG9mZiwgb25seVxuLy8gdGhlIGZpcnN0IG5ld2xpbmUgd2lsbCBiZSBvdXRwdXRcbkJlYXV0aWZpZXIucHJvdG90eXBlLmVhdFdoaXRlc3BhY2UgPSBmdW5jdGlvbihhbGxvd0F0TGVhc3RPbmVOZXdMaW5lKSB7XG4gIHZhciByZXN1bHQgPSB3aGl0ZXNwYWNlQ2hhci50ZXN0KHRoaXMuX2lucHV0LnBlZWsoKSk7XG4gIHZhciBpc0ZpcnN0TmV3TGluZSA9IHRydWU7XG5cbiAgd2hpbGUgKHdoaXRlc3BhY2VDaGFyLnRlc3QodGhpcy5faW5wdXQucGVlaygpKSkge1xuICAgIHRoaXMuX2NoID0gdGhpcy5faW5wdXQubmV4dCgpO1xuICAgIGlmIChhbGxvd0F0TGVhc3RPbmVOZXdMaW5lICYmIHRoaXMuX2NoID09PSAnXFxuJykge1xuICAgICAgaWYgKHRoaXMuX29wdGlvbnMucHJlc2VydmVfbmV3bGluZXMgfHwgaXNGaXJzdE5ld0xpbmUpIHtcbiAgICAgICAgaXNGaXJzdE5ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fb3V0cHV0LmFkZF9uZXdfbGluZSh0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIE5lc3RlZCBwc2V1ZG8tY2xhc3MgaWYgd2UgYXJlIGluc2lkZVJ1bGVcbi8vIGFuZCB0aGUgbmV4dCBzcGVjaWFsIGNoYXJhY3RlciBmb3VuZCBvcGVuc1xuLy8gYSBuZXcgYmxvY2tcbkJlYXV0aWZpZXIucHJvdG90eXBlLmZvdW5kTmVzdGVkUHNldWRvQ2xhc3MgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG9wZW5QYXJlbiA9IDA7XG4gIHZhciBpID0gMTtcbiAgdmFyIGNoID0gdGhpcy5faW5wdXQucGVlayhpKTtcbiAgd2hpbGUgKGNoKSB7XG4gICAgaWYgKGNoID09PSBcIntcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gJygnKSB7XG4gICAgICAvLyBwc2V1ZG9jbGFzc2VzIGNhbiBjb250YWluICgpXG4gICAgICBvcGVuUGFyZW4gKz0gMTtcbiAgICB9IGVsc2UgaWYgKGNoID09PSAnKScpIHtcbiAgICAgIGlmIChvcGVuUGFyZW4gPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgb3BlblBhcmVuIC09IDE7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gXCI7XCIgfHwgY2ggPT09IFwifVwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGkrKztcbiAgICBjaCA9IHRoaXMuX2lucHV0LnBlZWsoaSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUucHJpbnRfc3RyaW5nID0gZnVuY3Rpb24ob3V0cHV0X3N0cmluZykge1xuICB0aGlzLl9vdXRwdXQuc2V0X2luZGVudCh0aGlzLl9pbmRlbnRMZXZlbCk7XG4gIHRoaXMuX291dHB1dC5ub25fYnJlYWtpbmdfc3BhY2UgPSB0cnVlO1xuICB0aGlzLl9vdXRwdXQuYWRkX3Rva2VuKG91dHB1dF9zdHJpbmcpO1xufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUucHJlc2VydmVTaW5nbGVTcGFjZSA9IGZ1bmN0aW9uKGlzQWZ0ZXJTcGFjZSkge1xuICBpZiAoaXNBZnRlclNwYWNlKSB7XG4gICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gIH1cbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmluZGVudCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9pbmRlbnRMZXZlbCsrO1xufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUub3V0ZGVudCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5faW5kZW50TGV2ZWwgPiAwKSB7XG4gICAgdGhpcy5faW5kZW50TGV2ZWwtLTtcbiAgfVxufTtcblxuLypfX19fX19fX19fX19fX19fX19fX18tLS0tLS0tLS0tLS0tLS0tLS0tLV9fX19fX19fX19fX19fX19fX19fXyovXG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmJlYXV0aWZ5ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9vcHRpb25zLmRpc2FibGVkKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NvdXJjZV90ZXh0O1xuICB9XG5cbiAgdmFyIHNvdXJjZV90ZXh0ID0gdGhpcy5fc291cmNlX3RleHQ7XG4gIHZhciBlb2wgPSB0aGlzLl9vcHRpb25zLmVvbDtcbiAgaWYgKGVvbCA9PT0gJ2F1dG8nKSB7XG4gICAgZW9sID0gJ1xcbic7XG4gICAgaWYgKHNvdXJjZV90ZXh0ICYmIGxpbmVCcmVhay50ZXN0KHNvdXJjZV90ZXh0IHx8ICcnKSkge1xuICAgICAgZW9sID0gc291cmNlX3RleHQubWF0Y2gobGluZUJyZWFrKVswXTtcbiAgICB9XG4gIH1cblxuXG4gIC8vIEhBQ0s6IG5ld2xpbmUgcGFyc2luZyBpbmNvbnNpc3RlbnQuIFRoaXMgYnJ1dGUgZm9yY2Ugbm9ybWFsaXplcyB0aGUgdGhpcy5faW5wdXQuXG4gIHNvdXJjZV90ZXh0ID0gc291cmNlX3RleHQucmVwbGFjZShhbGxMaW5lQnJlYWtzLCAnXFxuJyk7XG5cbiAgLy8gcmVzZXRcbiAgdmFyIGJhc2VJbmRlbnRTdHJpbmcgPSBzb3VyY2VfdGV4dC5tYXRjaCgvXltcXHQgXSovKVswXTtcblxuICB0aGlzLl9vdXRwdXQgPSBuZXcgT3V0cHV0KHRoaXMuX29wdGlvbnMsIGJhc2VJbmRlbnRTdHJpbmcpO1xuICB0aGlzLl9pbnB1dCA9IG5ldyBJbnB1dFNjYW5uZXIoc291cmNlX3RleHQpO1xuICB0aGlzLl9pbmRlbnRMZXZlbCA9IDA7XG4gIHRoaXMuX25lc3RlZExldmVsID0gMDtcblxuICB0aGlzLl9jaCA9IG51bGw7XG4gIHZhciBwYXJlbkxldmVsID0gMDtcblxuICB2YXIgaW5zaWRlUnVsZSA9IGZhbHNlO1xuICAvLyBUaGlzIGlzIHRoZSB2YWx1ZSBzaWRlIG9mIGEgcHJvcGVydHkgdmFsdWUgcGFpciAoYmx1ZSBpbiB0aGUgZm9sbG93aW5nIGV4KVxuICAvLyBsYWJlbCB7IGNvbnRlbnQ6IGJsdWUgfVxuICB2YXIgaW5zaWRlUHJvcGVydHlWYWx1ZSA9IGZhbHNlO1xuICB2YXIgZW50ZXJpbmdDb25kaXRpb25hbEdyb3VwID0gZmFsc2U7XG4gIHZhciBpbnNpZGVBdEV4dGVuZCA9IGZhbHNlO1xuICB2YXIgaW5zaWRlQXRJbXBvcnQgPSBmYWxzZTtcbiAgdmFyIHRvcENoYXJhY3RlciA9IHRoaXMuX2NoO1xuICB2YXIgd2hpdGVzcGFjZTtcbiAgdmFyIGlzQWZ0ZXJTcGFjZTtcbiAgdmFyIHByZXZpb3VzX2NoO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgd2hpdGVzcGFjZSA9IHRoaXMuX2lucHV0LnJlYWQod2hpdGVzcGFjZVBhdHRlcm4pO1xuICAgIGlzQWZ0ZXJTcGFjZSA9IHdoaXRlc3BhY2UgIT09ICcnO1xuICAgIHByZXZpb3VzX2NoID0gdG9wQ2hhcmFjdGVyO1xuICAgIHRoaXMuX2NoID0gdGhpcy5faW5wdXQubmV4dCgpO1xuICAgIGlmICh0aGlzLl9jaCA9PT0gJ1xcXFwnICYmIHRoaXMuX2lucHV0Lmhhc05leHQoKSkge1xuICAgICAgdGhpcy5fY2ggKz0gdGhpcy5faW5wdXQubmV4dCgpO1xuICAgIH1cbiAgICB0b3BDaGFyYWN0ZXIgPSB0aGlzLl9jaDtcblxuICAgIGlmICghdGhpcy5fY2gpIHtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fY2ggPT09ICcvJyAmJiB0aGlzLl9pbnB1dC5wZWVrKCkgPT09ICcqJykge1xuICAgICAgLy8gLyogY3NzIGNvbW1lbnQgKi9cbiAgICAgIC8vIEFsd2F5cyBzdGFydCBibG9jayBjb21tZW50cyBvbiBhIG5ldyBsaW5lLlxuICAgICAgLy8gVGhpcyBoYW5kbGVzIHNjZW5hcmlvcyB3aGVyZSBhIGJsb2NrIGNvbW1lbnQgaW1tZWRpYXRlbHlcbiAgICAgIC8vIGZvbGxvd3MgYSBwcm9wZXJ0eSBkZWZpbml0aW9uIG9uIHRoZSBzYW1lIGxpbmUgb3Igd2hlcmVcbiAgICAgIC8vIG1pbmlmaWVkIGNvZGUgaXMgYmVpbmcgYmVhdXRpZmllZC5cbiAgICAgIHRoaXMuX291dHB1dC5hZGRfbmV3X2xpbmUoKTtcbiAgICAgIHRoaXMuX2lucHV0LmJhY2soKTtcblxuICAgICAgdmFyIGNvbW1lbnQgPSB0aGlzLl9pbnB1dC5yZWFkKGJsb2NrX2NvbW1lbnRfcGF0dGVybik7XG5cbiAgICAgIC8vIEhhbmRsZSBpZ25vcmUgZGlyZWN0aXZlXG4gICAgICB2YXIgZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXNfY29yZS5nZXRfZGlyZWN0aXZlcyhjb21tZW50KTtcbiAgICAgIGlmIChkaXJlY3RpdmVzICYmIGRpcmVjdGl2ZXMuaWdub3JlID09PSAnc3RhcnQnKSB7XG4gICAgICAgIGNvbW1lbnQgKz0gZGlyZWN0aXZlc19jb3JlLnJlYWRJZ25vcmVkKHRoaXMuX2lucHV0KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcmludF9zdHJpbmcoY29tbWVudCk7XG5cbiAgICAgIC8vIEVuc3VyZXMgYW55IG5ldyBsaW5lcyBmb2xsb3dpbmcgdGhlIGNvbW1lbnQgYXJlIHByZXNlcnZlZFxuICAgICAgdGhpcy5lYXRXaGl0ZXNwYWNlKHRydWUpO1xuXG4gICAgICAvLyBCbG9jayBjb21tZW50cyBhcmUgZm9sbG93ZWQgYnkgYSBuZXcgbGluZSBzbyB0aGV5IGRvbid0XG4gICAgICAvLyBzaGFyZSBhIGxpbmUgd2l0aCBvdGhlciBwcm9wZXJ0aWVzXG4gICAgICB0aGlzLl9vdXRwdXQuYWRkX25ld19saW5lKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9jaCA9PT0gJy8nICYmIHRoaXMuX2lucHV0LnBlZWsoKSA9PT0gJy8nKSB7XG4gICAgICAvLyAvLyBzaW5nbGUgbGluZSBjb21tZW50XG4gICAgICAvLyBQcmVzZXJ2ZXMgdGhlIHNwYWNlIGJlZm9yZSBhIGNvbW1lbnRcbiAgICAgIC8vIG9uIHRoZSBzYW1lIGxpbmUgYXMgYSBydWxlXG4gICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2lucHV0LmJhY2soKTtcbiAgICAgIHRoaXMucHJpbnRfc3RyaW5nKHRoaXMuX2lucHV0LnJlYWQoY29tbWVudF9wYXR0ZXJuKSk7XG5cbiAgICAgIC8vIEVuc3VyZXMgYW55IG5ldyBsaW5lcyBmb2xsb3dpbmcgdGhlIGNvbW1lbnQgYXJlIHByZXNlcnZlZFxuICAgICAgdGhpcy5lYXRXaGl0ZXNwYWNlKHRydWUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fY2ggPT09ICdAJykge1xuICAgICAgdGhpcy5wcmVzZXJ2ZVNpbmdsZVNwYWNlKGlzQWZ0ZXJTcGFjZSk7XG5cbiAgICAgIC8vIGRlYWwgd2l0aCBsZXNzIHByb3BlcnkgbWl4aW5zIEB7Li4ufVxuICAgICAgaWYgKHRoaXMuX2lucHV0LnBlZWsoKSA9PT0gJ3snKSB7XG4gICAgICAgIHRoaXMucHJpbnRfc3RyaW5nKHRoaXMuX2NoICsgdGhpcy5lYXRTdHJpbmcoJ30nKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByaW50X3N0cmluZyh0aGlzLl9jaCk7XG5cbiAgICAgICAgLy8gc3RyaXAgdHJhaWxpbmcgc3BhY2UsIGlmIHByZXNlbnQsIGZvciBoYXNoIHByb3BlcnR5IGNoZWNrc1xuICAgICAgICB2YXIgdmFyaWFibGVPclJ1bGUgPSB0aGlzLl9pbnB1dC5wZWVrVW50aWxBZnRlcigvWzogLDt7fSgpW1xcXVxcLz0nXCJdL2cpO1xuXG4gICAgICAgIGlmICh2YXJpYWJsZU9yUnVsZS5tYXRjaCgvWyA6XSQvKSkge1xuICAgICAgICAgIC8vIHdlIGhhdmUgYSB2YXJpYWJsZSBvciBwc2V1ZG8tY2xhc3MsIGFkZCBpdCBhbmQgaW5zZXJ0IG9uZSBzcGFjZSBiZWZvcmUgY29udGludWluZ1xuICAgICAgICAgIHZhcmlhYmxlT3JSdWxlID0gdGhpcy5lYXRTdHJpbmcoXCI6IFwiKS5yZXBsYWNlKC9cXHMkLywgJycpO1xuICAgICAgICAgIHRoaXMucHJpbnRfc3RyaW5nKHZhcmlhYmxlT3JSdWxlKTtcbiAgICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhcmlhYmxlT3JSdWxlID0gdmFyaWFibGVPclJ1bGUucmVwbGFjZSgvXFxzJC8sICcnKTtcblxuICAgICAgICBpZiAodmFyaWFibGVPclJ1bGUgPT09ICdleHRlbmQnKSB7XG4gICAgICAgICAgaW5zaWRlQXRFeHRlbmQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHZhcmlhYmxlT3JSdWxlID09PSAnaW1wb3J0Jykge1xuICAgICAgICAgIGluc2lkZUF0SW1wb3J0ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1pZ2h0IGJlIGEgbmVzdGluZyBhdC1ydWxlXG4gICAgICAgIGlmICh2YXJpYWJsZU9yUnVsZSBpbiB0aGlzLk5FU1RFRF9BVF9SVUxFKSB7XG4gICAgICAgICAgdGhpcy5fbmVzdGVkTGV2ZWwgKz0gMTtcbiAgICAgICAgICBpZiAodmFyaWFibGVPclJ1bGUgaW4gdGhpcy5DT05ESVRJT05BTF9HUk9VUF9SVUxFKSB7XG4gICAgICAgICAgICBlbnRlcmluZ0NvbmRpdGlvbmFsR3JvdXAgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBtaWdodCBiZSBsZXNzIHZhcmlhYmxlXG4gICAgICAgIH0gZWxzZSBpZiAoIWluc2lkZVJ1bGUgJiYgcGFyZW5MZXZlbCA9PT0gMCAmJiB2YXJpYWJsZU9yUnVsZS5pbmRleE9mKCc6JykgIT09IC0xKSB7XG4gICAgICAgICAgaW5zaWRlUHJvcGVydHlWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgdGhpcy5pbmRlbnQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fY2ggPT09ICcjJyAmJiB0aGlzLl9pbnB1dC5wZWVrKCkgPT09ICd7Jykge1xuICAgICAgdGhpcy5wcmVzZXJ2ZVNpbmdsZVNwYWNlKGlzQWZ0ZXJTcGFjZSk7XG4gICAgICB0aGlzLnByaW50X3N0cmluZyh0aGlzLl9jaCArIHRoaXMuZWF0U3RyaW5nKCd9JykpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fY2ggPT09ICd7Jykge1xuICAgICAgaWYgKGluc2lkZVByb3BlcnR5VmFsdWUpIHtcbiAgICAgICAgaW5zaWRlUHJvcGVydHlWYWx1ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm91dGRlbnQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5kZW50KCk7XG4gICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgIHRoaXMucHJpbnRfc3RyaW5nKHRoaXMuX2NoKTtcblxuICAgICAgLy8gd2hlbiBlbnRlcmluZyBjb25kaXRpb25hbCBncm91cHMsIG9ubHkgcnVsZXNldHMgYXJlIGFsbG93ZWRcbiAgICAgIGlmIChlbnRlcmluZ0NvbmRpdGlvbmFsR3JvdXApIHtcbiAgICAgICAgZW50ZXJpbmdDb25kaXRpb25hbEdyb3VwID0gZmFsc2U7XG4gICAgICAgIGluc2lkZVJ1bGUgPSAodGhpcy5faW5kZW50TGV2ZWwgPiB0aGlzLl9uZXN0ZWRMZXZlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBvdGhlcndpc2UsIGRlY2xhcmF0aW9ucyBhcmUgYWxzbyBhbGxvd2VkXG4gICAgICAgIGluc2lkZVJ1bGUgPSAodGhpcy5faW5kZW50TGV2ZWwgPj0gdGhpcy5fbmVzdGVkTGV2ZWwpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX29wdGlvbnMubmV3bGluZV9iZXR3ZWVuX3J1bGVzICYmIGluc2lkZVJ1bGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX291dHB1dC5wcmV2aW91c19saW5lICYmIHRoaXMuX291dHB1dC5wcmV2aW91c19saW5lLml0ZW0oLTEpICE9PSAneycpIHtcbiAgICAgICAgICB0aGlzLl9vdXRwdXQuZW5zdXJlX2VtcHR5X2xpbmVfYWJvdmUoJy8nLCAnLCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmVhdFdoaXRlc3BhY2UodHJ1ZSk7XG4gICAgICB0aGlzLl9vdXRwdXQuYWRkX25ld19saW5lKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9jaCA9PT0gJ30nKSB7XG4gICAgICB0aGlzLm91dGRlbnQoKTtcbiAgICAgIHRoaXMuX291dHB1dC5hZGRfbmV3X2xpbmUoKTtcbiAgICAgIGlmIChwcmV2aW91c19jaCA9PT0gJ3snKSB7XG4gICAgICAgIHRoaXMuX291dHB1dC50cmltKHRydWUpO1xuICAgICAgfVxuICAgICAgaW5zaWRlQXRJbXBvcnQgPSBmYWxzZTtcbiAgICAgIGluc2lkZUF0RXh0ZW5kID0gZmFsc2U7XG4gICAgICBpZiAoaW5zaWRlUHJvcGVydHlWYWx1ZSkge1xuICAgICAgICB0aGlzLm91dGRlbnQoKTtcbiAgICAgICAgaW5zaWRlUHJvcGVydHlWYWx1ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5fY2gpO1xuICAgICAgaW5zaWRlUnVsZSA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMuX25lc3RlZExldmVsKSB7XG4gICAgICAgIHRoaXMuX25lc3RlZExldmVsLS07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWF0V2hpdGVzcGFjZSh0cnVlKTtcbiAgICAgIHRoaXMuX291dHB1dC5hZGRfbmV3X2xpbmUoKTtcblxuICAgICAgaWYgKHRoaXMuX29wdGlvbnMubmV3bGluZV9iZXR3ZWVuX3J1bGVzICYmICF0aGlzLl9vdXRwdXQuanVzdF9hZGRlZF9ibGFua2xpbmUoKSkge1xuICAgICAgICBpZiAodGhpcy5faW5wdXQucGVlaygpICE9PSAnfScpIHtcbiAgICAgICAgICB0aGlzLl9vdXRwdXQuYWRkX25ld19saW5lKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9jaCA9PT0gXCI6XCIpIHtcbiAgICAgIGlmICgoaW5zaWRlUnVsZSB8fCBlbnRlcmluZ0NvbmRpdGlvbmFsR3JvdXApICYmICEodGhpcy5faW5wdXQubG9va0JhY2soXCImXCIpIHx8IHRoaXMuZm91bmROZXN0ZWRQc2V1ZG9DbGFzcygpKSAmJiAhdGhpcy5faW5wdXQubG9va0JhY2soXCIoXCIpICYmICFpbnNpZGVBdEV4dGVuZCAmJiBwYXJlbkxldmVsID09PSAwKSB7XG4gICAgICAgIC8vICdwcm9wZXJ0eTogdmFsdWUnIGRlbGltaXRlclxuICAgICAgICAvLyB3aGljaCBjb3VsZCBiZSBpbiBhIGNvbmRpdGlvbmFsIGdyb3VwIHF1ZXJ5XG4gICAgICAgIHRoaXMucHJpbnRfc3RyaW5nKCc6Jyk7XG4gICAgICAgIGlmICghaW5zaWRlUHJvcGVydHlWYWx1ZSkge1xuICAgICAgICAgIGluc2lkZVByb3BlcnR5VmFsdWUgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgIHRoaXMuZWF0V2hpdGVzcGFjZSh0cnVlKTtcbiAgICAgICAgICB0aGlzLmluZGVudCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzYXNzL2xlc3MgcGFyZW50IHJlZmVyZW5jZSBkb24ndCB1c2UgYSBzcGFjZVxuICAgICAgICAvLyBzYXNzIG5lc3RlZCBwc2V1ZG8tY2xhc3MgZG9uJ3QgdXNlIGEgc3BhY2VcblxuICAgICAgICAvLyBwcmVzZXJ2ZSBzcGFjZSBiZWZvcmUgcHNldWRvY2xhc3Nlcy9wc2V1ZG9lbGVtZW50cywgYXMgaXQgbWVhbnMgXCJpbiBhbnkgY2hpbGRcIlxuICAgICAgICBpZiAodGhpcy5faW5wdXQubG9va0JhY2soXCIgXCIpKSB7XG4gICAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2lucHV0LnBlZWsoKSA9PT0gXCI6XCIpIHtcbiAgICAgICAgICAvLyBwc2V1ZG8tZWxlbWVudFxuICAgICAgICAgIHRoaXMuX2NoID0gdGhpcy5faW5wdXQubmV4dCgpO1xuICAgICAgICAgIHRoaXMucHJpbnRfc3RyaW5nKFwiOjpcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gcHNldWRvLWNsYXNzXG4gICAgICAgICAgdGhpcy5wcmludF9zdHJpbmcoJzonKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fY2ggPT09ICdcIicgfHwgdGhpcy5fY2ggPT09ICdcXCcnKSB7XG4gICAgICB0aGlzLnByZXNlcnZlU2luZ2xlU3BhY2UoaXNBZnRlclNwYWNlKTtcbiAgICAgIHRoaXMucHJpbnRfc3RyaW5nKHRoaXMuX2NoICsgdGhpcy5lYXRTdHJpbmcodGhpcy5fY2gpKTtcbiAgICAgIHRoaXMuZWF0V2hpdGVzcGFjZSh0cnVlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2NoID09PSAnOycpIHtcbiAgICAgIGlmIChwYXJlbkxldmVsID09PSAwKSB7XG4gICAgICAgIGlmIChpbnNpZGVQcm9wZXJ0eVZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5vdXRkZW50KCk7XG4gICAgICAgICAgaW5zaWRlUHJvcGVydHlWYWx1ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGluc2lkZUF0RXh0ZW5kID0gZmFsc2U7XG4gICAgICAgIGluc2lkZUF0SW1wb3J0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHJpbnRfc3RyaW5nKHRoaXMuX2NoKTtcbiAgICAgICAgdGhpcy5lYXRXaGl0ZXNwYWNlKHRydWUpO1xuXG4gICAgICAgIC8vIFRoaXMgbWFpbnRhaW5zIHNpbmdsZSBsaW5lIGNvbW1lbnRzIG9uIHRoZSBzYW1lXG4gICAgICAgIC8vIGxpbmUuIEJsb2NrIGNvbW1lbnRzIGFyZSBhbHNvIGFmZmVjdGVkLCBidXRcbiAgICAgICAgLy8gYSBuZXcgbGluZSBpcyBhbHdheXMgb3V0cHV0IGJlZm9yZSBvbmUgaW5zaWRlXG4gICAgICAgIC8vIHRoYXQgc2VjdGlvblxuICAgICAgICBpZiAodGhpcy5faW5wdXQucGVlaygpICE9PSAnLycpIHtcbiAgICAgICAgICB0aGlzLl9vdXRwdXQuYWRkX25ld19saW5lKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJpbnRfc3RyaW5nKHRoaXMuX2NoKTtcbiAgICAgICAgdGhpcy5lYXRXaGl0ZXNwYWNlKHRydWUpO1xuICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX2NoID09PSAnKCcpIHsgLy8gbWF5IGJlIGEgdXJsXG4gICAgICBpZiAodGhpcy5faW5wdXQubG9va0JhY2soXCJ1cmxcIikpIHtcbiAgICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5fY2gpO1xuICAgICAgICB0aGlzLmVhdFdoaXRlc3BhY2UoKTtcbiAgICAgICAgcGFyZW5MZXZlbCsrO1xuICAgICAgICB0aGlzLmluZGVudCgpO1xuICAgICAgICB0aGlzLl9jaCA9IHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICAgICAgaWYgKHRoaXMuX2NoID09PSAnKScgfHwgdGhpcy5fY2ggPT09ICdcIicgfHwgdGhpcy5fY2ggPT09ICdcXCcnKSB7XG4gICAgICAgICAgdGhpcy5faW5wdXQuYmFjaygpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2NoKSB7XG4gICAgICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5fY2ggKyB0aGlzLmVhdFN0cmluZygnKScpKTtcbiAgICAgICAgICBpZiAocGFyZW5MZXZlbCkge1xuICAgICAgICAgICAgcGFyZW5MZXZlbC0tO1xuICAgICAgICAgICAgdGhpcy5vdXRkZW50KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZXNlcnZlU2luZ2xlU3BhY2UoaXNBZnRlclNwYWNlKTtcbiAgICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5fY2gpO1xuICAgICAgICB0aGlzLmVhdFdoaXRlc3BhY2UoKTtcbiAgICAgICAgcGFyZW5MZXZlbCsrO1xuICAgICAgICB0aGlzLmluZGVudCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fY2ggPT09ICcpJykge1xuICAgICAgaWYgKHBhcmVuTGV2ZWwpIHtcbiAgICAgICAgcGFyZW5MZXZlbC0tO1xuICAgICAgICB0aGlzLm91dGRlbnQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucHJpbnRfc3RyaW5nKHRoaXMuX2NoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2NoID09PSAnLCcpIHtcbiAgICAgIHRoaXMucHJpbnRfc3RyaW5nKHRoaXMuX2NoKTtcbiAgICAgIHRoaXMuZWF0V2hpdGVzcGFjZSh0cnVlKTtcbiAgICAgIGlmICh0aGlzLl9vcHRpb25zLnNlbGVjdG9yX3NlcGFyYXRvcl9uZXdsaW5lICYmICFpbnNpZGVQcm9wZXJ0eVZhbHVlICYmIHBhcmVuTGV2ZWwgPT09IDAgJiYgIWluc2lkZUF0SW1wb3J0KSB7XG4gICAgICAgIHRoaXMuX291dHB1dC5hZGRfbmV3X2xpbmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoKHRoaXMuX2NoID09PSAnPicgfHwgdGhpcy5fY2ggPT09ICcrJyB8fCB0aGlzLl9jaCA9PT0gJ34nKSAmJiAhaW5zaWRlUHJvcGVydHlWYWx1ZSAmJiBwYXJlbkxldmVsID09PSAwKSB7XG4gICAgICAvL2hhbmRsZSBjb21iaW5hdG9yIHNwYWNpbmdcbiAgICAgIGlmICh0aGlzLl9vcHRpb25zLnNwYWNlX2Fyb3VuZF9jb21iaW5hdG9yKSB7XG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICB0aGlzLnByaW50X3N0cmluZyh0aGlzLl9jaCk7XG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5fY2gpO1xuICAgICAgICB0aGlzLmVhdFdoaXRlc3BhY2UoKTtcbiAgICAgICAgLy8gc3F1YXNoIGV4dHJhIHdoaXRlc3BhY2VcbiAgICAgICAgaWYgKHRoaXMuX2NoICYmIHdoaXRlc3BhY2VDaGFyLnRlc3QodGhpcy5fY2gpKSB7XG4gICAgICAgICAgdGhpcy5fY2ggPSAnJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fY2ggPT09ICddJykge1xuICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5fY2gpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fY2ggPT09ICdbJykge1xuICAgICAgdGhpcy5wcmVzZXJ2ZVNpbmdsZVNwYWNlKGlzQWZ0ZXJTcGFjZSk7XG4gICAgICB0aGlzLnByaW50X3N0cmluZyh0aGlzLl9jaCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9jaCA9PT0gJz0nKSB7IC8vIG5vIHdoaXRlc3BhY2UgYmVmb3JlIG9yIGFmdGVyXG4gICAgICB0aGlzLmVhdFdoaXRlc3BhY2UoKTtcbiAgICAgIHRoaXMucHJpbnRfc3RyaW5nKCc9Jyk7XG4gICAgICBpZiAod2hpdGVzcGFjZUNoYXIudGVzdCh0aGlzLl9jaCkpIHtcbiAgICAgICAgdGhpcy5fY2ggPSAnJztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX2NoID09PSAnIScgJiYgIXRoaXMuX2lucHV0Lmxvb2tCYWNrKFwiXFxcXFwiKSkgeyAvLyAhaW1wb3J0YW50XG4gICAgICB0aGlzLnByaW50X3N0cmluZygnICcpO1xuICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5fY2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByZXNlcnZlU2luZ2xlU3BhY2UoaXNBZnRlclNwYWNlKTtcbiAgICAgIHRoaXMucHJpbnRfc3RyaW5nKHRoaXMuX2NoKTtcbiAgICB9XG4gIH1cblxuICB2YXIgc3dlZXRDb2RlID0gdGhpcy5fb3V0cHV0LmdldF9jb2RlKGVvbCk7XG5cbiAgcmV0dXJuIHN3ZWV0Q29kZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLkJlYXV0aWZpZXIgPSBCZWF1dGlmaWVyO1xuIiwiLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEJlYXV0aWZpZXIgPSByZXF1aXJlKCcuL2JlYXV0aWZpZXInKS5CZWF1dGlmaWVyLFxuICBPcHRpb25zID0gcmVxdWlyZSgnLi9vcHRpb25zJykuT3B0aW9ucztcblxuZnVuY3Rpb24gY3NzX2JlYXV0aWZ5KHNvdXJjZV90ZXh0LCBvcHRpb25zKSB7XG4gIHZhciBiZWF1dGlmaWVyID0gbmV3IEJlYXV0aWZpZXIoc291cmNlX3RleHQsIG9wdGlvbnMpO1xuICByZXR1cm4gYmVhdXRpZmllci5iZWF1dGlmeSgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNzc19iZWF1dGlmeTtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgT3B0aW9ucygpO1xufTtcbiIsIi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBCYXNlT3B0aW9ucyA9IHJlcXVpcmUoJy4uL2NvcmUvb3B0aW9ucycpLk9wdGlvbnM7XG5cbmZ1bmN0aW9uIE9wdGlvbnMob3B0aW9ucykge1xuICBCYXNlT3B0aW9ucy5jYWxsKHRoaXMsIG9wdGlvbnMsICdjc3MnKTtcblxuICB0aGlzLnNlbGVjdG9yX3NlcGFyYXRvcl9uZXdsaW5lID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ3NlbGVjdG9yX3NlcGFyYXRvcl9uZXdsaW5lJywgdHJ1ZSk7XG4gIHRoaXMubmV3bGluZV9iZXR3ZWVuX3J1bGVzID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ25ld2xpbmVfYmV0d2Vlbl9ydWxlcycsIHRydWUpO1xuICB2YXIgc3BhY2VfYXJvdW5kX3NlbGVjdG9yX3NlcGFyYXRvciA9IHRoaXMuX2dldF9ib29sZWFuKCdzcGFjZV9hcm91bmRfc2VsZWN0b3Jfc2VwYXJhdG9yJyk7XG4gIHRoaXMuc3BhY2VfYXJvdW5kX2NvbWJpbmF0b3IgPSB0aGlzLl9nZXRfYm9vbGVhbignc3BhY2VfYXJvdW5kX2NvbWJpbmF0b3InKSB8fCBzcGFjZV9hcm91bmRfc2VsZWN0b3Jfc2VwYXJhdG9yO1xuXG59XG5PcHRpb25zLnByb3RvdHlwZSA9IG5ldyBCYXNlT3B0aW9ucygpO1xuXG5cblxubW9kdWxlLmV4cG9ydHMuT3B0aW9ucyA9IE9wdGlvbnM7XG4iLCIvKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgT3B0aW9ucyA9IHJlcXVpcmUoJy4uL2h0bWwvb3B0aW9ucycpLk9wdGlvbnM7XG52YXIgT3V0cHV0ID0gcmVxdWlyZSgnLi4vY29yZS9vdXRwdXQnKS5PdXRwdXQ7XG52YXIgVG9rZW5pemVyID0gcmVxdWlyZSgnLi4vaHRtbC90b2tlbml6ZXInKS5Ub2tlbml6ZXI7XG52YXIgVE9LRU4gPSByZXF1aXJlKCcuLi9odG1sL3Rva2VuaXplcicpLlRPS0VOO1xuXG52YXIgbGluZUJyZWFrID0gL1xcclxcbnxbXFxyXFxuXS87XG52YXIgYWxsTGluZUJyZWFrcyA9IC9cXHJcXG58W1xcclxcbl0vZztcblxudmFyIFByaW50ZXIgPSBmdW5jdGlvbihvcHRpb25zLCBiYXNlX2luZGVudF9zdHJpbmcpIHsgLy9oYW5kbGVzIGlucHV0L291dHB1dCBhbmQgc29tZSBvdGhlciBwcmludGluZyBmdW5jdGlvbnNcblxuICB0aGlzLmluZGVudF9sZXZlbCA9IDA7XG4gIHRoaXMuYWxpZ25tZW50X3NpemUgPSAwO1xuICB0aGlzLm1heF9wcmVzZXJ2ZV9uZXdsaW5lcyA9IG9wdGlvbnMubWF4X3ByZXNlcnZlX25ld2xpbmVzO1xuICB0aGlzLnByZXNlcnZlX25ld2xpbmVzID0gb3B0aW9ucy5wcmVzZXJ2ZV9uZXdsaW5lcztcblxuICB0aGlzLl9vdXRwdXQgPSBuZXcgT3V0cHV0KG9wdGlvbnMsIGJhc2VfaW5kZW50X3N0cmluZyk7XG5cbn07XG5cblByaW50ZXIucHJvdG90eXBlLmN1cnJlbnRfbGluZV9oYXNfbWF0Y2ggPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gIHJldHVybiB0aGlzLl9vdXRwdXQuY3VycmVudF9saW5lLmhhc19tYXRjaChwYXR0ZXJuKTtcbn07XG5cblByaW50ZXIucHJvdG90eXBlLnNldF9zcGFjZV9iZWZvcmVfdG9rZW4gPSBmdW5jdGlvbih2YWx1ZSwgbm9uX2JyZWFraW5nKSB7XG4gIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB2YWx1ZTtcbiAgdGhpcy5fb3V0cHV0Lm5vbl9icmVha2luZ19zcGFjZSA9IG5vbl9icmVha2luZztcbn07XG5cblByaW50ZXIucHJvdG90eXBlLnNldF93cmFwX3BvaW50ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX291dHB1dC5zZXRfaW5kZW50KHRoaXMuaW5kZW50X2xldmVsLCB0aGlzLmFsaWdubWVudF9zaXplKTtcbiAgdGhpcy5fb3V0cHV0LnNldF93cmFwX3BvaW50KCk7XG59O1xuXG5cblByaW50ZXIucHJvdG90eXBlLmFkZF9yYXdfdG9rZW4gPSBmdW5jdGlvbih0b2tlbikge1xuICB0aGlzLl9vdXRwdXQuYWRkX3Jhd190b2tlbih0b2tlbik7XG59O1xuXG5QcmludGVyLnByb3RvdHlwZS5wcmludF9wcmVzZXJ2ZWRfbmV3bGluZXMgPSBmdW5jdGlvbihyYXdfdG9rZW4pIHtcbiAgdmFyIG5ld2xpbmVzID0gMDtcbiAgaWYgKHJhd190b2tlbi50eXBlICE9PSBUT0tFTi5URVhUICYmIHJhd190b2tlbi5wcmV2aW91cy50eXBlICE9PSBUT0tFTi5URVhUKSB7XG4gICAgbmV3bGluZXMgPSByYXdfdG9rZW4ubmV3bGluZXMgPyAxIDogMDtcbiAgfVxuXG4gIGlmICh0aGlzLnByZXNlcnZlX25ld2xpbmVzKSB7XG4gICAgbmV3bGluZXMgPSByYXdfdG9rZW4ubmV3bGluZXMgPCB0aGlzLm1heF9wcmVzZXJ2ZV9uZXdsaW5lcyArIDEgPyByYXdfdG9rZW4ubmV3bGluZXMgOiB0aGlzLm1heF9wcmVzZXJ2ZV9uZXdsaW5lcyArIDE7XG4gIH1cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBuZXdsaW5lczsgbisrKSB7XG4gICAgdGhpcy5wcmludF9uZXdsaW5lKG4gPiAwKTtcbiAgfVxuXG4gIHJldHVybiBuZXdsaW5lcyAhPT0gMDtcbn07XG5cblByaW50ZXIucHJvdG90eXBlLnRyYXZlcnNlX3doaXRlc3BhY2UgPSBmdW5jdGlvbihyYXdfdG9rZW4pIHtcbiAgaWYgKHJhd190b2tlbi53aGl0ZXNwYWNlX2JlZm9yZSB8fCByYXdfdG9rZW4ubmV3bGluZXMpIHtcbiAgICBpZiAoIXRoaXMucHJpbnRfcHJlc2VydmVkX25ld2xpbmVzKHJhd190b2tlbikpIHtcbiAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5QcmludGVyLnByb3RvdHlwZS5wcmV2aW91c190b2tlbl93cmFwcGVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9vdXRwdXQucHJldmlvdXNfdG9rZW5fd3JhcHBlZDtcbn07XG5cblByaW50ZXIucHJvdG90eXBlLnByaW50X25ld2xpbmUgPSBmdW5jdGlvbihmb3JjZSkge1xuICB0aGlzLl9vdXRwdXQuYWRkX25ld19saW5lKGZvcmNlKTtcbn07XG5cblByaW50ZXIucHJvdG90eXBlLnByaW50X3Rva2VuID0gZnVuY3Rpb24odG9rZW4pIHtcbiAgaWYgKHRva2VuLnRleHQpIHtcbiAgICB0aGlzLl9vdXRwdXQuc2V0X2luZGVudCh0aGlzLmluZGVudF9sZXZlbCwgdGhpcy5hbGlnbm1lbnRfc2l6ZSk7XG4gICAgdGhpcy5fb3V0cHV0LmFkZF90b2tlbih0b2tlbi50ZXh0KTtcbiAgfVxufTtcblxuUHJpbnRlci5wcm90b3R5cGUuaW5kZW50ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuaW5kZW50X2xldmVsKys7XG59O1xuXG5QcmludGVyLnByb3RvdHlwZS5nZXRfZnVsbF9pbmRlbnQgPSBmdW5jdGlvbihsZXZlbCkge1xuICBsZXZlbCA9IHRoaXMuaW5kZW50X2xldmVsICsgKGxldmVsIHx8IDApO1xuICBpZiAobGV2ZWwgPCAxKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX291dHB1dC5nZXRfaW5kZW50X3N0cmluZyhsZXZlbCk7XG59O1xuXG52YXIgZ2V0X3R5cGVfYXR0cmlidXRlID0gZnVuY3Rpb24oc3RhcnRfdG9rZW4pIHtcbiAgdmFyIHJlc3VsdCA9IG51bGw7XG4gIHZhciByYXdfdG9rZW4gPSBzdGFydF90b2tlbi5uZXh0O1xuXG4gIC8vIFNlYXJjaCBhdHRyaWJ1dGVzIGZvciBhIHR5cGUgYXR0cmlidXRlXG4gIHdoaWxlIChyYXdfdG9rZW4udHlwZSAhPT0gVE9LRU4uRU9GICYmIHN0YXJ0X3Rva2VuLmNsb3NlZCAhPT0gcmF3X3Rva2VuKSB7XG4gICAgaWYgKHJhd190b2tlbi50eXBlID09PSBUT0tFTi5BVFRSSUJVVEUgJiYgcmF3X3Rva2VuLnRleHQgPT09ICd0eXBlJykge1xuICAgICAgaWYgKHJhd190b2tlbi5uZXh0ICYmIHJhd190b2tlbi5uZXh0LnR5cGUgPT09IFRPS0VOLkVRVUFMUyAmJlxuICAgICAgICByYXdfdG9rZW4ubmV4dC5uZXh0ICYmIHJhd190b2tlbi5uZXh0Lm5leHQudHlwZSA9PT0gVE9LRU4uVkFMVUUpIHtcbiAgICAgICAgcmVzdWx0ID0gcmF3X3Rva2VuLm5leHQubmV4dC50ZXh0O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJhd190b2tlbiA9IHJhd190b2tlbi5uZXh0O1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBnZXRfY3VzdG9tX2JlYXV0aWZpZXJfbmFtZSA9IGZ1bmN0aW9uKHRhZ19jaGVjaywgcmF3X3Rva2VuKSB7XG4gIHZhciB0eXBlQXR0cmlidXRlID0gbnVsbDtcbiAgdmFyIHJlc3VsdCA9IG51bGw7XG5cbiAgaWYgKCFyYXdfdG9rZW4uY2xvc2VkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAodGFnX2NoZWNrID09PSAnc2NyaXB0Jykge1xuICAgIHR5cGVBdHRyaWJ1dGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgfSBlbHNlIGlmICh0YWdfY2hlY2sgPT09ICdzdHlsZScpIHtcbiAgICB0eXBlQXR0cmlidXRlID0gJ3RleHQvY3NzJztcbiAgfVxuXG4gIHR5cGVBdHRyaWJ1dGUgPSBnZXRfdHlwZV9hdHRyaWJ1dGUocmF3X3Rva2VuKSB8fCB0eXBlQXR0cmlidXRlO1xuXG4gIC8vIEZvciBzY3JpcHQgYW5kIHN0eWxlIHRhZ3MgdGhhdCBoYXZlIGEgdHlwZSBhdHRyaWJ1dGUsIG9ubHkgZW5hYmxlIGN1c3RvbSBiZWF1dGlmaWVycyBmb3IgbWF0Y2hpbmcgdmFsdWVzXG4gIC8vIEZvciB0aG9zZSB3aXRob3V0IGEgdHlwZSBhdHRyaWJ1dGUgdXNlIGRlZmF1bHQ7XG4gIGlmICh0eXBlQXR0cmlidXRlLnNlYXJjaCgndGV4dC9jc3MnKSA+IC0xKSB7XG4gICAgcmVzdWx0ID0gJ2Nzcyc7XG4gIH0gZWxzZSBpZiAodHlwZUF0dHJpYnV0ZS5zZWFyY2goLyh0ZXh0fGFwcGxpY2F0aW9ufGRvam8pXFwvKHgtKT8oamF2YXNjcmlwdHxlY21hc2NyaXB0fGpzY3JpcHR8bGl2ZXNjcmlwdHwobGRcXCspP2pzb258bWV0aG9kfGFzcGVjdCkvKSA+IC0xKSB7XG4gICAgcmVzdWx0ID0gJ2phdmFzY3JpcHQnO1xuICB9IGVsc2UgaWYgKHR5cGVBdHRyaWJ1dGUuc2VhcmNoKC8odGV4dHxhcHBsaWNhdGlvbnxkb2pvKVxcLyh4LSk/KGh0bWwpLykgPiAtMSkge1xuICAgIHJlc3VsdCA9ICdodG1sJztcbiAgfSBlbHNlIGlmICh0eXBlQXR0cmlidXRlLnNlYXJjaCgvdGVzdFxcL251bGwvKSA+IC0xKSB7XG4gICAgLy8gVGVzdCBvbmx5IG1pbWUtdHlwZSBmb3IgdGVzdGluZyB0aGUgYmVhdXRpZmllciB3aGVuIG51bGwgaXMgcGFzc2VkIGFzIGJlYXV0aWZpbmcgZnVuY3Rpb25cbiAgICByZXN1bHQgPSAnbnVsbCc7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZnVuY3Rpb24gaW5fYXJyYXkod2hhdCwgYXJyKSB7XG4gIHJldHVybiBhcnIuaW5kZXhPZih3aGF0KSAhPT0gLTE7XG59XG5cbmZ1bmN0aW9uIFRhZ0ZyYW1lKHBhcmVudCwgcGFyc2VyX3Rva2VuLCBpbmRlbnRfbGV2ZWwpIHtcbiAgdGhpcy5wYXJlbnQgPSBwYXJlbnQgfHwgbnVsbDtcbiAgdGhpcy50YWcgPSBwYXJzZXJfdG9rZW4gPyBwYXJzZXJfdG9rZW4udGFnX25hbWUgOiAnJztcbiAgdGhpcy5pbmRlbnRfbGV2ZWwgPSBpbmRlbnRfbGV2ZWwgfHwgMDtcbiAgdGhpcy5wYXJzZXJfdG9rZW4gPSBwYXJzZXJfdG9rZW4gfHwgbnVsbDtcbn1cblxuZnVuY3Rpb24gVGFnU3RhY2socHJpbnRlcikge1xuICB0aGlzLl9wcmludGVyID0gcHJpbnRlcjtcbiAgdGhpcy5fY3VycmVudF9mcmFtZSA9IG51bGw7XG59XG5cblRhZ1N0YWNrLnByb3RvdHlwZS5nZXRfcGFyc2VyX3Rva2VuID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9jdXJyZW50X2ZyYW1lID8gdGhpcy5fY3VycmVudF9mcmFtZS5wYXJzZXJfdG9rZW4gOiBudWxsO1xufTtcblxuVGFnU3RhY2sucHJvdG90eXBlLnJlY29yZF90YWcgPSBmdW5jdGlvbihwYXJzZXJfdG9rZW4pIHsgLy9mdW5jdGlvbiB0byByZWNvcmQgYSB0YWcgYW5kIGl0cyBwYXJlbnQgaW4gdGhpcy50YWdzIE9iamVjdFxuICB2YXIgbmV3X2ZyYW1lID0gbmV3IFRhZ0ZyYW1lKHRoaXMuX2N1cnJlbnRfZnJhbWUsIHBhcnNlcl90b2tlbiwgdGhpcy5fcHJpbnRlci5pbmRlbnRfbGV2ZWwpO1xuICB0aGlzLl9jdXJyZW50X2ZyYW1lID0gbmV3X2ZyYW1lO1xufTtcblxuVGFnU3RhY2sucHJvdG90eXBlLl90cnlfcG9wX2ZyYW1lID0gZnVuY3Rpb24oZnJhbWUpIHsgLy9mdW5jdGlvbiB0byByZXRyaWV2ZSB0aGUgb3BlbmluZyB0YWcgdG8gdGhlIGNvcnJlc3BvbmRpbmcgY2xvc2VyXG4gIHZhciBwYXJzZXJfdG9rZW4gPSBudWxsO1xuXG4gIGlmIChmcmFtZSkge1xuICAgIHBhcnNlcl90b2tlbiA9IGZyYW1lLnBhcnNlcl90b2tlbjtcbiAgICB0aGlzLl9wcmludGVyLmluZGVudF9sZXZlbCA9IGZyYW1lLmluZGVudF9sZXZlbDtcbiAgICB0aGlzLl9jdXJyZW50X2ZyYW1lID0gZnJhbWUucGFyZW50O1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlcl90b2tlbjtcbn07XG5cblRhZ1N0YWNrLnByb3RvdHlwZS5fZ2V0X2ZyYW1lID0gZnVuY3Rpb24odGFnX2xpc3QsIHN0b3BfbGlzdCkgeyAvL2Z1bmN0aW9uIHRvIHJldHJpZXZlIHRoZSBvcGVuaW5nIHRhZyB0byB0aGUgY29ycmVzcG9uZGluZyBjbG9zZXJcbiAgdmFyIGZyYW1lID0gdGhpcy5fY3VycmVudF9mcmFtZTtcblxuICB3aGlsZSAoZnJhbWUpIHsgLy90aWxsIHdlIHJlYWNoICcnICh0aGUgaW5pdGlhbCB2YWx1ZSk7XG4gICAgaWYgKHRhZ19saXN0LmluZGV4T2YoZnJhbWUudGFnKSAhPT0gLTEpIHsgLy9pZiB0aGlzIGlzIGl0IHVzZSBpdFxuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIGlmIChzdG9wX2xpc3QgJiYgc3RvcF9saXN0LmluZGV4T2YoZnJhbWUudGFnKSAhPT0gLTEpIHtcbiAgICAgIGZyYW1lID0gbnVsbDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBmcmFtZSA9IGZyYW1lLnBhcmVudDtcbiAgfVxuXG4gIHJldHVybiBmcmFtZTtcbn07XG5cblRhZ1N0YWNrLnByb3RvdHlwZS50cnlfcG9wID0gZnVuY3Rpb24odGFnLCBzdG9wX2xpc3QpIHsgLy9mdW5jdGlvbiB0byByZXRyaWV2ZSB0aGUgb3BlbmluZyB0YWcgdG8gdGhlIGNvcnJlc3BvbmRpbmcgY2xvc2VyXG4gIHZhciBmcmFtZSA9IHRoaXMuX2dldF9mcmFtZShbdGFnXSwgc3RvcF9saXN0KTtcbiAgcmV0dXJuIHRoaXMuX3RyeV9wb3BfZnJhbWUoZnJhbWUpO1xufTtcblxuVGFnU3RhY2sucHJvdG90eXBlLmluZGVudF90b190YWcgPSBmdW5jdGlvbih0YWdfbGlzdCkge1xuICB2YXIgZnJhbWUgPSB0aGlzLl9nZXRfZnJhbWUodGFnX2xpc3QpO1xuICBpZiAoZnJhbWUpIHtcbiAgICB0aGlzLl9wcmludGVyLmluZGVudF9sZXZlbCA9IGZyYW1lLmluZGVudF9sZXZlbDtcbiAgfVxufTtcblxuZnVuY3Rpb24gQmVhdXRpZmllcihzb3VyY2VfdGV4dCwgb3B0aW9ucywganNfYmVhdXRpZnksIGNzc19iZWF1dGlmeSkge1xuICAvL1dyYXBwZXIgZnVuY3Rpb24gdG8gaW52b2tlIGFsbCB0aGUgbmVjZXNzYXJ5IGNvbnN0cnVjdG9ycyBhbmQgZGVhbCB3aXRoIHRoZSBvdXRwdXQuXG4gIHRoaXMuX3NvdXJjZV90ZXh0ID0gc291cmNlX3RleHQgfHwgJyc7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLl9qc19iZWF1dGlmeSA9IGpzX2JlYXV0aWZ5O1xuICB0aGlzLl9jc3NfYmVhdXRpZnkgPSBjc3NfYmVhdXRpZnk7XG4gIHRoaXMuX3RhZ19zdGFjayA9IG51bGw7XG5cbiAgLy8gQWxsb3cgdGhlIHNldHRpbmcgb2YgbGFuZ3VhZ2UvZmlsZS10eXBlIHNwZWNpZmljIG9wdGlvbnNcbiAgLy8gd2l0aCBpbmhlcml0YW5jZSBvZiBvdmVyYWxsIHNldHRpbmdzXG4gIHZhciBvcHRpb25IdG1sID0gbmV3IE9wdGlvbnMob3B0aW9ucywgJ2h0bWwnKTtcblxuICB0aGlzLl9vcHRpb25zID0gb3B0aW9uSHRtbDtcblxuICB0aGlzLl9pc193cmFwX2F0dHJpYnV0ZXNfZm9yY2UgPSB0aGlzLl9vcHRpb25zLndyYXBfYXR0cmlidXRlcy5zdWJzdHIoMCwgJ2ZvcmNlJy5sZW5ndGgpID09PSAnZm9yY2UnO1xuICB0aGlzLl9pc193cmFwX2F0dHJpYnV0ZXNfZm9yY2VfZXhwYW5kX211bHRpbGluZSA9ICh0aGlzLl9vcHRpb25zLndyYXBfYXR0cmlidXRlcyA9PT0gJ2ZvcmNlLWV4cGFuZC1tdWx0aWxpbmUnKTtcbiAgdGhpcy5faXNfd3JhcF9hdHRyaWJ1dGVzX2ZvcmNlX2FsaWduZWQgPSAodGhpcy5fb3B0aW9ucy53cmFwX2F0dHJpYnV0ZXMgPT09ICdmb3JjZS1hbGlnbmVkJyk7XG4gIHRoaXMuX2lzX3dyYXBfYXR0cmlidXRlc19hbGlnbmVkX211bHRpcGxlID0gKHRoaXMuX29wdGlvbnMud3JhcF9hdHRyaWJ1dGVzID09PSAnYWxpZ25lZC1tdWx0aXBsZScpO1xuICB0aGlzLl9pc193cmFwX2F0dHJpYnV0ZXNfcHJlc2VydmUgPSB0aGlzLl9vcHRpb25zLndyYXBfYXR0cmlidXRlcy5zdWJzdHIoMCwgJ3ByZXNlcnZlJy5sZW5ndGgpID09PSAncHJlc2VydmUnO1xuICB0aGlzLl9pc193cmFwX2F0dHJpYnV0ZXNfcHJlc2VydmVfYWxpZ25lZCA9ICh0aGlzLl9vcHRpb25zLndyYXBfYXR0cmlidXRlcyA9PT0gJ3ByZXNlcnZlLWFsaWduZWQnKTtcbn1cblxuQmVhdXRpZmllci5wcm90b3R5cGUuYmVhdXRpZnkgPSBmdW5jdGlvbigpIHtcblxuICAvLyBpZiBkaXNhYmxlZCwgcmV0dXJuIHRoZSBpbnB1dCB1bmNoYW5nZWQuXG4gIGlmICh0aGlzLl9vcHRpb25zLmRpc2FibGVkKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NvdXJjZV90ZXh0O1xuICB9XG5cbiAgdmFyIHNvdXJjZV90ZXh0ID0gdGhpcy5fc291cmNlX3RleHQ7XG4gIHZhciBlb2wgPSB0aGlzLl9vcHRpb25zLmVvbDtcbiAgaWYgKHRoaXMuX29wdGlvbnMuZW9sID09PSAnYXV0bycpIHtcbiAgICBlb2wgPSAnXFxuJztcbiAgICBpZiAoc291cmNlX3RleHQgJiYgbGluZUJyZWFrLnRlc3Qoc291cmNlX3RleHQpKSB7XG4gICAgICBlb2wgPSBzb3VyY2VfdGV4dC5tYXRjaChsaW5lQnJlYWspWzBdO1xuICAgIH1cbiAgfVxuXG4gIC8vIEhBQ0s6IG5ld2xpbmUgcGFyc2luZyBpbmNvbnNpc3RlbnQuIFRoaXMgYnJ1dGUgZm9yY2Ugbm9ybWFsaXplcyB0aGUgaW5wdXQuXG4gIHNvdXJjZV90ZXh0ID0gc291cmNlX3RleHQucmVwbGFjZShhbGxMaW5lQnJlYWtzLCAnXFxuJyk7XG5cbiAgdmFyIGJhc2VJbmRlbnRTdHJpbmcgPSBzb3VyY2VfdGV4dC5tYXRjaCgvXltcXHQgXSovKVswXTtcblxuICB2YXIgbGFzdF90b2tlbiA9IHtcbiAgICB0ZXh0OiAnJyxcbiAgICB0eXBlOiAnJ1xuICB9O1xuXG4gIHZhciBsYXN0X3RhZ190b2tlbiA9IG5ldyBUYWdPcGVuUGFyc2VyVG9rZW4oKTtcblxuICB2YXIgcHJpbnRlciA9IG5ldyBQcmludGVyKHRoaXMuX29wdGlvbnMsIGJhc2VJbmRlbnRTdHJpbmcpO1xuICB2YXIgdG9rZW5zID0gbmV3IFRva2VuaXplcihzb3VyY2VfdGV4dCwgdGhpcy5fb3B0aW9ucykudG9rZW5pemUoKTtcblxuICB0aGlzLl90YWdfc3RhY2sgPSBuZXcgVGFnU3RhY2socHJpbnRlcik7XG5cbiAgdmFyIHBhcnNlcl90b2tlbiA9IG51bGw7XG4gIHZhciByYXdfdG9rZW4gPSB0b2tlbnMubmV4dCgpO1xuICB3aGlsZSAocmF3X3Rva2VuLnR5cGUgIT09IFRPS0VOLkVPRikge1xuXG4gICAgaWYgKHJhd190b2tlbi50eXBlID09PSBUT0tFTi5UQUdfT1BFTiB8fCByYXdfdG9rZW4udHlwZSA9PT0gVE9LRU4uQ09NTUVOVCkge1xuICAgICAgcGFyc2VyX3Rva2VuID0gdGhpcy5faGFuZGxlX3RhZ19vcGVuKHByaW50ZXIsIHJhd190b2tlbiwgbGFzdF90YWdfdG9rZW4sIGxhc3RfdG9rZW4pO1xuICAgICAgbGFzdF90YWdfdG9rZW4gPSBwYXJzZXJfdG9rZW47XG4gICAgfSBlbHNlIGlmICgocmF3X3Rva2VuLnR5cGUgPT09IFRPS0VOLkFUVFJJQlVURSB8fCByYXdfdG9rZW4udHlwZSA9PT0gVE9LRU4uRVFVQUxTIHx8IHJhd190b2tlbi50eXBlID09PSBUT0tFTi5WQUxVRSkgfHxcbiAgICAgIChyYXdfdG9rZW4udHlwZSA9PT0gVE9LRU4uVEVYVCAmJiAhbGFzdF90YWdfdG9rZW4udGFnX2NvbXBsZXRlKSkge1xuICAgICAgcGFyc2VyX3Rva2VuID0gdGhpcy5faGFuZGxlX2luc2lkZV90YWcocHJpbnRlciwgcmF3X3Rva2VuLCBsYXN0X3RhZ190b2tlbiwgdG9rZW5zKTtcbiAgICB9IGVsc2UgaWYgKHJhd190b2tlbi50eXBlID09PSBUT0tFTi5UQUdfQ0xPU0UpIHtcbiAgICAgIHBhcnNlcl90b2tlbiA9IHRoaXMuX2hhbmRsZV90YWdfY2xvc2UocHJpbnRlciwgcmF3X3Rva2VuLCBsYXN0X3RhZ190b2tlbik7XG4gICAgfSBlbHNlIGlmIChyYXdfdG9rZW4udHlwZSA9PT0gVE9LRU4uVEVYVCkge1xuICAgICAgcGFyc2VyX3Rva2VuID0gdGhpcy5faGFuZGxlX3RleHQocHJpbnRlciwgcmF3X3Rva2VuLCBsYXN0X3RhZ190b2tlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiwgYnV0IGlmIGl0IGRvZXMuIFByaW50IHRoZSByYXcgdG9rZW5cbiAgICAgIHByaW50ZXIuYWRkX3Jhd190b2tlbihyYXdfdG9rZW4pO1xuICAgIH1cblxuICAgIGxhc3RfdG9rZW4gPSBwYXJzZXJfdG9rZW47XG5cbiAgICByYXdfdG9rZW4gPSB0b2tlbnMubmV4dCgpO1xuICB9XG4gIHZhciBzd2VldF9jb2RlID0gcHJpbnRlci5fb3V0cHV0LmdldF9jb2RlKGVvbCk7XG5cbiAgcmV0dXJuIHN3ZWV0X2NvZGU7XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5faGFuZGxlX3RhZ19jbG9zZSA9IGZ1bmN0aW9uKHByaW50ZXIsIHJhd190b2tlbiwgbGFzdF90YWdfdG9rZW4pIHtcbiAgdmFyIHBhcnNlcl90b2tlbiA9IHtcbiAgICB0ZXh0OiByYXdfdG9rZW4udGV4dCxcbiAgICB0eXBlOiByYXdfdG9rZW4udHlwZVxuICB9O1xuICBwcmludGVyLmFsaWdubWVudF9zaXplID0gMDtcbiAgbGFzdF90YWdfdG9rZW4udGFnX2NvbXBsZXRlID0gdHJ1ZTtcblxuICBwcmludGVyLnNldF9zcGFjZV9iZWZvcmVfdG9rZW4ocmF3X3Rva2VuLm5ld2xpbmVzIHx8IHJhd190b2tlbi53aGl0ZXNwYWNlX2JlZm9yZSAhPT0gJycsIHRydWUpO1xuICBpZiAobGFzdF90YWdfdG9rZW4uaXNfdW5mb3JtYXR0ZWQpIHtcbiAgICBwcmludGVyLmFkZF9yYXdfdG9rZW4ocmF3X3Rva2VuKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAobGFzdF90YWdfdG9rZW4udGFnX3N0YXJ0X2NoYXIgPT09ICc8Jykge1xuICAgICAgcHJpbnRlci5zZXRfc3BhY2VfYmVmb3JlX3Rva2VuKHJhd190b2tlbi50ZXh0WzBdID09PSAnLycsIHRydWUpOyAvLyBzcGFjZSBiZWZvcmUgLz4sIG5vIHNwYWNlIGJlZm9yZSA+XG4gICAgICBpZiAodGhpcy5faXNfd3JhcF9hdHRyaWJ1dGVzX2ZvcmNlX2V4cGFuZF9tdWx0aWxpbmUgJiYgbGFzdF90YWdfdG9rZW4uaGFzX3dyYXBwZWRfYXR0cnMpIHtcbiAgICAgICAgcHJpbnRlci5wcmludF9uZXdsaW5lKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcHJpbnRlci5wcmludF90b2tlbihyYXdfdG9rZW4pO1xuXG4gIH1cblxuICBpZiAobGFzdF90YWdfdG9rZW4uaW5kZW50X2NvbnRlbnQgJiZcbiAgICAhKGxhc3RfdGFnX3Rva2VuLmlzX3VuZm9ybWF0dGVkIHx8IGxhc3RfdGFnX3Rva2VuLmlzX2NvbnRlbnRfdW5mb3JtYXR0ZWQpKSB7XG4gICAgcHJpbnRlci5pbmRlbnQoKTtcblxuICAgIC8vIG9ubHkgaW5kZW50IG9uY2UgcGVyIG9wZW5lZCB0YWdcbiAgICBsYXN0X3RhZ190b2tlbi5pbmRlbnRfY29udGVudCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKCFsYXN0X3RhZ190b2tlbi5pc19pbmxpbmVfZWxlbWVudCAmJlxuICAgICEobGFzdF90YWdfdG9rZW4uaXNfdW5mb3JtYXR0ZWQgfHwgbGFzdF90YWdfdG9rZW4uaXNfY29udGVudF91bmZvcm1hdHRlZCkpIHtcbiAgICBwcmludGVyLnNldF93cmFwX3BvaW50KCk7XG4gIH1cblxuICByZXR1cm4gcGFyc2VyX3Rva2VuO1xufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuX2hhbmRsZV9pbnNpZGVfdGFnID0gZnVuY3Rpb24ocHJpbnRlciwgcmF3X3Rva2VuLCBsYXN0X3RhZ190b2tlbiwgdG9rZW5zKSB7XG4gIHZhciB3cmFwcGVkID0gbGFzdF90YWdfdG9rZW4uaGFzX3dyYXBwZWRfYXR0cnM7XG4gIHZhciBwYXJzZXJfdG9rZW4gPSB7XG4gICAgdGV4dDogcmF3X3Rva2VuLnRleHQsXG4gICAgdHlwZTogcmF3X3Rva2VuLnR5cGVcbiAgfTtcblxuICBwcmludGVyLnNldF9zcGFjZV9iZWZvcmVfdG9rZW4ocmF3X3Rva2VuLm5ld2xpbmVzIHx8IHJhd190b2tlbi53aGl0ZXNwYWNlX2JlZm9yZSAhPT0gJycsIHRydWUpO1xuICBpZiAobGFzdF90YWdfdG9rZW4uaXNfdW5mb3JtYXR0ZWQpIHtcbiAgICBwcmludGVyLmFkZF9yYXdfdG9rZW4ocmF3X3Rva2VuKTtcbiAgfSBlbHNlIGlmIChsYXN0X3RhZ190b2tlbi50YWdfc3RhcnRfY2hhciA9PT0gJ3snICYmIHJhd190b2tlbi50eXBlID09PSBUT0tFTi5URVhUKSB7XG4gICAgLy8gRm9yIHRoZSBpbnNpZGVzIG9mIGhhbmRsZWJhcnMgYWxsb3cgbmV3bGluZXMgb3IgYSBzaW5nbGUgc3BhY2UgYmV0d2VlbiBvcGVuIGFuZCBjb250ZW50c1xuICAgIGlmIChwcmludGVyLnByaW50X3ByZXNlcnZlZF9uZXdsaW5lcyhyYXdfdG9rZW4pKSB7XG4gICAgICByYXdfdG9rZW4ubmV3bGluZXMgPSAwO1xuICAgICAgcHJpbnRlci5hZGRfcmF3X3Rva2VuKHJhd190b2tlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByaW50ZXIucHJpbnRfdG9rZW4ocmF3X3Rva2VuKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHJhd190b2tlbi50eXBlID09PSBUT0tFTi5BVFRSSUJVVEUpIHtcbiAgICAgIHByaW50ZXIuc2V0X3NwYWNlX2JlZm9yZV90b2tlbih0cnVlKTtcbiAgICAgIGxhc3RfdGFnX3Rva2VuLmF0dHJfY291bnQgKz0gMTtcbiAgICB9IGVsc2UgaWYgKHJhd190b2tlbi50eXBlID09PSBUT0tFTi5FUVVBTFMpIHsgLy9ubyBzcGFjZSBiZWZvcmUgPVxuICAgICAgcHJpbnRlci5zZXRfc3BhY2VfYmVmb3JlX3Rva2VuKGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKHJhd190b2tlbi50eXBlID09PSBUT0tFTi5WQUxVRSAmJiByYXdfdG9rZW4ucHJldmlvdXMudHlwZSA9PT0gVE9LRU4uRVFVQUxTKSB7IC8vbm8gc3BhY2UgYmVmb3JlIHZhbHVlXG4gICAgICBwcmludGVyLnNldF9zcGFjZV9iZWZvcmVfdG9rZW4oZmFsc2UpO1xuICAgIH1cblxuICAgIGlmIChyYXdfdG9rZW4udHlwZSA9PT0gVE9LRU4uQVRUUklCVVRFICYmIGxhc3RfdGFnX3Rva2VuLnRhZ19zdGFydF9jaGFyID09PSAnPCcpIHtcbiAgICAgIGlmICh0aGlzLl9pc193cmFwX2F0dHJpYnV0ZXNfcHJlc2VydmUgfHwgdGhpcy5faXNfd3JhcF9hdHRyaWJ1dGVzX3ByZXNlcnZlX2FsaWduZWQpIHtcbiAgICAgICAgcHJpbnRlci50cmF2ZXJzZV93aGl0ZXNwYWNlKHJhd190b2tlbik7XG4gICAgICAgIHdyYXBwZWQgPSB3cmFwcGVkIHx8IHJhd190b2tlbi5uZXdsaW5lcyAhPT0gMDtcbiAgICAgIH1cblxuXG4gICAgICBpZiAodGhpcy5faXNfd3JhcF9hdHRyaWJ1dGVzX2ZvcmNlKSB7XG4gICAgICAgIHZhciBmb3JjZV9hdHRyX3dyYXAgPSBsYXN0X3RhZ190b2tlbi5hdHRyX2NvdW50ID4gMTtcbiAgICAgICAgaWYgKHRoaXMuX2lzX3dyYXBfYXR0cmlidXRlc19mb3JjZV9leHBhbmRfbXVsdGlsaW5lICYmIGxhc3RfdGFnX3Rva2VuLmF0dHJfY291bnQgPT09IDEpIHtcbiAgICAgICAgICB2YXIgaXNfb25seV9hdHRyaWJ1dGUgPSB0cnVlO1xuICAgICAgICAgIHZhciBwZWVrX2luZGV4ID0gMDtcbiAgICAgICAgICB2YXIgcGVla190b2tlbjtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBwZWVrX3Rva2VuID0gdG9rZW5zLnBlZWsocGVla19pbmRleCk7XG4gICAgICAgICAgICBpZiAocGVla190b2tlbi50eXBlID09PSBUT0tFTi5BVFRSSUJVVEUpIHtcbiAgICAgICAgICAgICAgaXNfb25seV9hdHRyaWJ1dGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwZWVrX2luZGV4ICs9IDE7XG4gICAgICAgICAgfSB3aGlsZSAocGVla19pbmRleCA8IDQgJiYgcGVla190b2tlbi50eXBlICE9PSBUT0tFTi5FT0YgJiYgcGVla190b2tlbi50eXBlICE9PSBUT0tFTi5UQUdfQ0xPU0UpO1xuXG4gICAgICAgICAgZm9yY2VfYXR0cl93cmFwID0gIWlzX29ubHlfYXR0cmlidXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZvcmNlX2F0dHJfd3JhcCkge1xuICAgICAgICAgIHByaW50ZXIucHJpbnRfbmV3bGluZShmYWxzZSk7XG4gICAgICAgICAgd3JhcHBlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcHJpbnRlci5wcmludF90b2tlbihyYXdfdG9rZW4pO1xuICAgIHdyYXBwZWQgPSB3cmFwcGVkIHx8IHByaW50ZXIucHJldmlvdXNfdG9rZW5fd3JhcHBlZCgpO1xuICAgIGxhc3RfdGFnX3Rva2VuLmhhc193cmFwcGVkX2F0dHJzID0gd3JhcHBlZDtcbiAgfVxuICByZXR1cm4gcGFyc2VyX3Rva2VuO1xufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuX2hhbmRsZV90ZXh0ID0gZnVuY3Rpb24ocHJpbnRlciwgcmF3X3Rva2VuLCBsYXN0X3RhZ190b2tlbikge1xuICB2YXIgcGFyc2VyX3Rva2VuID0ge1xuICAgIHRleHQ6IHJhd190b2tlbi50ZXh0LFxuICAgIHR5cGU6ICdUS19DT05URU5UJ1xuICB9O1xuICBpZiAobGFzdF90YWdfdG9rZW4uY3VzdG9tX2JlYXV0aWZpZXJfbmFtZSkgeyAvL2NoZWNrIGlmIHdlIG5lZWQgdG8gZm9ybWF0IGphdmFzY3JpcHRcbiAgICB0aGlzLl9wcmludF9jdXN0b21fYmVhdGlmaWVyX3RleHQocHJpbnRlciwgcmF3X3Rva2VuLCBsYXN0X3RhZ190b2tlbik7XG4gIH0gZWxzZSBpZiAobGFzdF90YWdfdG9rZW4uaXNfdW5mb3JtYXR0ZWQgfHwgbGFzdF90YWdfdG9rZW4uaXNfY29udGVudF91bmZvcm1hdHRlZCkge1xuICAgIHByaW50ZXIuYWRkX3Jhd190b2tlbihyYXdfdG9rZW4pO1xuICB9IGVsc2Uge1xuICAgIHByaW50ZXIudHJhdmVyc2Vfd2hpdGVzcGFjZShyYXdfdG9rZW4pO1xuICAgIHByaW50ZXIucHJpbnRfdG9rZW4ocmF3X3Rva2VuKTtcbiAgfVxuICByZXR1cm4gcGFyc2VyX3Rva2VuO1xufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuX3ByaW50X2N1c3RvbV9iZWF0aWZpZXJfdGV4dCA9IGZ1bmN0aW9uKHByaW50ZXIsIHJhd190b2tlbiwgbGFzdF90YWdfdG9rZW4pIHtcbiAgdmFyIGxvY2FsID0gdGhpcztcbiAgaWYgKHJhd190b2tlbi50ZXh0ICE9PSAnJykge1xuXG4gICAgdmFyIHRleHQgPSByYXdfdG9rZW4udGV4dCxcbiAgICAgIF9iZWF1dGlmaWVyLFxuICAgICAgc2NyaXB0X2luZGVudF9sZXZlbCA9IDEsXG4gICAgICBwcmUgPSAnJyxcbiAgICAgIHBvc3QgPSAnJztcbiAgICBpZiAobGFzdF90YWdfdG9rZW4uY3VzdG9tX2JlYXV0aWZpZXJfbmFtZSA9PT0gJ2phdmFzY3JpcHQnICYmIHR5cGVvZiB0aGlzLl9qc19iZWF1dGlmeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgX2JlYXV0aWZpZXIgPSB0aGlzLl9qc19iZWF1dGlmeTtcbiAgICB9IGVsc2UgaWYgKGxhc3RfdGFnX3Rva2VuLmN1c3RvbV9iZWF1dGlmaWVyX25hbWUgPT09ICdjc3MnICYmIHR5cGVvZiB0aGlzLl9jc3NfYmVhdXRpZnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIF9iZWF1dGlmaWVyID0gdGhpcy5fY3NzX2JlYXV0aWZ5O1xuICAgIH0gZWxzZSBpZiAobGFzdF90YWdfdG9rZW4uY3VzdG9tX2JlYXV0aWZpZXJfbmFtZSA9PT0gJ2h0bWwnKSB7XG4gICAgICBfYmVhdXRpZmllciA9IGZ1bmN0aW9uKGh0bWxfc291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBiZWF1dGlmaWVyID0gbmV3IEJlYXV0aWZpZXIoaHRtbF9zb3VyY2UsIG9wdGlvbnMsIGxvY2FsLl9qc19iZWF1dGlmeSwgbG9jYWwuX2Nzc19iZWF1dGlmeSk7XG4gICAgICAgIHJldHVybiBiZWF1dGlmaWVyLmJlYXV0aWZ5KCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9vcHRpb25zLmluZGVudF9zY3JpcHRzID09PSBcImtlZXBcIikge1xuICAgICAgc2NyaXB0X2luZGVudF9sZXZlbCA9IDA7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9vcHRpb25zLmluZGVudF9zY3JpcHRzID09PSBcInNlcGFyYXRlXCIpIHtcbiAgICAgIHNjcmlwdF9pbmRlbnRfbGV2ZWwgPSAtcHJpbnRlci5pbmRlbnRfbGV2ZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZGVudGF0aW9uID0gcHJpbnRlci5nZXRfZnVsbF9pbmRlbnQoc2NyaXB0X2luZGVudF9sZXZlbCk7XG5cbiAgICAvLyBpZiB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgZW1wdHkgbGluZSBhdCB0aGUgZW5kIG9mIHRoaXMgdGV4dCwgc3RyaXAgaXRcbiAgICAvLyB3ZSdsbCBiZSBhZGRpbmcgb25lIGJhY2sgYWZ0ZXIgdGhlIHRleHQgYnV0IGJlZm9yZSB0aGUgY29udGFpbmluZyB0YWcuXG4gICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxuWyBcXHRdKiQvLCAnJyk7XG5cbiAgICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgY29udGVudCBpcyB3cmFwcGVkIGluIGEgY29tbWVudCBvciBjZGF0YS5cbiAgICBpZiAobGFzdF90YWdfdG9rZW4uY3VzdG9tX2JlYXV0aWZpZXJfbmFtZSAhPT0gJ2h0bWwnICYmXG4gICAgICB0ZXh0WzBdID09PSAnPCcgJiYgdGV4dC5tYXRjaCgvXig8IS0tfDwhXFxbQ0RBVEFcXFspLykpIHtcbiAgICAgIHZhciBtYXRjaGVkID0gL14oPCEtLVteXFxuXSp8PCFcXFtDREFUQVxcWykoXFxuPykoWyBcXHRcXG5dKikoW1xcc1xcU10qKSgtLT58XV0+KSQvLmV4ZWModGV4dCk7XG5cbiAgICAgIC8vIGlmIHdlIHN0YXJ0IHRvIHdyYXAgYnV0IGRvbid0IGZpbmlzaCwgcHJpbnQgcmF3XG4gICAgICBpZiAoIW1hdGNoZWQpIHtcbiAgICAgICAgcHJpbnRlci5hZGRfcmF3X3Rva2VuKHJhd190b2tlbik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcHJlID0gaW5kZW50YXRpb24gKyBtYXRjaGVkWzFdICsgJ1xcbic7XG4gICAgICB0ZXh0ID0gbWF0Y2hlZFs0XTtcbiAgICAgIGlmIChtYXRjaGVkWzVdKSB7XG4gICAgICAgIHBvc3QgPSBpbmRlbnRhdGlvbiArIG1hdGNoZWRbNV07XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBlbXB0eSBsaW5lIGF0IHRoZSBlbmQgb2YgdGhpcyB0ZXh0LCBzdHJpcCBpdFxuICAgICAgLy8gd2UnbGwgYmUgYWRkaW5nIG9uZSBiYWNrIGFmdGVyIHRoZSB0ZXh0IGJ1dCBiZWZvcmUgdGhlIGNvbnRhaW5pbmcgdGFnLlxuICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxuWyBcXHRdKiQvLCAnJyk7XG5cbiAgICAgIGlmIChtYXRjaGVkWzJdIHx8IG1hdGNoZWRbM10uaW5kZXhPZignXFxuJykgIT09IC0xKSB7XG4gICAgICAgIC8vIGlmIHRoZSBmaXJzdCBsaW5lIG9mIHRoZSBub24tY29tbWVudCB0ZXh0IGhhcyBzcGFjZXNcbiAgICAgICAgLy8gdXNlIHRoYXQgYXMgdGhlIGJhc2lzIGZvciBpbmRlbnRpbmcgaW4gbnVsbCBjYXNlLlxuICAgICAgICBtYXRjaGVkID0gbWF0Y2hlZFszXS5tYXRjaCgvWyBcXHRdKyQvKTtcbiAgICAgICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgICByYXdfdG9rZW4ud2hpdGVzcGFjZV9iZWZvcmUgPSBtYXRjaGVkWzBdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRleHQpIHtcbiAgICAgIGlmIChfYmVhdXRpZmllcikge1xuXG4gICAgICAgIC8vIGNhbGwgdGhlIEJlYXV0aWZpZXIgaWYgYXZhbGlhYmxlXG4gICAgICAgIHZhciBDaGlsZF9vcHRpb25zID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5lb2wgPSAnXFxuJztcbiAgICAgICAgfTtcbiAgICAgICAgQ2hpbGRfb3B0aW9ucy5wcm90b3R5cGUgPSB0aGlzLl9vcHRpb25zLnJhd19vcHRpb25zO1xuICAgICAgICB2YXIgY2hpbGRfb3B0aW9ucyA9IG5ldyBDaGlsZF9vcHRpb25zKCk7XG4gICAgICAgIHRleHQgPSBfYmVhdXRpZmllcihpbmRlbnRhdGlvbiArIHRleHQsIGNoaWxkX29wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc2ltcGx5IGluZGVudCB0aGUgc3RyaW5nIG90aGVyd2lzZVxuICAgICAgICB2YXIgd2hpdGUgPSByYXdfdG9rZW4ud2hpdGVzcGFjZV9iZWZvcmU7XG4gICAgICAgIGlmICh3aGl0ZSkge1xuICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UobmV3IFJlZ0V4cCgnXFxuKCcgKyB3aGl0ZSArICcpPycsICdnJyksICdcXG4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRleHQgPSBpbmRlbnRhdGlvbiArIHRleHQucmVwbGFjZSgvXFxuL2csICdcXG4nICsgaW5kZW50YXRpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcmUpIHtcbiAgICAgIGlmICghdGV4dCkge1xuICAgICAgICB0ZXh0ID0gcHJlICsgcG9zdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHQgPSBwcmUgKyB0ZXh0ICsgJ1xcbicgKyBwb3N0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHByaW50ZXIucHJpbnRfbmV3bGluZShmYWxzZSk7XG4gICAgaWYgKHRleHQpIHtcbiAgICAgIHJhd190b2tlbi50ZXh0ID0gdGV4dDtcbiAgICAgIHJhd190b2tlbi53aGl0ZXNwYWNlX2JlZm9yZSA9ICcnO1xuICAgICAgcmF3X3Rva2VuLm5ld2xpbmVzID0gMDtcbiAgICAgIHByaW50ZXIuYWRkX3Jhd190b2tlbihyYXdfdG9rZW4pO1xuICAgICAgcHJpbnRlci5wcmludF9uZXdsaW5lKHRydWUpO1xuICAgIH1cbiAgfVxufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuX2hhbmRsZV90YWdfb3BlbiA9IGZ1bmN0aW9uKHByaW50ZXIsIHJhd190b2tlbiwgbGFzdF90YWdfdG9rZW4sIGxhc3RfdG9rZW4pIHtcbiAgdmFyIHBhcnNlcl90b2tlbiA9IHRoaXMuX2dldF90YWdfb3Blbl90b2tlbihyYXdfdG9rZW4pO1xuXG4gIGlmICgobGFzdF90YWdfdG9rZW4uaXNfdW5mb3JtYXR0ZWQgfHwgbGFzdF90YWdfdG9rZW4uaXNfY29udGVudF91bmZvcm1hdHRlZCkgJiZcbiAgICByYXdfdG9rZW4udHlwZSA9PT0gVE9LRU4uVEFHX09QRU4gJiYgcmF3X3Rva2VuLnRleHQuaW5kZXhPZignPC8nKSA9PT0gMCkge1xuICAgIC8vIEVuZCBlbGVtZW50IHRhZ3MgZm9yIHVuZm9ybWF0dGVkIG9yIGNvbnRlbnRfdW5mb3JtYXR0ZWQgZWxlbWVudHNcbiAgICAvLyBhcmUgcHJpbnRlZCByYXcgdG8ga2VlcCBhbnkgbmV3bGluZXMgaW5zaWRlIHRoZW0gZXhhY3RseSB0aGUgc2FtZS5cbiAgICBwcmludGVyLmFkZF9yYXdfdG9rZW4ocmF3X3Rva2VuKTtcbiAgfSBlbHNlIHtcbiAgICBwcmludGVyLnRyYXZlcnNlX3doaXRlc3BhY2UocmF3X3Rva2VuKTtcbiAgICB0aGlzLl9zZXRfdGFnX3Bvc2l0aW9uKHByaW50ZXIsIHJhd190b2tlbiwgcGFyc2VyX3Rva2VuLCBsYXN0X3RhZ190b2tlbiwgbGFzdF90b2tlbik7XG4gICAgaWYgKCFwYXJzZXJfdG9rZW4uaXNfaW5saW5lX2VsZW1lbnQpIHtcbiAgICAgIHByaW50ZXIuc2V0X3dyYXBfcG9pbnQoKTtcbiAgICB9XG4gICAgcHJpbnRlci5wcmludF90b2tlbihyYXdfdG9rZW4pO1xuICB9XG5cbiAgLy9pbmRlbnQgYXR0cmlidXRlcyBhbiBhdXRvLCBmb3JjZWQsIGFsaWduZWQgb3IgZm9yY2VkLWFsaWduIGxpbmUtd3JhcFxuICBpZiAodGhpcy5faXNfd3JhcF9hdHRyaWJ1dGVzX2ZvcmNlX2FsaWduZWQgfHwgdGhpcy5faXNfd3JhcF9hdHRyaWJ1dGVzX2FsaWduZWRfbXVsdGlwbGUgfHwgdGhpcy5faXNfd3JhcF9hdHRyaWJ1dGVzX3ByZXNlcnZlX2FsaWduZWQpIHtcbiAgICBwYXJzZXJfdG9rZW4uYWxpZ25tZW50X3NpemUgPSByYXdfdG9rZW4udGV4dC5sZW5ndGggKyAxO1xuICB9XG5cbiAgaWYgKCFwYXJzZXJfdG9rZW4udGFnX2NvbXBsZXRlICYmICFwYXJzZXJfdG9rZW4uaXNfdW5mb3JtYXR0ZWQpIHtcbiAgICBwcmludGVyLmFsaWdubWVudF9zaXplID0gcGFyc2VyX3Rva2VuLmFsaWdubWVudF9zaXplO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlcl90b2tlbjtcbn07XG5cbnZhciBUYWdPcGVuUGFyc2VyVG9rZW4gPSBmdW5jdGlvbihwYXJlbnQsIHJhd190b2tlbikge1xuICB0aGlzLnBhcmVudCA9IHBhcmVudCB8fCBudWxsO1xuICB0aGlzLnRleHQgPSAnJztcbiAgdGhpcy50eXBlID0gJ1RLX1RBR19PUEVOJztcbiAgdGhpcy50YWdfbmFtZSA9ICcnO1xuICB0aGlzLmlzX2lubGluZV9lbGVtZW50ID0gZmFsc2U7XG4gIHRoaXMuaXNfdW5mb3JtYXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5pc19jb250ZW50X3VuZm9ybWF0dGVkID0gZmFsc2U7XG4gIHRoaXMuaXNfZW1wdHlfZWxlbWVudCA9IGZhbHNlO1xuICB0aGlzLmlzX3N0YXJ0X3RhZyA9IGZhbHNlO1xuICB0aGlzLmlzX2VuZF90YWcgPSBmYWxzZTtcbiAgdGhpcy5pbmRlbnRfY29udGVudCA9IGZhbHNlO1xuICB0aGlzLm11bHRpbGluZV9jb250ZW50ID0gZmFsc2U7XG4gIHRoaXMuY3VzdG9tX2JlYXV0aWZpZXJfbmFtZSA9IG51bGw7XG4gIHRoaXMuc3RhcnRfdGFnX3Rva2VuID0gbnVsbDtcbiAgdGhpcy5hdHRyX2NvdW50ID0gMDtcbiAgdGhpcy5oYXNfd3JhcHBlZF9hdHRycyA9IGZhbHNlO1xuICB0aGlzLmFsaWdubWVudF9zaXplID0gMDtcbiAgdGhpcy50YWdfY29tcGxldGUgPSBmYWxzZTtcbiAgdGhpcy50YWdfc3RhcnRfY2hhciA9ICcnO1xuICB0aGlzLnRhZ19jaGVjayA9ICcnO1xuXG4gIGlmICghcmF3X3Rva2VuKSB7XG4gICAgdGhpcy50YWdfY29tcGxldGUgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHZhciB0YWdfY2hlY2tfbWF0Y2g7XG5cbiAgICB0aGlzLnRhZ19zdGFydF9jaGFyID0gcmF3X3Rva2VuLnRleHRbMF07XG4gICAgdGhpcy50ZXh0ID0gcmF3X3Rva2VuLnRleHQ7XG5cbiAgICBpZiAodGhpcy50YWdfc3RhcnRfY2hhciA9PT0gJzwnKSB7XG4gICAgICB0YWdfY2hlY2tfbWF0Y2ggPSByYXdfdG9rZW4udGV4dC5tYXRjaCgvXjwoW15cXHM+XSopLyk7XG4gICAgICB0aGlzLnRhZ19jaGVjayA9IHRhZ19jaGVja19tYXRjaCA/IHRhZ19jaGVja19tYXRjaFsxXSA6ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YWdfY2hlY2tfbWF0Y2ggPSByYXdfdG9rZW4udGV4dC5tYXRjaCgvXnt7WyNcXF5dPyhbXlxcc31dKykvKTtcbiAgICAgIHRoaXMudGFnX2NoZWNrID0gdGFnX2NoZWNrX21hdGNoID8gdGFnX2NoZWNrX21hdGNoWzFdIDogJyc7XG4gICAgfVxuICAgIHRoaXMudGFnX2NoZWNrID0gdGhpcy50YWdfY2hlY2sudG9Mb3dlckNhc2UoKTtcblxuICAgIGlmIChyYXdfdG9rZW4udHlwZSA9PT0gVE9LRU4uQ09NTUVOVCkge1xuICAgICAgdGhpcy50YWdfY29tcGxldGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuaXNfc3RhcnRfdGFnID0gdGhpcy50YWdfY2hlY2suY2hhckF0KDApICE9PSAnLyc7XG4gICAgdGhpcy50YWdfbmFtZSA9ICF0aGlzLmlzX3N0YXJ0X3RhZyA/IHRoaXMudGFnX2NoZWNrLnN1YnN0cigxKSA6IHRoaXMudGFnX2NoZWNrO1xuICAgIHRoaXMuaXNfZW5kX3RhZyA9ICF0aGlzLmlzX3N0YXJ0X3RhZyB8fFxuICAgICAgKHJhd190b2tlbi5jbG9zZWQgJiYgcmF3X3Rva2VuLmNsb3NlZC50ZXh0ID09PSAnLz4nKTtcblxuICAgIC8vIGhhbmRsZWJhcnMgdGFncyB0aGF0IGRvbid0IHN0YXJ0IHdpdGggIyBvciBeIGFyZSBzaW5nbGVfdGFncywgYW5kIHNvIGFsc28gc3RhcnQgYW5kIGVuZC5cbiAgICB0aGlzLmlzX2VuZF90YWcgPSB0aGlzLmlzX2VuZF90YWcgfHxcbiAgICAgICh0aGlzLnRhZ19zdGFydF9jaGFyID09PSAneycgJiYgKHRoaXMudGV4dC5sZW5ndGggPCAzIHx8ICgvW14jXFxeXS8udGVzdCh0aGlzLnRleHQuY2hhckF0KDIpKSkpKTtcbiAgfVxufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuX2dldF90YWdfb3Blbl90b2tlbiA9IGZ1bmN0aW9uKHJhd190b2tlbikgeyAvL2Z1bmN0aW9uIHRvIGdldCBhIGZ1bGwgdGFnIGFuZCBwYXJzZSBpdHMgdHlwZVxuICB2YXIgcGFyc2VyX3Rva2VuID0gbmV3IFRhZ09wZW5QYXJzZXJUb2tlbih0aGlzLl90YWdfc3RhY2suZ2V0X3BhcnNlcl90b2tlbigpLCByYXdfdG9rZW4pO1xuXG4gIHBhcnNlcl90b2tlbi5hbGlnbm1lbnRfc2l6ZSA9IHRoaXMuX29wdGlvbnMud3JhcF9hdHRyaWJ1dGVzX2luZGVudF9zaXplO1xuXG4gIHBhcnNlcl90b2tlbi5pc19lbmRfdGFnID0gcGFyc2VyX3Rva2VuLmlzX2VuZF90YWcgfHxcbiAgICBpbl9hcnJheShwYXJzZXJfdG9rZW4udGFnX2NoZWNrLCB0aGlzLl9vcHRpb25zLnZvaWRfZWxlbWVudHMpO1xuXG4gIHBhcnNlcl90b2tlbi5pc19lbXB0eV9lbGVtZW50ID0gcGFyc2VyX3Rva2VuLnRhZ19jb21wbGV0ZSB8fFxuICAgIChwYXJzZXJfdG9rZW4uaXNfc3RhcnRfdGFnICYmIHBhcnNlcl90b2tlbi5pc19lbmRfdGFnKTtcblxuICBwYXJzZXJfdG9rZW4uaXNfdW5mb3JtYXR0ZWQgPSAhcGFyc2VyX3Rva2VuLnRhZ19jb21wbGV0ZSAmJiBpbl9hcnJheShwYXJzZXJfdG9rZW4udGFnX2NoZWNrLCB0aGlzLl9vcHRpb25zLnVuZm9ybWF0dGVkKTtcbiAgcGFyc2VyX3Rva2VuLmlzX2NvbnRlbnRfdW5mb3JtYXR0ZWQgPSAhcGFyc2VyX3Rva2VuLmlzX2VtcHR5X2VsZW1lbnQgJiYgaW5fYXJyYXkocGFyc2VyX3Rva2VuLnRhZ19jaGVjaywgdGhpcy5fb3B0aW9ucy5jb250ZW50X3VuZm9ybWF0dGVkKTtcbiAgcGFyc2VyX3Rva2VuLmlzX2lubGluZV9lbGVtZW50ID0gaW5fYXJyYXkocGFyc2VyX3Rva2VuLnRhZ19uYW1lLCB0aGlzLl9vcHRpb25zLmlubGluZSkgfHwgcGFyc2VyX3Rva2VuLnRhZ19zdGFydF9jaGFyID09PSAneyc7XG5cbiAgcmV0dXJuIHBhcnNlcl90b2tlbjtcbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLl9zZXRfdGFnX3Bvc2l0aW9uID0gZnVuY3Rpb24ocHJpbnRlciwgcmF3X3Rva2VuLCBwYXJzZXJfdG9rZW4sIGxhc3RfdGFnX3Rva2VuLCBsYXN0X3Rva2VuKSB7XG5cbiAgaWYgKCFwYXJzZXJfdG9rZW4uaXNfZW1wdHlfZWxlbWVudCkge1xuICAgIGlmIChwYXJzZXJfdG9rZW4uaXNfZW5kX3RhZykgeyAvL3RoaXMgdGFnIGlzIGEgZG91YmxlIHRhZyBzbyBjaGVjayBmb3IgdGFnLWVuZGluZ1xuICAgICAgcGFyc2VyX3Rva2VuLnN0YXJ0X3RhZ190b2tlbiA9IHRoaXMuX3RhZ19zdGFjay50cnlfcG9wKHBhcnNlcl90b2tlbi50YWdfbmFtZSk7IC8vcmVtb3ZlIGl0IGFuZCBhbGwgYW5jZXN0b3JzXG4gICAgfSBlbHNlIHsgLy8gaXQncyBhIHN0YXJ0LXRhZ1xuICAgICAgLy8gY2hlY2sgaWYgdGhpcyB0YWcgaXMgc3RhcnRpbmcgYW4gZWxlbWVudCB0aGF0IGhhcyBvcHRpb25hbCBlbmQgZWxlbWVudFxuICAgICAgLy8gYW5kIGRvIGFuIGVuZGluZyBuZWVkZWRcbiAgICAgIGlmICh0aGlzLl9kb19vcHRpb25hbF9lbmRfZWxlbWVudChwYXJzZXJfdG9rZW4pKSB7XG4gICAgICAgIGlmICghcGFyc2VyX3Rva2VuLmlzX2lubGluZV9lbGVtZW50KSB7XG4gICAgICAgICAgaWYgKHBhcnNlcl90b2tlbi5wYXJlbnQpIHtcbiAgICAgICAgICAgIHBhcnNlcl90b2tlbi5wYXJlbnQubXVsdGlsaW5lX2NvbnRlbnQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwcmludGVyLnByaW50X25ld2xpbmUoZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgdGhpcy5fdGFnX3N0YWNrLnJlY29yZF90YWcocGFyc2VyX3Rva2VuKTsgLy9wdXNoIGl0IG9uIHRoZSB0YWcgc3RhY2tcblxuICAgICAgaWYgKChwYXJzZXJfdG9rZW4udGFnX25hbWUgPT09ICdzY3JpcHQnIHx8IHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJ3N0eWxlJykgJiZcbiAgICAgICAgIShwYXJzZXJfdG9rZW4uaXNfdW5mb3JtYXR0ZWQgfHwgcGFyc2VyX3Rva2VuLmlzX2NvbnRlbnRfdW5mb3JtYXR0ZWQpKSB7XG4gICAgICAgIHBhcnNlcl90b2tlbi5jdXN0b21fYmVhdXRpZmllcl9uYW1lID0gZ2V0X2N1c3RvbV9iZWF1dGlmaWVyX25hbWUocGFyc2VyX3Rva2VuLnRhZ19jaGVjaywgcmF3X3Rva2VuKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoaW5fYXJyYXkocGFyc2VyX3Rva2VuLnRhZ19jaGVjaywgdGhpcy5fb3B0aW9ucy5leHRyYV9saW5lcnMpKSB7IC8vY2hlY2sgaWYgdGhpcyBkb3VibGUgbmVlZHMgYW4gZXh0cmEgbGluZVxuICAgIHByaW50ZXIucHJpbnRfbmV3bGluZShmYWxzZSk7XG4gICAgaWYgKCFwcmludGVyLl9vdXRwdXQuanVzdF9hZGRlZF9ibGFua2xpbmUoKSkge1xuICAgICAgcHJpbnRlci5wcmludF9uZXdsaW5lKHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwYXJzZXJfdG9rZW4uaXNfZW1wdHlfZWxlbWVudCkgeyAvL2lmIHRoaXMgdGFnIG5hbWUgaXMgYSBzaW5nbGUgdGFnIHR5cGUgKGVpdGhlciBpbiB0aGUgbGlzdCBvciBoYXMgYSBjbG9zaW5nIC8pXG5cbiAgICAvLyBpZiB5b3UgaGl0IGFuIGVsc2UgY2FzZSwgcmVzZXQgdGhlIGluZGVudCBsZXZlbCBpZiB5b3UgYXJlIGluc2lkZSBhbjpcbiAgICAvLyAnaWYnLCAndW5sZXNzJywgb3IgJ2VhY2gnIGJsb2NrLlxuICAgIGlmIChwYXJzZXJfdG9rZW4udGFnX3N0YXJ0X2NoYXIgPT09ICd7JyAmJiBwYXJzZXJfdG9rZW4udGFnX2NoZWNrID09PSAnZWxzZScpIHtcbiAgICAgIHRoaXMuX3RhZ19zdGFjay5pbmRlbnRfdG9fdGFnKFsnaWYnLCAndW5sZXNzJywgJ2VhY2gnXSk7XG4gICAgICBwYXJzZXJfdG9rZW4uaW5kZW50X2NvbnRlbnQgPSB0cnVlO1xuICAgICAgLy8gRG9uJ3QgYWRkIGEgbmV3bGluZSBpZiBvcGVuaW5nIHt7I2lmfX0gdGFnIGlzIG9uIHRoZSBjdXJyZW50IGxpbmVcbiAgICAgIHZhciBmb3VuZElmT25DdXJyZW50TGluZSA9IHByaW50ZXIuY3VycmVudF9saW5lX2hhc19tYXRjaCgve3sjaWYvKTtcbiAgICAgIGlmICghZm91bmRJZk9uQ3VycmVudExpbmUpIHtcbiAgICAgICAgcHJpbnRlci5wcmludF9uZXdsaW5lKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEb24ndCBhZGQgYSBuZXdsaW5lIGJlZm9yZSBlbGVtZW50cyB0aGF0IHNob3VsZCByZW1haW4gd2hlcmUgdGhleSBhcmUuXG4gICAgaWYgKHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJyEtLScgJiYgbGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5UQUdfQ0xPU0UgJiZcbiAgICAgIGxhc3RfdGFnX3Rva2VuLmlzX2VuZF90YWcgJiYgcGFyc2VyX3Rva2VuLnRleHQuaW5kZXhPZignXFxuJykgPT09IC0xKSB7XG4gICAgICAvL0RvIG5vdGhpbmcuIExlYXZlIGNvbW1lbnRzIG9uIHNhbWUgbGluZS5cbiAgICB9IGVsc2UgaWYgKCFwYXJzZXJfdG9rZW4uaXNfaW5saW5lX2VsZW1lbnQgJiYgIXBhcnNlcl90b2tlbi5pc191bmZvcm1hdHRlZCkge1xuICAgICAgcHJpbnRlci5wcmludF9uZXdsaW5lKGZhbHNlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocGFyc2VyX3Rva2VuLmlzX3VuZm9ybWF0dGVkIHx8IHBhcnNlcl90b2tlbi5pc19jb250ZW50X3VuZm9ybWF0dGVkKSB7XG4gICAgaWYgKCFwYXJzZXJfdG9rZW4uaXNfaW5saW5lX2VsZW1lbnQgJiYgIXBhcnNlcl90b2tlbi5pc191bmZvcm1hdHRlZCkge1xuICAgICAgcHJpbnRlci5wcmludF9uZXdsaW5lKGZhbHNlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocGFyc2VyX3Rva2VuLmlzX2VuZF90YWcpIHsgLy90aGlzIHRhZyBpcyBhIGRvdWJsZSB0YWcgc28gY2hlY2sgZm9yIHRhZy1lbmRpbmdcbiAgICBpZiAoKHBhcnNlcl90b2tlbi5zdGFydF90YWdfdG9rZW4gJiYgcGFyc2VyX3Rva2VuLnN0YXJ0X3RhZ190b2tlbi5tdWx0aWxpbmVfY29udGVudCkgfHxcbiAgICAgICEocGFyc2VyX3Rva2VuLmlzX2lubGluZV9lbGVtZW50IHx8XG4gICAgICAgIChsYXN0X3RhZ190b2tlbi5pc19pbmxpbmVfZWxlbWVudCkgfHxcbiAgICAgICAgKGxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uVEFHX0NMT1NFICYmXG4gICAgICAgICAgcGFyc2VyX3Rva2VuLnN0YXJ0X3RhZ190b2tlbiA9PT0gbGFzdF90YWdfdG9rZW4pIHx8XG4gICAgICAgIChsYXN0X3Rva2VuLnR5cGUgPT09ICdUS19DT05URU5UJylcbiAgICAgICkpIHtcbiAgICAgIHByaW50ZXIucHJpbnRfbmV3bGluZShmYWxzZSk7XG4gICAgfVxuICB9IGVsc2UgeyAvLyBpdCdzIGEgc3RhcnQtdGFnXG4gICAgcGFyc2VyX3Rva2VuLmluZGVudF9jb250ZW50ID0gIXBhcnNlcl90b2tlbi5jdXN0b21fYmVhdXRpZmllcl9uYW1lO1xuXG4gICAgaWYgKHBhcnNlcl90b2tlbi50YWdfc3RhcnRfY2hhciA9PT0gJzwnKSB7XG4gICAgICBpZiAocGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAnaHRtbCcpIHtcbiAgICAgICAgcGFyc2VyX3Rva2VuLmluZGVudF9jb250ZW50ID0gdGhpcy5fb3B0aW9ucy5pbmRlbnRfaW5uZXJfaHRtbDtcbiAgICAgIH0gZWxzZSBpZiAocGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAnaGVhZCcpIHtcbiAgICAgICAgcGFyc2VyX3Rva2VuLmluZGVudF9jb250ZW50ID0gdGhpcy5fb3B0aW9ucy5pbmRlbnRfaGVhZF9pbm5lcl9odG1sO1xuICAgICAgfSBlbHNlIGlmIChwYXJzZXJfdG9rZW4udGFnX25hbWUgPT09ICdib2R5Jykge1xuICAgICAgICBwYXJzZXJfdG9rZW4uaW5kZW50X2NvbnRlbnQgPSB0aGlzLl9vcHRpb25zLmluZGVudF9ib2R5X2lubmVyX2h0bWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFwYXJzZXJfdG9rZW4uaXNfaW5saW5lX2VsZW1lbnQgJiYgbGFzdF90b2tlbi50eXBlICE9PSAnVEtfQ09OVEVOVCcpIHtcbiAgICAgIGlmIChwYXJzZXJfdG9rZW4ucGFyZW50KSB7XG4gICAgICAgIHBhcnNlcl90b2tlbi5wYXJlbnQubXVsdGlsaW5lX2NvbnRlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcHJpbnRlci5wcmludF9uZXdsaW5lKGZhbHNlKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vVG8gYmUgdXNlZCBmb3IgPHA+IHRhZyBzcGVjaWFsIGNhc2U6XG4vL3ZhciBwX2Nsb3NlcnMgPSBbJ2FkZHJlc3MnLCAnYXJ0aWNsZScsICdhc2lkZScsICdibG9ja3F1b3RlJywgJ2RldGFpbHMnLCAnZGl2JywgJ2RsJywgJ2ZpZWxkc2V0JywgJ2ZpZ2NhcHRpb24nLCAnZmlndXJlJywgJ2Zvb3RlcicsICdmb3JtJywgJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2JywgJ2hlYWRlcicsICdocicsICdtYWluJywgJ25hdicsICdvbCcsICdwJywgJ3ByZScsICdzZWN0aW9uJywgJ3RhYmxlJywgJ3VsJ107XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLl9kb19vcHRpb25hbF9lbmRfZWxlbWVudCA9IGZ1bmN0aW9uKHBhcnNlcl90b2tlbikge1xuICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgLy8gTk9URTogY2FzZXMgb2YgXCJpZiB0aGVyZSBpcyBubyBtb3JlIGNvbnRlbnQgaW4gdGhlIHBhcmVudCBlbGVtZW50XCJcbiAgLy8gYXJlIGhhbmRsZWQgYXV0b21hdGljYWxseSBieSB0aGUgYmVhdXRpZmllci5cbiAgLy8gSXQgYXNzdW1lcyBwYXJlbnQgb3IgYW5jZXN0b3IgY2xvc2UgdGFnIGNsb3NlcyBhbGwgY2hpbGRyZW4uXG4gIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNvcHRpb25hbC10YWdzXG4gIGlmIChwYXJzZXJfdG9rZW4uaXNfZW1wdHlfZWxlbWVudCB8fCAhcGFyc2VyX3Rva2VuLmlzX3N0YXJ0X3RhZyB8fCAhcGFyc2VyX3Rva2VuLnBhcmVudCkge1xuICAgIHJldHVybjtcblxuICB9IGVsc2UgaWYgKHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJ2JvZHknKSB7XG4gICAgLy8gQSBoZWFkIGVsZW1lbnTigJlzIGVuZCB0YWcgbWF5IGJlIG9taXR0ZWQgaWYgdGhlIGhlYWQgZWxlbWVudCBpcyBub3QgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYSBzcGFjZSBjaGFyYWN0ZXIgb3IgYSBjb21tZW50LlxuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcCgnaGVhZCcpO1xuXG4gICAgLy99IGVsc2UgaWYgKHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJ2JvZHknKSB7XG4gICAgLy8gRE9ORTogQSBib2R5IGVsZW1lbnTigJlzIGVuZCB0YWcgbWF5IGJlIG9taXR0ZWQgaWYgdGhlIGJvZHkgZWxlbWVudCBpcyBub3QgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYSBjb21tZW50LlxuXG4gIH0gZWxzZSBpZiAocGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAnbGknKSB7XG4gICAgLy8gQW4gbGkgZWxlbWVudOKAmXMgZW5kIHRhZyBtYXkgYmUgb21pdHRlZCBpZiB0aGUgbGkgZWxlbWVudCBpcyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhbm90aGVyIGxpIGVsZW1lbnQgb3IgaWYgdGhlcmUgaXMgbm8gbW9yZSBjb250ZW50IGluIHRoZSBwYXJlbnQgZWxlbWVudC5cbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AoJ2xpJywgWydvbCcsICd1bCddKTtcblxuICB9IGVsc2UgaWYgKHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJ2RkJyB8fCBwYXJzZXJfdG9rZW4udGFnX25hbWUgPT09ICdkdCcpIHtcbiAgICAvLyBBIGRkIGVsZW1lbnTigJlzIGVuZCB0YWcgbWF5IGJlIG9taXR0ZWQgaWYgdGhlIGRkIGVsZW1lbnQgaXMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYW5vdGhlciBkZCBlbGVtZW50IG9yIGEgZHQgZWxlbWVudCwgb3IgaWYgdGhlcmUgaXMgbm8gbW9yZSBjb250ZW50IGluIHRoZSBwYXJlbnQgZWxlbWVudC5cbiAgICAvLyBBIGR0IGVsZW1lbnTigJlzIGVuZCB0YWcgbWF5IGJlIG9taXR0ZWQgaWYgdGhlIGR0IGVsZW1lbnQgaXMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYW5vdGhlciBkdCBlbGVtZW50IG9yIGEgZGQgZWxlbWVudC5cbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AoJ2R0JywgWydkbCddKTtcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AoJ2RkJywgWydkbCddKTtcblxuICAgIC8vfSBlbHNlIGlmIChwX2Nsb3NlcnMuaW5kZXhPZihwYXJzZXJfdG9rZW4udGFnX25hbWUpICE9PSAtMSkge1xuICAgIC8vVE9ETzogVEhJUyBJUyBBIEJVRyBGQVJNLiBXZSBhcmUgbm90IHB1dHRpbmcgdGhpcyBpbnRvIDEuOC4wIGFzIGl0IGlzIGxpa2VseSB0byBibG93IHVwLlxuICAgIC8vQSBwIGVsZW1lbnTigJlzIGVuZCB0YWcgbWF5IGJlIG9taXR0ZWQgaWYgdGhlIHAgZWxlbWVudCBpcyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhbiBhZGRyZXNzLCBhcnRpY2xlLCBhc2lkZSwgYmxvY2txdW90ZSwgZGV0YWlscywgZGl2LCBkbCwgZmllbGRzZXQsIGZpZ2NhcHRpb24sIGZpZ3VyZSwgZm9vdGVyLCBmb3JtLCBoMSwgaDIsIGgzLCBoNCwgaDUsIGg2LCBoZWFkZXIsIGhyLCBtYWluLCBuYXYsIG9sLCBwLCBwcmUsIHNlY3Rpb24sIHRhYmxlLCBvciB1bCBlbGVtZW50LCBvciBpZiB0aGVyZSBpcyBubyBtb3JlIGNvbnRlbnQgaW4gdGhlIHBhcmVudCBlbGVtZW50IGFuZCB0aGUgcGFyZW50IGVsZW1lbnQgaXMgYW4gSFRNTCBlbGVtZW50IHRoYXQgaXMgbm90IGFuIGEsIGF1ZGlvLCBkZWwsIGlucywgbWFwLCBub3NjcmlwdCwgb3IgdmlkZW8gZWxlbWVudCwgb3IgYW4gYXV0b25vbW91cyBjdXN0b20gZWxlbWVudC5cbiAgICAvL3Jlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcCgncCcsIFsnYm9keSddKTtcblxuICB9IGVsc2UgaWYgKHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJ3JwJyB8fCBwYXJzZXJfdG9rZW4udGFnX25hbWUgPT09ICdydCcpIHtcbiAgICAvLyBBbiBydCBlbGVtZW504oCZcyBlbmQgdGFnIG1heSBiZSBvbWl0dGVkIGlmIHRoZSBydCBlbGVtZW50IGlzIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGFuIHJ0IG9yIHJwIGVsZW1lbnQsIG9yIGlmIHRoZXJlIGlzIG5vIG1vcmUgY29udGVudCBpbiB0aGUgcGFyZW50IGVsZW1lbnQuXG4gICAgLy8gQW4gcnAgZWxlbWVudOKAmXMgZW5kIHRhZyBtYXkgYmUgb21pdHRlZCBpZiB0aGUgcnAgZWxlbWVudCBpcyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhbiBydCBvciBycCBlbGVtZW50LCBvciBpZiB0aGVyZSBpcyBubyBtb3JlIGNvbnRlbnQgaW4gdGhlIHBhcmVudCBlbGVtZW50LlxuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcCgncnQnLCBbJ3J1YnknLCAncnRjJ10pO1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcCgncnAnLCBbJ3J1YnknLCAncnRjJ10pO1xuXG4gIH0gZWxzZSBpZiAocGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAnb3B0Z3JvdXAnKSB7XG4gICAgLy8gQW4gb3B0Z3JvdXAgZWxlbWVudOKAmXMgZW5kIHRhZyBtYXkgYmUgb21pdHRlZCBpZiB0aGUgb3B0Z3JvdXAgZWxlbWVudCBpcyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhbm90aGVyIG9wdGdyb3VwIGVsZW1lbnQsIG9yIGlmIHRoZXJlIGlzIG5vIG1vcmUgY29udGVudCBpbiB0aGUgcGFyZW50IGVsZW1lbnQuXG4gICAgLy8gQW4gb3B0aW9uIGVsZW1lbnTigJlzIGVuZCB0YWcgbWF5IGJlIG9taXR0ZWQgaWYgdGhlIG9wdGlvbiBlbGVtZW50IGlzIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGFub3RoZXIgb3B0aW9uIGVsZW1lbnQsIG9yIGlmIGl0IGlzIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGFuIG9wdGdyb3VwIGVsZW1lbnQsIG9yIGlmIHRoZXJlIGlzIG5vIG1vcmUgY29udGVudCBpbiB0aGUgcGFyZW50IGVsZW1lbnQuXG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuX3RhZ19zdGFjay50cnlfcG9wKCdvcHRncm91cCcsIFsnc2VsZWN0J10pO1xuICAgIC8vcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuX3RhZ19zdGFjay50cnlfcG9wKCdvcHRpb24nLCBbJ3NlbGVjdCddKTtcblxuICB9IGVsc2UgaWYgKHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJ29wdGlvbicpIHtcbiAgICAvLyBBbiBvcHRpb24gZWxlbWVudOKAmXMgZW5kIHRhZyBtYXkgYmUgb21pdHRlZCBpZiB0aGUgb3B0aW9uIGVsZW1lbnQgaXMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYW5vdGhlciBvcHRpb24gZWxlbWVudCwgb3IgaWYgaXQgaXMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYW4gb3B0Z3JvdXAgZWxlbWVudCwgb3IgaWYgdGhlcmUgaXMgbm8gbW9yZSBjb250ZW50IGluIHRoZSBwYXJlbnQgZWxlbWVudC5cbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AoJ29wdGlvbicsIFsnc2VsZWN0JywgJ2RhdGFsaXN0JywgJ29wdGdyb3VwJ10pO1xuXG4gIH0gZWxzZSBpZiAocGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAnY29sZ3JvdXAnKSB7XG4gICAgLy8gRE9ORTogQSBjb2xncm91cCBlbGVtZW504oCZcyBlbmQgdGFnIG1heSBiZSBvbWl0dGVkIGlmIHRoZSBjb2xncm91cCBlbGVtZW50IGlzIG5vdCBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhIHNwYWNlIGNoYXJhY3RlciBvciBhIGNvbW1lbnQuXG4gICAgLy8gQSBjYXB0aW9uIGVsZW1lbnQncyBlbmQgdGFnIG1heSBiZSBvbW1pdHRlZCBpZiBhIGNvbGdyb3VwLCB0aGVhZCwgdGZvb3QsIHRib2R5LCBvciB0ciBlbGVtZW50IGlzIHN0YXJ0ZWQuXG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuX3RhZ19zdGFjay50cnlfcG9wKCdjYXB0aW9uJywgWyd0YWJsZSddKTtcblxuICB9IGVsc2UgaWYgKHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJ3RoZWFkJykge1xuICAgIC8vIEEgY29sZ3JvdXAgZWxlbWVudCdzIGVuZCB0YWcgbWF5IGJlIG9tbWl0dGVkIGlmIGEgdGhlYWQsIHRmb290LCB0Ym9keSwgb3IgdHIgZWxlbWVudCBpcyBzdGFydGVkLlxuICAgIC8vIEEgY2FwdGlvbiBlbGVtZW50J3MgZW5kIHRhZyBtYXkgYmUgb21taXR0ZWQgaWYgYSBjb2xncm91cCwgdGhlYWQsIHRmb290LCB0Ym9keSwgb3IgdHIgZWxlbWVudCBpcyBzdGFydGVkLlxuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcCgnY2FwdGlvbicsIFsndGFibGUnXSk7XG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuX3RhZ19zdGFjay50cnlfcG9wKCdjb2xncm91cCcsIFsndGFibGUnXSk7XG5cbiAgICAvL30gZWxzZSBpZiAocGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAnY2FwdGlvbicpIHtcbiAgICAvLyBET05FOiBBIGNhcHRpb24gZWxlbWVudOKAmXMgZW5kIHRhZyBtYXkgYmUgb21pdHRlZCBpZiB0aGUgY2FwdGlvbiBlbGVtZW50IGlzIG5vdCBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhIHNwYWNlIGNoYXJhY3RlciBvciBhIGNvbW1lbnQuXG5cbiAgfSBlbHNlIGlmIChwYXJzZXJfdG9rZW4udGFnX25hbWUgPT09ICd0Ym9keScgfHwgcGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAndGZvb3QnKSB7XG4gICAgLy8gQSB0aGVhZCBlbGVtZW504oCZcyBlbmQgdGFnIG1heSBiZSBvbWl0dGVkIGlmIHRoZSB0aGVhZCBlbGVtZW50IGlzIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGEgdGJvZHkgb3IgdGZvb3QgZWxlbWVudC5cbiAgICAvLyBBIHRib2R5IGVsZW1lbnTigJlzIGVuZCB0YWcgbWF5IGJlIG9taXR0ZWQgaWYgdGhlIHRib2R5IGVsZW1lbnQgaXMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYSB0Ym9keSBvciB0Zm9vdCBlbGVtZW50LCBvciBpZiB0aGVyZSBpcyBubyBtb3JlIGNvbnRlbnQgaW4gdGhlIHBhcmVudCBlbGVtZW50LlxuICAgIC8vIEEgY29sZ3JvdXAgZWxlbWVudCdzIGVuZCB0YWcgbWF5IGJlIG9tbWl0dGVkIGlmIGEgdGhlYWQsIHRmb290LCB0Ym9keSwgb3IgdHIgZWxlbWVudCBpcyBzdGFydGVkLlxuICAgIC8vIEEgY2FwdGlvbiBlbGVtZW50J3MgZW5kIHRhZyBtYXkgYmUgb21taXR0ZWQgaWYgYSBjb2xncm91cCwgdGhlYWQsIHRmb290LCB0Ym9keSwgb3IgdHIgZWxlbWVudCBpcyBzdGFydGVkLlxuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcCgnY2FwdGlvbicsIFsndGFibGUnXSk7XG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuX3RhZ19zdGFjay50cnlfcG9wKCdjb2xncm91cCcsIFsndGFibGUnXSk7XG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuX3RhZ19zdGFjay50cnlfcG9wKCd0aGVhZCcsIFsndGFibGUnXSk7XG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuX3RhZ19zdGFjay50cnlfcG9wKCd0Ym9keScsIFsndGFibGUnXSk7XG5cbiAgICAvL30gZWxzZSBpZiAocGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAndGZvb3QnKSB7XG4gICAgLy8gRE9ORTogQSB0Zm9vdCBlbGVtZW504oCZcyBlbmQgdGFnIG1heSBiZSBvbWl0dGVkIGlmIHRoZXJlIGlzIG5vIG1vcmUgY29udGVudCBpbiB0aGUgcGFyZW50IGVsZW1lbnQuXG5cbiAgfSBlbHNlIGlmIChwYXJzZXJfdG9rZW4udGFnX25hbWUgPT09ICd0cicpIHtcbiAgICAvLyBBIHRyIGVsZW1lbnTigJlzIGVuZCB0YWcgbWF5IGJlIG9taXR0ZWQgaWYgdGhlIHRyIGVsZW1lbnQgaXMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYW5vdGhlciB0ciBlbGVtZW50LCBvciBpZiB0aGVyZSBpcyBubyBtb3JlIGNvbnRlbnQgaW4gdGhlIHBhcmVudCBlbGVtZW50LlxuICAgIC8vIEEgY29sZ3JvdXAgZWxlbWVudCdzIGVuZCB0YWcgbWF5IGJlIG9tbWl0dGVkIGlmIGEgdGhlYWQsIHRmb290LCB0Ym9keSwgb3IgdHIgZWxlbWVudCBpcyBzdGFydGVkLlxuICAgIC8vIEEgY2FwdGlvbiBlbGVtZW50J3MgZW5kIHRhZyBtYXkgYmUgb21taXR0ZWQgaWYgYSBjb2xncm91cCwgdGhlYWQsIHRmb290LCB0Ym9keSwgb3IgdHIgZWxlbWVudCBpcyBzdGFydGVkLlxuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcCgnY2FwdGlvbicsIFsndGFibGUnXSk7XG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuX3RhZ19zdGFjay50cnlfcG9wKCdjb2xncm91cCcsIFsndGFibGUnXSk7XG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuX3RhZ19zdGFjay50cnlfcG9wKCd0cicsIFsndGFibGUnLCAndGhlYWQnLCAndGJvZHknLCAndGZvb3QnXSk7XG5cbiAgfSBlbHNlIGlmIChwYXJzZXJfdG9rZW4udGFnX25hbWUgPT09ICd0aCcgfHwgcGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAndGQnKSB7XG4gICAgLy8gQSB0ZCBlbGVtZW504oCZcyBlbmQgdGFnIG1heSBiZSBvbWl0dGVkIGlmIHRoZSB0ZCBlbGVtZW50IGlzIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGEgdGQgb3IgdGggZWxlbWVudCwgb3IgaWYgdGhlcmUgaXMgbm8gbW9yZSBjb250ZW50IGluIHRoZSBwYXJlbnQgZWxlbWVudC5cbiAgICAvLyBBIHRoIGVsZW1lbnTigJlzIGVuZCB0YWcgbWF5IGJlIG9taXR0ZWQgaWYgdGhlIHRoIGVsZW1lbnQgaXMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYSB0ZCBvciB0aCBlbGVtZW50LCBvciBpZiB0aGVyZSBpcyBubyBtb3JlIGNvbnRlbnQgaW4gdGhlIHBhcmVudCBlbGVtZW50LlxuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcCgndGQnLCBbJ3RhYmxlJywgJ3RoZWFkJywgJ3Rib2R5JywgJ3Rmb290JywgJ3RyJ10pO1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcCgndGgnLCBbJ3RhYmxlJywgJ3RoZWFkJywgJ3Rib2R5JywgJ3Rmb290JywgJ3RyJ10pO1xuICB9XG5cbiAgLy8gU3RhcnQgZWxlbWVudCBvbWlzc2lvbiBub3QgaGFuZGxlZCBjdXJyZW50bHlcbiAgLy8gQSBoZWFkIGVsZW1lbnTigJlzIHN0YXJ0IHRhZyBtYXkgYmUgb21pdHRlZCBpZiB0aGUgZWxlbWVudCBpcyBlbXB0eSwgb3IgaWYgdGhlIGZpcnN0IHRoaW5nIGluc2lkZSB0aGUgaGVhZCBlbGVtZW50IGlzIGFuIGVsZW1lbnQuXG4gIC8vIEEgdGJvZHkgZWxlbWVudOKAmXMgc3RhcnQgdGFnIG1heSBiZSBvbWl0dGVkIGlmIHRoZSBmaXJzdCB0aGluZyBpbnNpZGUgdGhlIHRib2R5IGVsZW1lbnQgaXMgYSB0ciBlbGVtZW50LCBhbmQgaWYgdGhlIGVsZW1lbnQgaXMgbm90IGltbWVkaWF0ZWx5IHByZWNlZGVkIGJ5IGEgdGJvZHksIHRoZWFkLCBvciB0Zm9vdCBlbGVtZW50IHdob3NlIGVuZCB0YWcgaGFzIGJlZW4gb21pdHRlZC4gKEl0IGNhbuKAmXQgYmUgb21pdHRlZCBpZiB0aGUgZWxlbWVudCBpcyBlbXB0eS4pXG4gIC8vIEEgY29sZ3JvdXAgZWxlbWVudOKAmXMgc3RhcnQgdGFnIG1heSBiZSBvbWl0dGVkIGlmIHRoZSBmaXJzdCB0aGluZyBpbnNpZGUgdGhlIGNvbGdyb3VwIGVsZW1lbnQgaXMgYSBjb2wgZWxlbWVudCwgYW5kIGlmIHRoZSBlbGVtZW50IGlzIG5vdCBpbW1lZGlhdGVseSBwcmVjZWRlZCBieSBhbm90aGVyIGNvbGdyb3VwIGVsZW1lbnQgd2hvc2UgZW5kIHRhZyBoYXMgYmVlbiBvbWl0dGVkLiAoSXQgY2Fu4oCZdCBiZSBvbWl0dGVkIGlmIHRoZSBlbGVtZW50IGlzIGVtcHR5LilcblxuICAvLyBGaXggdXAgdGhlIHBhcmVudCBvZiB0aGUgcGFyc2VyIHRva2VuXG4gIHBhcnNlcl90b2tlbi5wYXJlbnQgPSB0aGlzLl90YWdfc3RhY2suZ2V0X3BhcnNlcl90b2tlbigpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5CZWF1dGlmaWVyID0gQmVhdXRpZmllcjtcbiIsIi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBCZWF1dGlmaWVyID0gcmVxdWlyZSgnLi9iZWF1dGlmaWVyJykuQmVhdXRpZmllcixcbiAgT3B0aW9ucyA9IHJlcXVpcmUoJy4vb3B0aW9ucycpLk9wdGlvbnM7XG5cbmZ1bmN0aW9uIHN0eWxlX2h0bWwoaHRtbF9zb3VyY2UsIG9wdGlvbnMsIGpzX2JlYXV0aWZ5LCBjc3NfYmVhdXRpZnkpIHtcbiAgdmFyIGJlYXV0aWZpZXIgPSBuZXcgQmVhdXRpZmllcihodG1sX3NvdXJjZSwgb3B0aW9ucywganNfYmVhdXRpZnksIGNzc19iZWF1dGlmeSk7XG4gIHJldHVybiBiZWF1dGlmaWVyLmJlYXV0aWZ5KCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R5bGVfaHRtbDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgT3B0aW9ucygpO1xufTtcbiIsIi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBCYXNlT3B0aW9ucyA9IHJlcXVpcmUoJy4uL2NvcmUvb3B0aW9ucycpLk9wdGlvbnM7XG5cbmZ1bmN0aW9uIE9wdGlvbnMob3B0aW9ucykge1xuICBCYXNlT3B0aW9ucy5jYWxsKHRoaXMsIG9wdGlvbnMsICdodG1sJyk7XG4gIGlmICh0aGlzLnRlbXBsYXRpbmcubGVuZ3RoID09PSAxICYmIHRoaXMudGVtcGxhdGluZ1swXSA9PT0gJ2F1dG8nKSB7XG4gICAgdGhpcy50ZW1wbGF0aW5nID0gWydkamFuZ28nLCAnZXJiJywgJ2hhbmRsZWJhcnMnLCAncGhwJ107XG4gIH1cblxuICB0aGlzLmluZGVudF9pbm5lcl9odG1sID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ2luZGVudF9pbm5lcl9odG1sJyk7XG4gIHRoaXMuaW5kZW50X2JvZHlfaW5uZXJfaHRtbCA9IHRoaXMuX2dldF9ib29sZWFuKCdpbmRlbnRfYm9keV9pbm5lcl9odG1sJywgdHJ1ZSk7XG4gIHRoaXMuaW5kZW50X2hlYWRfaW5uZXJfaHRtbCA9IHRoaXMuX2dldF9ib29sZWFuKCdpbmRlbnRfaGVhZF9pbm5lcl9odG1sJywgdHJ1ZSk7XG5cbiAgdGhpcy5pbmRlbnRfaGFuZGxlYmFycyA9IHRoaXMuX2dldF9ib29sZWFuKCdpbmRlbnRfaGFuZGxlYmFycycsIHRydWUpO1xuICB0aGlzLndyYXBfYXR0cmlidXRlcyA9IHRoaXMuX2dldF9zZWxlY3Rpb24oJ3dyYXBfYXR0cmlidXRlcycsXG4gICAgWydhdXRvJywgJ2ZvcmNlJywgJ2ZvcmNlLWFsaWduZWQnLCAnZm9yY2UtZXhwYW5kLW11bHRpbGluZScsICdhbGlnbmVkLW11bHRpcGxlJywgJ3ByZXNlcnZlJywgJ3ByZXNlcnZlLWFsaWduZWQnXSk7XG4gIHRoaXMud3JhcF9hdHRyaWJ1dGVzX2luZGVudF9zaXplID0gdGhpcy5fZ2V0X251bWJlcignd3JhcF9hdHRyaWJ1dGVzX2luZGVudF9zaXplJywgdGhpcy5pbmRlbnRfc2l6ZSk7XG4gIHRoaXMuZXh0cmFfbGluZXJzID0gdGhpcy5fZ2V0X2FycmF5KCdleHRyYV9saW5lcnMnLCBbJ2hlYWQnLCAnYm9keScsICcvaHRtbCddKTtcblxuICAvLyBCbG9jayB2cyBpbmxpbmUgZWxlbWVudHNcbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9CbG9jay1sZXZlbF9lbGVtZW50c1xuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0lubGluZV9lbGVtZW50c1xuICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZG9tLmh0bWwjcGhyYXNpbmctY29udGVudFxuICB0aGlzLmlubGluZSA9IHRoaXMuX2dldF9hcnJheSgnaW5saW5lJywgW1xuICAgICdhJywgJ2FiYnInLCAnYXJlYScsICdhdWRpbycsICdiJywgJ2JkaScsICdiZG8nLCAnYnInLCAnYnV0dG9uJywgJ2NhbnZhcycsICdjaXRlJyxcbiAgICAnY29kZScsICdkYXRhJywgJ2RhdGFsaXN0JywgJ2RlbCcsICdkZm4nLCAnZW0nLCAnZW1iZWQnLCAnaScsICdpZnJhbWUnLCAnaW1nJyxcbiAgICAnaW5wdXQnLCAnaW5zJywgJ2tiZCcsICdrZXlnZW4nLCAnbGFiZWwnLCAnbWFwJywgJ21hcmsnLCAnbWF0aCcsICdtZXRlcicsICdub3NjcmlwdCcsXG4gICAgJ29iamVjdCcsICdvdXRwdXQnLCAncHJvZ3Jlc3MnLCAncScsICdydWJ5JywgJ3MnLCAnc2FtcCcsIC8qICdzY3JpcHQnLCAqLyAnc2VsZWN0JywgJ3NtYWxsJyxcbiAgICAnc3BhbicsICdzdHJvbmcnLCAnc3ViJywgJ3N1cCcsICdzdmcnLCAndGVtcGxhdGUnLCAndGV4dGFyZWEnLCAndGltZScsICd1JywgJ3ZhcicsXG4gICAgJ3ZpZGVvJywgJ3dicicsICd0ZXh0JyxcbiAgICAvLyBvYnNvbGV0ZSBpbmxpbmUgdGFnc1xuICAgICdhY3JvbnltJywgJ2JpZycsICdzdHJpa2UnLCAndHQnXG4gIF0pO1xuICB0aGlzLnZvaWRfZWxlbWVudHMgPSB0aGlzLl9nZXRfYXJyYXkoJ3ZvaWRfZWxlbWVudHMnLCBbXG4gICAgLy8gSFRMTSB2b2lkIGVsZW1lbnRzIC0gYWthIHNlbGYtY2xvc2luZyB0YWdzIC0gYWthIHNpbmdsZXRvbnNcbiAgICAvLyBodHRwczovL3d3dy53My5vcmcvaHRtbC93Zy9kcmFmdHMvaHRtbC9tYXN0ZXIvc3ludGF4Lmh0bWwjdm9pZC1lbGVtZW50c1xuICAgICdhcmVhJywgJ2Jhc2UnLCAnYnInLCAnY29sJywgJ2VtYmVkJywgJ2hyJywgJ2ltZycsICdpbnB1dCcsICdrZXlnZW4nLFxuICAgICdsaW5rJywgJ21lbnVpdGVtJywgJ21ldGEnLCAncGFyYW0nLCAnc291cmNlJywgJ3RyYWNrJywgJ3dicicsXG4gICAgLy8gTk9URTogT3B0aW9uYWwgdGFncyBhcmUgdG9vIGNvbXBsZXggZm9yIGEgc2ltcGxlIGxpc3RcbiAgICAvLyB0aGV5IGFyZSBoYXJkIGNvZGVkIGluIF9kb19vcHRpb25hbF9lbmRfZWxlbWVudFxuXG4gICAgLy8gRG9jdHlwZSBhbmQgeG1sIGVsZW1lbnRzXG4gICAgJyFkb2N0eXBlJywgJz94bWwnLFxuXG4gICAgLy8gb2Jzb2xldGUgdGFnc1xuICAgIC8vIGJhc2Vmb250OiBodHRwczovL3d3dy5jb21wdXRlcmhvcGUuY29tL2phcmdvbi9oL2h0bWwtYmFzZWZvbnQtdGFnLmh0bVxuICAgIC8vIGlzbmRleDogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L2lzaW5kZXhcbiAgICAnYmFzZWZvbnQnLCAnaXNpbmRleCdcbiAgXSk7XG4gIHRoaXMudW5mb3JtYXR0ZWQgPSB0aGlzLl9nZXRfYXJyYXkoJ3VuZm9ybWF0dGVkJywgW10pO1xuICB0aGlzLmNvbnRlbnRfdW5mb3JtYXR0ZWQgPSB0aGlzLl9nZXRfYXJyYXkoJ2NvbnRlbnRfdW5mb3JtYXR0ZWQnLCBbXG4gICAgJ3ByZScsICd0ZXh0YXJlYSdcbiAgXSk7XG4gIHRoaXMudW5mb3JtYXR0ZWRfY29udGVudF9kZWxpbWl0ZXIgPSB0aGlzLl9nZXRfY2hhcmFjdGVycygndW5mb3JtYXR0ZWRfY29udGVudF9kZWxpbWl0ZXInKTtcbiAgdGhpcy5pbmRlbnRfc2NyaXB0cyA9IHRoaXMuX2dldF9zZWxlY3Rpb24oJ2luZGVudF9zY3JpcHRzJywgWydub3JtYWwnLCAna2VlcCcsICdzZXBhcmF0ZSddKTtcblxufVxuT3B0aW9ucy5wcm90b3R5cGUgPSBuZXcgQmFzZU9wdGlvbnMoKTtcblxuXG5cbm1vZHVsZS5leHBvcnRzLk9wdGlvbnMgPSBPcHRpb25zO1xuIiwiLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEJhc2VUb2tlbml6ZXIgPSByZXF1aXJlKCcuLi9jb3JlL3Rva2VuaXplcicpLlRva2VuaXplcjtcbnZhciBCQVNFVE9LRU4gPSByZXF1aXJlKCcuLi9jb3JlL3Rva2VuaXplcicpLlRPS0VOO1xudmFyIERpcmVjdGl2ZXMgPSByZXF1aXJlKCcuLi9jb3JlL2RpcmVjdGl2ZXMnKS5EaXJlY3RpdmVzO1xudmFyIFRlbXBsYXRhYmxlUGF0dGVybiA9IHJlcXVpcmUoJy4uL2NvcmUvdGVtcGxhdGFibGVwYXR0ZXJuJykuVGVtcGxhdGFibGVQYXR0ZXJuO1xudmFyIFBhdHRlcm4gPSByZXF1aXJlKCcuLi9jb3JlL3BhdHRlcm4nKS5QYXR0ZXJuO1xuXG52YXIgVE9LRU4gPSB7XG4gIFRBR19PUEVOOiAnVEtfVEFHX09QRU4nLFxuICBUQUdfQ0xPU0U6ICdUS19UQUdfQ0xPU0UnLFxuICBBVFRSSUJVVEU6ICdUS19BVFRSSUJVVEUnLFxuICBFUVVBTFM6ICdUS19FUVVBTFMnLFxuICBWQUxVRTogJ1RLX1ZBTFVFJyxcbiAgQ09NTUVOVDogJ1RLX0NPTU1FTlQnLFxuICBURVhUOiAnVEtfVEVYVCcsXG4gIFVOS05PV046ICdUS19VTktOT1dOJyxcbiAgU1RBUlQ6IEJBU0VUT0tFTi5TVEFSVCxcbiAgUkFXOiBCQVNFVE9LRU4uUkFXLFxuICBFT0Y6IEJBU0VUT0tFTi5FT0Zcbn07XG5cbnZhciBkaXJlY3RpdmVzX2NvcmUgPSBuZXcgRGlyZWN0aXZlcygvPFxcIS0tLywgLy0tPi8pO1xuXG52YXIgVG9rZW5pemVyID0gZnVuY3Rpb24oaW5wdXRfc3RyaW5nLCBvcHRpb25zKSB7XG4gIEJhc2VUb2tlbml6ZXIuY2FsbCh0aGlzLCBpbnB1dF9zdHJpbmcsIG9wdGlvbnMpO1xuICB0aGlzLl9jdXJyZW50X3RhZ19uYW1lID0gJyc7XG5cbiAgLy8gV29yZHMgZW5kIGF0IHdoaXRlc3BhY2Ugb3Igd2hlbiBhIHRhZyBzdGFydHNcbiAgLy8gaWYgd2UgYXJlIGluZGVudGluZyBoYW5kbGViYXJzLCB0aGV5IGFyZSBjb25zaWRlcmVkIHRhZ3NcbiAgdmFyIHRlbXBsYXRhYmxlX3JlYWRlciA9IG5ldyBUZW1wbGF0YWJsZVBhdHRlcm4odGhpcy5faW5wdXQpLnJlYWRfb3B0aW9ucyh0aGlzLl9vcHRpb25zKTtcbiAgdmFyIHBhdHRlcm5fcmVhZGVyID0gbmV3IFBhdHRlcm4odGhpcy5faW5wdXQpO1xuXG4gIHRoaXMuX19wYXR0ZXJucyA9IHtcbiAgICB3b3JkOiB0ZW1wbGF0YWJsZV9yZWFkZXIudW50aWwoL1tcXG5cXHJcXHQgPF0vKSxcbiAgICBzaW5nbGVfcXVvdGU6IHRlbXBsYXRhYmxlX3JlYWRlci51bnRpbF9hZnRlcigvJy8pLFxuICAgIGRvdWJsZV9xdW90ZTogdGVtcGxhdGFibGVfcmVhZGVyLnVudGlsX2FmdGVyKC9cIi8pLFxuICAgIGF0dHJpYnV0ZTogdGVtcGxhdGFibGVfcmVhZGVyLnVudGlsKC9bXFxuXFxyXFx0ID0+XXxcXC8+LyksXG4gICAgZWxlbWVudF9uYW1lOiB0ZW1wbGF0YWJsZV9yZWFkZXIudW50aWwoL1tcXG5cXHJcXHQgPlxcL10vKSxcblxuICAgIGhhbmRsZWJhcnNfY29tbWVudDogcGF0dGVybl9yZWFkZXIuc3RhcnRpbmdfd2l0aCgve3shLS0vKS51bnRpbF9hZnRlcigvLS19fS8pLFxuICAgIGhhbmRsZWJhcnM6IHBhdHRlcm5fcmVhZGVyLnN0YXJ0aW5nX3dpdGgoL3t7LykudW50aWxfYWZ0ZXIoL319LyksXG4gICAgaGFuZGxlYmFyc19vcGVuOiBwYXR0ZXJuX3JlYWRlci51bnRpbCgvW1xcblxcclxcdCB9XS8pLFxuICAgIGhhbmRsZWJhcnNfcmF3X2Nsb3NlOiBwYXR0ZXJuX3JlYWRlci51bnRpbCgvfX0vKSxcbiAgICBjb21tZW50OiBwYXR0ZXJuX3JlYWRlci5zdGFydGluZ193aXRoKC88IS0tLykudW50aWxfYWZ0ZXIoLy0tPi8pLFxuICAgIGNkYXRhOiBwYXR0ZXJuX3JlYWRlci5zdGFydGluZ193aXRoKC88IVxcW0NEQVRBXFxbLykudW50aWxfYWZ0ZXIoL11dPi8pLFxuICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbmRpdGlvbmFsX2NvbW1lbnRcbiAgICBjb25kaXRpb25hbF9jb21tZW50OiBwYXR0ZXJuX3JlYWRlci5zdGFydGluZ193aXRoKC88IVxcWy8pLnVudGlsX2FmdGVyKC9dPi8pLFxuICAgIHByb2Nlc3Npbmc6IHBhdHRlcm5fcmVhZGVyLnN0YXJ0aW5nX3dpdGgoLzxcXD8vKS51bnRpbF9hZnRlcigvXFw/Pi8pXG4gIH07XG5cbiAgaWYgKHRoaXMuX29wdGlvbnMuaW5kZW50X2hhbmRsZWJhcnMpIHtcbiAgICB0aGlzLl9fcGF0dGVybnMud29yZCA9IHRoaXMuX19wYXR0ZXJucy53b3JkLmV4Y2x1ZGUoJ2hhbmRsZWJhcnMnKTtcbiAgfVxuXG4gIHRoaXMuX3VuZm9ybWF0dGVkX2NvbnRlbnRfZGVsaW1pdGVyID0gbnVsbDtcblxuICBpZiAodGhpcy5fb3B0aW9ucy51bmZvcm1hdHRlZF9jb250ZW50X2RlbGltaXRlcikge1xuICAgIHZhciBsaXRlcmFsX3JlZ2V4cCA9IHRoaXMuX2lucHV0LmdldF9saXRlcmFsX3JlZ2V4cCh0aGlzLl9vcHRpb25zLnVuZm9ybWF0dGVkX2NvbnRlbnRfZGVsaW1pdGVyKTtcbiAgICB0aGlzLl9fcGF0dGVybnMudW5mb3JtYXR0ZWRfY29udGVudF9kZWxpbWl0ZXIgPVxuICAgICAgcGF0dGVybl9yZWFkZXIubWF0Y2hpbmcobGl0ZXJhbF9yZWdleHApXG4gICAgICAudW50aWxfYWZ0ZXIobGl0ZXJhbF9yZWdleHApO1xuICB9XG59O1xuVG9rZW5pemVyLnByb3RvdHlwZSA9IG5ldyBCYXNlVG9rZW5pemVyKCk7XG5cblRva2VuaXplci5wcm90b3R5cGUuX2lzX2NvbW1lbnQgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7IC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbiAgcmV0dXJuIGZhbHNlOyAvL2N1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uQ09NTUVOVCB8fCBjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLlVOS05PV047XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9pc19vcGVuaW5nID0gZnVuY3Rpb24oY3VycmVudF90b2tlbikge1xuICByZXR1cm4gY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5UQUdfT1BFTjtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2lzX2Nsb3NpbmcgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuLCBvcGVuX3Rva2VuKSB7XG4gIHJldHVybiBjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLlRBR19DTE9TRSAmJlxuICAgIChvcGVuX3Rva2VuICYmIChcbiAgICAgICgoY3VycmVudF90b2tlbi50ZXh0ID09PSAnPicgfHwgY3VycmVudF90b2tlbi50ZXh0ID09PSAnLz4nKSAmJiBvcGVuX3Rva2VuLnRleHRbMF0gPT09ICc8JykgfHxcbiAgICAgIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICd9fScgJiYgb3Blbl90b2tlbi50ZXh0WzBdID09PSAneycgJiYgb3Blbl90b2tlbi50ZXh0WzFdID09PSAneycpKSk7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZXNldCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jdXJyZW50X3RhZ19uYW1lID0gJyc7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9nZXRfbmV4dF90b2tlbiA9IGZ1bmN0aW9uKHByZXZpb3VzX3Rva2VuLCBvcGVuX3Rva2VuKSB7IC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbiAgdmFyIHRva2VuID0gbnVsbDtcbiAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcbiAgdmFyIGMgPSB0aGlzLl9pbnB1dC5wZWVrKCk7XG5cbiAgaWYgKGMgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLkVPRiwgJycpO1xuICB9XG5cbiAgdG9rZW4gPSB0b2tlbiB8fCB0aGlzLl9yZWFkX29wZW5faGFuZGxlYmFycyhjLCBvcGVuX3Rva2VuKTtcbiAgdG9rZW4gPSB0b2tlbiB8fCB0aGlzLl9yZWFkX2F0dHJpYnV0ZShjLCBwcmV2aW91c190b2tlbiwgb3Blbl90b2tlbik7XG4gIHRva2VuID0gdG9rZW4gfHwgdGhpcy5fcmVhZF9yYXdfY29udGVudChjLCBwcmV2aW91c190b2tlbiwgb3Blbl90b2tlbik7XG4gIHRva2VuID0gdG9rZW4gfHwgdGhpcy5fcmVhZF9jbG9zZShjLCBvcGVuX3Rva2VuKTtcbiAgdG9rZW4gPSB0b2tlbiB8fCB0aGlzLl9yZWFkX2NvbnRlbnRfd29yZChjKTtcbiAgdG9rZW4gPSB0b2tlbiB8fCB0aGlzLl9yZWFkX2NvbW1lbnRfb3JfY2RhdGEoYyk7XG4gIHRva2VuID0gdG9rZW4gfHwgdGhpcy5fcmVhZF9wcm9jZXNzaW5nKGMpO1xuICB0b2tlbiA9IHRva2VuIHx8IHRoaXMuX3JlYWRfb3BlbihjLCBvcGVuX3Rva2VuKTtcbiAgdG9rZW4gPSB0b2tlbiB8fCB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uVU5LTk9XTiwgdGhpcy5faW5wdXQubmV4dCgpKTtcblxuICByZXR1cm4gdG9rZW47XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZWFkX2NvbW1lbnRfb3JfY2RhdGEgPSBmdW5jdGlvbihjKSB7IC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbiAgdmFyIHRva2VuID0gbnVsbDtcbiAgdmFyIHJlc3VsdGluZ19zdHJpbmcgPSBudWxsO1xuICB2YXIgZGlyZWN0aXZlcyA9IG51bGw7XG5cbiAgaWYgKGMgPT09ICc8Jykge1xuICAgIHZhciBwZWVrMSA9IHRoaXMuX2lucHV0LnBlZWsoMSk7XG4gICAgLy8gV2UgdHJlYXQgYWxsIGNvbW1lbnRzIGFzIGxpdGVyYWxzLCBldmVuIG1vcmUgdGhhbiBwcmVmb3JtYXR0ZWQgdGFnc1xuICAgIC8vIHdlIG9ubHkgbG9vayBmb3IgdGhlIGFwcHJvcHJpYXRlIGNsb3NpbmcgbWFya2VyXG4gICAgaWYgKHBlZWsxID09PSAnIScpIHtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9fcGF0dGVybnMuY29tbWVudC5yZWFkKCk7XG5cbiAgICAgIC8vIG9ubHkgcHJvY2VzcyBkaXJlY3RpdmUgb24gaHRtbCBjb21tZW50c1xuICAgICAgaWYgKHJlc3VsdGluZ19zdHJpbmcpIHtcbiAgICAgICAgZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXNfY29yZS5nZXRfZGlyZWN0aXZlcyhyZXN1bHRpbmdfc3RyaW5nKTtcbiAgICAgICAgaWYgKGRpcmVjdGl2ZXMgJiYgZGlyZWN0aXZlcy5pZ25vcmUgPT09ICdzdGFydCcpIHtcbiAgICAgICAgICByZXN1bHRpbmdfc3RyaW5nICs9IGRpcmVjdGl2ZXNfY29yZS5yZWFkSWdub3JlZCh0aGlzLl9pbnB1dCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9fcGF0dGVybnMuY2RhdGEucmVhZCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZXN1bHRpbmdfc3RyaW5nKSB7XG4gICAgICB0b2tlbiA9IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5DT01NRU5ULCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgICAgIHRva2VuLmRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0b2tlbjtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3JlYWRfcHJvY2Vzc2luZyA9IGZ1bmN0aW9uKGMpIHsgLy8ganNoaW50IHVudXNlZDpmYWxzZVxuICB2YXIgdG9rZW4gPSBudWxsO1xuICB2YXIgcmVzdWx0aW5nX3N0cmluZyA9IG51bGw7XG4gIHZhciBkaXJlY3RpdmVzID0gbnVsbDtcblxuICBpZiAoYyA9PT0gJzwnKSB7XG4gICAgdmFyIHBlZWsxID0gdGhpcy5faW5wdXQucGVlaygxKTtcbiAgICBpZiAocGVlazEgPT09ICchJyB8fCBwZWVrMSA9PT0gJz8nKSB7XG4gICAgICByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5fX3BhdHRlcm5zLmNvbmRpdGlvbmFsX2NvbW1lbnQucmVhZCgpO1xuICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHJlc3VsdGluZ19zdHJpbmcgfHwgdGhpcy5fX3BhdHRlcm5zLnByb2Nlc3NpbmcucmVhZCgpO1xuICAgIH1cblxuICAgIGlmIChyZXN1bHRpbmdfc3RyaW5nKSB7XG4gICAgICB0b2tlbiA9IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5DT01NRU5ULCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgICAgIHRva2VuLmRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0b2tlbjtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3JlYWRfb3BlbiA9IGZ1bmN0aW9uKGMsIG9wZW5fdG9rZW4pIHtcbiAgdmFyIHJlc3VsdGluZ19zdHJpbmcgPSBudWxsO1xuICB2YXIgdG9rZW4gPSBudWxsO1xuICBpZiAoIW9wZW5fdG9rZW4pIHtcbiAgICBpZiAoYyA9PT0gJzwnKSB7XG5cbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgICBpZiAodGhpcy5faW5wdXQucGVlaygpID09PSAnLycpIHtcbiAgICAgICAgcmVzdWx0aW5nX3N0cmluZyArPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgICB9XG4gICAgICByZXN1bHRpbmdfc3RyaW5nICs9IHRoaXMuX19wYXR0ZXJucy5lbGVtZW50X25hbWUucmVhZCgpO1xuICAgICAgdG9rZW4gPSB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uVEFHX09QRU4sIHJlc3VsdGluZ19zdHJpbmcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG9rZW47XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZWFkX29wZW5faGFuZGxlYmFycyA9IGZ1bmN0aW9uKGMsIG9wZW5fdG9rZW4pIHtcbiAgdmFyIHJlc3VsdGluZ19zdHJpbmcgPSBudWxsO1xuICB2YXIgdG9rZW4gPSBudWxsO1xuICBpZiAoIW9wZW5fdG9rZW4pIHtcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5pbmRlbnRfaGFuZGxlYmFycyAmJiBjID09PSAneycgJiYgdGhpcy5faW5wdXQucGVlaygxKSA9PT0gJ3snKSB7XG4gICAgICBpZiAodGhpcy5faW5wdXQucGVlaygyKSA9PT0gJyEnKSB7XG4gICAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9fcGF0dGVybnMuaGFuZGxlYmFyc19jb21tZW50LnJlYWQoKTtcbiAgICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHJlc3VsdGluZ19zdHJpbmcgfHwgdGhpcy5fX3BhdHRlcm5zLmhhbmRsZWJhcnMucmVhZCgpO1xuICAgICAgICB0b2tlbiA9IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5DT01NRU5ULCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9fcGF0dGVybnMuaGFuZGxlYmFyc19vcGVuLnJlYWQoKTtcbiAgICAgICAgdG9rZW4gPSB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uVEFHX09QRU4sIHJlc3VsdGluZ19zdHJpbmcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdG9rZW47XG59O1xuXG5cblRva2VuaXplci5wcm90b3R5cGUuX3JlYWRfY2xvc2UgPSBmdW5jdGlvbihjLCBvcGVuX3Rva2VuKSB7XG4gIHZhciByZXN1bHRpbmdfc3RyaW5nID0gbnVsbDtcbiAgdmFyIHRva2VuID0gbnVsbDtcbiAgaWYgKG9wZW5fdG9rZW4pIHtcbiAgICBpZiAob3Blbl90b2tlbi50ZXh0WzBdID09PSAnPCcgJiYgKGMgPT09ICc+JyB8fCAoYyA9PT0gJy8nICYmIHRoaXMuX2lucHV0LnBlZWsoMSkgPT09ICc+JykpKSB7XG4gICAgICByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5faW5wdXQubmV4dCgpO1xuICAgICAgaWYgKGMgPT09ICcvJykgeyAvLyAgZm9yIGNsb3NlIHRhZyBcIi8+XCJcbiAgICAgICAgcmVzdWx0aW5nX3N0cmluZyArPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgICB9XG4gICAgICB0b2tlbiA9IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5UQUdfQ0xPU0UsIHJlc3VsdGluZ19zdHJpbmcpO1xuICAgIH0gZWxzZSBpZiAob3Blbl90b2tlbi50ZXh0WzBdID09PSAneycgJiYgYyA9PT0gJ30nICYmIHRoaXMuX2lucHV0LnBlZWsoMSkgPT09ICd9Jykge1xuICAgICAgdGhpcy5faW5wdXQubmV4dCgpO1xuICAgICAgdGhpcy5faW5wdXQubmV4dCgpO1xuICAgICAgdG9rZW4gPSB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uVEFHX0NMT1NFLCAnfX0nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdG9rZW47XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZWFkX2F0dHJpYnV0ZSA9IGZ1bmN0aW9uKGMsIHByZXZpb3VzX3Rva2VuLCBvcGVuX3Rva2VuKSB7XG4gIHZhciB0b2tlbiA9IG51bGw7XG4gIHZhciByZXN1bHRpbmdfc3RyaW5nID0gJyc7XG4gIGlmIChvcGVuX3Rva2VuICYmIG9wZW5fdG9rZW4udGV4dFswXSA9PT0gJzwnKSB7XG5cbiAgICBpZiAoYyA9PT0gJz0nKSB7XG4gICAgICB0b2tlbiA9IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5FUVVBTFMsIHRoaXMuX2lucHV0Lm5leHQoKSk7XG4gICAgfSBlbHNlIGlmIChjID09PSAnXCInIHx8IGMgPT09IFwiJ1wiKSB7XG4gICAgICB2YXIgY29udGVudCA9IHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICAgIGlmIChjID09PSAnXCInKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gdGhpcy5fX3BhdHRlcm5zLmRvdWJsZV9xdW90ZS5yZWFkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZW50ICs9IHRoaXMuX19wYXR0ZXJucy5zaW5nbGVfcXVvdGUucmVhZCgpO1xuICAgICAgfVxuICAgICAgdG9rZW4gPSB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uVkFMVUUsIGNvbnRlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5fX3BhdHRlcm5zLmF0dHJpYnV0ZS5yZWFkKCk7XG5cbiAgICAgIGlmIChyZXN1bHRpbmdfc3RyaW5nKSB7XG4gICAgICAgIGlmIChwcmV2aW91c190b2tlbi50eXBlID09PSBUT0tFTi5FUVVBTFMpIHtcbiAgICAgICAgICB0b2tlbiA9IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5WQUxVRSwgcmVzdWx0aW5nX3N0cmluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9rZW4gPSB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uQVRUUklCVVRFLCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdG9rZW47XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9pc19jb250ZW50X3VuZm9ybWF0dGVkID0gZnVuY3Rpb24odGFnX25hbWUpIHtcbiAgLy8gdm9pZF9lbGVtZW50cyBoYXZlIG5vIGNvbnRlbnQgYW5kIHNvIGNhbm5vdCBoYXZlIHVuZm9ybWF0dGVkIGNvbnRlbnRcbiAgLy8gc2NyaXB0IGFuZCBzdHlsZSB0YWdzIHNob3VsZCBhbHdheXMgYmUgcmVhZCBhcyB1bmZvcm1hdHRlZCBjb250ZW50XG4gIC8vIGZpbmFsbHkgY29udGVudF91bmZvcm1hdHRlZCBhbmQgdW5mb3JtYXR0ZWQgZWxlbWVudCBjb250ZW50cyBhcmUgdW5mb3JtYXR0ZWRcbiAgcmV0dXJuIHRoaXMuX29wdGlvbnMudm9pZF9lbGVtZW50cy5pbmRleE9mKHRhZ19uYW1lKSA9PT0gLTEgJiZcbiAgICAodGhpcy5fb3B0aW9ucy5jb250ZW50X3VuZm9ybWF0dGVkLmluZGV4T2YodGFnX25hbWUpICE9PSAtMSB8fFxuICAgICAgdGhpcy5fb3B0aW9ucy51bmZvcm1hdHRlZC5pbmRleE9mKHRhZ19uYW1lKSAhPT0gLTEpO1xufTtcblxuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZWFkX3Jhd19jb250ZW50ID0gZnVuY3Rpb24oYywgcHJldmlvdXNfdG9rZW4sIG9wZW5fdG9rZW4pIHsgLy8ganNoaW50IHVudXNlZDpmYWxzZVxuICB2YXIgcmVzdWx0aW5nX3N0cmluZyA9ICcnO1xuICBpZiAob3Blbl90b2tlbiAmJiBvcGVuX3Rva2VuLnRleHRbMF0gPT09ICd7Jykge1xuICAgIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9fcGF0dGVybnMuaGFuZGxlYmFyc19yYXdfY2xvc2UucmVhZCgpO1xuICB9IGVsc2UgaWYgKHByZXZpb3VzX3Rva2VuLnR5cGUgPT09IFRPS0VOLlRBR19DTE9TRSAmJiAocHJldmlvdXNfdG9rZW4ub3BlbmVkLnRleHRbMF0gPT09ICc8JykpIHtcbiAgICB2YXIgdGFnX25hbWUgPSBwcmV2aW91c190b2tlbi5vcGVuZWQudGV4dC5zdWJzdHIoMSkudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAodGFnX25hbWUgPT09ICdzY3JpcHQnIHx8IHRhZ19uYW1lID09PSAnc3R5bGUnKSB7XG4gICAgICAvLyBTY3JpcHQgYW5kIHN0eWxlIHRhZ3MgYXJlIGFsbG93ZWQgdG8gaGF2ZSBjb21tZW50cyB3cmFwcGluZyB0aGVpciBjb250ZW50XG4gICAgICAvLyBvciBqdXN0IGhhdmUgcmVndWxhciBjb250ZW50LlxuICAgICAgdmFyIHRva2VuID0gdGhpcy5fcmVhZF9jb21tZW50X29yX2NkYXRhKGMpO1xuICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgIHRva2VuLnR5cGUgPSBUT0tFTi5URVhUO1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICB9XG4gICAgICByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5faW5wdXQucmVhZFVudGlsKG5ldyBSZWdFeHAoJzwvJyArIHRhZ19uYW1lICsgJ1tcXFxcblxcXFxyXFxcXHQgXSo/PicsICdpZycpKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2lzX2NvbnRlbnRfdW5mb3JtYXR0ZWQodGFnX25hbWUpKSB7XG4gICAgICByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5faW5wdXQucmVhZFVudGlsKG5ldyBSZWdFeHAoJzwvJyArIHRhZ19uYW1lICsgJ1tcXFxcblxcXFxyXFxcXHQgXSo/PicsICdpZycpKTtcbiAgICB9XG4gIH1cblxuICBpZiAocmVzdWx0aW5nX3N0cmluZykge1xuICAgIHJldHVybiB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uVEVYVCwgcmVzdWx0aW5nX3N0cmluZyk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3JlYWRfY29udGVudF93b3JkID0gZnVuY3Rpb24oYykge1xuICB2YXIgcmVzdWx0aW5nX3N0cmluZyA9ICcnO1xuICBpZiAodGhpcy5fb3B0aW9ucy51bmZvcm1hdHRlZF9jb250ZW50X2RlbGltaXRlcikge1xuICAgIGlmIChjID09PSB0aGlzLl9vcHRpb25zLnVuZm9ybWF0dGVkX2NvbnRlbnRfZGVsaW1pdGVyWzBdKSB7XG4gICAgICByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5fX3BhdHRlcm5zLnVuZm9ybWF0dGVkX2NvbnRlbnRfZGVsaW1pdGVyLnJlYWQoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXJlc3VsdGluZ19zdHJpbmcpIHtcbiAgICByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5fX3BhdHRlcm5zLndvcmQucmVhZCgpO1xuICB9XG4gIGlmIChyZXN1bHRpbmdfc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5URVhULCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuVG9rZW5pemVyID0gVG9rZW5pemVyO1xubW9kdWxlLmV4cG9ydHMuVE9LRU4gPSBUT0tFTjtcbiIsIi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBqc19iZWF1dGlmeSA9IHJlcXVpcmUoJy4vamF2YXNjcmlwdC9pbmRleCcpO1xudmFyIGNzc19iZWF1dGlmeSA9IHJlcXVpcmUoJy4vY3NzL2luZGV4Jyk7XG52YXIgaHRtbF9iZWF1dGlmeSA9IHJlcXVpcmUoJy4vaHRtbC9pbmRleCcpO1xuXG5mdW5jdGlvbiBzdHlsZV9odG1sKGh0bWxfc291cmNlLCBvcHRpb25zLCBqcywgY3NzKSB7XG4gIGpzID0ganMgfHwganNfYmVhdXRpZnk7XG4gIGNzcyA9IGNzcyB8fCBjc3NfYmVhdXRpZnk7XG4gIHJldHVybiBodG1sX2JlYXV0aWZ5KGh0bWxfc291cmNlLCBvcHRpb25zLCBqcywgY3NzKTtcbn1cbnN0eWxlX2h0bWwuZGVmYXVsdE9wdGlvbnMgPSBodG1sX2JlYXV0aWZ5LmRlZmF1bHRPcHRpb25zO1xuXG5tb2R1bGUuZXhwb3J0cy5qcyA9IGpzX2JlYXV0aWZ5O1xubW9kdWxlLmV4cG9ydHMuY3NzID0gY3NzX2JlYXV0aWZ5O1xubW9kdWxlLmV4cG9ydHMuaHRtbCA9IHN0eWxlX2h0bWw7XG4iLCIvKiBqc2hpbnQgbm9kZTogdHJ1ZSwgY3VybHk6IGZhbHNlICovXG4vLyBQYXJ0cyBvZiB0aGlzIHNlY3Rpb24gb2YgY29kZSBpcyB0YWtlbiBmcm9tIGFjb3JuLlxuLy9cbi8vIEFjb3JuIHdhcyB3cml0dGVuIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIHJlbGVhc2VkIHVuZGVyIGFuIE1JVFxuLy8gbGljZW5zZS4gVGhlIFVuaWNvZGUgcmVnZXhwcyAoZm9yIGlkZW50aWZpZXJzIGFuZCB3aGl0ZXNwYWNlKSB3ZXJlXG4vLyB0YWtlbiBmcm9tIFtFc3ByaW1hXShodHRwOi8vZXNwcmltYS5vcmcpIGJ5IEFyaXlhIEhpZGF5YXQuXG4vL1xuLy8gR2l0IHJlcG9zaXRvcmllcyBmb3IgQWNvcm4gYXJlIGF2YWlsYWJsZSBhdFxuLy9cbi8vICAgICBodHRwOi8vbWFyaWpuaGF2ZXJiZWtlLm5sL2dpdC9hY29yblxuLy8gICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJpam5oL2Fjb3JuLmdpdFxuXG4vLyAjIyBDaGFyYWN0ZXIgY2F0ZWdvcmllc1xuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gYWNvcm4gdXNlZCBjaGFyIGNvZGVzIHRvIHNxdWVlemUgdGhlIGxhc3QgYml0IG9mIHBlcmZvcm1hbmNlIG91dFxuLy8gQmVhdXRpZmllciBpcyBva2F5IHdpdGhvdXQgdGhhdCwgc28gd2UncmUgdXNpbmcgcmVnZXhcbi8vIHBlcm1pdCAjICgyMyksICQgKDM2KSwgYW5kIEAgKDY0KS4gQCBpcyB1c2VkIGluIEVTNyBkZWNvcmF0b3JzLlxuLy8gNjUgdGhyb3VnaCA5MSBhcmUgdXBwZXJjYXNlIGxldHRlcnMuXG4vLyBwZXJtaXQgXyAoOTUpLlxuLy8gOTcgdGhyb3VnaCAxMjMgYXJlIGxvd2VyY2FzZSBsZXR0ZXJzLlxudmFyIGJhc2VBU0NJSWlkZW50aWZpZXJTdGFydENoYXJzID0gXCJcXFxceDIzXFxcXHgyNFxcXFx4NDBcXFxceDQxLVxcXFx4NWFcXFxceDVmXFxcXHg2MS1cXFxceDdhXCI7XG5cbi8vIGluc2lkZSBhbiBpZGVudGlmaWVyIEAgaXMgbm90IGFsbG93ZWQgYnV0IDAtOSBhcmUuXG52YXIgYmFzZUFTQ0lJaWRlbnRpZmllckNoYXJzID0gXCJcXFxceDI0XFxcXHgzMC1cXFxceDM5XFxcXHg0MS1cXFxceDVhXFxcXHg1ZlxcXFx4NjEtXFxcXHg3YVwiO1xuXG4vLyBCaWcgdWdseSByZWd1bGFyIGV4cHJlc3Npb25zIHRoYXQgbWF0Y2ggY2hhcmFjdGVycyBpbiB0aGVcbi8vIHdoaXRlc3BhY2UsIGlkZW50aWZpZXIsIGFuZCBpZGVudGlmaWVyLXN0YXJ0IGNhdGVnb3JpZXMuIFRoZXNlXG4vLyBhcmUgb25seSBhcHBsaWVkIHdoZW4gYSBjaGFyYWN0ZXIgaXMgZm91bmQgdG8gYWN0dWFsbHkgaGF2ZSBhXG4vLyBjb2RlIHBvaW50IGFib3ZlIDEyOC5cbnZhciBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzID0gXCJcXFxceGFhXFxcXHhiNVxcXFx4YmFcXFxceGMwLVxcXFx4ZDZcXFxceGQ4LVxcXFx4ZjZcXFxceGY4LVxcXFx1MDJjMVxcXFx1MDJjNi1cXFxcdTAyZDFcXFxcdTAyZTAtXFxcXHUwMmU0XFxcXHUwMmVjXFxcXHUwMmVlXFxcXHUwMzcwLVxcXFx1MDM3NFxcXFx1MDM3NlxcXFx1MDM3N1xcXFx1MDM3YS1cXFxcdTAzN2RcXFxcdTAzODZcXFxcdTAzODgtXFxcXHUwMzhhXFxcXHUwMzhjXFxcXHUwMzhlLVxcXFx1MDNhMVxcXFx1MDNhMy1cXFxcdTAzZjVcXFxcdTAzZjctXFxcXHUwNDgxXFxcXHUwNDhhLVxcXFx1MDUyN1xcXFx1MDUzMS1cXFxcdTA1NTZcXFxcdTA1NTlcXFxcdTA1NjEtXFxcXHUwNTg3XFxcXHUwNWQwLVxcXFx1MDVlYVxcXFx1MDVmMC1cXFxcdTA1ZjJcXFxcdTA2MjAtXFxcXHUwNjRhXFxcXHUwNjZlXFxcXHUwNjZmXFxcXHUwNjcxLVxcXFx1MDZkM1xcXFx1MDZkNVxcXFx1MDZlNVxcXFx1MDZlNlxcXFx1MDZlZVxcXFx1MDZlZlxcXFx1MDZmYS1cXFxcdTA2ZmNcXFxcdTA2ZmZcXFxcdTA3MTBcXFxcdTA3MTItXFxcXHUwNzJmXFxcXHUwNzRkLVxcXFx1MDdhNVxcXFx1MDdiMVxcXFx1MDdjYS1cXFxcdTA3ZWFcXFxcdTA3ZjRcXFxcdTA3ZjVcXFxcdTA3ZmFcXFxcdTA4MDAtXFxcXHUwODE1XFxcXHUwODFhXFxcXHUwODI0XFxcXHUwODI4XFxcXHUwODQwLVxcXFx1MDg1OFxcXFx1MDhhMFxcXFx1MDhhMi1cXFxcdTA4YWNcXFxcdTA5MDQtXFxcXHUwOTM5XFxcXHUwOTNkXFxcXHUwOTUwXFxcXHUwOTU4LVxcXFx1MDk2MVxcXFx1MDk3MS1cXFxcdTA5NzdcXFxcdTA5NzktXFxcXHUwOTdmXFxcXHUwOTg1LVxcXFx1MDk4Y1xcXFx1MDk4ZlxcXFx1MDk5MFxcXFx1MDk5My1cXFxcdTA5YThcXFxcdTA5YWEtXFxcXHUwOWIwXFxcXHUwOWIyXFxcXHUwOWI2LVxcXFx1MDliOVxcXFx1MDliZFxcXFx1MDljZVxcXFx1MDlkY1xcXFx1MDlkZFxcXFx1MDlkZi1cXFxcdTA5ZTFcXFxcdTA5ZjBcXFxcdTA5ZjFcXFxcdTBhMDUtXFxcXHUwYTBhXFxcXHUwYTBmXFxcXHUwYTEwXFxcXHUwYTEzLVxcXFx1MGEyOFxcXFx1MGEyYS1cXFxcdTBhMzBcXFxcdTBhMzJcXFxcdTBhMzNcXFxcdTBhMzVcXFxcdTBhMzZcXFxcdTBhMzhcXFxcdTBhMzlcXFxcdTBhNTktXFxcXHUwYTVjXFxcXHUwYTVlXFxcXHUwYTcyLVxcXFx1MGE3NFxcXFx1MGE4NS1cXFxcdTBhOGRcXFxcdTBhOGYtXFxcXHUwYTkxXFxcXHUwYTkzLVxcXFx1MGFhOFxcXFx1MGFhYS1cXFxcdTBhYjBcXFxcdTBhYjJcXFxcdTBhYjNcXFxcdTBhYjUtXFxcXHUwYWI5XFxcXHUwYWJkXFxcXHUwYWQwXFxcXHUwYWUwXFxcXHUwYWUxXFxcXHUwYjA1LVxcXFx1MGIwY1xcXFx1MGIwZlxcXFx1MGIxMFxcXFx1MGIxMy1cXFxcdTBiMjhcXFxcdTBiMmEtXFxcXHUwYjMwXFxcXHUwYjMyXFxcXHUwYjMzXFxcXHUwYjM1LVxcXFx1MGIzOVxcXFx1MGIzZFxcXFx1MGI1Y1xcXFx1MGI1ZFxcXFx1MGI1Zi1cXFxcdTBiNjFcXFxcdTBiNzFcXFxcdTBiODNcXFxcdTBiODUtXFxcXHUwYjhhXFxcXHUwYjhlLVxcXFx1MGI5MFxcXFx1MGI5Mi1cXFxcdTBiOTVcXFxcdTBiOTlcXFxcdTBiOWFcXFxcdTBiOWNcXFxcdTBiOWVcXFxcdTBiOWZcXFxcdTBiYTNcXFxcdTBiYTRcXFxcdTBiYTgtXFxcXHUwYmFhXFxcXHUwYmFlLVxcXFx1MGJiOVxcXFx1MGJkMFxcXFx1MGMwNS1cXFxcdTBjMGNcXFxcdTBjMGUtXFxcXHUwYzEwXFxcXHUwYzEyLVxcXFx1MGMyOFxcXFx1MGMyYS1cXFxcdTBjMzNcXFxcdTBjMzUtXFxcXHUwYzM5XFxcXHUwYzNkXFxcXHUwYzU4XFxcXHUwYzU5XFxcXHUwYzYwXFxcXHUwYzYxXFxcXHUwYzg1LVxcXFx1MGM4Y1xcXFx1MGM4ZS1cXFxcdTBjOTBcXFxcdTBjOTItXFxcXHUwY2E4XFxcXHUwY2FhLVxcXFx1MGNiM1xcXFx1MGNiNS1cXFxcdTBjYjlcXFxcdTBjYmRcXFxcdTBjZGVcXFxcdTBjZTBcXFxcdTBjZTFcXFxcdTBjZjFcXFxcdTBjZjJcXFxcdTBkMDUtXFxcXHUwZDBjXFxcXHUwZDBlLVxcXFx1MGQxMFxcXFx1MGQxMi1cXFxcdTBkM2FcXFxcdTBkM2RcXFxcdTBkNGVcXFxcdTBkNjBcXFxcdTBkNjFcXFxcdTBkN2EtXFxcXHUwZDdmXFxcXHUwZDg1LVxcXFx1MGQ5NlxcXFx1MGQ5YS1cXFxcdTBkYjFcXFxcdTBkYjMtXFxcXHUwZGJiXFxcXHUwZGJkXFxcXHUwZGMwLVxcXFx1MGRjNlxcXFx1MGUwMS1cXFxcdTBlMzBcXFxcdTBlMzJcXFxcdTBlMzNcXFxcdTBlNDAtXFxcXHUwZTQ2XFxcXHUwZTgxXFxcXHUwZTgyXFxcXHUwZTg0XFxcXHUwZTg3XFxcXHUwZTg4XFxcXHUwZThhXFxcXHUwZThkXFxcXHUwZTk0LVxcXFx1MGU5N1xcXFx1MGU5OS1cXFxcdTBlOWZcXFxcdTBlYTEtXFxcXHUwZWEzXFxcXHUwZWE1XFxcXHUwZWE3XFxcXHUwZWFhXFxcXHUwZWFiXFxcXHUwZWFkLVxcXFx1MGViMFxcXFx1MGViMlxcXFx1MGViM1xcXFx1MGViZFxcXFx1MGVjMC1cXFxcdTBlYzRcXFxcdTBlYzZcXFxcdTBlZGMtXFxcXHUwZWRmXFxcXHUwZjAwXFxcXHUwZjQwLVxcXFx1MGY0N1xcXFx1MGY0OS1cXFxcdTBmNmNcXFxcdTBmODgtXFxcXHUwZjhjXFxcXHUxMDAwLVxcXFx1MTAyYVxcXFx1MTAzZlxcXFx1MTA1MC1cXFxcdTEwNTVcXFxcdTEwNWEtXFxcXHUxMDVkXFxcXHUxMDYxXFxcXHUxMDY1XFxcXHUxMDY2XFxcXHUxMDZlLVxcXFx1MTA3MFxcXFx1MTA3NS1cXFxcdTEwODFcXFxcdTEwOGVcXFxcdTEwYTAtXFxcXHUxMGM1XFxcXHUxMGM3XFxcXHUxMGNkXFxcXHUxMGQwLVxcXFx1MTBmYVxcXFx1MTBmYy1cXFxcdTEyNDhcXFxcdTEyNGEtXFxcXHUxMjRkXFxcXHUxMjUwLVxcXFx1MTI1NlxcXFx1MTI1OFxcXFx1MTI1YS1cXFxcdTEyNWRcXFxcdTEyNjAtXFxcXHUxMjg4XFxcXHUxMjhhLVxcXFx1MTI4ZFxcXFx1MTI5MC1cXFxcdTEyYjBcXFxcdTEyYjItXFxcXHUxMmI1XFxcXHUxMmI4LVxcXFx1MTJiZVxcXFx1MTJjMFxcXFx1MTJjMi1cXFxcdTEyYzVcXFxcdTEyYzgtXFxcXHUxMmQ2XFxcXHUxMmQ4LVxcXFx1MTMxMFxcXFx1MTMxMi1cXFxcdTEzMTVcXFxcdTEzMTgtXFxcXHUxMzVhXFxcXHUxMzgwLVxcXFx1MTM4ZlxcXFx1MTNhMC1cXFxcdTEzZjRcXFxcdTE0MDEtXFxcXHUxNjZjXFxcXHUxNjZmLVxcXFx1MTY3ZlxcXFx1MTY4MS1cXFxcdTE2OWFcXFxcdTE2YTAtXFxcXHUxNmVhXFxcXHUxNmVlLVxcXFx1MTZmMFxcXFx1MTcwMC1cXFxcdTE3MGNcXFxcdTE3MGUtXFxcXHUxNzExXFxcXHUxNzIwLVxcXFx1MTczMVxcXFx1MTc0MC1cXFxcdTE3NTFcXFxcdTE3NjAtXFxcXHUxNzZjXFxcXHUxNzZlLVxcXFx1MTc3MFxcXFx1MTc4MC1cXFxcdTE3YjNcXFxcdTE3ZDdcXFxcdTE3ZGNcXFxcdTE4MjAtXFxcXHUxODc3XFxcXHUxODgwLVxcXFx1MThhOFxcXFx1MThhYVxcXFx1MThiMC1cXFxcdTE4ZjVcXFxcdTE5MDAtXFxcXHUxOTFjXFxcXHUxOTUwLVxcXFx1MTk2ZFxcXFx1MTk3MC1cXFxcdTE5NzRcXFxcdTE5ODAtXFxcXHUxOWFiXFxcXHUxOWMxLVxcXFx1MTljN1xcXFx1MWEwMC1cXFxcdTFhMTZcXFxcdTFhMjAtXFxcXHUxYTU0XFxcXHUxYWE3XFxcXHUxYjA1LVxcXFx1MWIzM1xcXFx1MWI0NS1cXFxcdTFiNGJcXFxcdTFiODMtXFxcXHUxYmEwXFxcXHUxYmFlXFxcXHUxYmFmXFxcXHUxYmJhLVxcXFx1MWJlNVxcXFx1MWMwMC1cXFxcdTFjMjNcXFxcdTFjNGQtXFxcXHUxYzRmXFxcXHUxYzVhLVxcXFx1MWM3ZFxcXFx1MWNlOS1cXFxcdTFjZWNcXFxcdTFjZWUtXFxcXHUxY2YxXFxcXHUxY2Y1XFxcXHUxY2Y2XFxcXHUxZDAwLVxcXFx1MWRiZlxcXFx1MWUwMC1cXFxcdTFmMTVcXFxcdTFmMTgtXFxcXHUxZjFkXFxcXHUxZjIwLVxcXFx1MWY0NVxcXFx1MWY0OC1cXFxcdTFmNGRcXFxcdTFmNTAtXFxcXHUxZjU3XFxcXHUxZjU5XFxcXHUxZjViXFxcXHUxZjVkXFxcXHUxZjVmLVxcXFx1MWY3ZFxcXFx1MWY4MC1cXFxcdTFmYjRcXFxcdTFmYjYtXFxcXHUxZmJjXFxcXHUxZmJlXFxcXHUxZmMyLVxcXFx1MWZjNFxcXFx1MWZjNi1cXFxcdTFmY2NcXFxcdTFmZDAtXFxcXHUxZmQzXFxcXHUxZmQ2LVxcXFx1MWZkYlxcXFx1MWZlMC1cXFxcdTFmZWNcXFxcdTFmZjItXFxcXHUxZmY0XFxcXHUxZmY2LVxcXFx1MWZmY1xcXFx1MjA3MVxcXFx1MjA3ZlxcXFx1MjA5MC1cXFxcdTIwOWNcXFxcdTIxMDJcXFxcdTIxMDdcXFxcdTIxMGEtXFxcXHUyMTEzXFxcXHUyMTE1XFxcXHUyMTE5LVxcXFx1MjExZFxcXFx1MjEyNFxcXFx1MjEyNlxcXFx1MjEyOFxcXFx1MjEyYS1cXFxcdTIxMmRcXFxcdTIxMmYtXFxcXHUyMTM5XFxcXHUyMTNjLVxcXFx1MjEzZlxcXFx1MjE0NS1cXFxcdTIxNDlcXFxcdTIxNGVcXFxcdTIxNjAtXFxcXHUyMTg4XFxcXHUyYzAwLVxcXFx1MmMyZVxcXFx1MmMzMC1cXFxcdTJjNWVcXFxcdTJjNjAtXFxcXHUyY2U0XFxcXHUyY2ViLVxcXFx1MmNlZVxcXFx1MmNmMlxcXFx1MmNmM1xcXFx1MmQwMC1cXFxcdTJkMjVcXFxcdTJkMjdcXFxcdTJkMmRcXFxcdTJkMzAtXFxcXHUyZDY3XFxcXHUyZDZmXFxcXHUyZDgwLVxcXFx1MmQ5NlxcXFx1MmRhMC1cXFxcdTJkYTZcXFxcdTJkYTgtXFxcXHUyZGFlXFxcXHUyZGIwLVxcXFx1MmRiNlxcXFx1MmRiOC1cXFxcdTJkYmVcXFxcdTJkYzAtXFxcXHUyZGM2XFxcXHUyZGM4LVxcXFx1MmRjZVxcXFx1MmRkMC1cXFxcdTJkZDZcXFxcdTJkZDgtXFxcXHUyZGRlXFxcXHUyZTJmXFxcXHUzMDA1LVxcXFx1MzAwN1xcXFx1MzAyMS1cXFxcdTMwMjlcXFxcdTMwMzEtXFxcXHUzMDM1XFxcXHUzMDM4LVxcXFx1MzAzY1xcXFx1MzA0MS1cXFxcdTMwOTZcXFxcdTMwOWQtXFxcXHUzMDlmXFxcXHUzMGExLVxcXFx1MzBmYVxcXFx1MzBmYy1cXFxcdTMwZmZcXFxcdTMxMDUtXFxcXHUzMTJkXFxcXHUzMTMxLVxcXFx1MzE4ZVxcXFx1MzFhMC1cXFxcdTMxYmFcXFxcdTMxZjAtXFxcXHUzMWZmXFxcXHUzNDAwLVxcXFx1NGRiNVxcXFx1NGUwMC1cXFxcdTlmY2NcXFxcdWEwMDAtXFxcXHVhNDhjXFxcXHVhNGQwLVxcXFx1YTRmZFxcXFx1YTUwMC1cXFxcdWE2MGNcXFxcdWE2MTAtXFxcXHVhNjFmXFxcXHVhNjJhXFxcXHVhNjJiXFxcXHVhNjQwLVxcXFx1YTY2ZVxcXFx1YTY3Zi1cXFxcdWE2OTdcXFxcdWE2YTAtXFxcXHVhNmVmXFxcXHVhNzE3LVxcXFx1YTcxZlxcXFx1YTcyMi1cXFxcdWE3ODhcXFxcdWE3OGItXFxcXHVhNzhlXFxcXHVhNzkwLVxcXFx1YTc5M1xcXFx1YTdhMC1cXFxcdWE3YWFcXFxcdWE3ZjgtXFxcXHVhODAxXFxcXHVhODAzLVxcXFx1YTgwNVxcXFx1YTgwNy1cXFxcdWE4MGFcXFxcdWE4MGMtXFxcXHVhODIyXFxcXHVhODQwLVxcXFx1YTg3M1xcXFx1YTg4Mi1cXFxcdWE4YjNcXFxcdWE4ZjItXFxcXHVhOGY3XFxcXHVhOGZiXFxcXHVhOTBhLVxcXFx1YTkyNVxcXFx1YTkzMC1cXFxcdWE5NDZcXFxcdWE5NjAtXFxcXHVhOTdjXFxcXHVhOTg0LVxcXFx1YTliMlxcXFx1YTljZlxcXFx1YWEwMC1cXFxcdWFhMjhcXFxcdWFhNDAtXFxcXHVhYTQyXFxcXHVhYTQ0LVxcXFx1YWE0YlxcXFx1YWE2MC1cXFxcdWFhNzZcXFxcdWFhN2FcXFxcdWFhODAtXFxcXHVhYWFmXFxcXHVhYWIxXFxcXHVhYWI1XFxcXHVhYWI2XFxcXHVhYWI5LVxcXFx1YWFiZFxcXFx1YWFjMFxcXFx1YWFjMlxcXFx1YWFkYi1cXFxcdWFhZGRcXFxcdWFhZTAtXFxcXHVhYWVhXFxcXHVhYWYyLVxcXFx1YWFmNFxcXFx1YWIwMS1cXFxcdWFiMDZcXFxcdWFiMDktXFxcXHVhYjBlXFxcXHVhYjExLVxcXFx1YWIxNlxcXFx1YWIyMC1cXFxcdWFiMjZcXFxcdWFiMjgtXFxcXHVhYjJlXFxcXHVhYmMwLVxcXFx1YWJlMlxcXFx1YWMwMC1cXFxcdWQ3YTNcXFxcdWQ3YjAtXFxcXHVkN2M2XFxcXHVkN2NiLVxcXFx1ZDdmYlxcXFx1ZjkwMC1cXFxcdWZhNmRcXFxcdWZhNzAtXFxcXHVmYWQ5XFxcXHVmYjAwLVxcXFx1ZmIwNlxcXFx1ZmIxMy1cXFxcdWZiMTdcXFxcdWZiMWRcXFxcdWZiMWYtXFxcXHVmYjI4XFxcXHVmYjJhLVxcXFx1ZmIzNlxcXFx1ZmIzOC1cXFxcdWZiM2NcXFxcdWZiM2VcXFxcdWZiNDBcXFxcdWZiNDFcXFxcdWZiNDNcXFxcdWZiNDRcXFxcdWZiNDYtXFxcXHVmYmIxXFxcXHVmYmQzLVxcXFx1ZmQzZFxcXFx1ZmQ1MC1cXFxcdWZkOGZcXFxcdWZkOTItXFxcXHVmZGM3XFxcXHVmZGYwLVxcXFx1ZmRmYlxcXFx1ZmU3MC1cXFxcdWZlNzRcXFxcdWZlNzYtXFxcXHVmZWZjXFxcXHVmZjIxLVxcXFx1ZmYzYVxcXFx1ZmY0MS1cXFxcdWZmNWFcXFxcdWZmNjYtXFxcXHVmZmJlXFxcXHVmZmMyLVxcXFx1ZmZjN1xcXFx1ZmZjYS1cXFxcdWZmY2ZcXFxcdWZmZDItXFxcXHVmZmQ3XFxcXHVmZmRhLVxcXFx1ZmZkY1wiO1xudmFyIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzID0gXCJcXFxcdTAzMDAtXFxcXHUwMzZmXFxcXHUwNDgzLVxcXFx1MDQ4N1xcXFx1MDU5MS1cXFxcdTA1YmRcXFxcdTA1YmZcXFxcdTA1YzFcXFxcdTA1YzJcXFxcdTA1YzRcXFxcdTA1YzVcXFxcdTA1YzdcXFxcdTA2MTAtXFxcXHUwNjFhXFxcXHUwNjIwLVxcXFx1MDY0OVxcXFx1MDY3Mi1cXFxcdTA2ZDNcXFxcdTA2ZTctXFxcXHUwNmU4XFxcXHUwNmZiLVxcXFx1MDZmY1xcXFx1MDczMC1cXFxcdTA3NGFcXFxcdTA4MDAtXFxcXHUwODE0XFxcXHUwODFiLVxcXFx1MDgyM1xcXFx1MDgyNS1cXFxcdTA4MjdcXFxcdTA4MjktXFxcXHUwODJkXFxcXHUwODQwLVxcXFx1MDg1N1xcXFx1MDhlNC1cXFxcdTA4ZmVcXFxcdTA5MDAtXFxcXHUwOTAzXFxcXHUwOTNhLVxcXFx1MDkzY1xcXFx1MDkzZS1cXFxcdTA5NGZcXFxcdTA5NTEtXFxcXHUwOTU3XFxcXHUwOTYyLVxcXFx1MDk2M1xcXFx1MDk2Ni1cXFxcdTA5NmZcXFxcdTA5ODEtXFxcXHUwOTgzXFxcXHUwOWJjXFxcXHUwOWJlLVxcXFx1MDljNFxcXFx1MDljN1xcXFx1MDljOFxcXFx1MDlkN1xcXFx1MDlkZi1cXFxcdTA5ZTBcXFxcdTBhMDEtXFxcXHUwYTAzXFxcXHUwYTNjXFxcXHUwYTNlLVxcXFx1MGE0MlxcXFx1MGE0N1xcXFx1MGE0OFxcXFx1MGE0Yi1cXFxcdTBhNGRcXFxcdTBhNTFcXFxcdTBhNjYtXFxcXHUwYTcxXFxcXHUwYTc1XFxcXHUwYTgxLVxcXFx1MGE4M1xcXFx1MGFiY1xcXFx1MGFiZS1cXFxcdTBhYzVcXFxcdTBhYzctXFxcXHUwYWM5XFxcXHUwYWNiLVxcXFx1MGFjZFxcXFx1MGFlMi1cXFxcdTBhZTNcXFxcdTBhZTYtXFxcXHUwYWVmXFxcXHUwYjAxLVxcXFx1MGIwM1xcXFx1MGIzY1xcXFx1MGIzZS1cXFxcdTBiNDRcXFxcdTBiNDdcXFxcdTBiNDhcXFxcdTBiNGItXFxcXHUwYjRkXFxcXHUwYjU2XFxcXHUwYjU3XFxcXHUwYjVmLVxcXFx1MGI2MFxcXFx1MGI2Ni1cXFxcdTBiNmZcXFxcdTBiODJcXFxcdTBiYmUtXFxcXHUwYmMyXFxcXHUwYmM2LVxcXFx1MGJjOFxcXFx1MGJjYS1cXFxcdTBiY2RcXFxcdTBiZDdcXFxcdTBiZTYtXFxcXHUwYmVmXFxcXHUwYzAxLVxcXFx1MGMwM1xcXFx1MGM0Ni1cXFxcdTBjNDhcXFxcdTBjNGEtXFxcXHUwYzRkXFxcXHUwYzU1XFxcXHUwYzU2XFxcXHUwYzYyLVxcXFx1MGM2M1xcXFx1MGM2Ni1cXFxcdTBjNmZcXFxcdTBjODJcXFxcdTBjODNcXFxcdTBjYmNcXFxcdTBjYmUtXFxcXHUwY2M0XFxcXHUwY2M2LVxcXFx1MGNjOFxcXFx1MGNjYS1cXFxcdTBjY2RcXFxcdTBjZDVcXFxcdTBjZDZcXFxcdTBjZTItXFxcXHUwY2UzXFxcXHUwY2U2LVxcXFx1MGNlZlxcXFx1MGQwMlxcXFx1MGQwM1xcXFx1MGQ0Ni1cXFxcdTBkNDhcXFxcdTBkNTdcXFxcdTBkNjItXFxcXHUwZDYzXFxcXHUwZDY2LVxcXFx1MGQ2ZlxcXFx1MGQ4MlxcXFx1MGQ4M1xcXFx1MGRjYVxcXFx1MGRjZi1cXFxcdTBkZDRcXFxcdTBkZDZcXFxcdTBkZDgtXFxcXHUwZGRmXFxcXHUwZGYyXFxcXHUwZGYzXFxcXHUwZTM0LVxcXFx1MGUzYVxcXFx1MGU0MC1cXFxcdTBlNDVcXFxcdTBlNTAtXFxcXHUwZTU5XFxcXHUwZWI0LVxcXFx1MGViOVxcXFx1MGVjOC1cXFxcdTBlY2RcXFxcdTBlZDAtXFxcXHUwZWQ5XFxcXHUwZjE4XFxcXHUwZjE5XFxcXHUwZjIwLVxcXFx1MGYyOVxcXFx1MGYzNVxcXFx1MGYzN1xcXFx1MGYzOVxcXFx1MGY0MS1cXFxcdTBmNDdcXFxcdTBmNzEtXFxcXHUwZjg0XFxcXHUwZjg2LVxcXFx1MGY4N1xcXFx1MGY4ZC1cXFxcdTBmOTdcXFxcdTBmOTktXFxcXHUwZmJjXFxcXHUwZmM2XFxcXHUxMDAwLVxcXFx1MTAyOVxcXFx1MTA0MC1cXFxcdTEwNDlcXFxcdTEwNjctXFxcXHUxMDZkXFxcXHUxMDcxLVxcXFx1MTA3NFxcXFx1MTA4Mi1cXFxcdTEwOGRcXFxcdTEwOGYtXFxcXHUxMDlkXFxcXHUxMzVkLVxcXFx1MTM1ZlxcXFx1MTcwZS1cXFxcdTE3MTBcXFxcdTE3MjAtXFxcXHUxNzMwXFxcXHUxNzQwLVxcXFx1MTc1MFxcXFx1MTc3MlxcXFx1MTc3M1xcXFx1MTc4MC1cXFxcdTE3YjJcXFxcdTE3ZGRcXFxcdTE3ZTAtXFxcXHUxN2U5XFxcXHUxODBiLVxcXFx1MTgwZFxcXFx1MTgxMC1cXFxcdTE4MTlcXFxcdTE5MjAtXFxcXHUxOTJiXFxcXHUxOTMwLVxcXFx1MTkzYlxcXFx1MTk1MS1cXFxcdTE5NmRcXFxcdTE5YjAtXFxcXHUxOWMwXFxcXHUxOWM4LVxcXFx1MTljOVxcXFx1MTlkMC1cXFxcdTE5ZDlcXFxcdTFhMDAtXFxcXHUxYTE1XFxcXHUxYTIwLVxcXFx1MWE1M1xcXFx1MWE2MC1cXFxcdTFhN2NcXFxcdTFhN2YtXFxcXHUxYTg5XFxcXHUxYTkwLVxcXFx1MWE5OVxcXFx1MWI0Ni1cXFxcdTFiNGJcXFxcdTFiNTAtXFxcXHUxYjU5XFxcXHUxYjZiLVxcXFx1MWI3M1xcXFx1MWJiMC1cXFxcdTFiYjlcXFxcdTFiZTYtXFxcXHUxYmYzXFxcXHUxYzAwLVxcXFx1MWMyMlxcXFx1MWM0MC1cXFxcdTFjNDlcXFxcdTFjNWItXFxcXHUxYzdkXFxcXHUxY2QwLVxcXFx1MWNkMlxcXFx1MWQwMC1cXFxcdTFkYmVcXFxcdTFlMDEtXFxcXHUxZjE1XFxcXHUyMDBjXFxcXHUyMDBkXFxcXHUyMDNmXFxcXHUyMDQwXFxcXHUyMDU0XFxcXHUyMGQwLVxcXFx1MjBkY1xcXFx1MjBlMVxcXFx1MjBlNS1cXFxcdTIwZjBcXFxcdTJkODEtXFxcXHUyZDk2XFxcXHUyZGUwLVxcXFx1MmRmZlxcXFx1MzAyMS1cXFxcdTMwMjhcXFxcdTMwOTlcXFxcdTMwOWFcXFxcdWE2NDAtXFxcXHVhNjZkXFxcXHVhNjc0LVxcXFx1YTY3ZFxcXFx1YTY5ZlxcXFx1YTZmMC1cXFxcdWE2ZjFcXFxcdWE3ZjgtXFxcXHVhODAwXFxcXHVhODA2XFxcXHVhODBiXFxcXHVhODIzLVxcXFx1YTgyN1xcXFx1YTg4MC1cXFxcdWE4ODFcXFxcdWE4YjQtXFxcXHVhOGM0XFxcXHVhOGQwLVxcXFx1YThkOVxcXFx1YThmMy1cXFxcdWE4ZjdcXFxcdWE5MDAtXFxcXHVhOTA5XFxcXHVhOTI2LVxcXFx1YTkyZFxcXFx1YTkzMC1cXFxcdWE5NDVcXFxcdWE5ODAtXFxcXHVhOTgzXFxcXHVhOWIzLVxcXFx1YTljMFxcXFx1YWEwMC1cXFxcdWFhMjdcXFxcdWFhNDAtXFxcXHVhYTQxXFxcXHVhYTRjLVxcXFx1YWE0ZFxcXFx1YWE1MC1cXFxcdWFhNTlcXFxcdWFhN2JcXFxcdWFhZTAtXFxcXHVhYWU5XFxcXHVhYWYyLVxcXFx1YWFmM1xcXFx1YWJjMC1cXFxcdWFiZTFcXFxcdWFiZWNcXFxcdWFiZWRcXFxcdWFiZjAtXFxcXHVhYmY5XFxcXHVmYjIwLVxcXFx1ZmIyOFxcXFx1ZmUwMC1cXFxcdWZlMGZcXFxcdWZlMjAtXFxcXHVmZTI2XFxcXHVmZTMzXFxcXHVmZTM0XFxcXHVmZTRkLVxcXFx1ZmU0ZlxcXFx1ZmYxMC1cXFxcdWZmMTlcXFxcdWZmM2ZcIjtcbi8vdmFyIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0ID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBcIl1cIik7XG4vL3ZhciBub25BU0NJSWlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKFwiW1wiICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzICsgXCJdXCIpO1xuXG52YXIgaWRlbnRpZmllclN0YXJ0ID0gXCIoPzpcXFxcXFxcXHVbMC05YS1mQS1GXXs0fXxbXCIgKyBiYXNlQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBcIl0pXCI7XG52YXIgaWRlbnRpZmllckNoYXJzID0gXCIoPzpcXFxcXFxcXHVbMC05YS1mQS1GXXs0fXxbXCIgKyBiYXNlQVNDSUlpZGVudGlmaWVyQ2hhcnMgKyBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzICsgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgKyBcIl0pKlwiO1xuXG5leHBvcnRzLmlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKGlkZW50aWZpZXJTdGFydCArIGlkZW50aWZpZXJDaGFycywgJ2cnKTtcbmV4cG9ydHMuaWRlbnRpZmllclN0YXJ0ID0gbmV3IFJlZ0V4cChpZGVudGlmaWVyU3RhcnQpO1xuZXhwb3J0cy5pZGVudGlmaWVyTWF0Y2ggPSBuZXcgUmVnRXhwKFwiKD86XFxcXFxcXFx1WzAtOWEtZkEtRl17NH18W1wiICsgYmFzZUFTQ0lJaWRlbnRpZmllckNoYXJzICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzICsgXCJdKStcIik7XG5cbnZhciBub25BU0NJSXdoaXRlc3BhY2UgPSAvW1xcdTE2ODBcXHUxODBlXFx1MjAwMC1cXHUyMDBhXFx1MjAyZlxcdTIwNWZcXHUzMDAwXFx1ZmVmZl0vOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblxuLy8gV2hldGhlciBhIHNpbmdsZSBjaGFyYWN0ZXIgZGVub3RlcyBhIG5ld2xpbmUuXG5cbmV4cG9ydHMubmV3bGluZSA9IC9bXFxuXFxyXFx1MjAyOFxcdTIwMjldLztcblxuLy8gTWF0Y2hlcyBhIHdob2xlIGxpbmUgYnJlYWsgKHdoZXJlIENSTEYgaXMgY29uc2lkZXJlZCBhIHNpbmdsZVxuLy8gbGluZSBicmVhaykuIFVzZWQgdG8gY291bnQgbGluZXMuXG5cbi8vIGluIGphdmFzY3JpcHQsIHRoZXNlIHR3byBkaWZmZXJcbi8vIGluIHB5dGhvbiB0aGV5IGFyZSB0aGUgc2FtZSwgZGlmZmVyZW50IG1ldGhvZHMgYXJlIGNhbGxlZCBvbiB0aGVtXG5leHBvcnRzLmxpbmVCcmVhayA9IG5ldyBSZWdFeHAoJ1xcclxcbnwnICsgZXhwb3J0cy5uZXdsaW5lLnNvdXJjZSk7XG5leHBvcnRzLmFsbExpbmVCcmVha3MgPSBuZXcgUmVnRXhwKGV4cG9ydHMubGluZUJyZWFrLnNvdXJjZSwgJ2cnKTtcbiIsIi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBPdXRwdXQgPSByZXF1aXJlKCcuLi9jb3JlL291dHB1dCcpLk91dHB1dDtcbnZhciBUb2tlbiA9IHJlcXVpcmUoJy4uL2NvcmUvdG9rZW4nKS5Ub2tlbjtcbnZhciBhY29ybiA9IHJlcXVpcmUoJy4vYWNvcm4nKTtcbnZhciBPcHRpb25zID0gcmVxdWlyZSgnLi9vcHRpb25zJykuT3B0aW9ucztcbnZhciBUb2tlbml6ZXIgPSByZXF1aXJlKCcuL3Rva2VuaXplcicpLlRva2VuaXplcjtcbnZhciBsaW5lX3N0YXJ0ZXJzID0gcmVxdWlyZSgnLi90b2tlbml6ZXInKS5saW5lX3N0YXJ0ZXJzO1xudmFyIHBvc2l0aW9uYWJsZV9vcGVyYXRvcnMgPSByZXF1aXJlKCcuL3Rva2VuaXplcicpLnBvc2l0aW9uYWJsZV9vcGVyYXRvcnM7XG52YXIgVE9LRU4gPSByZXF1aXJlKCcuL3Rva2VuaXplcicpLlRPS0VOO1xuXG5cbmZ1bmN0aW9uIGluX2FycmF5KHdoYXQsIGFycikge1xuICByZXR1cm4gYXJyLmluZGV4T2Yod2hhdCkgIT09IC0xO1xufVxuXG5mdW5jdGlvbiBsdHJpbShzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoL15cXHMrL2csICcnKTtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVNYXBGcm9tU3RyaW5ncyhsaXN0KSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBsaXN0Lmxlbmd0aDsgeCsrKSB7XG4gICAgLy8gbWFrZSB0aGUgbWFwcGVkIG5hbWVzIHVuZGVyc2NvcmVkIGluc3RlYWQgb2YgZGFzaFxuICAgIHJlc3VsdFtsaXN0W3hdLnJlcGxhY2UoLy0vZywgJ18nKV0gPSBsaXN0W3hdO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHJlc2VydmVkX3dvcmQodG9rZW4sIHdvcmQpIHtcbiAgcmV0dXJuIHRva2VuICYmIHRva2VuLnR5cGUgPT09IFRPS0VOLlJFU0VSVkVEICYmIHRva2VuLnRleHQgPT09IHdvcmQ7XG59XG5cbmZ1bmN0aW9uIHJlc2VydmVkX2FycmF5KHRva2VuLCB3b3Jkcykge1xuICByZXR1cm4gdG9rZW4gJiYgdG9rZW4udHlwZSA9PT0gVE9LRU4uUkVTRVJWRUQgJiYgaW5fYXJyYXkodG9rZW4udGV4dCwgd29yZHMpO1xufVxuLy8gVW5zdXJlIG9mIHdoYXQgdGhleSBtZWFuLCBidXQgdGhleSB3b3JrLiBXb3J0aCBjbGVhbmluZyB1cCBpbiBmdXR1cmUuXG52YXIgc3BlY2lhbF93b3JkcyA9IFsnY2FzZScsICdyZXR1cm4nLCAnZG8nLCAnaWYnLCAndGhyb3cnLCAnZWxzZScsICdhd2FpdCcsICdicmVhaycsICdjb250aW51ZScsICdhc3luYyddO1xuXG52YXIgdmFsaWRQb3NpdGlvblZhbHVlcyA9IFsnYmVmb3JlLW5ld2xpbmUnLCAnYWZ0ZXItbmV3bGluZScsICdwcmVzZXJ2ZS1uZXdsaW5lJ107XG5cbi8vIEdlbmVyYXRlIG1hcCBmcm9tIGFycmF5XG52YXIgT1BFUkFUT1JfUE9TSVRJT04gPSBnZW5lcmF0ZU1hcEZyb21TdHJpbmdzKHZhbGlkUG9zaXRpb25WYWx1ZXMpO1xuXG52YXIgT1BFUkFUT1JfUE9TSVRJT05fQkVGT1JFX09SX1BSRVNFUlZFID0gW09QRVJBVE9SX1BPU0lUSU9OLmJlZm9yZV9uZXdsaW5lLCBPUEVSQVRPUl9QT1NJVElPTi5wcmVzZXJ2ZV9uZXdsaW5lXTtcblxudmFyIE1PREUgPSB7XG4gIEJsb2NrU3RhdGVtZW50OiAnQmxvY2tTdGF0ZW1lbnQnLCAvLyAnQkxPQ0snXG4gIFN0YXRlbWVudDogJ1N0YXRlbWVudCcsIC8vICdTVEFURU1FTlQnXG4gIE9iamVjdExpdGVyYWw6ICdPYmplY3RMaXRlcmFsJywgLy8gJ09CSkVDVCcsXG4gIEFycmF5TGl0ZXJhbDogJ0FycmF5TGl0ZXJhbCcsIC8vJ1tFWFBSRVNTSU9OXScsXG4gIEZvckluaXRpYWxpemVyOiAnRm9ySW5pdGlhbGl6ZXInLCAvLycoRk9SLUVYUFJFU1NJT04pJyxcbiAgQ29uZGl0aW9uYWw6ICdDb25kaXRpb25hbCcsIC8vJyhDT05ELUVYUFJFU1NJT04pJyxcbiAgRXhwcmVzc2lvbjogJ0V4cHJlc3Npb24nIC8vJyhFWFBSRVNTSU9OKSdcbn07XG5cbmZ1bmN0aW9uIHJlbW92ZV9yZWR1bmRhbnRfaW5kZW50YXRpb24ob3V0cHV0LCBmcmFtZSkge1xuICAvLyBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGVmZmVjdGl2ZSBidXQgaGFzIHNvbWUgaXNzdWVzOlxuICAvLyAgICAgLSBjYW4gY2F1c2UgbGluZSB3cmFwIHRvIGhhcHBlbiB0b28gc29vbiBkdWUgdG8gaW5kZW50IHJlbW92YWxcbiAgLy8gICAgICAgICAgIGFmdGVyIHdyYXAgcG9pbnRzIGFyZSBjYWxjdWxhdGVkXG4gIC8vIFRoZXNlIGlzc3VlcyBhcmUgbWlub3IgY29tcGFyZWQgdG8gdWdseSBpbmRlbnRhdGlvbi5cblxuICBpZiAoZnJhbWUubXVsdGlsaW5lX2ZyYW1lIHx8XG4gICAgZnJhbWUubW9kZSA9PT0gTU9ERS5Gb3JJbml0aWFsaXplciB8fFxuICAgIGZyYW1lLm1vZGUgPT09IE1PREUuQ29uZGl0aW9uYWwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyByZW1vdmUgb25lIGluZGVudCBmcm9tIGVhY2ggbGluZSBpbnNpZGUgdGhpcyBzZWN0aW9uXG4gIG91dHB1dC5yZW1vdmVfaW5kZW50KGZyYW1lLnN0YXJ0X2xpbmVfaW5kZXgpO1xufVxuXG4vLyB3ZSBjb3VsZCB1c2UganVzdCBzdHJpbmcuc3BsaXQsIGJ1dFxuLy8gSUUgZG9lc24ndCBsaWtlIHJldHVybmluZyBlbXB0eSBzdHJpbmdzXG5mdW5jdGlvbiBzcGxpdF9saW5lYnJlYWtzKHMpIHtcbiAgLy9yZXR1cm4gcy5zcGxpdCgvXFx4MGRcXHgwYXxcXHgwYS8pO1xuXG4gIHMgPSBzLnJlcGxhY2UoYWNvcm4uYWxsTGluZUJyZWFrcywgJ1xcbicpO1xuICB2YXIgb3V0ID0gW10sXG4gICAgaWR4ID0gcy5pbmRleE9mKFwiXFxuXCIpO1xuICB3aGlsZSAoaWR4ICE9PSAtMSkge1xuICAgIG91dC5wdXNoKHMuc3Vic3RyaW5nKDAsIGlkeCkpO1xuICAgIHMgPSBzLnN1YnN0cmluZyhpZHggKyAxKTtcbiAgICBpZHggPSBzLmluZGV4T2YoXCJcXG5cIik7XG4gIH1cbiAgaWYgKHMubGVuZ3RoKSB7XG4gICAgb3V0LnB1c2gocyk7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gaXNfYXJyYXkobW9kZSkge1xuICByZXR1cm4gbW9kZSA9PT0gTU9ERS5BcnJheUxpdGVyYWw7XG59XG5cbmZ1bmN0aW9uIGlzX2V4cHJlc3Npb24obW9kZSkge1xuICByZXR1cm4gaW5fYXJyYXkobW9kZSwgW01PREUuRXhwcmVzc2lvbiwgTU9ERS5Gb3JJbml0aWFsaXplciwgTU9ERS5Db25kaXRpb25hbF0pO1xufVxuXG5mdW5jdGlvbiBhbGxfbGluZXNfc3RhcnRfd2l0aChsaW5lcywgYykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxpbmUgPSBsaW5lc1tpXS50cmltKCk7XG4gICAgaWYgKGxpbmUuY2hhckF0KDApICE9PSBjKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBlYWNoX2xpbmVfbWF0Y2hlc19pbmRlbnQobGluZXMsIGluZGVudCkge1xuICB2YXIgaSA9IDAsXG4gICAgbGVuID0gbGluZXMubGVuZ3RoLFxuICAgIGxpbmU7XG4gIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBsaW5lID0gbGluZXNbaV07XG4gICAgLy8gYWxsb3cgZW1wdHkgbGluZXMgdG8gcGFzcyB0aHJvdWdoXG4gICAgaWYgKGxpbmUgJiYgbGluZS5pbmRleE9mKGluZGVudCkgIT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cblxuZnVuY3Rpb24gQmVhdXRpZmllcihzb3VyY2VfdGV4dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5fc291cmNlX3RleHQgPSBzb3VyY2VfdGV4dCB8fCAnJztcblxuICB0aGlzLl9vdXRwdXQgPSBudWxsO1xuICB0aGlzLl90b2tlbnMgPSBudWxsO1xuICB0aGlzLl9sYXN0X2xhc3RfdGV4dCA9IG51bGw7XG4gIHRoaXMuX2ZsYWdzID0gbnVsbDtcbiAgdGhpcy5fcHJldmlvdXNfZmxhZ3MgPSBudWxsO1xuXG4gIHRoaXMuX2ZsYWdfc3RvcmUgPSBudWxsO1xuICB0aGlzLl9vcHRpb25zID0gbmV3IE9wdGlvbnMob3B0aW9ucyk7XG59XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmNyZWF0ZV9mbGFncyA9IGZ1bmN0aW9uKGZsYWdzX2Jhc2UsIG1vZGUpIHtcbiAgdmFyIG5leHRfaW5kZW50X2xldmVsID0gMDtcbiAgaWYgKGZsYWdzX2Jhc2UpIHtcbiAgICBuZXh0X2luZGVudF9sZXZlbCA9IGZsYWdzX2Jhc2UuaW5kZW50YXRpb25fbGV2ZWw7XG4gICAgaWYgKCF0aGlzLl9vdXRwdXQuanVzdF9hZGRlZF9uZXdsaW5lKCkgJiZcbiAgICAgIGZsYWdzX2Jhc2UubGluZV9pbmRlbnRfbGV2ZWwgPiBuZXh0X2luZGVudF9sZXZlbCkge1xuICAgICAgbmV4dF9pbmRlbnRfbGV2ZWwgPSBmbGFnc19iYXNlLmxpbmVfaW5kZW50X2xldmVsO1xuICAgIH1cbiAgfVxuXG4gIHZhciBuZXh0X2ZsYWdzID0ge1xuICAgIG1vZGU6IG1vZGUsXG4gICAgcGFyZW50OiBmbGFnc19iYXNlLFxuICAgIGxhc3RfdG9rZW46IGZsYWdzX2Jhc2UgPyBmbGFnc19iYXNlLmxhc3RfdG9rZW4gOiBuZXcgVG9rZW4oVE9LRU4uU1RBUlRfQkxPQ0ssICcnKSwgLy8gbGFzdCB0b2tlbiB0ZXh0XG4gICAgbGFzdF93b3JkOiBmbGFnc19iYXNlID8gZmxhZ3NfYmFzZS5sYXN0X3dvcmQgOiAnJywgLy8gbGFzdCBUT0tFTi5XT1JEIHBhc3NlZFxuICAgIGRlY2xhcmF0aW9uX3N0YXRlbWVudDogZmFsc2UsXG4gICAgZGVjbGFyYXRpb25fYXNzaWdubWVudDogZmFsc2UsXG4gICAgbXVsdGlsaW5lX2ZyYW1lOiBmYWxzZSxcbiAgICBpbmxpbmVfZnJhbWU6IGZhbHNlLFxuICAgIGlmX2Jsb2NrOiBmYWxzZSxcbiAgICBlbHNlX2Jsb2NrOiBmYWxzZSxcbiAgICBkb19ibG9jazogZmFsc2UsXG4gICAgZG9fd2hpbGU6IGZhbHNlLFxuICAgIGltcG9ydF9ibG9jazogZmFsc2UsXG4gICAgaW5fY2FzZV9zdGF0ZW1lbnQ6IGZhbHNlLCAvLyBzd2l0Y2goLi4peyBJTlNJREUgSEVSRSB9XG4gICAgaW5fY2FzZTogZmFsc2UsIC8vIHdlJ3JlIG9uIHRoZSBleGFjdCBsaW5lIHdpdGggXCJjYXNlIDA6XCJcbiAgICBjYXNlX2JvZHk6IGZhbHNlLCAvLyB0aGUgaW5kZW50ZWQgY2FzZS1hY3Rpb24gYmxvY2tcbiAgICBpbmRlbnRhdGlvbl9sZXZlbDogbmV4dF9pbmRlbnRfbGV2ZWwsXG4gICAgYWxpZ25tZW50OiAwLFxuICAgIGxpbmVfaW5kZW50X2xldmVsOiBmbGFnc19iYXNlID8gZmxhZ3NfYmFzZS5saW5lX2luZGVudF9sZXZlbCA6IG5leHRfaW5kZW50X2xldmVsLFxuICAgIHN0YXJ0X2xpbmVfaW5kZXg6IHRoaXMuX291dHB1dC5nZXRfbGluZV9udW1iZXIoKSxcbiAgICB0ZXJuYXJ5X2RlcHRoOiAwXG4gIH07XG4gIHJldHVybiBuZXh0X2ZsYWdzO1xufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuX3Jlc2V0ID0gZnVuY3Rpb24oc291cmNlX3RleHQpIHtcbiAgdmFyIGJhc2VJbmRlbnRTdHJpbmcgPSBzb3VyY2VfdGV4dC5tYXRjaCgvXltcXHQgXSovKVswXTtcblxuICB0aGlzLl9sYXN0X2xhc3RfdGV4dCA9ICcnOyAvLyBwcmUtbGFzdCB0b2tlbiB0ZXh0XG4gIHRoaXMuX291dHB1dCA9IG5ldyBPdXRwdXQodGhpcy5fb3B0aW9ucywgYmFzZUluZGVudFN0cmluZyk7XG5cbiAgLy8gSWYgdGVzdGluZyB0aGUgaWdub3JlIGRpcmVjdGl2ZSwgc3RhcnQgd2l0aCBvdXRwdXQgZGlzYWJsZSBzZXQgdG8gdHJ1ZVxuICB0aGlzLl9vdXRwdXQucmF3ID0gdGhpcy5fb3B0aW9ucy50ZXN0X291dHB1dF9yYXc7XG5cblxuICAvLyBTdGFjayBvZiBwYXJzaW5nL2Zvcm1hdHRpbmcgc3RhdGVzLCBpbmNsdWRpbmcgTU9ERS5cbiAgLy8gV2UgdG9rZW5pemUsIHBhcnNlLCBhbmQgb3V0cHV0IGluIGFuIGFsbW9zdCBwdXJlbHkgYSBmb3J3YXJkLW9ubHkgc3RyZWFtIG9mIHRva2VuIGlucHV0XG4gIC8vIGFuZCBmb3JtYXR0ZWQgb3V0cHV0LiAgVGhpcyBtYWtlcyB0aGUgYmVhdXRpZmllciBsZXNzIGFjY3VyYXRlIHRoYW4gZnVsbCBwYXJzZXJzXG4gIC8vIGJ1dCBhbHNvIGZhciBtb3JlIHRvbGVyYW50IG9mIHN5bnRheCBlcnJvcnMuXG4gIC8vXG4gIC8vIEZvciBleGFtcGxlLCB0aGUgZGVmYXVsdCBtb2RlIGlzIE1PREUuQmxvY2tTdGF0ZW1lbnQuIElmIHdlIHNlZSBhICd7JyB3ZSBwdXNoIGEgbmV3IGZyYW1lIG9mIHR5cGVcbiAgLy8gTU9ERS5CbG9ja1N0YXRlbWVudCBvbiB0aGUgdGhlIHN0YWNrLCBldmVuIHRob3VnaCBpdCBjb3VsZCBiZSBvYmplY3QgbGl0ZXJhbC4gIElmIHdlIGxhdGVyXG4gIC8vIGVuY291bnRlciBhIFwiOlwiLCB3ZSdsbCBzd2l0Y2ggdG8gdG8gTU9ERS5PYmplY3RMaXRlcmFsLiAgSWYgd2UgdGhlbiBzZWUgYSBcIjtcIixcbiAgLy8gbW9zdCBmdWxsIHBhcnNlcnMgd291bGQgZGllLCBidXQgdGhlIGJlYXV0aWZpZXIgZ3JhY2VmdWxseSBmYWxscyBiYWNrIHRvXG4gIC8vIE1PREUuQmxvY2tTdGF0ZW1lbnQgYW5kIGNvbnRpbnVlcyBvbi5cbiAgdGhpcy5fZmxhZ19zdG9yZSA9IFtdO1xuICB0aGlzLnNldF9tb2RlKE1PREUuQmxvY2tTdGF0ZW1lbnQpO1xuICB2YXIgdG9rZW5pemVyID0gbmV3IFRva2VuaXplcihzb3VyY2VfdGV4dCwgdGhpcy5fb3B0aW9ucyk7XG4gIHRoaXMuX3Rva2VucyA9IHRva2VuaXplci50b2tlbml6ZSgpO1xuICByZXR1cm4gc291cmNlX3RleHQ7XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5iZWF1dGlmeSA9IGZ1bmN0aW9uKCkge1xuICAvLyBpZiBkaXNhYmxlZCwgcmV0dXJuIHRoZSBpbnB1dCB1bmNoYW5nZWQuXG4gIGlmICh0aGlzLl9vcHRpb25zLmRpc2FibGVkKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NvdXJjZV90ZXh0O1xuICB9XG5cbiAgdmFyIHN3ZWV0X2NvZGU7XG4gIHZhciBzb3VyY2VfdGV4dCA9IHRoaXMuX3Jlc2V0KHRoaXMuX3NvdXJjZV90ZXh0KTtcblxuICB2YXIgZW9sID0gdGhpcy5fb3B0aW9ucy5lb2w7XG4gIGlmICh0aGlzLl9vcHRpb25zLmVvbCA9PT0gJ2F1dG8nKSB7XG4gICAgZW9sID0gJ1xcbic7XG4gICAgaWYgKHNvdXJjZV90ZXh0ICYmIGFjb3JuLmxpbmVCcmVhay50ZXN0KHNvdXJjZV90ZXh0IHx8ICcnKSkge1xuICAgICAgZW9sID0gc291cmNlX3RleHQubWF0Y2goYWNvcm4ubGluZUJyZWFrKVswXTtcbiAgICB9XG4gIH1cblxuICB2YXIgY3VycmVudF90b2tlbiA9IHRoaXMuX3Rva2Vucy5uZXh0KCk7XG4gIHdoaWxlIChjdXJyZW50X3Rva2VuKSB7XG4gICAgdGhpcy5oYW5kbGVfdG9rZW4oY3VycmVudF90b2tlbik7XG5cbiAgICB0aGlzLl9sYXN0X2xhc3RfdGV4dCA9IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dDtcbiAgICB0aGlzLl9mbGFncy5sYXN0X3Rva2VuID0gY3VycmVudF90b2tlbjtcblxuICAgIGN1cnJlbnRfdG9rZW4gPSB0aGlzLl90b2tlbnMubmV4dCgpO1xuICB9XG5cbiAgc3dlZXRfY29kZSA9IHRoaXMuX291dHB1dC5nZXRfY29kZShlb2wpO1xuXG4gIHJldHVybiBzd2VldF9jb2RlO1xufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuaGFuZGxlX3Rva2VuID0gZnVuY3Rpb24oY3VycmVudF90b2tlbiwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKSB7XG4gIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLlNUQVJUX0VYUFIpIHtcbiAgICB0aGlzLmhhbmRsZV9zdGFydF9leHByKGN1cnJlbnRfdG9rZW4pO1xuICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uRU5EX0VYUFIpIHtcbiAgICB0aGlzLmhhbmRsZV9lbmRfZXhwcihjdXJyZW50X3Rva2VuKTtcbiAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLlNUQVJUX0JMT0NLKSB7XG4gICAgdGhpcy5oYW5kbGVfc3RhcnRfYmxvY2soY3VycmVudF90b2tlbik7XG4gIH0gZWxzZSBpZiAoY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5FTkRfQkxPQ0spIHtcbiAgICB0aGlzLmhhbmRsZV9lbmRfYmxvY2soY3VycmVudF90b2tlbik7XG4gIH0gZWxzZSBpZiAoY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5XT1JEKSB7XG4gICAgdGhpcy5oYW5kbGVfd29yZChjdXJyZW50X3Rva2VuKTtcbiAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLlJFU0VSVkVEKSB7XG4gICAgdGhpcy5oYW5kbGVfd29yZChjdXJyZW50X3Rva2VuKTtcbiAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLlNFTUlDT0xPTikge1xuICAgIHRoaXMuaGFuZGxlX3NlbWljb2xvbihjdXJyZW50X3Rva2VuKTtcbiAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLlNUUklORykge1xuICAgIHRoaXMuaGFuZGxlX3N0cmluZyhjdXJyZW50X3Rva2VuKTtcbiAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLkVRVUFMUykge1xuICAgIHRoaXMuaGFuZGxlX2VxdWFscyhjdXJyZW50X3Rva2VuKTtcbiAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLk9QRVJBVE9SKSB7XG4gICAgdGhpcy5oYW5kbGVfb3BlcmF0b3IoY3VycmVudF90b2tlbik7XG4gIH0gZWxzZSBpZiAoY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5DT01NQSkge1xuICAgIHRoaXMuaGFuZGxlX2NvbW1hKGN1cnJlbnRfdG9rZW4pO1xuICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uQkxPQ0tfQ09NTUVOVCkge1xuICAgIHRoaXMuaGFuZGxlX2Jsb2NrX2NvbW1lbnQoY3VycmVudF90b2tlbiwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLkNPTU1FTlQpIHtcbiAgICB0aGlzLmhhbmRsZV9jb21tZW50KGN1cnJlbnRfdG9rZW4sIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyk7XG4gIH0gZWxzZSBpZiAoY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5ET1QpIHtcbiAgICB0aGlzLmhhbmRsZV9kb3QoY3VycmVudF90b2tlbik7XG4gIH0gZWxzZSBpZiAoY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5FT0YpIHtcbiAgICB0aGlzLmhhbmRsZV9lb2YoY3VycmVudF90b2tlbik7XG4gIH0gZWxzZSBpZiAoY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5VTktOT1dOKSB7XG4gICAgdGhpcy5oYW5kbGVfdW5rbm93bihjdXJyZW50X3Rva2VuLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaGFuZGxlX3Vua25vd24oY3VycmVudF90b2tlbiwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgfVxufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzID0gZnVuY3Rpb24oY3VycmVudF90b2tlbiwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKSB7XG4gIHZhciBuZXdsaW5lcyA9IGN1cnJlbnRfdG9rZW4ubmV3bGluZXM7XG4gIHZhciBrZWVwX3doaXRlc3BhY2UgPSB0aGlzLl9vcHRpb25zLmtlZXBfYXJyYXlfaW5kZW50YXRpb24gJiYgaXNfYXJyYXkodGhpcy5fZmxhZ3MubW9kZSk7XG5cbiAgaWYgKGN1cnJlbnRfdG9rZW4uY29tbWVudHNfYmVmb3JlKSB7XG4gICAgdmFyIGNvbW1lbnRfdG9rZW4gPSBjdXJyZW50X3Rva2VuLmNvbW1lbnRzX2JlZm9yZS5uZXh0KCk7XG4gICAgd2hpbGUgKGNvbW1lbnRfdG9rZW4pIHtcbiAgICAgIC8vIFRoZSBjbGVhbmVzdCBoYW5kbGluZyBvZiBpbmxpbmUgY29tbWVudHMgaXMgdG8gdHJlYXQgdGhlbSBhcyB0aG91Z2ggdGhleSBhcmVuJ3QgdGhlcmUuXG4gICAgICAvLyBKdXN0IGNvbnRpbnVlIGZvcm1hdHRpbmcgYW5kIHRoZSBiZWhhdmlvciBzaG91bGQgYmUgbG9naWNhbC5cbiAgICAgIC8vIEFsc28gaWdub3JlIHVua25vd24gdG9rZW5zLiAgQWdhaW4sIHRoaXMgc2hvdWxkIHJlc3VsdCBpbiBiZXR0ZXIgYmVoYXZpb3IuXG4gICAgICB0aGlzLmhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhjb21tZW50X3Rva2VuLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICAgICAgdGhpcy5oYW5kbGVfdG9rZW4oY29tbWVudF90b2tlbiwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgICAgIGNvbW1lbnRfdG9rZW4gPSBjdXJyZW50X3Rva2VuLmNvbW1lbnRzX2JlZm9yZS5uZXh0KCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGtlZXBfd2hpdGVzcGFjZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3bGluZXM7IGkgKz0gMSkge1xuICAgICAgdGhpcy5wcmludF9uZXdsaW5lKGkgPiAwLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5tYXhfcHJlc2VydmVfbmV3bGluZXMgJiYgbmV3bGluZXMgPiB0aGlzLl9vcHRpb25zLm1heF9wcmVzZXJ2ZV9uZXdsaW5lcykge1xuICAgICAgbmV3bGluZXMgPSB0aGlzLl9vcHRpb25zLm1heF9wcmVzZXJ2ZV9uZXdsaW5lcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5wcmVzZXJ2ZV9uZXdsaW5lcykge1xuICAgICAgaWYgKG5ld2xpbmVzID4gMSkge1xuICAgICAgICB0aGlzLnByaW50X25ld2xpbmUoZmFsc2UsIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyk7XG4gICAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgbmV3bGluZXM7IGogKz0gMSkge1xuICAgICAgICAgIHRoaXMucHJpbnRfbmV3bGluZSh0cnVlLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cbnZhciBuZXdsaW5lX3Jlc3RyaWN0ZWRfdG9rZW5zID0gWydhc3luYycsICdicmVhaycsICdjb250aW51ZScsICdyZXR1cm4nLCAndGhyb3cnLCAneWllbGQnXTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZSA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4sIGZvcmNlX2xpbmV3cmFwKSB7XG4gIGZvcmNlX2xpbmV3cmFwID0gKGZvcmNlX2xpbmV3cmFwID09PSB1bmRlZmluZWQpID8gZmFsc2UgOiBmb3JjZV9saW5ld3JhcDtcblxuICAvLyBOZXZlciB3cmFwIHRoZSBmaXJzdCB0b2tlbiBvbiBhIGxpbmVcbiAgaWYgKHRoaXMuX291dHB1dC5qdXN0X2FkZGVkX25ld2xpbmUoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzaG91bGRQcmVzZXJ2ZU9yRm9yY2UgPSAodGhpcy5fb3B0aW9ucy5wcmVzZXJ2ZV9uZXdsaW5lcyAmJiBjdXJyZW50X3Rva2VuLm5ld2xpbmVzKSB8fCBmb3JjZV9saW5ld3JhcDtcbiAgdmFyIG9wZXJhdG9yTG9naWNBcHBsaWVzID0gaW5fYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0LCBwb3NpdGlvbmFibGVfb3BlcmF0b3JzKSB8fFxuICAgIGluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCwgcG9zaXRpb25hYmxlX29wZXJhdG9ycyk7XG5cbiAgaWYgKG9wZXJhdG9yTG9naWNBcHBsaWVzKSB7XG4gICAgdmFyIHNob3VsZFByaW50T3BlcmF0b3JOZXdsaW5lID0gKFxuICAgICAgICBpbl9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQsIHBvc2l0aW9uYWJsZV9vcGVyYXRvcnMpICYmXG4gICAgICAgIGluX2FycmF5KHRoaXMuX29wdGlvbnMub3BlcmF0b3JfcG9zaXRpb24sIE9QRVJBVE9SX1BPU0lUSU9OX0JFRk9SRV9PUl9QUkVTRVJWRSlcbiAgICAgICkgfHxcbiAgICAgIGluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCwgcG9zaXRpb25hYmxlX29wZXJhdG9ycyk7XG4gICAgc2hvdWxkUHJlc2VydmVPckZvcmNlID0gc2hvdWxkUHJlc2VydmVPckZvcmNlICYmIHNob3VsZFByaW50T3BlcmF0b3JOZXdsaW5lO1xuICB9XG5cbiAgaWYgKHNob3VsZFByZXNlcnZlT3JGb3JjZSkge1xuICAgIHRoaXMucHJpbnRfbmV3bGluZShmYWxzZSwgdHJ1ZSk7XG4gIH0gZWxzZSBpZiAodGhpcy5fb3B0aW9ucy53cmFwX2xpbmVfbGVuZ3RoKSB7XG4gICAgaWYgKHJlc2VydmVkX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4sIG5ld2xpbmVfcmVzdHJpY3RlZF90b2tlbnMpKSB7XG4gICAgICAvLyBUaGVzZSB0b2tlbnMgc2hvdWxkIG5ldmVyIGhhdmUgYSBuZXdsaW5lIGluc2VydGVkXG4gICAgICAvLyBiZXR3ZWVuIHRoZW0gYW5kIHRoZSBmb2xsb3dpbmcgZXhwcmVzc2lvbi5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fb3V0cHV0LnNldF93cmFwX3BvaW50KCk7XG4gIH1cbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLnByaW50X25ld2xpbmUgPSBmdW5jdGlvbihmb3JjZV9uZXdsaW5lLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpIHtcbiAgaWYgKCFwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpIHtcbiAgICBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ICE9PSAnOycgJiYgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ICE9PSAnLCcgJiYgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ICE9PSAnPScgJiYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSAhPT0gVE9LRU4uT1BFUkFUT1IgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnLS0nIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJysrJykpIHtcbiAgICAgIHZhciBuZXh0X3Rva2VuID0gdGhpcy5fdG9rZW5zLnBlZWsoKTtcbiAgICAgIHdoaWxlICh0aGlzLl9mbGFncy5tb2RlID09PSBNT0RFLlN0YXRlbWVudCAmJlxuICAgICAgICAhKHRoaXMuX2ZsYWdzLmlmX2Jsb2NrICYmIHJlc2VydmVkX3dvcmQobmV4dF90b2tlbiwgJ2Vsc2UnKSkgJiZcbiAgICAgICAgIXRoaXMuX2ZsYWdzLmRvX2Jsb2NrKSB7XG4gICAgICAgIHRoaXMucmVzdG9yZV9tb2RlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMuX291dHB1dC5hZGRfbmV3X2xpbmUoZm9yY2VfbmV3bGluZSkpIHtcbiAgICB0aGlzLl9mbGFncy5tdWx0aWxpbmVfZnJhbWUgPSB0cnVlO1xuICB9XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5wcmludF90b2tlbl9saW5lX2luZGVudGF0aW9uID0gZnVuY3Rpb24oY3VycmVudF90b2tlbikge1xuICBpZiAodGhpcy5fb3V0cHV0Lmp1c3RfYWRkZWRfbmV3bGluZSgpKSB7XG4gICAgaWYgKHRoaXMuX29wdGlvbnMua2VlcF9hcnJheV9pbmRlbnRhdGlvbiAmJlxuICAgICAgY3VycmVudF90b2tlbi5uZXdsaW5lcyAmJlxuICAgICAgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJ1snIHx8IGlzX2FycmF5KHRoaXMuX2ZsYWdzLm1vZGUpKSkge1xuICAgICAgdGhpcy5fb3V0cHV0LmN1cnJlbnRfbGluZS5zZXRfaW5kZW50KC0xKTtcbiAgICAgIHRoaXMuX291dHB1dC5jdXJyZW50X2xpbmUucHVzaChjdXJyZW50X3Rva2VuLndoaXRlc3BhY2VfYmVmb3JlKTtcbiAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX291dHB1dC5zZXRfaW5kZW50KHRoaXMuX2ZsYWdzLmluZGVudGF0aW9uX2xldmVsLCB0aGlzLl9mbGFncy5hbGlnbm1lbnQpKSB7XG4gICAgICB0aGlzLl9mbGFncy5saW5lX2luZGVudF9sZXZlbCA9IHRoaXMuX2ZsYWdzLmluZGVudGF0aW9uX2xldmVsO1xuICAgIH1cbiAgfVxufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUucHJpbnRfdG9rZW4gPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7XG4gIGlmICh0aGlzLl9vdXRwdXQucmF3KSB7XG4gICAgdGhpcy5fb3V0cHV0LmFkZF9yYXdfdG9rZW4oY3VycmVudF90b2tlbik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHRoaXMuX29wdGlvbnMuY29tbWFfZmlyc3QgJiYgY3VycmVudF90b2tlbi5wcmV2aW91cyAmJiBjdXJyZW50X3Rva2VuLnByZXZpb3VzLnR5cGUgPT09IFRPS0VOLkNPTU1BICYmXG4gICAgdGhpcy5fb3V0cHV0Lmp1c3RfYWRkZWRfbmV3bGluZSgpKSB7XG4gICAgaWYgKHRoaXMuX291dHB1dC5wcmV2aW91c19saW5lLmxhc3QoKSA9PT0gJywnKSB7XG4gICAgICB2YXIgcG9wcGVkID0gdGhpcy5fb3V0cHV0LnByZXZpb3VzX2xpbmUucG9wKCk7XG4gICAgICAvLyBpZiB0aGUgY29tbWEgd2FzIGFscmVhZHkgYXQgdGhlIHN0YXJ0IG9mIHRoZSBsaW5lLFxuICAgICAgLy8gcHVsbCBiYWNrIG9udG8gdGhhdCBsaW5lIGFuZCByZXByaW50IHRoZSBpbmRlbnRhdGlvblxuICAgICAgaWYgKHRoaXMuX291dHB1dC5wcmV2aW91c19saW5lLmlzX2VtcHR5KCkpIHtcbiAgICAgICAgdGhpcy5fb3V0cHV0LnByZXZpb3VzX2xpbmUucHVzaChwb3BwZWQpO1xuICAgICAgICB0aGlzLl9vdXRwdXQudHJpbSh0cnVlKTtcbiAgICAgICAgdGhpcy5fb3V0cHV0LmN1cnJlbnRfbGluZS5wb3AoKTtcbiAgICAgICAgdGhpcy5fb3V0cHV0LnRyaW0oKTtcbiAgICAgIH1cblxuICAgICAgLy8gYWRkIHRoZSBjb21tYSBpbiBmcm9udCBvZiB0aGUgbmV4dCB0b2tlblxuICAgICAgdGhpcy5wcmludF90b2tlbl9saW5lX2luZGVudGF0aW9uKGN1cnJlbnRfdG9rZW4pO1xuICAgICAgdGhpcy5fb3V0cHV0LmFkZF90b2tlbignLCcpO1xuICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5wcmludF90b2tlbl9saW5lX2luZGVudGF0aW9uKGN1cnJlbnRfdG9rZW4pO1xuICB0aGlzLl9vdXRwdXQubm9uX2JyZWFraW5nX3NwYWNlID0gdHJ1ZTtcbiAgdGhpcy5fb3V0cHV0LmFkZF90b2tlbihjdXJyZW50X3Rva2VuLnRleHQpO1xuICBpZiAodGhpcy5fb3V0cHV0LnByZXZpb3VzX3Rva2VuX3dyYXBwZWQpIHtcbiAgICB0aGlzLl9mbGFncy5tdWx0aWxpbmVfZnJhbWUgPSB0cnVlO1xuICB9XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5pbmRlbnQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fZmxhZ3MuaW5kZW50YXRpb25fbGV2ZWwgKz0gMTtcbiAgdGhpcy5fb3V0cHV0LnNldF9pbmRlbnQodGhpcy5fZmxhZ3MuaW5kZW50YXRpb25fbGV2ZWwsIHRoaXMuX2ZsYWdzLmFsaWdubWVudCk7XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5kZWluZGVudCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fZmxhZ3MuaW5kZW50YXRpb25fbGV2ZWwgPiAwICYmXG4gICAgKCghdGhpcy5fZmxhZ3MucGFyZW50KSB8fCB0aGlzLl9mbGFncy5pbmRlbnRhdGlvbl9sZXZlbCA+IHRoaXMuX2ZsYWdzLnBhcmVudC5pbmRlbnRhdGlvbl9sZXZlbCkpIHtcbiAgICB0aGlzLl9mbGFncy5pbmRlbnRhdGlvbl9sZXZlbCAtPSAxO1xuICAgIHRoaXMuX291dHB1dC5zZXRfaW5kZW50KHRoaXMuX2ZsYWdzLmluZGVudGF0aW9uX2xldmVsLCB0aGlzLl9mbGFncy5hbGlnbm1lbnQpO1xuICB9XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5zZXRfbW9kZSA9IGZ1bmN0aW9uKG1vZGUpIHtcbiAgaWYgKHRoaXMuX2ZsYWdzKSB7XG4gICAgdGhpcy5fZmxhZ19zdG9yZS5wdXNoKHRoaXMuX2ZsYWdzKTtcbiAgICB0aGlzLl9wcmV2aW91c19mbGFncyA9IHRoaXMuX2ZsYWdzO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX3ByZXZpb3VzX2ZsYWdzID0gdGhpcy5jcmVhdGVfZmxhZ3MobnVsbCwgbW9kZSk7XG4gIH1cblxuICB0aGlzLl9mbGFncyA9IHRoaXMuY3JlYXRlX2ZsYWdzKHRoaXMuX3ByZXZpb3VzX2ZsYWdzLCBtb2RlKTtcbiAgdGhpcy5fb3V0cHV0LnNldF9pbmRlbnQodGhpcy5fZmxhZ3MuaW5kZW50YXRpb25fbGV2ZWwsIHRoaXMuX2ZsYWdzLmFsaWdubWVudCk7XG59O1xuXG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLnJlc3RvcmVfbW9kZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fZmxhZ19zdG9yZS5sZW5ndGggPiAwKSB7XG4gICAgdGhpcy5fcHJldmlvdXNfZmxhZ3MgPSB0aGlzLl9mbGFncztcbiAgICB0aGlzLl9mbGFncyA9IHRoaXMuX2ZsYWdfc3RvcmUucG9wKCk7XG4gICAgaWYgKHRoaXMuX3ByZXZpb3VzX2ZsYWdzLm1vZGUgPT09IE1PREUuU3RhdGVtZW50KSB7XG4gICAgICByZW1vdmVfcmVkdW5kYW50X2luZGVudGF0aW9uKHRoaXMuX291dHB1dCwgdGhpcy5fcHJldmlvdXNfZmxhZ3MpO1xuICAgIH1cbiAgICB0aGlzLl9vdXRwdXQuc2V0X2luZGVudCh0aGlzLl9mbGFncy5pbmRlbnRhdGlvbl9sZXZlbCwgdGhpcy5fZmxhZ3MuYWxpZ25tZW50KTtcbiAgfVxufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuc3RhcnRfb2Zfb2JqZWN0X3Byb3BlcnR5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9mbGFncy5wYXJlbnQubW9kZSA9PT0gTU9ERS5PYmplY3RMaXRlcmFsICYmIHRoaXMuX2ZsYWdzLm1vZGUgPT09IE1PREUuU3RhdGVtZW50ICYmIChcbiAgICAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnOicgJiYgdGhpcy5fZmxhZ3MudGVybmFyeV9kZXB0aCA9PT0gMCkgfHwgKHJlc2VydmVkX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4sIFsnZ2V0JywgJ3NldCddKSkpO1xufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuc3RhcnRfb2Zfc3RhdGVtZW50ID0gZnVuY3Rpb24oY3VycmVudF90b2tlbikge1xuICB2YXIgc3RhcnQgPSBmYWxzZTtcbiAgc3RhcnQgPSBzdGFydCB8fCByZXNlcnZlZF9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLCBbJ3ZhcicsICdsZXQnLCAnY29uc3QnXSkgJiYgY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5XT1JEO1xuICBzdGFydCA9IHN0YXJ0IHx8IHJlc2VydmVkX3dvcmQodGhpcy5fZmxhZ3MubGFzdF90b2tlbiwgJ2RvJyk7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgKCEodGhpcy5fZmxhZ3MucGFyZW50Lm1vZGUgPT09IE1PREUuT2JqZWN0TGl0ZXJhbCAmJiB0aGlzLl9mbGFncy5tb2RlID09PSBNT0RFLlN0YXRlbWVudCkpICYmIHJlc2VydmVkX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4sIG5ld2xpbmVfcmVzdHJpY3RlZF90b2tlbnMpICYmICFjdXJyZW50X3Rva2VuLm5ld2xpbmVzO1xuICBzdGFydCA9IHN0YXJ0IHx8IHJlc2VydmVkX3dvcmQodGhpcy5fZmxhZ3MubGFzdF90b2tlbiwgJ2Vsc2UnKSAmJlxuICAgICEocmVzZXJ2ZWRfd29yZChjdXJyZW50X3Rva2VuLCAnaWYnKSAmJiAhY3VycmVudF90b2tlbi5jb21tZW50c19iZWZvcmUpO1xuICBzdGFydCA9IHN0YXJ0IHx8ICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkVORF9FWFBSICYmICh0aGlzLl9wcmV2aW91c19mbGFncy5tb2RlID09PSBNT0RFLkZvckluaXRpYWxpemVyIHx8IHRoaXMuX3ByZXZpb3VzX2ZsYWdzLm1vZGUgPT09IE1PREUuQ29uZGl0aW9uYWwpKTtcbiAgc3RhcnQgPSBzdGFydCB8fCAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5XT1JEICYmIHRoaXMuX2ZsYWdzLm1vZGUgPT09IE1PREUuQmxvY2tTdGF0ZW1lbnQgJiZcbiAgICAhdGhpcy5fZmxhZ3MuaW5fY2FzZSAmJlxuICAgICEoY3VycmVudF90b2tlbi50ZXh0ID09PSAnLS0nIHx8IGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJysrJykgJiZcbiAgICB0aGlzLl9sYXN0X2xhc3RfdGV4dCAhPT0gJ2Z1bmN0aW9uJyAmJlxuICAgIGN1cnJlbnRfdG9rZW4udHlwZSAhPT0gVE9LRU4uV09SRCAmJiBjdXJyZW50X3Rva2VuLnR5cGUgIT09IFRPS0VOLlJFU0VSVkVEKTtcbiAgc3RhcnQgPSBzdGFydCB8fCAodGhpcy5fZmxhZ3MubW9kZSA9PT0gTU9ERS5PYmplY3RMaXRlcmFsICYmIChcbiAgICAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnOicgJiYgdGhpcy5fZmxhZ3MudGVybmFyeV9kZXB0aCA9PT0gMCkgfHwgcmVzZXJ2ZWRfYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbiwgWydnZXQnLCAnc2V0J10pKSk7XG5cbiAgaWYgKHN0YXJ0KSB7XG4gICAgdGhpcy5zZXRfbW9kZShNT0RFLlN0YXRlbWVudCk7XG4gICAgdGhpcy5pbmRlbnQoKTtcblxuICAgIHRoaXMuaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzKGN1cnJlbnRfdG9rZW4sIHRydWUpO1xuXG4gICAgLy8gSXNzdWUgIzI3NjpcbiAgICAvLyBJZiBzdGFydGluZyBhIG5ldyBzdGF0ZW1lbnQgd2l0aCBbaWYsIGZvciwgd2hpbGUsIGRvXSwgcHVzaCB0byBhIG5ldyBsaW5lLlxuICAgIC8vIGlmIChhKSBpZiAoYikgaWYoYykgZCgpOyBlbHNlIGUoKTsgZWxzZSBmKCk7XG4gICAgaWYgKCF0aGlzLnN0YXJ0X29mX29iamVjdF9wcm9wZXJ0eSgpKSB7XG4gICAgICB0aGlzLmFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoY3VycmVudF90b2tlbixcbiAgICAgICAgcmVzZXJ2ZWRfYXJyYXkoY3VycmVudF90b2tlbiwgWydkbycsICdmb3InLCAnaWYnLCAnd2hpbGUnXSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5oYW5kbGVfc3RhcnRfZXhwciA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4pIHtcbiAgLy8gVGhlIGNvbmRpdGlvbmFsIHN0YXJ0cyB0aGUgc3RhdGVtZW50IGlmIGFwcHJvcHJpYXRlLlxuICBpZiAoIXRoaXMuc3RhcnRfb2Zfc3RhdGVtZW50KGN1cnJlbnRfdG9rZW4pKSB7XG4gICAgdGhpcy5oYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbik7XG4gIH1cblxuICB2YXIgbmV4dF9tb2RlID0gTU9ERS5FeHByZXNzaW9uO1xuICBpZiAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnWycpIHtcblxuICAgIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLldPUkQgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnKScpIHtcbiAgICAgIC8vIHRoaXMgaXMgYXJyYXkgaW5kZXggc3BlY2lmaWVyLCBicmVhayBpbW1lZGlhdGVseVxuICAgICAgLy8gYVt4XSwgZm4oKVt4XVxuICAgICAgaWYgKHJlc2VydmVkX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4sIGxpbmVfc3RhcnRlcnMpKSB7XG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcbiAgICAgIHRoaXMuc2V0X21vZGUobmV4dF9tb2RlKTtcbiAgICAgIHRoaXMuaW5kZW50KCk7XG4gICAgICBpZiAodGhpcy5fb3B0aW9ucy5zcGFjZV9pbl9wYXJlbikge1xuICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBuZXh0X21vZGUgPSBNT0RFLkFycmF5TGl0ZXJhbDtcbiAgICBpZiAoaXNfYXJyYXkodGhpcy5fZmxhZ3MubW9kZSkpIHtcbiAgICAgIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICdbJyB8fFxuICAgICAgICAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnLCcgJiYgKHRoaXMuX2xhc3RfbGFzdF90ZXh0ID09PSAnXScgfHwgdGhpcy5fbGFzdF9sYXN0X3RleHQgPT09ICd9JykpKSB7XG4gICAgICAgIC8vIF0sIFsgZ29lcyB0byBuZXcgbGluZVxuICAgICAgICAvLyB9LCBbIGdvZXMgdG8gbmV3IGxpbmVcbiAgICAgICAgaWYgKCF0aGlzLl9vcHRpb25zLmtlZXBfYXJyYXlfaW5kZW50YXRpb24pIHtcbiAgICAgICAgICB0aGlzLnByaW50X25ld2xpbmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaW5fYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlLCBbVE9LRU4uU1RBUlRfRVhQUiwgVE9LRU4uRU5EX0VYUFIsIFRPS0VOLldPUkQsIFRPS0VOLk9QRVJBVE9SXSkpIHtcbiAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5SRVNFUlZFRCkge1xuICAgICAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJ2ZvcicpIHtcbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRoaXMuX29wdGlvbnMuc3BhY2VfYmVmb3JlX2NvbmRpdGlvbmFsO1xuICAgICAgICBuZXh0X21vZGUgPSBNT0RFLkZvckluaXRpYWxpemVyO1xuICAgICAgfSBlbHNlIGlmIChpbl9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQsIFsnaWYnLCAnd2hpbGUnXSkpIHtcbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRoaXMuX29wdGlvbnMuc3BhY2VfYmVmb3JlX2NvbmRpdGlvbmFsO1xuICAgICAgICBuZXh0X21vZGUgPSBNT0RFLkNvbmRpdGlvbmFsO1xuICAgICAgfSBlbHNlIGlmIChpbl9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3dvcmQsIFsnYXdhaXQnLCAnYXN5bmMnXSkpIHtcbiAgICAgICAgLy8gU2hvdWxkIGJlIGEgc3BhY2UgYmV0d2VlbiBhd2FpdCBhbmQgYW4gSUlGRSwgb3IgYXN5bmMgYW5kIGFuIGFycm93IGZ1bmN0aW9uXG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICdpbXBvcnQnICYmIGN1cnJlbnRfdG9rZW4ud2hpdGVzcGFjZV9iZWZvcmUgPT09ICcnKSB7XG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoaW5fYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0LCBsaW5lX3N0YXJ0ZXJzKSB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICdjYXRjaCcpIHtcbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkVRVUFMUyB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLk9QRVJBVE9SKSB7XG4gICAgICAvLyBTdXBwb3J0IG9mIHRoaXMga2luZCBvZiBuZXdsaW5lIHByZXNlcnZhdGlvbi5cbiAgICAgIC8vIGEgPSAoYiAmJlxuICAgICAgLy8gICAgIChjIHx8IGQpKTtcbiAgICAgIGlmICghdGhpcy5zdGFydF9vZl9vYmplY3RfcHJvcGVydHkoKSkge1xuICAgICAgICB0aGlzLmFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoY3VycmVudF90b2tlbik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLldPUkQpIHtcbiAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcblxuICAgICAgLy8gZnVuY3Rpb24gbmFtZSgpIHZzIGZ1bmN0aW9uIG5hbWUgKClcbiAgICAgIC8vIGZ1bmN0aW9uKiBuYW1lKCkgdnMgZnVuY3Rpb24qIG5hbWUgKClcbiAgICAgIC8vIGFzeW5jIG5hbWUoKSB2cyBhc3luYyBuYW1lICgpXG4gICAgICAvLyBJbiBFUzYsIHlvdSBjYW4gYWxzbyBkZWZpbmUgdGhlIG1ldGhvZCBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdFxuICAgICAgLy8gdmFyIG9iaiA9IHthOiBmdW5jdGlvbigpIHt9fVxuICAgICAgLy8gSXQgY2FuIGJlIGFiYnJldmlhdGVkXG4gICAgICAvLyB2YXIgb2JqID0ge2EoKSB7fX1cbiAgICAgIC8vIHZhciBvYmogPSB7IGEoKSB7fX0gdnMgdmFyIG9iaiA9IHsgYSAoKSB7fX1cbiAgICAgIC8vIHZhciBvYmogPSB7ICogYSgpIHt9fSB2cyB2YXIgb2JqID0geyAqIGEgKCkge319XG4gICAgICB2YXIgcGVla19iYWNrX3R3byA9IHRoaXMuX3Rva2Vucy5wZWVrKC0zKTtcbiAgICAgIGlmICh0aGlzLl9vcHRpb25zLnNwYWNlX2FmdGVyX25hbWVkX2Z1bmN0aW9uICYmIHBlZWtfYmFja190d28pIHtcbiAgICAgICAgLy8gcGVlayBzdGFydHMgYXQgbmV4dCBjaGFyYWN0ZXIgc28gLTEgaXMgY3VycmVudCB0b2tlblxuICAgICAgICB2YXIgcGVla19iYWNrX3RocmVlID0gdGhpcy5fdG9rZW5zLnBlZWsoLTQpO1xuICAgICAgICBpZiAocmVzZXJ2ZWRfYXJyYXkocGVla19iYWNrX3R3bywgWydhc3luYycsICdmdW5jdGlvbiddKSB8fFxuICAgICAgICAgIChwZWVrX2JhY2tfdHdvLnRleHQgPT09ICcqJyAmJiByZXNlcnZlZF9hcnJheShwZWVrX2JhY2tfdGhyZWUsIFsnYXN5bmMnLCAnZnVuY3Rpb24nXSkpKSB7XG4gICAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MubW9kZSA9PT0gTU9ERS5PYmplY3RMaXRlcmFsKSB7XG4gICAgICAgICAgaWYgKChwZWVrX2JhY2tfdHdvLnRleHQgPT09ICd7JyB8fCBwZWVrX2JhY2tfdHdvLnRleHQgPT09ICcsJykgfHxcbiAgICAgICAgICAgIChwZWVrX2JhY2tfdHdvLnRleHQgPT09ICcqJyAmJiAocGVla19iYWNrX3RocmVlLnRleHQgPT09ICd7JyB8fCBwZWVrX2JhY2tfdGhyZWUudGV4dCA9PT0gJywnKSkpIHtcbiAgICAgICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdXBwb3J0IHByZXNlcnZpbmcgd3JhcHBlZCBhcnJvdyBmdW5jdGlvbiBleHByZXNzaW9uc1xuICAgICAgLy8gYS5iKCdjJyxcbiAgICAgIC8vICAgICAoKSA9PiBkLmVcbiAgICAgIC8vIClcbiAgICAgIHRoaXMuYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShjdXJyZW50X3Rva2VuKTtcbiAgICB9XG5cbiAgICAvLyBmdW5jdGlvbigpIHZzIGZ1bmN0aW9uICgpXG4gICAgLy8geWllbGQqKCkgdnMgeWllbGQqICgpXG4gICAgLy8gZnVuY3Rpb24qKCkgdnMgZnVuY3Rpb24qICgpXG4gICAgaWYgKCh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLlJFU0VSVkVEICYmICh0aGlzLl9mbGFncy5sYXN0X3dvcmQgPT09ICdmdW5jdGlvbicgfHwgdGhpcy5fZmxhZ3MubGFzdF93b3JkID09PSAndHlwZW9mJykpIHx8XG4gICAgICAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnKicgJiZcbiAgICAgICAgKGluX2FycmF5KHRoaXMuX2xhc3RfbGFzdF90ZXh0LCBbJ2Z1bmN0aW9uJywgJ3lpZWxkJ10pIHx8XG4gICAgICAgICAgKHRoaXMuX2ZsYWdzLm1vZGUgPT09IE1PREUuT2JqZWN0TGl0ZXJhbCAmJiBpbl9hcnJheSh0aGlzLl9sYXN0X2xhc3RfdGV4dCwgWyd7JywgJywnXSkpKSkpIHtcbiAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0aGlzLl9vcHRpb25zLnNwYWNlX2FmdGVyX2Fub25fZnVuY3Rpb247XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJzsnIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uU1RBUlRfQkxPQ0spIHtcbiAgICB0aGlzLnByaW50X25ld2xpbmUoKTtcbiAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkVORF9FWFBSIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uU1RBUlRfRVhQUiB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkVORF9CTE9DSyB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICcuJyB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkNPTU1BKSB7XG4gICAgLy8gZG8gbm90aGluZyBvbiAoKCBhbmQgKSggYW5kIF1bIGFuZCBdKCBhbmQgLihcbiAgICAvLyBUT0RPOiBDb25zaWRlciB3aGV0aGVyIGZvcmNpbmcgdGhpcyBpcyByZXF1aXJlZC4gIFJldmlldyBmYWlsaW5nIHRlc3RzIHdoZW4gcmVtb3ZlZC5cbiAgICB0aGlzLmFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoY3VycmVudF90b2tlbiwgY3VycmVudF90b2tlbi5uZXdsaW5lcyk7XG4gIH1cblxuICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuICB0aGlzLnNldF9tb2RlKG5leHRfbW9kZSk7XG4gIGlmICh0aGlzLl9vcHRpb25zLnNwYWNlX2luX3BhcmVuKSB7XG4gICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gIH1cblxuICAvLyBJbiBhbGwgY2FzZXMsIGlmIHdlIG5ld2xpbmUgd2hpbGUgaW5zaWRlIGFuIGV4cHJlc3Npb24gaXQgc2hvdWxkIGJlIGluZGVudGVkLlxuICB0aGlzLmluZGVudCgpO1xufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuaGFuZGxlX2VuZF9leHByID0gZnVuY3Rpb24oY3VycmVudF90b2tlbikge1xuICAvLyBzdGF0ZW1lbnRzIGluc2lkZSBleHByZXNzaW9ucyBhcmUgbm90IHZhbGlkIHN5bnRheCwgYnV0Li4uXG4gIC8vIHN0YXRlbWVudHMgbXVzdCBhbGwgYmUgY2xvc2VkIHdoZW4gdGhlaXIgY29udGFpbmVyIGNsb3Nlc1xuICB3aGlsZSAodGhpcy5fZmxhZ3MubW9kZSA9PT0gTU9ERS5TdGF0ZW1lbnQpIHtcbiAgICB0aGlzLnJlc3RvcmVfbW9kZSgpO1xuICB9XG5cbiAgdGhpcy5oYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbik7XG5cbiAgaWYgKHRoaXMuX2ZsYWdzLm11bHRpbGluZV9mcmFtZSkge1xuICAgIHRoaXMuYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShjdXJyZW50X3Rva2VuLFxuICAgICAgY3VycmVudF90b2tlbi50ZXh0ID09PSAnXScgJiYgaXNfYXJyYXkodGhpcy5fZmxhZ3MubW9kZSkgJiYgIXRoaXMuX29wdGlvbnMua2VlcF9hcnJheV9pbmRlbnRhdGlvbik7XG4gIH1cblxuICBpZiAodGhpcy5fb3B0aW9ucy5zcGFjZV9pbl9wYXJlbikge1xuICAgIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLlNUQVJUX0VYUFIgJiYgIXRoaXMuX29wdGlvbnMuc3BhY2VfaW5fZW1wdHlfcGFyZW4pIHtcbiAgICAgIC8vICgpIFtdIG5vIGlubmVyIHNwYWNlIGluIGVtcHR5IHBhcmVucyBsaWtlIHRoZXNlLCBldmVyLCByZWYgIzMyMFxuICAgICAgdGhpcy5fb3V0cHV0LnRyaW0oKTtcbiAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgfVxuICB9XG4gIHRoaXMuZGVpbmRlbnQoKTtcbiAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcbiAgdGhpcy5yZXN0b3JlX21vZGUoKTtcblxuICByZW1vdmVfcmVkdW5kYW50X2luZGVudGF0aW9uKHRoaXMuX291dHB1dCwgdGhpcy5fcHJldmlvdXNfZmxhZ3MpO1xuXG4gIC8vIGRvIHt9IHdoaWxlICgpIC8vIG5vIHN0YXRlbWVudCByZXF1aXJlZCBhZnRlclxuICBpZiAodGhpcy5fZmxhZ3MuZG9fd2hpbGUgJiYgdGhpcy5fcHJldmlvdXNfZmxhZ3MubW9kZSA9PT0gTU9ERS5Db25kaXRpb25hbCkge1xuICAgIHRoaXMuX3ByZXZpb3VzX2ZsYWdzLm1vZGUgPSBNT0RFLkV4cHJlc3Npb247XG4gICAgdGhpcy5fZmxhZ3MuZG9fYmxvY2sgPSBmYWxzZTtcbiAgICB0aGlzLl9mbGFncy5kb193aGlsZSA9IGZhbHNlO1xuXG4gIH1cbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmhhbmRsZV9zdGFydF9ibG9jayA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4pIHtcbiAgdGhpcy5oYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbik7XG5cbiAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBzaG91bGQgYmUgdHJlYXRlZCBhcyBhIE9iamVjdExpdGVyYWxcbiAgdmFyIG5leHRfdG9rZW4gPSB0aGlzLl90b2tlbnMucGVlaygpO1xuICB2YXIgc2Vjb25kX3Rva2VuID0gdGhpcy5fdG9rZW5zLnBlZWsoMSk7XG4gIGlmICh0aGlzLl9mbGFncy5sYXN0X3dvcmQgPT09ICdzd2l0Y2gnICYmIHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uRU5EX0VYUFIpIHtcbiAgICB0aGlzLnNldF9tb2RlKE1PREUuQmxvY2tTdGF0ZW1lbnQpO1xuICAgIHRoaXMuX2ZsYWdzLmluX2Nhc2Vfc3RhdGVtZW50ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5jYXNlX2JvZHkpIHtcbiAgICB0aGlzLnNldF9tb2RlKE1PREUuQmxvY2tTdGF0ZW1lbnQpO1xuICB9IGVsc2UgaWYgKHNlY29uZF90b2tlbiAmJiAoXG4gICAgICAoaW5fYXJyYXkoc2Vjb25kX3Rva2VuLnRleHQsIFsnOicsICcsJ10pICYmIGluX2FycmF5KG5leHRfdG9rZW4udHlwZSwgW1RPS0VOLlNUUklORywgVE9LRU4uV09SRCwgVE9LRU4uUkVTRVJWRURdKSkgfHxcbiAgICAgIChpbl9hcnJheShuZXh0X3Rva2VuLnRleHQsIFsnZ2V0JywgJ3NldCcsICcuLi4nXSkgJiYgaW5fYXJyYXkoc2Vjb25kX3Rva2VuLnR5cGUsIFtUT0tFTi5XT1JELCBUT0tFTi5SRVNFUlZFRF0pKVxuICAgICkpIHtcbiAgICAvLyBXZSBkb24ndCBzdXBwb3J0IFR5cGVTY3JpcHQsYnV0IHdlIGRpZG4ndCBicmVhayBpdCBmb3IgYSB2ZXJ5IGxvbmcgdGltZS5cbiAgICAvLyBXZSdsbCB0cnkgdG8ga2VlcCBub3QgYnJlYWtpbmcgaXQuXG4gICAgaWYgKCFpbl9hcnJheSh0aGlzLl9sYXN0X2xhc3RfdGV4dCwgWydjbGFzcycsICdpbnRlcmZhY2UnXSkpIHtcbiAgICAgIHRoaXMuc2V0X21vZGUoTU9ERS5PYmplY3RMaXRlcmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRfbW9kZShNT0RFLkJsb2NrU3RhdGVtZW50KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5PUEVSQVRPUiAmJiB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICc9PicpIHtcbiAgICAvLyBhcnJvdyBmdW5jdGlvbjogKHBhcmFtMSwgcGFyYW1OKSA9PiB7IHN0YXRlbWVudHMgfVxuICAgIHRoaXMuc2V0X21vZGUoTU9ERS5CbG9ja1N0YXRlbWVudCk7XG4gIH0gZWxzZSBpZiAoaW5fYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlLCBbVE9LRU4uRVFVQUxTLCBUT0tFTi5TVEFSVF9FWFBSLCBUT0tFTi5DT01NQSwgVE9LRU4uT1BFUkFUT1JdKSB8fFxuICAgIHJlc2VydmVkX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4sIFsncmV0dXJuJywgJ3Rocm93JywgJ2ltcG9ydCcsICdkZWZhdWx0J10pXG4gICkge1xuICAgIC8vIERldGVjdGluZyBzaG9ydGhhbmQgZnVuY3Rpb24gc3ludGF4IGlzIGRpZmZpY3VsdCBieSBzY2FubmluZyBmb3J3YXJkLFxuICAgIC8vICAgICBzbyBjaGVjayB0aGUgc3Vycm91bmRpbmcgY29udGV4dC5cbiAgICAvLyBJZiB0aGUgYmxvY2sgaXMgYmVpbmcgcmV0dXJuZWQsIGltcG9ydGVkLCBleHBvcnQgZGVmYXVsdCwgcGFzc2VkIGFzIGFyZyxcbiAgICAvLyAgICAgYXNzaWduZWQgd2l0aCA9IG9yIGFzc2lnbmVkIGluIGEgbmVzdGVkIG9iamVjdCwgdHJlYXQgYXMgYW4gT2JqZWN0TGl0ZXJhbC5cbiAgICB0aGlzLnNldF9tb2RlKE1PREUuT2JqZWN0TGl0ZXJhbCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zZXRfbW9kZShNT0RFLkJsb2NrU3RhdGVtZW50KTtcbiAgfVxuXG4gIHZhciBlbXB0eV9icmFjZXMgPSAhbmV4dF90b2tlbi5jb21tZW50c19iZWZvcmUgJiYgbmV4dF90b2tlbi50ZXh0ID09PSAnfSc7XG4gIHZhciBlbXB0eV9hbm9ueW1vdXNfZnVuY3Rpb24gPSBlbXB0eV9icmFjZXMgJiYgdGhpcy5fZmxhZ3MubGFzdF93b3JkID09PSAnZnVuY3Rpb24nICYmXG4gICAgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5FTkRfRVhQUjtcblxuICBpZiAodGhpcy5fb3B0aW9ucy5icmFjZV9wcmVzZXJ2ZV9pbmxpbmUpIC8vIGNoZWNrIGZvciBpbmxpbmUsIHNldCBpbmxpbmVfZnJhbWUgaWYgc29cbiAge1xuICAgIC8vIHNlYXJjaCBmb3J3YXJkIGZvciBhIG5ld2xpbmUgd2FudGVkIGluc2lkZSB0aGlzIGJsb2NrXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgY2hlY2tfdG9rZW4gPSBudWxsO1xuICAgIHRoaXMuX2ZsYWdzLmlubGluZV9mcmFtZSA9IHRydWU7XG4gICAgZG8ge1xuICAgICAgaW5kZXggKz0gMTtcbiAgICAgIGNoZWNrX3Rva2VuID0gdGhpcy5fdG9rZW5zLnBlZWsoaW5kZXggLSAxKTtcbiAgICAgIGlmIChjaGVja190b2tlbi5uZXdsaW5lcykge1xuICAgICAgICB0aGlzLl9mbGFncy5pbmxpbmVfZnJhbWUgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoY2hlY2tfdG9rZW4udHlwZSAhPT0gVE9LRU4uRU9GICYmXG4gICAgICAhKGNoZWNrX3Rva2VuLnR5cGUgPT09IFRPS0VOLkVORF9CTE9DSyAmJiBjaGVja190b2tlbi5vcGVuZWQgPT09IGN1cnJlbnRfdG9rZW4pKTtcbiAgfVxuXG4gIGlmICgodGhpcy5fb3B0aW9ucy5icmFjZV9zdHlsZSA9PT0gXCJleHBhbmRcIiB8fFxuICAgICAgKHRoaXMuX29wdGlvbnMuYnJhY2Vfc3R5bGUgPT09IFwibm9uZVwiICYmIGN1cnJlbnRfdG9rZW4ubmV3bGluZXMpKSAmJlxuICAgICF0aGlzLl9mbGFncy5pbmxpbmVfZnJhbWUpIHtcbiAgICBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlICE9PSBUT0tFTi5PUEVSQVRPUiAmJlxuICAgICAgKGVtcHR5X2Fub255bW91c19mdW5jdGlvbiB8fFxuICAgICAgICB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkVRVUFMUyB8fFxuICAgICAgICAocmVzZXJ2ZWRfYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbiwgc3BlY2lhbF93b3JkcykgJiYgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ICE9PSAnZWxzZScpKSkge1xuICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHJpbnRfbmV3bGluZShmYWxzZSwgdHJ1ZSk7XG4gICAgfVxuICB9IGVsc2UgeyAvLyBjb2xsYXBzZSB8fCBpbmxpbmVfZnJhbWVcbiAgICBpZiAoaXNfYXJyYXkodGhpcy5fcHJldmlvdXNfZmxhZ3MubW9kZSkgJiYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uU1RBUlRfRVhQUiB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkNPTU1BKSkge1xuICAgICAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uQ09NTUEgfHwgdGhpcy5fb3B0aW9ucy5zcGFjZV9pbl9wYXJlbikge1xuICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uQ09NTUEgfHwgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uU1RBUlRfRVhQUiAmJiB0aGlzLl9mbGFncy5pbmxpbmVfZnJhbWUpKSB7XG4gICAgICAgIHRoaXMuYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShjdXJyZW50X3Rva2VuKTtcbiAgICAgICAgdGhpcy5fcHJldmlvdXNfZmxhZ3MubXVsdGlsaW5lX2ZyYW1lID0gdGhpcy5fcHJldmlvdXNfZmxhZ3MubXVsdGlsaW5lX2ZyYW1lIHx8IHRoaXMuX2ZsYWdzLm11bHRpbGluZV9mcmFtZTtcbiAgICAgICAgdGhpcy5fZmxhZ3MubXVsdGlsaW5lX2ZyYW1lID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgIT09IFRPS0VOLk9QRVJBVE9SICYmIHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSAhPT0gVE9LRU4uU1RBUlRfRVhQUikge1xuICAgICAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uU1RBUlRfQkxPQ0sgJiYgIXRoaXMuX2ZsYWdzLmlubGluZV9mcmFtZSkge1xuICAgICAgICB0aGlzLnByaW50X25ld2xpbmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuICB0aGlzLmluZGVudCgpO1xuXG4gIC8vIEV4Y2VwdCBmb3Igc3BlY2lmaWMgY2FzZXMsIG9wZW4gYnJhY2VzIGFyZSBmb2xsb3dlZCBieSBhIG5ldyBsaW5lLlxuICBpZiAoIWVtcHR5X2JyYWNlcyAmJiAhKHRoaXMuX29wdGlvbnMuYnJhY2VfcHJlc2VydmVfaW5saW5lICYmIHRoaXMuX2ZsYWdzLmlubGluZV9mcmFtZSkpIHtcbiAgICB0aGlzLnByaW50X25ld2xpbmUoKTtcbiAgfVxufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuaGFuZGxlX2VuZF9ibG9jayA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4pIHtcbiAgLy8gc3RhdGVtZW50cyBtdXN0IGFsbCBiZSBjbG9zZWQgd2hlbiB0aGVpciBjb250YWluZXIgY2xvc2VzXG4gIHRoaXMuaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzKGN1cnJlbnRfdG9rZW4pO1xuXG4gIHdoaWxlICh0aGlzLl9mbGFncy5tb2RlID09PSBNT0RFLlN0YXRlbWVudCkge1xuICAgIHRoaXMucmVzdG9yZV9tb2RlKCk7XG4gIH1cblxuICB2YXIgZW1wdHlfYnJhY2VzID0gdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5TVEFSVF9CTE9DSztcblxuICBpZiAodGhpcy5fZmxhZ3MuaW5saW5lX2ZyYW1lICYmICFlbXB0eV9icmFjZXMpIHsgLy8gdHJ5IGlubGluZV9mcmFtZSAob25seSBzZXQgaWYgdGhpcy5fb3B0aW9ucy5icmFjZXMtcHJlc2VydmUtaW5saW5lKSBmaXJzdFxuICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICB9IGVsc2UgaWYgKHRoaXMuX29wdGlvbnMuYnJhY2Vfc3R5bGUgPT09IFwiZXhwYW5kXCIpIHtcbiAgICBpZiAoIWVtcHR5X2JyYWNlcykge1xuICAgICAgdGhpcy5wcmludF9uZXdsaW5lKCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIHNraXAge31cbiAgICBpZiAoIWVtcHR5X2JyYWNlcykge1xuICAgICAgaWYgKGlzX2FycmF5KHRoaXMuX2ZsYWdzLm1vZGUpICYmIHRoaXMuX29wdGlvbnMua2VlcF9hcnJheV9pbmRlbnRhdGlvbikge1xuICAgICAgICAvLyB3ZSBSRUFMTFkgbmVlZCBhIG5ld2xpbmUgaGVyZSwgYnV0IG5ld2xpbmVyIHdvdWxkIHNraXAgdGhhdFxuICAgICAgICB0aGlzLl9vcHRpb25zLmtlZXBfYXJyYXlfaW5kZW50YXRpb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcmludF9uZXdsaW5lKCk7XG4gICAgICAgIHRoaXMuX29wdGlvbnMua2VlcF9hcnJheV9pbmRlbnRhdGlvbiA9IHRydWU7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJpbnRfbmV3bGluZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB0aGlzLnJlc3RvcmVfbW9kZSgpO1xuICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuaGFuZGxlX3dvcmQgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7XG4gIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLlJFU0VSVkVEKSB7XG4gICAgaWYgKGluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCwgWydzZXQnLCAnZ2V0J10pICYmIHRoaXMuX2ZsYWdzLm1vZGUgIT09IE1PREUuT2JqZWN0TGl0ZXJhbCkge1xuICAgICAgY3VycmVudF90b2tlbi50eXBlID0gVE9LRU4uV09SRDtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJ2ltcG9ydCcgJiYgdGhpcy5fdG9rZW5zLnBlZWsoKS50ZXh0ID09PSAnKCcpIHtcbiAgICAgIGN1cnJlbnRfdG9rZW4udHlwZSA9IFRPS0VOLldPUkQ7XG4gICAgfSBlbHNlIGlmIChpbl9hcnJheShjdXJyZW50X3Rva2VuLnRleHQsIFsnYXMnLCAnZnJvbSddKSAmJiAhdGhpcy5fZmxhZ3MuaW1wb3J0X2Jsb2NrKSB7XG4gICAgICBjdXJyZW50X3Rva2VuLnR5cGUgPSBUT0tFTi5XT1JEO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MubW9kZSA9PT0gTU9ERS5PYmplY3RMaXRlcmFsKSB7XG4gICAgICB2YXIgbmV4dF90b2tlbiA9IHRoaXMuX3Rva2Vucy5wZWVrKCk7XG4gICAgICBpZiAobmV4dF90b2tlbi50ZXh0ID09PSAnOicpIHtcbiAgICAgICAgY3VycmVudF90b2tlbi50eXBlID0gVE9LRU4uV09SRDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5zdGFydF9vZl9zdGF0ZW1lbnQoY3VycmVudF90b2tlbikpIHtcbiAgICAvLyBUaGUgY29uZGl0aW9uYWwgc3RhcnRzIHRoZSBzdGF0ZW1lbnQgaWYgYXBwcm9wcmlhdGUuXG4gICAgaWYgKHJlc2VydmVkX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4sIFsndmFyJywgJ2xldCcsICdjb25zdCddKSAmJiBjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLldPUkQpIHtcbiAgICAgIHRoaXMuX2ZsYWdzLmRlY2xhcmF0aW9uX3N0YXRlbWVudCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4ubmV3bGluZXMgJiYgIWlzX2V4cHJlc3Npb24odGhpcy5fZmxhZ3MubW9kZSkgJiZcbiAgICAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlICE9PSBUT0tFTi5PUEVSQVRPUiB8fCAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnLS0nIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJysrJykpICYmXG4gICAgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlICE9PSBUT0tFTi5FUVVBTFMgJiZcbiAgICAodGhpcy5fb3B0aW9ucy5wcmVzZXJ2ZV9uZXdsaW5lcyB8fCAhcmVzZXJ2ZWRfYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbiwgWyd2YXInLCAnbGV0JywgJ2NvbnN0JywgJ3NldCcsICdnZXQnXSkpKSB7XG4gICAgdGhpcy5oYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbik7XG4gICAgdGhpcy5wcmludF9uZXdsaW5lKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5oYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbik7XG4gIH1cblxuICBpZiAodGhpcy5fZmxhZ3MuZG9fYmxvY2sgJiYgIXRoaXMuX2ZsYWdzLmRvX3doaWxlKSB7XG4gICAgaWYgKHJlc2VydmVkX3dvcmQoY3VycmVudF90b2tlbiwgJ3doaWxlJykpIHtcbiAgICAgIC8vIGRvIHt9ICMjIHdoaWxlICgpXG4gICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG4gICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2ZsYWdzLmRvX3doaWxlID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZG8ge30gc2hvdWxkIGFsd2F5cyBoYXZlIHdoaWxlIGFzIHRoZSBuZXh0IHdvcmQuXG4gICAgICAvLyBpZiB3ZSBkb24ndCBzZWUgdGhlIGV4cGVjdGVkIHdoaWxlLCByZWNvdmVyXG4gICAgICB0aGlzLnByaW50X25ld2xpbmUoKTtcbiAgICAgIHRoaXMuX2ZsYWdzLmRvX2Jsb2NrID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgbWF5IGJlIGZvbGxvd2VkIGJ5IGVsc2UsIG9yIG5vdFxuICAvLyBCYXJlL2lubGluZSBpZnMgYXJlIHRyaWNreVxuICAvLyBOZWVkIHRvIHVud2luZCB0aGUgbW9kZXMgY29ycmVjdGx5OiBpZiAoYSkgaWYgKGIpIGMoKTsgZWxzZSBkKCk7IGVsc2UgZSgpO1xuICBpZiAodGhpcy5fZmxhZ3MuaWZfYmxvY2spIHtcbiAgICBpZiAoIXRoaXMuX2ZsYWdzLmVsc2VfYmxvY2sgJiYgcmVzZXJ2ZWRfd29yZChjdXJyZW50X3Rva2VuLCAnZWxzZScpKSB7XG4gICAgICB0aGlzLl9mbGFncy5lbHNlX2Jsb2NrID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKHRoaXMuX2ZsYWdzLm1vZGUgPT09IE1PREUuU3RhdGVtZW50KSB7XG4gICAgICAgIHRoaXMucmVzdG9yZV9tb2RlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9mbGFncy5pZl9ibG9jayA9IGZhbHNlO1xuICAgICAgdGhpcy5fZmxhZ3MuZWxzZV9ibG9jayA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLl9mbGFncy5pbl9jYXNlX3N0YXRlbWVudCAmJiByZXNlcnZlZF9hcnJheShjdXJyZW50X3Rva2VuLCBbJ2Nhc2UnLCAnZGVmYXVsdCddKSkge1xuICAgIHRoaXMucHJpbnRfbmV3bGluZSgpO1xuICAgIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgIT09IFRPS0VOLkVORF9CTE9DSyAmJiAodGhpcy5fZmxhZ3MuY2FzZV9ib2R5IHx8IHRoaXMuX29wdGlvbnMuanNsaW50X2hhcHB5KSkge1xuICAgICAgLy8gc3dpdGNoIGNhc2VzIGZvbGxvd2luZyBvbmUgYW5vdGhlclxuICAgICAgdGhpcy5kZWluZGVudCgpO1xuICAgIH1cbiAgICB0aGlzLl9mbGFncy5jYXNlX2JvZHkgPSBmYWxzZTtcblxuICAgIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG4gICAgdGhpcy5fZmxhZ3MuaW5fY2FzZSA9IHRydWU7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uQ09NTUEgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5TVEFSVF9FWFBSIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uRVFVQUxTIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uT1BFUkFUT1IpIHtcbiAgICBpZiAoIXRoaXMuc3RhcnRfb2Zfb2JqZWN0X3Byb3BlcnR5KCkpIHtcbiAgICAgIHRoaXMuYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShjdXJyZW50X3Rva2VuKTtcbiAgICB9XG4gIH1cblxuICBpZiAocmVzZXJ2ZWRfd29yZChjdXJyZW50X3Rva2VuLCAnZnVuY3Rpb24nKSkge1xuICAgIGlmIChpbl9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQsIFsnfScsICc7J10pIHx8XG4gICAgICAodGhpcy5fb3V0cHV0Lmp1c3RfYWRkZWRfbmV3bGluZSgpICYmICEoaW5fYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0LCBbJygnLCAnWycsICd7JywgJzonLCAnPScsICcsJ10pIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uT1BFUkFUT1IpKSkge1xuICAgICAgLy8gbWFrZSBzdXJlIHRoZXJlIGlzIGEgbmljZSBjbGVhbiBzcGFjZSBvZiBhdCBsZWFzdCBvbmUgYmxhbmsgbGluZVxuICAgICAgLy8gYmVmb3JlIGEgbmV3IGZ1bmN0aW9uIGRlZmluaXRpb25cbiAgICAgIGlmICghdGhpcy5fb3V0cHV0Lmp1c3RfYWRkZWRfYmxhbmtsaW5lKCkgJiYgIWN1cnJlbnRfdG9rZW4uY29tbWVudHNfYmVmb3JlKSB7XG4gICAgICAgIHRoaXMucHJpbnRfbmV3bGluZSgpO1xuICAgICAgICB0aGlzLnByaW50X25ld2xpbmUodHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLlJFU0VSVkVEIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uV09SRCkge1xuICAgICAgaWYgKHJlc2VydmVkX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4sIFsnZ2V0JywgJ3NldCcsICduZXcnLCAnZXhwb3J0J10pIHx8XG4gICAgICAgIHJlc2VydmVkX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4sIG5ld2xpbmVfcmVzdHJpY3RlZF90b2tlbnMpKSB7XG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChyZXNlcnZlZF93b3JkKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4sICdkZWZhdWx0JykgJiYgdGhpcy5fbGFzdF9sYXN0X3RleHQgPT09ICdleHBvcnQnKSB7XG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICdkZWNsYXJlJykge1xuICAgICAgICAvLyBhY2NvbW9kYXRlcyBUeXBlc2NyaXB0IGRlY2xhcmUgZnVuY3Rpb24gZm9ybWF0dGluZ1xuICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJpbnRfbmV3bGluZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5PUEVSQVRPUiB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICc9Jykge1xuICAgICAgLy8gZm9vID0gZnVuY3Rpb25cbiAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuX2ZsYWdzLm11bHRpbGluZV9mcmFtZSAmJiAoaXNfZXhwcmVzc2lvbih0aGlzLl9mbGFncy5tb2RlKSB8fCBpc19hcnJheSh0aGlzLl9mbGFncy5tb2RlKSkpIHtcbiAgICAgIC8vIChmdW5jdGlvblxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByaW50X25ld2xpbmUoKTtcbiAgICB9XG5cbiAgICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuICAgIHRoaXMuX2ZsYWdzLmxhc3Rfd29yZCA9IGN1cnJlbnRfdG9rZW4udGV4dDtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcHJlZml4ID0gJ05PTkUnO1xuXG4gIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkVORF9CTE9DSykge1xuXG4gICAgaWYgKHRoaXMuX3ByZXZpb3VzX2ZsYWdzLmlubGluZV9mcmFtZSkge1xuICAgICAgcHJlZml4ID0gJ1NQQUNFJztcbiAgICB9IGVsc2UgaWYgKCFyZXNlcnZlZF9hcnJheShjdXJyZW50X3Rva2VuLCBbJ2Vsc2UnLCAnY2F0Y2gnLCAnZmluYWxseScsICdmcm9tJ10pKSB7XG4gICAgICBwcmVmaXggPSAnTkVXTElORSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLl9vcHRpb25zLmJyYWNlX3N0eWxlID09PSBcImV4cGFuZFwiIHx8XG4gICAgICAgIHRoaXMuX29wdGlvbnMuYnJhY2Vfc3R5bGUgPT09IFwiZW5kLWV4cGFuZFwiIHx8XG4gICAgICAgICh0aGlzLl9vcHRpb25zLmJyYWNlX3N0eWxlID09PSBcIm5vbmVcIiAmJiBjdXJyZW50X3Rva2VuLm5ld2xpbmVzKSkge1xuICAgICAgICBwcmVmaXggPSAnTkVXTElORSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmVmaXggPSAnU1BBQ0UnO1xuICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5TRU1JQ09MT04gJiYgdGhpcy5fZmxhZ3MubW9kZSA9PT0gTU9ERS5CbG9ja1N0YXRlbWVudCkge1xuICAgIC8vIFRPRE86IFNob3VsZCB0aGlzIGJlIGZvciBTVEFURU1FTlQgYXMgd2VsbD9cbiAgICBwcmVmaXggPSAnTkVXTElORSc7XG4gIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5TRU1JQ09MT04gJiYgaXNfZXhwcmVzc2lvbih0aGlzLl9mbGFncy5tb2RlKSkge1xuICAgIHByZWZpeCA9ICdTUEFDRSc7XG4gIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5TVFJJTkcpIHtcbiAgICBwcmVmaXggPSAnTkVXTElORSc7XG4gIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5SRVNFUlZFRCB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLldPUkQgfHxcbiAgICAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnKicgJiZcbiAgICAgIChpbl9hcnJheSh0aGlzLl9sYXN0X2xhc3RfdGV4dCwgWydmdW5jdGlvbicsICd5aWVsZCddKSB8fFxuICAgICAgICAodGhpcy5fZmxhZ3MubW9kZSA9PT0gTU9ERS5PYmplY3RMaXRlcmFsICYmIGluX2FycmF5KHRoaXMuX2xhc3RfbGFzdF90ZXh0LCBbJ3snLCAnLCddKSkpKSkge1xuICAgIHByZWZpeCA9ICdTUEFDRSc7XG4gIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5TVEFSVF9CTE9DSykge1xuICAgIGlmICh0aGlzLl9mbGFncy5pbmxpbmVfZnJhbWUpIHtcbiAgICAgIHByZWZpeCA9ICdTUEFDRSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZWZpeCA9ICdORVdMSU5FJztcbiAgICB9XG4gIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5FTkRfRVhQUikge1xuICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgIHByZWZpeCA9ICdORVdMSU5FJztcbiAgfVxuXG4gIGlmIChyZXNlcnZlZF9hcnJheShjdXJyZW50X3Rva2VuLCBsaW5lX3N0YXJ0ZXJzKSAmJiB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgIT09ICcpJykge1xuICAgIGlmICh0aGlzLl9mbGFncy5pbmxpbmVfZnJhbWUgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnZWxzZScgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnZXhwb3J0Jykge1xuICAgICAgcHJlZml4ID0gJ1NQQUNFJztcbiAgICB9IGVsc2Uge1xuICAgICAgcHJlZml4ID0gJ05FV0xJTkUnO1xuICAgIH1cblxuICB9XG5cbiAgaWYgKHJlc2VydmVkX2FycmF5KGN1cnJlbnRfdG9rZW4sIFsnZWxzZScsICdjYXRjaCcsICdmaW5hbGx5J10pKSB7XG4gICAgaWYgKCghKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uRU5EX0JMT0NLICYmIHRoaXMuX3ByZXZpb3VzX2ZsYWdzLm1vZGUgPT09IE1PREUuQmxvY2tTdGF0ZW1lbnQpIHx8XG4gICAgICAgIHRoaXMuX29wdGlvbnMuYnJhY2Vfc3R5bGUgPT09IFwiZXhwYW5kXCIgfHxcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5icmFjZV9zdHlsZSA9PT0gXCJlbmQtZXhwYW5kXCIgfHxcbiAgICAgICAgKHRoaXMuX29wdGlvbnMuYnJhY2Vfc3R5bGUgPT09IFwibm9uZVwiICYmIGN1cnJlbnRfdG9rZW4ubmV3bGluZXMpKSAmJlxuICAgICAgIXRoaXMuX2ZsYWdzLmlubGluZV9mcmFtZSkge1xuICAgICAgdGhpcy5wcmludF9uZXdsaW5lKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX291dHB1dC50cmltKHRydWUpO1xuICAgICAgdmFyIGxpbmUgPSB0aGlzLl9vdXRwdXQuY3VycmVudF9saW5lO1xuICAgICAgLy8gSWYgd2UgdHJpbW1lZCBhbmQgdGhlcmUncyBzb21ldGhpbmcgb3RoZXIgdGhhbiBhIGNsb3NlIGJsb2NrIGJlZm9yZSB1c1xuICAgICAgLy8gcHV0IGEgbmV3bGluZSBiYWNrIGluLiAgSGFuZGxlcyAnfSAvLyBjb21tZW50JyBzY2VuYXJpby5cbiAgICAgIGlmIChsaW5lLmxhc3QoKSAhPT0gJ30nKSB7XG4gICAgICAgIHRoaXMucHJpbnRfbmV3bGluZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKHByZWZpeCA9PT0gJ05FV0xJTkUnKSB7XG4gICAgaWYgKHJlc2VydmVkX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4sIHNwZWNpYWxfd29yZHMpKSB7XG4gICAgICAvLyBubyBuZXdsaW5lIGJldHdlZW4gJ3JldHVybiBubm4nXG4gICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJ2RlY2xhcmUnICYmIHJlc2VydmVkX2FycmF5KGN1cnJlbnRfdG9rZW4sIFsndmFyJywgJ2xldCcsICdjb25zdCddKSkge1xuICAgICAgLy8gYWNjb21vZGF0ZXMgVHlwZXNjcmlwdCBkZWNsYXJlIGZvcm1hdHRpbmdcbiAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlICE9PSBUT0tFTi5FTkRfRVhQUikge1xuICAgICAgaWYgKCh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgIT09IFRPS0VOLlNUQVJUX0VYUFIgfHwgIXJlc2VydmVkX2FycmF5KGN1cnJlbnRfdG9rZW4sIFsndmFyJywgJ2xldCcsICdjb25zdCddKSkgJiYgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ICE9PSAnOicpIHtcbiAgICAgICAgLy8gbm8gbmVlZCB0byBmb3JjZSBuZXdsaW5lIG9uICd2YXInOiBmb3IgKHZhciB4ID0gMC4uLilcbiAgICAgICAgaWYgKHJlc2VydmVkX3dvcmQoY3VycmVudF90b2tlbiwgJ2lmJykgJiYgcmVzZXJ2ZWRfd29yZChjdXJyZW50X3Rva2VuLnByZXZpb3VzLCAnZWxzZScpKSB7XG4gICAgICAgICAgLy8gbm8gbmV3bGluZSBmb3IgfSBlbHNlIGlmIHtcbiAgICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnByaW50X25ld2xpbmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmVzZXJ2ZWRfYXJyYXkoY3VycmVudF90b2tlbiwgbGluZV9zdGFydGVycykgJiYgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ICE9PSAnKScpIHtcbiAgICAgIHRoaXMucHJpbnRfbmV3bGluZSgpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5tdWx0aWxpbmVfZnJhbWUgJiYgaXNfYXJyYXkodGhpcy5fZmxhZ3MubW9kZSkgJiYgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnLCcgJiYgdGhpcy5fbGFzdF9sYXN0X3RleHQgPT09ICd9Jykge1xuICAgIHRoaXMucHJpbnRfbmV3bGluZSgpOyAvLyB9LCBpbiBsaXN0cyBnZXQgYSBuZXdsaW5lIHRyZWF0bWVudFxuICB9IGVsc2UgaWYgKHByZWZpeCA9PT0gJ1NQQUNFJykge1xuICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICB9XG4gIGlmIChjdXJyZW50X3Rva2VuLnByZXZpb3VzICYmIChjdXJyZW50X3Rva2VuLnByZXZpb3VzLnR5cGUgPT09IFRPS0VOLldPUkQgfHwgY3VycmVudF90b2tlbi5wcmV2aW91cy50eXBlID09PSBUT0tFTi5SRVNFUlZFRCkpIHtcbiAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgfVxuICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuICB0aGlzLl9mbGFncy5sYXN0X3dvcmQgPSBjdXJyZW50X3Rva2VuLnRleHQ7XG5cbiAgaWYgKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uUkVTRVJWRUQpIHtcbiAgICBpZiAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnZG8nKSB7XG4gICAgICB0aGlzLl9mbGFncy5kb19ibG9jayA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICdpZicpIHtcbiAgICAgIHRoaXMuX2ZsYWdzLmlmX2Jsb2NrID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJ2ltcG9ydCcpIHtcbiAgICAgIHRoaXMuX2ZsYWdzLmltcG9ydF9ibG9jayA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5pbXBvcnRfYmxvY2sgJiYgcmVzZXJ2ZWRfd29yZChjdXJyZW50X3Rva2VuLCAnZnJvbScpKSB7XG4gICAgICB0aGlzLl9mbGFncy5pbXBvcnRfYmxvY2sgPSBmYWxzZTtcbiAgICB9XG4gIH1cbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmhhbmRsZV9zZW1pY29sb24gPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7XG4gIGlmICh0aGlzLnN0YXJ0X29mX3N0YXRlbWVudChjdXJyZW50X3Rva2VuKSkge1xuICAgIC8vIFRoZSBjb25kaXRpb25hbCBzdGFydHMgdGhlIHN0YXRlbWVudCBpZiBhcHByb3ByaWF0ZS5cbiAgICAvLyBTZW1pY29sb24gY2FuIGJlIHRoZSBzdGFydCAoYW5kIGVuZCkgb2YgYSBzdGF0ZW1lbnRcbiAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5oYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbik7XG4gIH1cblxuICB2YXIgbmV4dF90b2tlbiA9IHRoaXMuX3Rva2Vucy5wZWVrKCk7XG4gIHdoaWxlICh0aGlzLl9mbGFncy5tb2RlID09PSBNT0RFLlN0YXRlbWVudCAmJlxuICAgICEodGhpcy5fZmxhZ3MuaWZfYmxvY2sgJiYgcmVzZXJ2ZWRfd29yZChuZXh0X3Rva2VuLCAnZWxzZScpKSAmJlxuICAgICF0aGlzLl9mbGFncy5kb19ibG9jaykge1xuICAgIHRoaXMucmVzdG9yZV9tb2RlKCk7XG4gIH1cblxuICAvLyBoYWNreSBidXQgZWZmZWN0aXZlIGZvciB0aGUgbW9tZW50XG4gIGlmICh0aGlzLl9mbGFncy5pbXBvcnRfYmxvY2spIHtcbiAgICB0aGlzLl9mbGFncy5pbXBvcnRfYmxvY2sgPSBmYWxzZTtcbiAgfVxuICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuaGFuZGxlX3N0cmluZyA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4pIHtcbiAgaWYgKHRoaXMuc3RhcnRfb2Zfc3RhdGVtZW50KGN1cnJlbnRfdG9rZW4pKSB7XG4gICAgLy8gVGhlIGNvbmRpdGlvbmFsIHN0YXJ0cyB0aGUgc3RhdGVtZW50IGlmIGFwcHJvcHJpYXRlLlxuICAgIC8vIE9uZSBkaWZmZXJlbmNlIC0gc3RyaW5ncyB3YW50IGF0IGxlYXN0IGEgc3BhY2UgYmVmb3JlXG4gICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5oYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbik7XG4gICAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uUkVTRVJWRUQgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5XT1JEIHx8IHRoaXMuX2ZsYWdzLmlubGluZV9mcmFtZSkge1xuICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkNPTU1BIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uU1RBUlRfRVhQUiB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkVRVUFMUyB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLk9QRVJBVE9SKSB7XG4gICAgICBpZiAoIXRoaXMuc3RhcnRfb2Zfb2JqZWN0X3Byb3BlcnR5KCkpIHtcbiAgICAgICAgdGhpcy5hbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKGN1cnJlbnRfdG9rZW4pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByaW50X25ld2xpbmUoKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmhhbmRsZV9lcXVhbHMgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7XG4gIGlmICh0aGlzLnN0YXJ0X29mX3N0YXRlbWVudChjdXJyZW50X3Rva2VuKSkge1xuICAgIC8vIFRoZSBjb25kaXRpb25hbCBzdGFydHMgdGhlIHN0YXRlbWVudCBpZiBhcHByb3ByaWF0ZS5cbiAgfSBlbHNlIHtcbiAgICB0aGlzLmhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhjdXJyZW50X3Rva2VuKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9mbGFncy5kZWNsYXJhdGlvbl9zdGF0ZW1lbnQpIHtcbiAgICAvLyBqdXN0IGdvdCBhbiAnPScgaW4gYSB2YXItbGluZSwgZGlmZmVyZW50IGZvcm1hdHRpbmcvbGluZS1icmVha2luZywgZXRjIHdpbGwgbm93IGJlIGRvbmVcbiAgICB0aGlzLl9mbGFncy5kZWNsYXJhdGlvbl9hc3NpZ25tZW50ID0gdHJ1ZTtcbiAgfVxuICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcbiAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5oYW5kbGVfY29tbWEgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7XG4gIHRoaXMuaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzKGN1cnJlbnRfdG9rZW4sIHRydWUpO1xuXG4gIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG4gIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICBpZiAodGhpcy5fZmxhZ3MuZGVjbGFyYXRpb25fc3RhdGVtZW50KSB7XG4gICAgaWYgKGlzX2V4cHJlc3Npb24odGhpcy5fZmxhZ3MucGFyZW50Lm1vZGUpKSB7XG4gICAgICAvLyBkbyBub3QgYnJlYWsgb24gY29tbWEsIGZvcih2YXIgYSA9IDEsIGIgPSAyKVxuICAgICAgdGhpcy5fZmxhZ3MuZGVjbGFyYXRpb25fYXNzaWdubWVudCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9mbGFncy5kZWNsYXJhdGlvbl9hc3NpZ25tZW50KSB7XG4gICAgICB0aGlzLl9mbGFncy5kZWNsYXJhdGlvbl9hc3NpZ25tZW50ID0gZmFsc2U7XG4gICAgICB0aGlzLnByaW50X25ld2xpbmUoZmFsc2UsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb3B0aW9ucy5jb21tYV9maXJzdCkge1xuICAgICAgLy8gZm9yIGNvbW1hLWZpcnN0LCB3ZSB3YW50IHRvIGFsbG93IGEgbmV3bGluZSBiZWZvcmUgdGhlIGNvbW1hXG4gICAgICAvLyB0byB0dXJuIGludG8gYSBuZXdsaW5lIGFmdGVyIHRoZSBjb21tYSwgd2hpY2ggd2Ugd2lsbCBmaXh1cCBsYXRlclxuICAgICAgdGhpcy5hbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKGN1cnJlbnRfdG9rZW4pO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5tb2RlID09PSBNT0RFLk9iamVjdExpdGVyYWwgfHxcbiAgICAodGhpcy5fZmxhZ3MubW9kZSA9PT0gTU9ERS5TdGF0ZW1lbnQgJiYgdGhpcy5fZmxhZ3MucGFyZW50Lm1vZGUgPT09IE1PREUuT2JqZWN0TGl0ZXJhbCkpIHtcbiAgICBpZiAodGhpcy5fZmxhZ3MubW9kZSA9PT0gTU9ERS5TdGF0ZW1lbnQpIHtcbiAgICAgIHRoaXMucmVzdG9yZV9tb2RlKCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9mbGFncy5pbmxpbmVfZnJhbWUpIHtcbiAgICAgIHRoaXMucHJpbnRfbmV3bGluZSgpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLl9vcHRpb25zLmNvbW1hX2ZpcnN0KSB7XG4gICAgLy8gRVhQUiBvciBET19CTE9DS1xuICAgIC8vIGZvciBjb21tYS1maXJzdCwgd2Ugd2FudCB0byBhbGxvdyBhIG5ld2xpbmUgYmVmb3JlIHRoZSBjb21tYVxuICAgIC8vIHRvIHR1cm4gaW50byBhIG5ld2xpbmUgYWZ0ZXIgdGhlIGNvbW1hLCB3aGljaCB3ZSB3aWxsIGZpeHVwIGxhdGVyXG4gICAgdGhpcy5hbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKGN1cnJlbnRfdG9rZW4pO1xuICB9XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5oYW5kbGVfb3BlcmF0b3IgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7XG4gIHZhciBpc0dlbmVyYXRvckFzdGVyaXNrID0gY3VycmVudF90b2tlbi50ZXh0ID09PSAnKicgJiZcbiAgICAocmVzZXJ2ZWRfYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbiwgWydmdW5jdGlvbicsICd5aWVsZCddKSB8fFxuICAgICAgKGluX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSwgW1RPS0VOLlNUQVJUX0JMT0NLLCBUT0tFTi5DT01NQSwgVE9LRU4uRU5EX0JMT0NLLCBUT0tFTi5TRU1JQ09MT05dKSlcbiAgICApO1xuICB2YXIgaXNVbmFyeSA9IGluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCwgWyctJywgJysnXSkgJiYgKFxuICAgIGluX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSwgW1RPS0VOLlNUQVJUX0JMT0NLLCBUT0tFTi5TVEFSVF9FWFBSLCBUT0tFTi5FUVVBTFMsIFRPS0VOLk9QRVJBVE9SXSkgfHxcbiAgICBpbl9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQsIGxpbmVfc3RhcnRlcnMpIHx8XG4gICAgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnLCdcbiAgKTtcblxuICBpZiAodGhpcy5zdGFydF9vZl9zdGF0ZW1lbnQoY3VycmVudF90b2tlbikpIHtcbiAgICAvLyBUaGUgY29uZGl0aW9uYWwgc3RhcnRzIHRoZSBzdGF0ZW1lbnQgaWYgYXBwcm9wcmlhdGUuXG4gIH0gZWxzZSB7XG4gICAgdmFyIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyA9ICFpc0dlbmVyYXRvckFzdGVyaXNrO1xuICAgIHRoaXMuaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzKGN1cnJlbnRfdG9rZW4sIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyk7XG4gIH1cblxuICBpZiAocmVzZXJ2ZWRfYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbiwgc3BlY2lhbF93b3JkcykpIHtcbiAgICAvLyBcInJldHVyblwiIGhhZCBhIHNwZWNpYWwgaGFuZGxpbmcgaW4gVEtfV09SRC4gTm93IHdlIG5lZWQgdG8gcmV0dXJuIHRoZSBmYXZvclxuICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gaGFjayBmb3IgYWN0aW9uc2NyaXB0J3MgaW1wb3J0IC4qO1xuICBpZiAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnKicgJiYgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5ET1QpIHtcbiAgICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICc6OicpIHtcbiAgICAvLyBubyBzcGFjZXMgYXJvdW5kIGV4b3RpYyBuYW1lc3BhY2luZyBzeW50YXggb3BlcmF0b3JcbiAgICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEFsbG93IGxpbmUgd3JhcHBpbmcgYmV0d2VlbiBvcGVyYXRvcnMgd2hlbiBvcGVyYXRvcl9wb3NpdGlvbiBpc1xuICAvLyAgIHNldCB0byBiZWZvcmUgb3IgcHJlc2VydmVcbiAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uT1BFUkFUT1IgJiYgaW5fYXJyYXkodGhpcy5fb3B0aW9ucy5vcGVyYXRvcl9wb3NpdGlvbiwgT1BFUkFUT1JfUE9TSVRJT05fQkVGT1JFX09SX1BSRVNFUlZFKSkge1xuICAgIHRoaXMuYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShjdXJyZW50X3Rva2VuKTtcbiAgfVxuXG4gIGlmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICc6JyAmJiB0aGlzLl9mbGFncy5pbl9jYXNlKSB7XG4gICAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcblxuICAgIHRoaXMuX2ZsYWdzLmluX2Nhc2UgPSBmYWxzZTtcbiAgICB0aGlzLl9mbGFncy5jYXNlX2JvZHkgPSB0cnVlO1xuICAgIGlmICh0aGlzLl90b2tlbnMucGVlaygpLnR5cGUgIT09IFRPS0VOLlNUQVJUX0JMT0NLKSB7XG4gICAgICB0aGlzLmluZGVudCgpO1xuICAgICAgdGhpcy5wcmludF9uZXdsaW5lKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc3BhY2VfYmVmb3JlID0gdHJ1ZTtcbiAgdmFyIHNwYWNlX2FmdGVyID0gdHJ1ZTtcbiAgdmFyIGluX3Rlcm5hcnkgPSBmYWxzZTtcbiAgaWYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJzonKSB7XG4gICAgaWYgKHRoaXMuX2ZsYWdzLnRlcm5hcnlfZGVwdGggPT09IDApIHtcbiAgICAgIC8vIENvbG9uIGlzIGludmFsaWQgamF2YXNjcmlwdCBvdXRzaWRlIG9mIHRlcm5hcnkgYW5kIG9iamVjdCwgYnV0IGRvIG91ciBiZXN0IHRvIGd1ZXNzIHdoYXQgd2FzIG1lYW50LlxuICAgICAgc3BhY2VfYmVmb3JlID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2ZsYWdzLnRlcm5hcnlfZGVwdGggLT0gMTtcbiAgICAgIGluX3Rlcm5hcnkgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICc/Jykge1xuICAgIHRoaXMuX2ZsYWdzLnRlcm5hcnlfZGVwdGggKz0gMTtcbiAgfVxuXG4gIC8vIGxldCdzIGhhbmRsZSB0aGUgb3BlcmF0b3JfcG9zaXRpb24gb3B0aW9uIHByaW9yIHRvIGFueSBjb25mbGljdGluZyBsb2dpY1xuICBpZiAoIWlzVW5hcnkgJiYgIWlzR2VuZXJhdG9yQXN0ZXJpc2sgJiYgdGhpcy5fb3B0aW9ucy5wcmVzZXJ2ZV9uZXdsaW5lcyAmJiBpbl9hcnJheShjdXJyZW50X3Rva2VuLnRleHQsIHBvc2l0aW9uYWJsZV9vcGVyYXRvcnMpKSB7XG4gICAgdmFyIGlzQ29sb24gPSBjdXJyZW50X3Rva2VuLnRleHQgPT09ICc6JztcbiAgICB2YXIgaXNUZXJuYXJ5Q29sb24gPSAoaXNDb2xvbiAmJiBpbl90ZXJuYXJ5KTtcbiAgICB2YXIgaXNPdGhlckNvbG9uID0gKGlzQ29sb24gJiYgIWluX3Rlcm5hcnkpO1xuXG4gICAgc3dpdGNoICh0aGlzLl9vcHRpb25zLm9wZXJhdG9yX3Bvc2l0aW9uKSB7XG4gICAgICBjYXNlIE9QRVJBVE9SX1BPU0lUSU9OLmJlZm9yZV9uZXdsaW5lOlxuICAgICAgICAvLyBpZiB0aGUgY3VycmVudCB0b2tlbiBpcyA6IGFuZCBpdCdzIG5vdCBhIHRlcm5hcnkgc3RhdGVtZW50IHRoZW4gd2Ugc2V0IHNwYWNlX2JlZm9yZSB0byBmYWxzZVxuICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gIWlzT3RoZXJDb2xvbjtcblxuICAgICAgICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuXG4gICAgICAgIGlmICghaXNDb2xvbiB8fCBpc1Rlcm5hcnlDb2xvbikge1xuICAgICAgICAgIHRoaXMuYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShjdXJyZW50X3Rva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgT1BFUkFUT1JfUE9TSVRJT04uYWZ0ZXJfbmV3bGluZTpcbiAgICAgICAgLy8gaWYgdGhlIGN1cnJlbnQgdG9rZW4gaXMgYW55dGhpbmcgYnV0IGNvbG9uLCBvciAodmlhIGRlZHVjdGlvbikgaXQncyBhIGNvbG9uIGFuZCBpbiBhIHRlcm5hcnkgc3RhdGVtZW50LFxuICAgICAgICAvLyAgIHRoZW4gcHJpbnQgYSBuZXdsaW5lLlxuXG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuXG4gICAgICAgIGlmICghaXNDb2xvbiB8fCBpc1Rlcm5hcnlDb2xvbikge1xuICAgICAgICAgIGlmICh0aGlzLl90b2tlbnMucGVlaygpLm5ld2xpbmVzKSB7XG4gICAgICAgICAgICB0aGlzLnByaW50X25ld2xpbmUoZmFsc2UsIHRydWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoY3VycmVudF90b2tlbik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG5cbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSBPUEVSQVRPUl9QT1NJVElPTi5wcmVzZXJ2ZV9uZXdsaW5lOlxuICAgICAgICBpZiAoIWlzT3RoZXJDb2xvbikge1xuICAgICAgICAgIHRoaXMuYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShjdXJyZW50X3Rva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHdlIGp1c3QgYWRkZWQgYSBuZXdsaW5lLCBvciB0aGUgY3VycmVudCB0b2tlbiBpcyA6IGFuZCBpdCdzIG5vdCBhIHRlcm5hcnkgc3RhdGVtZW50LFxuICAgICAgICAvLyAgIHRoZW4gd2Ugc2V0IHNwYWNlX2JlZm9yZSB0byBmYWxzZVxuICAgICAgICBzcGFjZV9iZWZvcmUgPSAhKHRoaXMuX291dHB1dC5qdXN0X2FkZGVkX25ld2xpbmUoKSB8fCBpc090aGVyQ29sb24pO1xuXG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSBzcGFjZV9iZWZvcmU7XG4gICAgICAgIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzR2VuZXJhdG9yQXN0ZXJpc2spIHtcbiAgICB0aGlzLmFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoY3VycmVudF90b2tlbik7XG4gICAgc3BhY2VfYmVmb3JlID0gZmFsc2U7XG4gICAgdmFyIG5leHRfdG9rZW4gPSB0aGlzLl90b2tlbnMucGVlaygpO1xuICAgIHNwYWNlX2FmdGVyID0gbmV4dF90b2tlbiAmJiBpbl9hcnJheShuZXh0X3Rva2VuLnR5cGUsIFtUT0tFTi5XT1JELCBUT0tFTi5SRVNFUlZFRF0pO1xuICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJy4uLicpIHtcbiAgICB0aGlzLmFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoY3VycmVudF90b2tlbik7XG4gICAgc3BhY2VfYmVmb3JlID0gdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5TVEFSVF9CTE9DSztcbiAgICBzcGFjZV9hZnRlciA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKGluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCwgWyctLScsICcrKycsICchJywgJ34nXSkgfHwgaXNVbmFyeSkge1xuICAgIC8vIHVuYXJ5IG9wZXJhdG9ycyAoYW5kIGJpbmFyeSArLy0gcHJldGVuZGluZyB0byBiZSB1bmFyeSkgc3BlY2lhbCBjYXNlc1xuICAgIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkNPTU1BIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uU1RBUlRfRVhQUikge1xuICAgICAgdGhpcy5hbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKGN1cnJlbnRfdG9rZW4pO1xuICAgIH1cblxuICAgIHNwYWNlX2JlZm9yZSA9IGZhbHNlO1xuICAgIHNwYWNlX2FmdGVyID0gZmFsc2U7XG5cbiAgICAvLyBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNS4xLyNzZWMtNy45LjFcbiAgICAvLyBpZiB0aGVyZSBpcyBhIG5ld2xpbmUgYmV0d2VlbiAtLSBvciArKyBhbmQgYW55dGhpbmcgZWxzZSB3ZSBzaG91bGQgcHJlc2VydmUgaXQuXG4gICAgaWYgKGN1cnJlbnRfdG9rZW4ubmV3bGluZXMgJiYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJy0tJyB8fCBjdXJyZW50X3Rva2VuLnRleHQgPT09ICcrKycpKSB7XG4gICAgICB0aGlzLnByaW50X25ld2xpbmUoZmFsc2UsIHRydWUpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICc7JyAmJiBpc19leHByZXNzaW9uKHRoaXMuX2ZsYWdzLm1vZGUpKSB7XG4gICAgICAvLyBmb3IgKDs7ICsraSlcbiAgICAgIC8vICAgICAgICBeXl5cbiAgICAgIHNwYWNlX2JlZm9yZSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uUkVTRVJWRUQpIHtcbiAgICAgIHNwYWNlX2JlZm9yZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkVORF9FWFBSKSB7XG4gICAgICBzcGFjZV9iZWZvcmUgPSAhKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJ10nICYmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICctLScgfHwgY3VycmVudF90b2tlbi50ZXh0ID09PSAnKysnKSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLk9QRVJBVE9SKSB7XG4gICAgICAvLyBhKysgKyArK2I7XG4gICAgICAvLyBhIC0gLWJcbiAgICAgIHNwYWNlX2JlZm9yZSA9IGluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCwgWyctLScsICctJywgJysrJywgJysnXSkgJiYgaW5fYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0LCBbJy0tJywgJy0nLCAnKysnLCAnKyddKTtcbiAgICAgIC8vICsgYW5kIC0gYXJlIG5vdCB1bmFyeSB3aGVuIHByZWNlZWRlZCBieSAtLSBvciArKyBvcGVyYXRvclxuICAgICAgLy8gYS0tICsgYlxuICAgICAgLy8gYSAqICtiXG4gICAgICAvLyBhIC0gLWJcbiAgICAgIGlmIChpbl9hcnJheShjdXJyZW50X3Rva2VuLnRleHQsIFsnKycsICctJ10pICYmIGluX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCwgWyctLScsICcrKyddKSkge1xuICAgICAgICBzcGFjZV9hZnRlciA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG5cbiAgICBpZiAoKCh0aGlzLl9mbGFncy5tb2RlID09PSBNT0RFLkJsb2NrU3RhdGVtZW50ICYmICF0aGlzLl9mbGFncy5pbmxpbmVfZnJhbWUpIHx8IHRoaXMuX2ZsYWdzLm1vZGUgPT09IE1PREUuU3RhdGVtZW50KSAmJlxuICAgICAgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJ3snIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJzsnKSkge1xuICAgICAgLy8geyBmb287IC0taSB9XG4gICAgICAvLyBmb28oKTsgLS1iYXI7XG4gICAgICB0aGlzLnByaW50X25ld2xpbmUoKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiB8fCBzcGFjZV9iZWZvcmU7XG4gIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG4gIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSBzcGFjZV9hZnRlcjtcbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmhhbmRsZV9ibG9ja19jb21tZW50ID0gZnVuY3Rpb24oY3VycmVudF90b2tlbiwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKSB7XG4gIGlmICh0aGlzLl9vdXRwdXQucmF3KSB7XG4gICAgdGhpcy5fb3V0cHV0LmFkZF9yYXdfdG9rZW4oY3VycmVudF90b2tlbik7XG4gICAgaWYgKGN1cnJlbnRfdG9rZW4uZGlyZWN0aXZlcyAmJiBjdXJyZW50X3Rva2VuLmRpcmVjdGl2ZXMucHJlc2VydmUgPT09ICdlbmQnKSB7XG4gICAgICAvLyBJZiB3ZSdyZSB0ZXN0aW5nIHRoZSByYXcgb3V0cHV0IGJlaGF2aW9yLCBkbyBub3QgYWxsb3cgYSBkaXJlY3RpdmUgdG8gdHVybiBpdCBvZmYuXG4gICAgICB0aGlzLl9vdXRwdXQucmF3ID0gdGhpcy5fb3B0aW9ucy50ZXN0X291dHB1dF9yYXc7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjdXJyZW50X3Rva2VuLmRpcmVjdGl2ZXMpIHtcbiAgICB0aGlzLnByaW50X25ld2xpbmUoZmFsc2UsIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyk7XG4gICAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcbiAgICBpZiAoY3VycmVudF90b2tlbi5kaXJlY3RpdmVzLnByZXNlcnZlID09PSAnc3RhcnQnKSB7XG4gICAgICB0aGlzLl9vdXRwdXQucmF3ID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5wcmludF9uZXdsaW5lKGZhbHNlLCB0cnVlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBpbmxpbmUgYmxvY2tcbiAgaWYgKCFhY29ybi5uZXdsaW5lLnRlc3QoY3VycmVudF90b2tlbi50ZXh0KSAmJiAhY3VycmVudF90b2tlbi5uZXdsaW5lcykge1xuICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG4gICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgcmV0dXJuO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucHJpbnRfYmxvY2tfY29tbW1lbnQoY3VycmVudF90b2tlbiwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgfVxufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUucHJpbnRfYmxvY2tfY29tbW1lbnQgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpIHtcbiAgdmFyIGxpbmVzID0gc3BsaXRfbGluZWJyZWFrcyhjdXJyZW50X3Rva2VuLnRleHQpO1xuICB2YXIgajsgLy8gaXRlcmF0b3IgZm9yIHRoaXMgY2FzZVxuICB2YXIgamF2YWRvYyA9IGZhbHNlO1xuICB2YXIgc3Rhcmxlc3MgPSBmYWxzZTtcbiAgdmFyIGxhc3RJbmRlbnQgPSBjdXJyZW50X3Rva2VuLndoaXRlc3BhY2VfYmVmb3JlO1xuICB2YXIgbGFzdEluZGVudExlbmd0aCA9IGxhc3RJbmRlbnQubGVuZ3RoO1xuXG4gIC8vIGJsb2NrIGNvbW1lbnQgc3RhcnRzIHdpdGggYSBuZXcgbGluZVxuICB0aGlzLnByaW50X25ld2xpbmUoZmFsc2UsIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyk7XG5cbiAgLy8gZmlyc3QgbGluZSBhbHdheXMgaW5kZW50ZWRcbiAgdGhpcy5wcmludF90b2tlbl9saW5lX2luZGVudGF0aW9uKGN1cnJlbnRfdG9rZW4pO1xuICB0aGlzLl9vdXRwdXQuYWRkX3Rva2VuKGxpbmVzWzBdKTtcbiAgdGhpcy5wcmludF9uZXdsaW5lKGZhbHNlLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuXG5cbiAgaWYgKGxpbmVzLmxlbmd0aCA+IDEpIHtcbiAgICBsaW5lcyA9IGxpbmVzLnNsaWNlKDEpO1xuICAgIGphdmFkb2MgPSBhbGxfbGluZXNfc3RhcnRfd2l0aChsaW5lcywgJyonKTtcbiAgICBzdGFybGVzcyA9IGVhY2hfbGluZV9tYXRjaGVzX2luZGVudChsaW5lcywgbGFzdEluZGVudCk7XG5cbiAgICBpZiAoamF2YWRvYykge1xuICAgICAgdGhpcy5fZmxhZ3MuYWxpZ25tZW50ID0gMTtcbiAgICB9XG5cbiAgICBmb3IgKGogPSAwOyBqIDwgbGluZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChqYXZhZG9jKSB7XG4gICAgICAgIC8vIGphdmFkb2M6IHJlZm9ybWF0IGFuZCByZS1pbmRlbnRcbiAgICAgICAgdGhpcy5wcmludF90b2tlbl9saW5lX2luZGVudGF0aW9uKGN1cnJlbnRfdG9rZW4pO1xuICAgICAgICB0aGlzLl9vdXRwdXQuYWRkX3Rva2VuKGx0cmltKGxpbmVzW2pdKSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJsZXNzICYmIGxpbmVzW2pdKSB7XG4gICAgICAgIC8vIHN0YXJsZXNzOiByZS1pbmRlbnQgbm9uLWVtcHR5IGNvbnRlbnQsIGF2b2lkaW5nIHRyaW1cbiAgICAgICAgdGhpcy5wcmludF90b2tlbl9saW5lX2luZGVudGF0aW9uKGN1cnJlbnRfdG9rZW4pO1xuICAgICAgICB0aGlzLl9vdXRwdXQuYWRkX3Rva2VuKGxpbmVzW2pdLnN1YnN0cmluZyhsYXN0SW5kZW50TGVuZ3RoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBub3JtYWwgY29tbWVudHMgb3V0cHV0IHJhd1xuICAgICAgICB0aGlzLl9vdXRwdXQuY3VycmVudF9saW5lLnNldF9pbmRlbnQoLTEpO1xuICAgICAgICB0aGlzLl9vdXRwdXQuYWRkX3Rva2VuKGxpbmVzW2pdKTtcbiAgICAgIH1cblxuICAgICAgLy8gZm9yIGNvbW1lbnRzIG9uIHRoZWlyIG93biBsaW5lIG9yICBtb3JlIHRoYW4gb25lIGxpbmUsIG1ha2Ugc3VyZSB0aGVyZSdzIGEgbmV3IGxpbmUgYWZ0ZXJcbiAgICAgIHRoaXMucHJpbnRfbmV3bGluZShmYWxzZSwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgICB9XG5cbiAgICB0aGlzLl9mbGFncy5hbGlnbm1lbnQgPSAwO1xuICB9XG59O1xuXG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmhhbmRsZV9jb21tZW50ID0gZnVuY3Rpb24oY3VycmVudF90b2tlbiwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKSB7XG4gIGlmIChjdXJyZW50X3Rva2VuLm5ld2xpbmVzKSB7XG4gICAgdGhpcy5wcmludF9uZXdsaW5lKGZhbHNlLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX291dHB1dC50cmltKHRydWUpO1xuICB9XG5cbiAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG4gIHRoaXMucHJpbnRfbmV3bGluZShmYWxzZSwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmhhbmRsZV9kb3QgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7XG4gIGlmICh0aGlzLnN0YXJ0X29mX3N0YXRlbWVudChjdXJyZW50X3Rva2VuKSkge1xuICAgIC8vIFRoZSBjb25kaXRpb25hbCBzdGFydHMgdGhlIHN0YXRlbWVudCBpZiBhcHByb3ByaWF0ZS5cbiAgfSBlbHNlIHtcbiAgICB0aGlzLmhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhjdXJyZW50X3Rva2VuLCB0cnVlKTtcbiAgfVxuXG4gIGlmIChyZXNlcnZlZF9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLCBzcGVjaWFsX3dvcmRzKSkge1xuICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBhbGxvdyBwcmVzZXJ2ZWQgbmV3bGluZXMgYmVmb3JlIGRvdHMgaW4gZ2VuZXJhbFxuICAgIC8vIGZvcmNlIG5ld2xpbmVzIG9uIGRvdHMgYWZ0ZXIgY2xvc2UgcGFyZW4gd2hlbiBicmVha19jaGFpbmVkIC0gZm9yIGJhcigpLmJheigpXG4gICAgdGhpcy5hbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKGN1cnJlbnRfdG9rZW4sXG4gICAgICB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICcpJyAmJiB0aGlzLl9vcHRpb25zLmJyZWFrX2NoYWluZWRfbWV0aG9kcyk7XG4gIH1cblxuICAvLyBPbmx5IHVuaW5kZW50IGNoYWluZWQgbWV0aG9kIGRvdCBpZiB0aGlzIGRvdCBzdGFydHMgYSBuZXcgbGluZS5cbiAgLy8gT3RoZXJ3aXNlIHRoZSBhdXRvbWF0aWMgZXh0cmEgaW5kZW50YXRpb24gcmVtb3ZhbCB3aWxsIGhhbmRsZSB0aGUgb3ZlciBpbmRlbnRcbiAgaWYgKHRoaXMuX29wdGlvbnMudW5pbmRlbnRfY2hhaW5lZF9tZXRob2RzICYmIHRoaXMuX291dHB1dC5qdXN0X2FkZGVkX25ld2xpbmUoKSkge1xuICAgIHRoaXMuZGVpbmRlbnQoKTtcbiAgfVxuXG4gIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5oYW5kbGVfdW5rbm93biA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4sIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncykge1xuICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuXG4gIGlmIChjdXJyZW50X3Rva2VuLnRleHRbY3VycmVudF90b2tlbi50ZXh0Lmxlbmd0aCAtIDFdID09PSAnXFxuJykge1xuICAgIHRoaXMucHJpbnRfbmV3bGluZShmYWxzZSwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgfVxufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuaGFuZGxlX2VvZiA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4pIHtcbiAgLy8gVW53aW5kIGFueSBvcGVuIHN0YXRlbWVudHNcbiAgd2hpbGUgKHRoaXMuX2ZsYWdzLm1vZGUgPT09IE1PREUuU3RhdGVtZW50KSB7XG4gICAgdGhpcy5yZXN0b3JlX21vZGUoKTtcbiAgfVxuICB0aGlzLmhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhjdXJyZW50X3Rva2VuKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLkJlYXV0aWZpZXIgPSBCZWF1dGlmaWVyO1xuIiwiLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEJlYXV0aWZpZXIgPSByZXF1aXJlKCcuL2JlYXV0aWZpZXInKS5CZWF1dGlmaWVyLFxuICBPcHRpb25zID0gcmVxdWlyZSgnLi9vcHRpb25zJykuT3B0aW9ucztcblxuZnVuY3Rpb24ganNfYmVhdXRpZnkoanNfc291cmNlX3RleHQsIG9wdGlvbnMpIHtcbiAgdmFyIGJlYXV0aWZpZXIgPSBuZXcgQmVhdXRpZmllcihqc19zb3VyY2VfdGV4dCwgb3B0aW9ucyk7XG4gIHJldHVybiBiZWF1dGlmaWVyLmJlYXV0aWZ5KCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ganNfYmVhdXRpZnk7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IE9wdGlvbnMoKTtcbn07XG4iLCIvKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQmFzZU9wdGlvbnMgPSByZXF1aXJlKCcuLi9jb3JlL29wdGlvbnMnKS5PcHRpb25zO1xuXG52YXIgdmFsaWRQb3NpdGlvblZhbHVlcyA9IFsnYmVmb3JlLW5ld2xpbmUnLCAnYWZ0ZXItbmV3bGluZScsICdwcmVzZXJ2ZS1uZXdsaW5lJ107XG5cbmZ1bmN0aW9uIE9wdGlvbnMob3B0aW9ucykge1xuICBCYXNlT3B0aW9ucy5jYWxsKHRoaXMsIG9wdGlvbnMsICdqcycpO1xuXG4gIC8vIGNvbXBhdGliaWxpdHksIHJlXG4gIHZhciByYXdfYnJhY2Vfc3R5bGUgPSB0aGlzLnJhd19vcHRpb25zLmJyYWNlX3N0eWxlIHx8IG51bGw7XG4gIGlmIChyYXdfYnJhY2Vfc3R5bGUgPT09IFwiZXhwYW5kLXN0cmljdFwiKSB7IC8vZ3JhY2VmdWwgaGFuZGxpbmcgb2YgZGVwcmVjYXRlZCBvcHRpb25cbiAgICB0aGlzLnJhd19vcHRpb25zLmJyYWNlX3N0eWxlID0gXCJleHBhbmRcIjtcbiAgfSBlbHNlIGlmIChyYXdfYnJhY2Vfc3R5bGUgPT09IFwiY29sbGFwc2UtcHJlc2VydmUtaW5saW5lXCIpIHsgLy9ncmFjZWZ1bCBoYW5kbGluZyBvZiBkZXByZWNhdGVkIG9wdGlvblxuICAgIHRoaXMucmF3X29wdGlvbnMuYnJhY2Vfc3R5bGUgPSBcImNvbGxhcHNlLHByZXNlcnZlLWlubGluZVwiO1xuICB9IGVsc2UgaWYgKHRoaXMucmF3X29wdGlvbnMuYnJhY2VzX29uX293bl9saW5lICE9PSB1bmRlZmluZWQpIHsgLy9ncmFjZWZ1bCBoYW5kbGluZyBvZiBkZXByZWNhdGVkIG9wdGlvblxuICAgIHRoaXMucmF3X29wdGlvbnMuYnJhY2Vfc3R5bGUgPSB0aGlzLnJhd19vcHRpb25zLmJyYWNlc19vbl9vd25fbGluZSA/IFwiZXhwYW5kXCIgOiBcImNvbGxhcHNlXCI7XG4gICAgLy8gfSBlbHNlIGlmICghcmF3X2JyYWNlX3N0eWxlKSB7IC8vTm90aGluZyBleGlzdHMgdG8gc2V0IGl0XG4gICAgLy8gICByYXdfYnJhY2Vfc3R5bGUgPSBcImNvbGxhcHNlXCI7XG4gIH1cblxuICAvL3ByZXNlcnZlLWlubGluZSBpbiBkZWxpbWl0ZWQgc3RyaW5nIHdpbGwgdHJpZ2dlciBicmFjZV9wcmVzZXJ2ZV9pbmxpbmUsIGV2ZXJ5dGhpbmdcbiAgLy9lbHNlIGlzIGNvbnNpZGVyZWQgYSBicmFjZV9zdHlsZSBhbmQgdGhlIGxhc3Qgb25lIG9ubHkgd2lsbCBoYXZlIGFuIGVmZmVjdFxuXG4gIHZhciBicmFjZV9zdHlsZV9zcGxpdCA9IHRoaXMuX2dldF9zZWxlY3Rpb25fbGlzdCgnYnJhY2Vfc3R5bGUnLCBbJ2NvbGxhcHNlJywgJ2V4cGFuZCcsICdlbmQtZXhwYW5kJywgJ25vbmUnLCAncHJlc2VydmUtaW5saW5lJ10pO1xuXG4gIHRoaXMuYnJhY2VfcHJlc2VydmVfaW5saW5lID0gZmFsc2U7IC8vRGVmYXVsdHMgaW4gY2FzZSBvbmUgb3Igb3RoZXIgd2FzIG5vdCBzcGVjaWZpZWQgaW4gbWV0YS1vcHRpb25cbiAgdGhpcy5icmFjZV9zdHlsZSA9IFwiY29sbGFwc2VcIjtcblxuICBmb3IgKHZhciBicyA9IDA7IGJzIDwgYnJhY2Vfc3R5bGVfc3BsaXQubGVuZ3RoOyBicysrKSB7XG4gICAgaWYgKGJyYWNlX3N0eWxlX3NwbGl0W2JzXSA9PT0gXCJwcmVzZXJ2ZS1pbmxpbmVcIikge1xuICAgICAgdGhpcy5icmFjZV9wcmVzZXJ2ZV9pbmxpbmUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJyYWNlX3N0eWxlID0gYnJhY2Vfc3R5bGVfc3BsaXRbYnNdO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMudW5pbmRlbnRfY2hhaW5lZF9tZXRob2RzID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ3VuaW5kZW50X2NoYWluZWRfbWV0aG9kcycpO1xuICB0aGlzLmJyZWFrX2NoYWluZWRfbWV0aG9kcyA9IHRoaXMuX2dldF9ib29sZWFuKCdicmVha19jaGFpbmVkX21ldGhvZHMnKTtcbiAgdGhpcy5zcGFjZV9pbl9wYXJlbiA9IHRoaXMuX2dldF9ib29sZWFuKCdzcGFjZV9pbl9wYXJlbicpO1xuICB0aGlzLnNwYWNlX2luX2VtcHR5X3BhcmVuID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ3NwYWNlX2luX2VtcHR5X3BhcmVuJyk7XG4gIHRoaXMuanNsaW50X2hhcHB5ID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ2pzbGludF9oYXBweScpO1xuICB0aGlzLnNwYWNlX2FmdGVyX2Fub25fZnVuY3Rpb24gPSB0aGlzLl9nZXRfYm9vbGVhbignc3BhY2VfYWZ0ZXJfYW5vbl9mdW5jdGlvbicpO1xuICB0aGlzLnNwYWNlX2FmdGVyX25hbWVkX2Z1bmN0aW9uID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ3NwYWNlX2FmdGVyX25hbWVkX2Z1bmN0aW9uJyk7XG4gIHRoaXMua2VlcF9hcnJheV9pbmRlbnRhdGlvbiA9IHRoaXMuX2dldF9ib29sZWFuKCdrZWVwX2FycmF5X2luZGVudGF0aW9uJyk7XG4gIHRoaXMuc3BhY2VfYmVmb3JlX2NvbmRpdGlvbmFsID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ3NwYWNlX2JlZm9yZV9jb25kaXRpb25hbCcsIHRydWUpO1xuICB0aGlzLnVuZXNjYXBlX3N0cmluZ3MgPSB0aGlzLl9nZXRfYm9vbGVhbigndW5lc2NhcGVfc3RyaW5ncycpO1xuICB0aGlzLmU0eCA9IHRoaXMuX2dldF9ib29sZWFuKCdlNHgnKTtcbiAgdGhpcy5jb21tYV9maXJzdCA9IHRoaXMuX2dldF9ib29sZWFuKCdjb21tYV9maXJzdCcpO1xuICB0aGlzLm9wZXJhdG9yX3Bvc2l0aW9uID0gdGhpcy5fZ2V0X3NlbGVjdGlvbignb3BlcmF0b3JfcG9zaXRpb24nLCB2YWxpZFBvc2l0aW9uVmFsdWVzKTtcblxuICAvLyBGb3IgdGVzdGluZyBvZiBiZWF1dGlmeSBwcmVzZXJ2ZTpzdGFydCBkaXJlY3RpdmVcbiAgdGhpcy50ZXN0X291dHB1dF9yYXcgPSB0aGlzLl9nZXRfYm9vbGVhbigndGVzdF9vdXRwdXRfcmF3Jyk7XG5cbiAgLy8gZm9yY2UgdGhpcy5fb3B0aW9ucy5zcGFjZV9hZnRlcl9hbm9uX2Z1bmN0aW9uIHRvIHRydWUgaWYgdGhpcy5fb3B0aW9ucy5qc2xpbnRfaGFwcHlcbiAgaWYgKHRoaXMuanNsaW50X2hhcHB5KSB7XG4gICAgdGhpcy5zcGFjZV9hZnRlcl9hbm9uX2Z1bmN0aW9uID0gdHJ1ZTtcbiAgfVxuXG59XG5PcHRpb25zLnByb3RvdHlwZSA9IG5ldyBCYXNlT3B0aW9ucygpO1xuXG5cblxubW9kdWxlLmV4cG9ydHMuT3B0aW9ucyA9IE9wdGlvbnM7XG4iLCIvKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgSW5wdXRTY2FubmVyID0gcmVxdWlyZSgnLi4vY29yZS9pbnB1dHNjYW5uZXInKS5JbnB1dFNjYW5uZXI7XG52YXIgQmFzZVRva2VuaXplciA9IHJlcXVpcmUoJy4uL2NvcmUvdG9rZW5pemVyJykuVG9rZW5pemVyO1xudmFyIEJBU0VUT0tFTiA9IHJlcXVpcmUoJy4uL2NvcmUvdG9rZW5pemVyJykuVE9LRU47XG52YXIgRGlyZWN0aXZlcyA9IHJlcXVpcmUoJy4uL2NvcmUvZGlyZWN0aXZlcycpLkRpcmVjdGl2ZXM7XG52YXIgYWNvcm4gPSByZXF1aXJlKCcuL2Fjb3JuJyk7XG52YXIgUGF0dGVybiA9IHJlcXVpcmUoJy4uL2NvcmUvcGF0dGVybicpLlBhdHRlcm47XG52YXIgVGVtcGxhdGFibGVQYXR0ZXJuID0gcmVxdWlyZSgnLi4vY29yZS90ZW1wbGF0YWJsZXBhdHRlcm4nKS5UZW1wbGF0YWJsZVBhdHRlcm47XG5cblxuZnVuY3Rpb24gaW5fYXJyYXkod2hhdCwgYXJyKSB7XG4gIHJldHVybiBhcnIuaW5kZXhPZih3aGF0KSAhPT0gLTE7XG59XG5cblxudmFyIFRPS0VOID0ge1xuICBTVEFSVF9FWFBSOiAnVEtfU1RBUlRfRVhQUicsXG4gIEVORF9FWFBSOiAnVEtfRU5EX0VYUFInLFxuICBTVEFSVF9CTE9DSzogJ1RLX1NUQVJUX0JMT0NLJyxcbiAgRU5EX0JMT0NLOiAnVEtfRU5EX0JMT0NLJyxcbiAgV09SRDogJ1RLX1dPUkQnLFxuICBSRVNFUlZFRDogJ1RLX1JFU0VSVkVEJyxcbiAgU0VNSUNPTE9OOiAnVEtfU0VNSUNPTE9OJyxcbiAgU1RSSU5HOiAnVEtfU1RSSU5HJyxcbiAgRVFVQUxTOiAnVEtfRVFVQUxTJyxcbiAgT1BFUkFUT1I6ICdUS19PUEVSQVRPUicsXG4gIENPTU1BOiAnVEtfQ09NTUEnLFxuICBCTE9DS19DT01NRU5UOiAnVEtfQkxPQ0tfQ09NTUVOVCcsXG4gIENPTU1FTlQ6ICdUS19DT01NRU5UJyxcbiAgRE9UOiAnVEtfRE9UJyxcbiAgVU5LTk9XTjogJ1RLX1VOS05PV04nLFxuICBTVEFSVDogQkFTRVRPS0VOLlNUQVJULFxuICBSQVc6IEJBU0VUT0tFTi5SQVcsXG4gIEVPRjogQkFTRVRPS0VOLkVPRlxufTtcblxuXG52YXIgZGlyZWN0aXZlc19jb3JlID0gbmV3IERpcmVjdGl2ZXMoL1xcL1xcKi8sIC9cXCpcXC8vKTtcblxudmFyIG51bWJlcl9wYXR0ZXJuID0gLzBbeFhdWzAxMjM0NTY3ODlhYmNkZWZBQkNERUZdKnwwW29PXVswMTIzNDU2N10qfDBbYkJdWzAxXSp8XFxkK258KD86XFwuXFxkK3xcXGQrXFwuP1xcZCopKD86W2VFXVsrLV0/XFxkKyk/LztcblxudmFyIGRpZ2l0ID0gL1swLTldLztcblxuLy8gRG90IFwiLlwiIG11c3QgYmUgZGlzdGluZ3Vpc2hlZCBmcm9tIFwiLi4uXCIgYW5kIGRlY2ltYWxcbnZhciBkb3RfcGF0dGVybiA9IC9bXlxcZFxcLl0vO1xuXG52YXIgcG9zaXRpb25hYmxlX29wZXJhdG9ycyA9IChcbiAgXCI+Pj4gPT09ICE9PSBcIiArXG4gIFwiPDwgJiYgPj0gKiogIT0gPT0gPD0gPj4gfHwgXCIgK1xuICBcIjwgLyAtICsgPiA6ICYgJSA/IF4gfCAqXCIpLnNwbGl0KCcgJyk7XG5cbi8vIElNUE9SVEFOVDogdGhpcyBtdXN0IGJlIHNvcnRlZCBsb25nZXN0IHRvIHNob3J0ZXN0IG9yIHRva2VuaXppbmcgbWFueSBub3Qgd29yay5cbi8vIEFsc28sIHlvdSBtdXN0IHVwZGF0ZSBwb3NzaXRpb25hYmxlIG9wZXJhdG9ycyBzZXBhcmF0ZWx5IGZyb20gcHVuY3RcbnZhciBwdW5jdCA9XG4gIFwiPj4+PSBcIiArXG4gIFwiLi4uID4+PSA8PD0gPT09ID4+PiAhPT0gKio9IFwiICtcbiAgXCI9PiBePSA6OiAvPSA8PCA8PSA9PSAmJiAtPSA+PSA+PiAhPSAtLSArPSAqKiB8fCArKyAlPSAmPSAqPSB8PSBcIiArXG4gIFwiPSAhID8gPiA8IDogLyBeIC0gKyAqICYgJSB+IHxcIjtcblxucHVuY3QgPSBwdW5jdC5yZXBsYWNlKC9bLVtcXF17fSgpKis/LixcXFxcXiR8I10vZywgXCJcXFxcJCZcIik7XG5wdW5jdCA9IHB1bmN0LnJlcGxhY2UoLyAvZywgJ3wnKTtcblxudmFyIHB1bmN0X3BhdHRlcm4gPSBuZXcgUmVnRXhwKHB1bmN0KTtcblxuLy8gd29yZHMgd2hpY2ggc2hvdWxkIGFsd2F5cyBzdGFydCBvbiBuZXcgbGluZS5cbnZhciBsaW5lX3N0YXJ0ZXJzID0gJ2NvbnRpbnVlLHRyeSx0aHJvdyxyZXR1cm4sdmFyLGxldCxjb25zdCxpZixzd2l0Y2gsY2FzZSxkZWZhdWx0LGZvcix3aGlsZSxicmVhayxmdW5jdGlvbixpbXBvcnQsZXhwb3J0Jy5zcGxpdCgnLCcpO1xudmFyIHJlc2VydmVkX3dvcmRzID0gbGluZV9zdGFydGVycy5jb25jYXQoWydkbycsICdpbicsICdvZicsICdlbHNlJywgJ2dldCcsICdzZXQnLCAnbmV3JywgJ2NhdGNoJywgJ2ZpbmFsbHknLCAndHlwZW9mJywgJ3lpZWxkJywgJ2FzeW5jJywgJ2F3YWl0JywgJ2Zyb20nLCAnYXMnXSk7XG52YXIgcmVzZXJ2ZWRfd29yZF9wYXR0ZXJuID0gbmV3IFJlZ0V4cCgnXig/OicgKyByZXNlcnZlZF93b3Jkcy5qb2luKCd8JykgKyAnKSQnKTtcblxuLy8gdmFyIHRlbXBsYXRlX3BhdHRlcm4gPSAvKD86KD86PFxcP3BocHw8XFw/PSlbXFxzXFxTXSo/XFw/Pil8KD86PCVbXFxzXFxTXSo/JT4pL2c7XG5cbnZhciBpbl9odG1sX2NvbW1lbnQ7XG5cbnZhciBUb2tlbml6ZXIgPSBmdW5jdGlvbihpbnB1dF9zdHJpbmcsIG9wdGlvbnMpIHtcbiAgQmFzZVRva2VuaXplci5jYWxsKHRoaXMsIGlucHV0X3N0cmluZywgb3B0aW9ucyk7XG5cbiAgdGhpcy5fcGF0dGVybnMud2hpdGVzcGFjZSA9IHRoaXMuX3BhdHRlcm5zLndoaXRlc3BhY2UubWF0Y2hpbmcoXG4gICAgL1xcdTAwQTBcXHUxNjgwXFx1MTgwZVxcdTIwMDAtXFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcdWZlZmYvLnNvdXJjZSxcbiAgICAvXFx1MjAyOFxcdTIwMjkvLnNvdXJjZSk7XG5cbiAgdmFyIHBhdHRlcm5fcmVhZGVyID0gbmV3IFBhdHRlcm4odGhpcy5faW5wdXQpO1xuICB2YXIgdGVtcGxhdGFibGUgPSBuZXcgVGVtcGxhdGFibGVQYXR0ZXJuKHRoaXMuX2lucHV0KVxuICAgIC5yZWFkX29wdGlvbnModGhpcy5fb3B0aW9ucyk7XG5cbiAgdGhpcy5fX3BhdHRlcm5zID0ge1xuICAgIHRlbXBsYXRlOiB0ZW1wbGF0YWJsZSxcbiAgICBpZGVudGlmaWVyOiB0ZW1wbGF0YWJsZS5zdGFydGluZ193aXRoKGFjb3JuLmlkZW50aWZpZXIpLm1hdGNoaW5nKGFjb3JuLmlkZW50aWZpZXJNYXRjaCksXG4gICAgbnVtYmVyOiBwYXR0ZXJuX3JlYWRlci5tYXRjaGluZyhudW1iZXJfcGF0dGVybiksXG4gICAgcHVuY3Q6IHBhdHRlcm5fcmVhZGVyLm1hdGNoaW5nKHB1bmN0X3BhdHRlcm4pLFxuICAgIC8vIGNvbW1lbnQgZW5kcyBqdXN0IGJlZm9yZSBuZWFyZXN0IGxpbmVmZWVkIG9yIGVuZCBvZiBmaWxlXG4gICAgY29tbWVudDogcGF0dGVybl9yZWFkZXIuc3RhcnRpbmdfd2l0aCgvXFwvXFwvLykudW50aWwoL1tcXG5cXHJcXHUyMDI4XFx1MjAyOV0vKSxcbiAgICAvLyAgLyogLi4uICovIGNvbW1lbnQgZW5kcyB3aXRoIG5lYXJlc3QgKi8gb3IgZW5kIG9mIGZpbGVcbiAgICBibG9ja19jb21tZW50OiBwYXR0ZXJuX3JlYWRlci5zdGFydGluZ193aXRoKC9cXC9cXCovKS51bnRpbF9hZnRlcigvXFwqXFwvLyksXG4gICAgaHRtbF9jb21tZW50X3N0YXJ0OiBwYXR0ZXJuX3JlYWRlci5tYXRjaGluZygvPCEtLS8pLFxuICAgIGh0bWxfY29tbWVudF9lbmQ6IHBhdHRlcm5fcmVhZGVyLm1hdGNoaW5nKC8tLT4vKSxcbiAgICBpbmNsdWRlOiBwYXR0ZXJuX3JlYWRlci5zdGFydGluZ193aXRoKC8jaW5jbHVkZS8pLnVudGlsX2FmdGVyKGFjb3JuLmxpbmVCcmVhayksXG4gICAgc2hlYmFuZzogcGF0dGVybl9yZWFkZXIuc3RhcnRpbmdfd2l0aCgvIyEvKS51bnRpbF9hZnRlcihhY29ybi5saW5lQnJlYWspLFxuICAgIHhtbDogcGF0dGVybl9yZWFkZXIubWF0Y2hpbmcoL1tcXHNcXFNdKj88KFxcLz8pKFstYS16QS1aOjAtOV8uXSt8e1tcXHNcXFNdKz99fCFcXFtDREFUQVxcW1tcXHNcXFNdKj9cXF1cXF0pKFxccyt7W1xcc1xcU10rP318XFxzK1stYS16QS1aOjAtOV8uXSt8XFxzK1stYS16QS1aOjAtOV8uXStcXHMqPVxccyooJ1teJ10qJ3xcIlteXCJdKlwifHtbXFxzXFxTXSs/fSkpKlxccyooXFwvPylcXHMqPi8pLFxuICAgIHNpbmdsZV9xdW90ZTogdGVtcGxhdGFibGUudW50aWwoL1snXFxcXFxcblxcclxcdTIwMjhcXHUyMDI5XS8pLFxuICAgIGRvdWJsZV9xdW90ZTogdGVtcGxhdGFibGUudW50aWwoL1tcIlxcXFxcXG5cXHJcXHUyMDI4XFx1MjAyOV0vKSxcbiAgICB0ZW1wbGF0ZV90ZXh0OiB0ZW1wbGF0YWJsZS51bnRpbCgvW2BcXFxcJF0vKSxcbiAgICB0ZW1wbGF0ZV9leHByZXNzaW9uOiB0ZW1wbGF0YWJsZS51bnRpbCgvW2B9XFxcXF0vKVxuICB9O1xuXG59O1xuVG9rZW5pemVyLnByb3RvdHlwZSA9IG5ldyBCYXNlVG9rZW5pemVyKCk7XG5cblRva2VuaXplci5wcm90b3R5cGUuX2lzX2NvbW1lbnQgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7XG4gIHJldHVybiBjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLkNPTU1FTlQgfHwgY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5CTE9DS19DT01NRU5UIHx8IGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uVU5LTk9XTjtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2lzX29wZW5pbmcgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7XG4gIHJldHVybiBjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLlNUQVJUX0JMT0NLIHx8IGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uU1RBUlRfRVhQUjtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2lzX2Nsb3NpbmcgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuLCBvcGVuX3Rva2VuKSB7XG4gIHJldHVybiAoY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5FTkRfQkxPQ0sgfHwgY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5FTkRfRVhQUikgJiZcbiAgICAob3Blbl90b2tlbiAmJiAoXG4gICAgICAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnXScgJiYgb3Blbl90b2tlbi50ZXh0ID09PSAnWycpIHx8XG4gICAgICAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnKScgJiYgb3Blbl90b2tlbi50ZXh0ID09PSAnKCcpIHx8XG4gICAgICAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnfScgJiYgb3Blbl90b2tlbi50ZXh0ID09PSAneycpKSk7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZXNldCA9IGZ1bmN0aW9uKCkge1xuICBpbl9odG1sX2NvbW1lbnQgPSBmYWxzZTtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2dldF9uZXh0X3Rva2VuID0gZnVuY3Rpb24ocHJldmlvdXNfdG9rZW4sIG9wZW5fdG9rZW4pIHsgLy8ganNoaW50IHVudXNlZDpmYWxzZVxuICB2YXIgdG9rZW4gPSBudWxsO1xuICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuICB2YXIgYyA9IHRoaXMuX2lucHV0LnBlZWsoKTtcblxuICBpZiAoYyA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uRU9GLCAnJyk7XG4gIH1cblxuICB0b2tlbiA9IHRva2VuIHx8IHRoaXMuX3JlYWRfbm9uX2phdmFzY3JpcHQoYyk7XG4gIHRva2VuID0gdG9rZW4gfHwgdGhpcy5fcmVhZF9zdHJpbmcoYyk7XG4gIHRva2VuID0gdG9rZW4gfHwgdGhpcy5fcmVhZF93b3JkKHByZXZpb3VzX3Rva2VuKTtcbiAgdG9rZW4gPSB0b2tlbiB8fCB0aGlzLl9yZWFkX3NpbmdsZXMoYyk7XG4gIHRva2VuID0gdG9rZW4gfHwgdGhpcy5fcmVhZF9jb21tZW50KGMpO1xuICB0b2tlbiA9IHRva2VuIHx8IHRoaXMuX3JlYWRfcmVnZXhwKGMsIHByZXZpb3VzX3Rva2VuKTtcbiAgdG9rZW4gPSB0b2tlbiB8fCB0aGlzLl9yZWFkX3htbChjLCBwcmV2aW91c190b2tlbik7XG4gIHRva2VuID0gdG9rZW4gfHwgdGhpcy5fcmVhZF9wdW5jdHVhdGlvbigpO1xuICB0b2tlbiA9IHRva2VuIHx8IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5VTktOT1dOLCB0aGlzLl9pbnB1dC5uZXh0KCkpO1xuXG4gIHJldHVybiB0b2tlbjtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3JlYWRfd29yZCA9IGZ1bmN0aW9uKHByZXZpb3VzX3Rva2VuKSB7XG4gIHZhciByZXN1bHRpbmdfc3RyaW5nO1xuICByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5fX3BhdHRlcm5zLmlkZW50aWZpZXIucmVhZCgpO1xuICBpZiAocmVzdWx0aW5nX3N0cmluZyAhPT0gJycpIHtcbiAgICByZXN1bHRpbmdfc3RyaW5nID0gcmVzdWx0aW5nX3N0cmluZy5yZXBsYWNlKGFjb3JuLmFsbExpbmVCcmVha3MsICdcXG4nKTtcbiAgICBpZiAoIShwcmV2aW91c190b2tlbi50eXBlID09PSBUT0tFTi5ET1QgfHxcbiAgICAgICAgKHByZXZpb3VzX3Rva2VuLnR5cGUgPT09IFRPS0VOLlJFU0VSVkVEICYmIChwcmV2aW91c190b2tlbi50ZXh0ID09PSAnc2V0JyB8fCBwcmV2aW91c190b2tlbi50ZXh0ID09PSAnZ2V0JykpKSAmJlxuICAgICAgcmVzZXJ2ZWRfd29yZF9wYXR0ZXJuLnRlc3QocmVzdWx0aW5nX3N0cmluZykpIHtcbiAgICAgIGlmIChyZXN1bHRpbmdfc3RyaW5nID09PSAnaW4nIHx8IHJlc3VsdGluZ19zdHJpbmcgPT09ICdvZicpIHsgLy8gaGFjayBmb3IgJ2luJyBhbmQgJ29mJyBvcGVyYXRvcnNcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5PUEVSQVRPUiwgcmVzdWx0aW5nX3N0cmluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLlJFU0VSVkVELCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5XT1JELCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgfVxuXG4gIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9fcGF0dGVybnMubnVtYmVyLnJlYWQoKTtcbiAgaWYgKHJlc3VsdGluZ19zdHJpbmcgIT09ICcnKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5XT1JELCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgfVxufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fcmVhZF9zaW5nbGVzID0gZnVuY3Rpb24oYykge1xuICB2YXIgdG9rZW4gPSBudWxsO1xuICBpZiAoYyA9PT0gJygnIHx8IGMgPT09ICdbJykge1xuICAgIHRva2VuID0gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLlNUQVJUX0VYUFIsIGMpO1xuICB9IGVsc2UgaWYgKGMgPT09ICcpJyB8fCBjID09PSAnXScpIHtcbiAgICB0b2tlbiA9IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5FTkRfRVhQUiwgYyk7XG4gIH0gZWxzZSBpZiAoYyA9PT0gJ3snKSB7XG4gICAgdG9rZW4gPSB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uU1RBUlRfQkxPQ0ssIGMpO1xuICB9IGVsc2UgaWYgKGMgPT09ICd9Jykge1xuICAgIHRva2VuID0gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLkVORF9CTE9DSywgYyk7XG4gIH0gZWxzZSBpZiAoYyA9PT0gJzsnKSB7XG4gICAgdG9rZW4gPSB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uU0VNSUNPTE9OLCBjKTtcbiAgfSBlbHNlIGlmIChjID09PSAnLicgJiYgZG90X3BhdHRlcm4udGVzdCh0aGlzLl9pbnB1dC5wZWVrKDEpKSkge1xuICAgIHRva2VuID0gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLkRPVCwgYyk7XG4gIH0gZWxzZSBpZiAoYyA9PT0gJywnKSB7XG4gICAgdG9rZW4gPSB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uQ09NTUEsIGMpO1xuICB9XG5cbiAgaWYgKHRva2VuKSB7XG4gICAgdGhpcy5faW5wdXQubmV4dCgpO1xuICB9XG4gIHJldHVybiB0b2tlbjtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3JlYWRfcHVuY3R1YXRpb24gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9fcGF0dGVybnMucHVuY3QucmVhZCgpO1xuXG4gIGlmIChyZXN1bHRpbmdfc3RyaW5nICE9PSAnJykge1xuICAgIGlmIChyZXN1bHRpbmdfc3RyaW5nID09PSAnPScpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uRVFVQUxTLCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5PUEVSQVRPUiwgcmVzdWx0aW5nX3N0cmluZyk7XG4gICAgfVxuICB9XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZWFkX25vbl9qYXZhc2NyaXB0ID0gZnVuY3Rpb24oYykge1xuICB2YXIgcmVzdWx0aW5nX3N0cmluZyA9ICcnO1xuXG4gIGlmIChjID09PSAnIycpIHtcbiAgICBpZiAodGhpcy5faXNfZmlyc3RfdG9rZW4oKSkge1xuICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHRoaXMuX19wYXR0ZXJucy5zaGViYW5nLnJlYWQoKTtcblxuICAgICAgaWYgKHJlc3VsdGluZ19zdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5VTktOT1dOLCByZXN1bHRpbmdfc3RyaW5nLnRyaW0oKSArICdcXG4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBoYW5kbGVzIGV4dGVuZHNjcmlwdCAjaW5jbHVkZXNcbiAgICByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5fX3BhdHRlcm5zLmluY2x1ZGUucmVhZCgpO1xuXG4gICAgaWYgKHJlc3VsdGluZ19zdHJpbmcpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uVU5LTk9XTiwgcmVzdWx0aW5nX3N0cmluZy50cmltKCkgKyAnXFxuJyk7XG4gICAgfVxuXG4gICAgYyA9IHRoaXMuX2lucHV0Lm5leHQoKTtcblxuICAgIC8vIFNwaWRlcm1vbmtleS1zcGVjaWZpYyBzaGFycCB2YXJpYWJsZXMgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMuIENvbnNpZGVyZWQgb2Jzb2xldGUuXG4gICAgdmFyIHNoYXJwID0gJyMnO1xuICAgIGlmICh0aGlzLl9pbnB1dC5oYXNOZXh0KCkgJiYgdGhpcy5faW5wdXQudGVzdENoYXIoZGlnaXQpKSB7XG4gICAgICBkbyB7XG4gICAgICAgIGMgPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgICAgIHNoYXJwICs9IGM7XG4gICAgICB9IHdoaWxlICh0aGlzLl9pbnB1dC5oYXNOZXh0KCkgJiYgYyAhPT0gJyMnICYmIGMgIT09ICc9Jyk7XG4gICAgICBpZiAoYyA9PT0gJyMnKSB7XG4gICAgICAgIC8vXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2lucHV0LnBlZWsoKSA9PT0gJ1snICYmIHRoaXMuX2lucHV0LnBlZWsoMSkgPT09ICddJykge1xuICAgICAgICBzaGFycCArPSAnW10nO1xuICAgICAgICB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgICAgIHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5faW5wdXQucGVlaygpID09PSAneycgJiYgdGhpcy5faW5wdXQucGVlaygxKSA9PT0gJ30nKSB7XG4gICAgICAgIHNoYXJwICs9ICd7fSc7XG4gICAgICAgIHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICAgICAgdGhpcy5faW5wdXQubmV4dCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5XT1JELCBzaGFycCk7XG4gICAgfVxuXG4gICAgdGhpcy5faW5wdXQuYmFjaygpO1xuXG4gIH0gZWxzZSBpZiAoYyA9PT0gJzwnICYmIHRoaXMuX2lzX2ZpcnN0X3Rva2VuKCkpIHtcbiAgICByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5fX3BhdHRlcm5zLmh0bWxfY29tbWVudF9zdGFydC5yZWFkKCk7XG4gICAgaWYgKHJlc3VsdGluZ19zdHJpbmcpIHtcbiAgICAgIHdoaWxlICh0aGlzLl9pbnB1dC5oYXNOZXh0KCkgJiYgIXRoaXMuX2lucHV0LnRlc3RDaGFyKGFjb3JuLm5ld2xpbmUpKSB7XG4gICAgICAgIHJlc3VsdGluZ19zdHJpbmcgKz0gdGhpcy5faW5wdXQubmV4dCgpO1xuICAgICAgfVxuICAgICAgaW5faHRtbF9jb21tZW50ID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uQ09NTUVOVCwgcmVzdWx0aW5nX3N0cmluZyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGluX2h0bWxfY29tbWVudCAmJiBjID09PSAnLScpIHtcbiAgICByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5fX3BhdHRlcm5zLmh0bWxfY29tbWVudF9lbmQucmVhZCgpO1xuICAgIGlmIChyZXN1bHRpbmdfc3RyaW5nKSB7XG4gICAgICBpbl9odG1sX2NvbW1lbnQgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uQ09NTUVOVCwgcmVzdWx0aW5nX3N0cmluZyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZWFkX2NvbW1lbnQgPSBmdW5jdGlvbihjKSB7XG4gIHZhciB0b2tlbiA9IG51bGw7XG4gIGlmIChjID09PSAnLycpIHtcbiAgICB2YXIgY29tbWVudCA9ICcnO1xuICAgIGlmICh0aGlzLl9pbnB1dC5wZWVrKDEpID09PSAnKicpIHtcbiAgICAgIC8vIHBlZWsgZm9yIGNvbW1lbnQgLyogLi4uICovXG4gICAgICBjb21tZW50ID0gdGhpcy5fX3BhdHRlcm5zLmJsb2NrX2NvbW1lbnQucmVhZCgpO1xuICAgICAgdmFyIGRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzX2NvcmUuZ2V0X2RpcmVjdGl2ZXMoY29tbWVudCk7XG4gICAgICBpZiAoZGlyZWN0aXZlcyAmJiBkaXJlY3RpdmVzLmlnbm9yZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICBjb21tZW50ICs9IGRpcmVjdGl2ZXNfY29yZS5yZWFkSWdub3JlZCh0aGlzLl9pbnB1dCk7XG4gICAgICB9XG4gICAgICBjb21tZW50ID0gY29tbWVudC5yZXBsYWNlKGFjb3JuLmFsbExpbmVCcmVha3MsICdcXG4nKTtcbiAgICAgIHRva2VuID0gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLkJMT0NLX0NPTU1FTlQsIGNvbW1lbnQpO1xuICAgICAgdG9rZW4uZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXM7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9pbnB1dC5wZWVrKDEpID09PSAnLycpIHtcbiAgICAgIC8vIHBlZWsgZm9yIGNvbW1lbnQgLy8gLi4uXG4gICAgICBjb21tZW50ID0gdGhpcy5fX3BhdHRlcm5zLmNvbW1lbnQucmVhZCgpO1xuICAgICAgdG9rZW4gPSB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uQ09NTUVOVCwgY29tbWVudCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0b2tlbjtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3JlYWRfc3RyaW5nID0gZnVuY3Rpb24oYykge1xuICBpZiAoYyA9PT0gJ2AnIHx8IGMgPT09IFwiJ1wiIHx8IGMgPT09ICdcIicpIHtcbiAgICB2YXIgcmVzdWx0aW5nX3N0cmluZyA9IHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICB0aGlzLmhhc19jaGFyX2VzY2FwZXMgPSBmYWxzZTtcblxuICAgIGlmIChjID09PSAnYCcpIHtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgKz0gdGhpcy5fcmVhZF9zdHJpbmdfcmVjdXJzaXZlKCdgJywgdHJ1ZSwgJyR7Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgKz0gdGhpcy5fcmVhZF9zdHJpbmdfcmVjdXJzaXZlKGMpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhhc19jaGFyX2VzY2FwZXMgJiYgdGhpcy5fb3B0aW9ucy51bmVzY2FwZV9zdHJpbmdzKSB7XG4gICAgICByZXN1bHRpbmdfc3RyaW5nID0gdW5lc2NhcGVfc3RyaW5nKHJlc3VsdGluZ19zdHJpbmcpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9pbnB1dC5wZWVrKCkgPT09IGMpIHtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgKz0gdGhpcy5faW5wdXQubmV4dCgpO1xuICAgIH1cblxuICAgIHJlc3VsdGluZ19zdHJpbmcgPSByZXN1bHRpbmdfc3RyaW5nLnJlcGxhY2UoYWNvcm4uYWxsTGluZUJyZWFrcywgJ1xcbicpO1xuXG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5TVFJJTkcsIHJlc3VsdGluZ19zdHJpbmcpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9hbGxvd19yZWdleHBfb3JfeG1sID0gZnVuY3Rpb24ocHJldmlvdXNfdG9rZW4pIHtcbiAgLy8gcmVnZXggYW5kIHhtbCBjYW4gb25seSBhcHBlYXIgaW4gc3BlY2lmaWMgbG9jYXRpb25zIGR1cmluZyBwYXJzaW5nXG4gIHJldHVybiAocHJldmlvdXNfdG9rZW4udHlwZSA9PT0gVE9LRU4uUkVTRVJWRUQgJiYgaW5fYXJyYXkocHJldmlvdXNfdG9rZW4udGV4dCwgWydyZXR1cm4nLCAnY2FzZScsICd0aHJvdycsICdlbHNlJywgJ2RvJywgJ3R5cGVvZicsICd5aWVsZCddKSkgfHxcbiAgICAocHJldmlvdXNfdG9rZW4udHlwZSA9PT0gVE9LRU4uRU5EX0VYUFIgJiYgcHJldmlvdXNfdG9rZW4udGV4dCA9PT0gJyknICYmXG4gICAgICBwcmV2aW91c190b2tlbi5vcGVuZWQucHJldmlvdXMudHlwZSA9PT0gVE9LRU4uUkVTRVJWRUQgJiYgaW5fYXJyYXkocHJldmlvdXNfdG9rZW4ub3BlbmVkLnByZXZpb3VzLnRleHQsIFsnaWYnLCAnd2hpbGUnLCAnZm9yJ10pKSB8fFxuICAgIChpbl9hcnJheShwcmV2aW91c190b2tlbi50eXBlLCBbVE9LRU4uQ09NTUVOVCwgVE9LRU4uU1RBUlRfRVhQUiwgVE9LRU4uU1RBUlRfQkxPQ0ssIFRPS0VOLlNUQVJULFxuICAgICAgVE9LRU4uRU5EX0JMT0NLLCBUT0tFTi5PUEVSQVRPUiwgVE9LRU4uRVFVQUxTLCBUT0tFTi5FT0YsIFRPS0VOLlNFTUlDT0xPTiwgVE9LRU4uQ09NTUFcbiAgICBdKSk7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZWFkX3JlZ2V4cCA9IGZ1bmN0aW9uKGMsIHByZXZpb3VzX3Rva2VuKSB7XG5cbiAgaWYgKGMgPT09ICcvJyAmJiB0aGlzLl9hbGxvd19yZWdleHBfb3JfeG1sKHByZXZpb3VzX3Rva2VuKSkge1xuICAgIC8vIGhhbmRsZSByZWdleHBcbiAgICAvL1xuICAgIHZhciByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5faW5wdXQubmV4dCgpO1xuICAgIHZhciBlc2MgPSBmYWxzZTtcblxuICAgIHZhciBpbl9jaGFyX2NsYXNzID0gZmFsc2U7XG4gICAgd2hpbGUgKHRoaXMuX2lucHV0Lmhhc05leHQoKSAmJlxuICAgICAgKChlc2MgfHwgaW5fY2hhcl9jbGFzcyB8fCB0aGlzLl9pbnB1dC5wZWVrKCkgIT09IGMpICYmXG4gICAgICAgICF0aGlzLl9pbnB1dC50ZXN0Q2hhcihhY29ybi5uZXdsaW5lKSkpIHtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgKz0gdGhpcy5faW5wdXQucGVlaygpO1xuICAgICAgaWYgKCFlc2MpIHtcbiAgICAgICAgZXNjID0gdGhpcy5faW5wdXQucGVlaygpID09PSAnXFxcXCc7XG4gICAgICAgIGlmICh0aGlzLl9pbnB1dC5wZWVrKCkgPT09ICdbJykge1xuICAgICAgICAgIGluX2NoYXJfY2xhc3MgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2lucHV0LnBlZWsoKSA9PT0gJ10nKSB7XG4gICAgICAgICAgaW5fY2hhcl9jbGFzcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlc2MgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faW5wdXQucGVlaygpID09PSBjKSB7XG4gICAgICByZXN1bHRpbmdfc3RyaW5nICs9IHRoaXMuX2lucHV0Lm5leHQoKTtcblxuICAgICAgLy8gcmVnZXhwcyBtYXkgaGF2ZSBtb2RpZmllcnMgL3JlZ2V4cC9NT0QgLCBzbyBmZXRjaCB0aG9zZSwgdG9vXG4gICAgICAvLyBPbmx5IFtnaW1dIGFyZSB2YWxpZCwgYnV0IGlmIHRoZSB1c2VyIHB1dHMgaW4gZ2FyYmFnZSwgZG8gd2hhdCB3ZSBjYW4gdG8gdGFrZSBpdC5cbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgKz0gdGhpcy5faW5wdXQucmVhZChhY29ybi5pZGVudGlmaWVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5TVFJJTkcsIHJlc3VsdGluZ19zdHJpbmcpO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fcmVhZF94bWwgPSBmdW5jdGlvbihjLCBwcmV2aW91c190b2tlbikge1xuXG4gIGlmICh0aGlzLl9vcHRpb25zLmU0eCAmJiBjID09PSBcIjxcIiAmJiB0aGlzLl9hbGxvd19yZWdleHBfb3JfeG1sKHByZXZpb3VzX3Rva2VuKSkge1xuICAgIHZhciB4bWxTdHIgPSAnJztcbiAgICB2YXIgbWF0Y2ggPSB0aGlzLl9fcGF0dGVybnMueG1sLnJlYWRfbWF0Y2goKTtcbiAgICAvLyBoYW5kbGUgZTR4IHhtbCBsaXRlcmFsc1xuICAgIC8vXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICAvLyBUcmltIHJvb3QgdGFnIHRvIGF0dGVtcHQgdG9cbiAgICAgIHZhciByb290VGFnID0gbWF0Y2hbMl0ucmVwbGFjZSgvXntcXHMrLywgJ3snKS5yZXBsYWNlKC9cXHMrfSQvLCAnfScpO1xuICAgICAgdmFyIGlzQ3VybHlSb290ID0gcm9vdFRhZy5pbmRleE9mKCd7JykgPT09IDA7XG4gICAgICB2YXIgZGVwdGggPSAwO1xuICAgICAgd2hpbGUgKG1hdGNoKSB7XG4gICAgICAgIHZhciBpc0VuZFRhZyA9ICEhbWF0Y2hbMV07XG4gICAgICAgIHZhciB0YWdOYW1lID0gbWF0Y2hbMl07XG4gICAgICAgIHZhciBpc1NpbmdsZXRvblRhZyA9ICghIW1hdGNoW21hdGNoLmxlbmd0aCAtIDFdKSB8fCAodGFnTmFtZS5zbGljZSgwLCA4KSA9PT0gXCIhW0NEQVRBW1wiKTtcbiAgICAgICAgaWYgKCFpc1NpbmdsZXRvblRhZyAmJlxuICAgICAgICAgICh0YWdOYW1lID09PSByb290VGFnIHx8IChpc0N1cmx5Um9vdCAmJiB0YWdOYW1lLnJlcGxhY2UoL157XFxzKy8sICd7JykucmVwbGFjZSgvXFxzK30kLywgJ30nKSkpKSB7XG4gICAgICAgICAgaWYgKGlzRW5kVGFnKSB7XG4gICAgICAgICAgICAtLWRlcHRoO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICArK2RlcHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB4bWxTdHIgKz0gbWF0Y2hbMF07XG4gICAgICAgIGlmIChkZXB0aCA8PSAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbWF0Y2ggPSB0aGlzLl9fcGF0dGVybnMueG1sLnJlYWRfbWF0Y2goKTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBjbG9zZSBjb3JyZWN0bHksIGtlZXAgdW5mb3JtYXR0ZWQuXG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHhtbFN0ciArPSB0aGlzLl9pbnB1dC5tYXRjaCgvW1xcc1xcU10qL2cpWzBdO1xuICAgICAgfVxuICAgICAgeG1sU3RyID0geG1sU3RyLnJlcGxhY2UoYWNvcm4uYWxsTGluZUJyZWFrcywgJ1xcbicpO1xuICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5TVFJJTkcsIHhtbFN0cik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5mdW5jdGlvbiB1bmVzY2FwZV9zdHJpbmcocykge1xuICAvLyBZb3UgdGhpbmsgdGhhdCBhIHJlZ2V4IHdvdWxkIHdvcmsgZm9yIHRoaXNcbiAgLy8gcmV0dXJuIHMucmVwbGFjZSgvXFxcXHgoWzAtOWEtZl17Mn0pL2dpLCBmdW5jdGlvbihtYXRjaCwgdmFsKSB7XG4gIC8vICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQodmFsLCAxNikpO1xuICAvLyAgICAgfSlcbiAgLy8gSG93ZXZlciwgZGVhbGluZyB3aXRoICdcXHhmZicsICdcXFxceGZmJywgJ1xcXFxcXHhmZicgbWFrZXMgdGhpcyBtb3JlIGZ1bi5cbiAgdmFyIG91dCA9ICcnLFxuICAgIGVzY2FwZWQgPSAwO1xuXG4gIHZhciBpbnB1dF9zY2FuID0gbmV3IElucHV0U2Nhbm5lcihzKTtcbiAgdmFyIG1hdGNoZWQgPSBudWxsO1xuXG4gIHdoaWxlIChpbnB1dF9zY2FuLmhhc05leHQoKSkge1xuICAgIC8vIEtlZXAgYW55IHdoaXRlc3BhY2UsIG5vbi1zbGFzaCBjaGFyYWN0ZXJzXG4gICAgLy8gYWxzbyBrZWVwIHNsYXNoIHBhaXJzLlxuICAgIG1hdGNoZWQgPSBpbnB1dF9zY2FuLm1hdGNoKC8oW1xcc118W15cXFxcXXxcXFxcXFxcXCkrL2cpO1xuXG4gICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgIG91dCArPSBtYXRjaGVkWzBdO1xuICAgIH1cblxuICAgIGlmIChpbnB1dF9zY2FuLnBlZWsoKSA9PT0gJ1xcXFwnKSB7XG4gICAgICBpbnB1dF9zY2FuLm5leHQoKTtcbiAgICAgIGlmIChpbnB1dF9zY2FuLnBlZWsoKSA9PT0gJ3gnKSB7XG4gICAgICAgIG1hdGNoZWQgPSBpbnB1dF9zY2FuLm1hdGNoKC94KFswLTlBLUZhLWZdezJ9KS9nKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5wdXRfc2Nhbi5wZWVrKCkgPT09ICd1Jykge1xuICAgICAgICBtYXRjaGVkID0gaW5wdXRfc2Nhbi5tYXRjaCgvdShbMC05QS1GYS1mXXs0fSkvZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gJ1xcXFwnO1xuICAgICAgICBpZiAoaW5wdXRfc2Nhbi5oYXNOZXh0KCkpIHtcbiAgICAgICAgICBvdXQgKz0gaW5wdXRfc2Nhbi5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZXJlJ3Mgc29tZSBlcnJvciBkZWNvZGluZywgcmV0dXJuIHRoZSBvcmlnaW5hbCBzdHJpbmdcbiAgICAgIGlmICghbWF0Y2hlZCkge1xuICAgICAgICByZXR1cm4gcztcbiAgICAgIH1cblxuICAgICAgZXNjYXBlZCA9IHBhcnNlSW50KG1hdGNoZWRbMV0sIDE2KTtcblxuICAgICAgaWYgKGVzY2FwZWQgPiAweDdlICYmIGVzY2FwZWQgPD0gMHhmZiAmJiBtYXRjaGVkWzBdLmluZGV4T2YoJ3gnKSA9PT0gMCkge1xuICAgICAgICAvLyB3ZSBiYWlsIG91dCBvbiBcXHg3Zi4uXFx4ZmYsXG4gICAgICAgIC8vIGxlYXZpbmcgd2hvbGUgc3RyaW5nIGVzY2FwZWQsXG4gICAgICAgIC8vIGFzIGl0J3MgcHJvYmFibHkgY29tcGxldGVseSBiaW5hcnlcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgICB9IGVsc2UgaWYgKGVzY2FwZWQgPj0gMHgwMCAmJiBlc2NhcGVkIDwgMHgyMCkge1xuICAgICAgICAvLyBsZWF2ZSAweDAwLi4uMHgxZiBlc2NhcGVkXG4gICAgICAgIG91dCArPSAnXFxcXCcgKyBtYXRjaGVkWzBdO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAoZXNjYXBlZCA9PT0gMHgyMiB8fCBlc2NhcGVkID09PSAweDI3IHx8IGVzY2FwZWQgPT09IDB4NWMpIHtcbiAgICAgICAgLy8gc2luZ2xlLXF1b3RlLCBhcG9zdHJvcGhlLCBiYWNrc2xhc2ggLSBlc2NhcGUgdGhlc2VcbiAgICAgICAgb3V0ICs9ICdcXFxcJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoZXNjYXBlZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShlc2NhcGVkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuXG4vLyBoYW5kbGUgc3RyaW5nXG4vL1xuVG9rZW5pemVyLnByb3RvdHlwZS5fcmVhZF9zdHJpbmdfcmVjdXJzaXZlID0gZnVuY3Rpb24oZGVsaW1pdGVyLCBhbGxvd191bmVzY2FwZWRfbmV3bGluZXMsIHN0YXJ0X3N1Yikge1xuICB2YXIgY3VycmVudF9jaGFyO1xuICB2YXIgcGF0dGVybjtcbiAgaWYgKGRlbGltaXRlciA9PT0gJ1xcJycpIHtcbiAgICBwYXR0ZXJuID0gdGhpcy5fX3BhdHRlcm5zLnNpbmdsZV9xdW90ZTtcbiAgfSBlbHNlIGlmIChkZWxpbWl0ZXIgPT09ICdcIicpIHtcbiAgICBwYXR0ZXJuID0gdGhpcy5fX3BhdHRlcm5zLmRvdWJsZV9xdW90ZTtcbiAgfSBlbHNlIGlmIChkZWxpbWl0ZXIgPT09ICdgJykge1xuICAgIHBhdHRlcm4gPSB0aGlzLl9fcGF0dGVybnMudGVtcGxhdGVfdGV4dDtcbiAgfSBlbHNlIGlmIChkZWxpbWl0ZXIgPT09ICd9Jykge1xuICAgIHBhdHRlcm4gPSB0aGlzLl9fcGF0dGVybnMudGVtcGxhdGVfZXhwcmVzc2lvbjtcbiAgfVxuXG4gIHZhciByZXN1bHRpbmdfc3RyaW5nID0gcGF0dGVybi5yZWFkKCk7XG4gIHZhciBuZXh0ID0gJyc7XG4gIHdoaWxlICh0aGlzLl9pbnB1dC5oYXNOZXh0KCkpIHtcbiAgICBuZXh0ID0gdGhpcy5faW5wdXQubmV4dCgpO1xuICAgIGlmIChuZXh0ID09PSBkZWxpbWl0ZXIgfHxcbiAgICAgICghYWxsb3dfdW5lc2NhcGVkX25ld2xpbmVzICYmIGFjb3JuLm5ld2xpbmUudGVzdChuZXh0KSkpIHtcbiAgICAgIHRoaXMuX2lucHV0LmJhY2soKTtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSBpZiAobmV4dCA9PT0gJ1xcXFwnICYmIHRoaXMuX2lucHV0Lmhhc05leHQoKSkge1xuICAgICAgY3VycmVudF9jaGFyID0gdGhpcy5faW5wdXQucGVlaygpO1xuXG4gICAgICBpZiAoY3VycmVudF9jaGFyID09PSAneCcgfHwgY3VycmVudF9jaGFyID09PSAndScpIHtcbiAgICAgICAgdGhpcy5oYXNfY2hhcl9lc2NhcGVzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudF9jaGFyID09PSAnXFxyJyAmJiB0aGlzLl9pbnB1dC5wZWVrKDEpID09PSAnXFxuJykge1xuICAgICAgICB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgICB9XG4gICAgICBuZXh0ICs9IHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICB9IGVsc2UgaWYgKHN0YXJ0X3N1Yikge1xuICAgICAgaWYgKHN0YXJ0X3N1YiA9PT0gJyR7JyAmJiBuZXh0ID09PSAnJCcgJiYgdGhpcy5faW5wdXQucGVlaygpID09PSAneycpIHtcbiAgICAgICAgbmV4dCArPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGFydF9zdWIgPT09IG5leHQpIHtcbiAgICAgICAgaWYgKGRlbGltaXRlciA9PT0gJ2AnKSB7XG4gICAgICAgICAgbmV4dCArPSB0aGlzLl9yZWFkX3N0cmluZ19yZWN1cnNpdmUoJ30nLCBhbGxvd191bmVzY2FwZWRfbmV3bGluZXMsICdgJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dCArPSB0aGlzLl9yZWFkX3N0cmluZ19yZWN1cnNpdmUoJ2AnLCBhbGxvd191bmVzY2FwZWRfbmV3bGluZXMsICckeycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pbnB1dC5oYXNOZXh0KCkpIHtcbiAgICAgICAgICBuZXh0ICs9IHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBuZXh0ICs9IHBhdHRlcm4ucmVhZCgpO1xuICAgIHJlc3VsdGluZ19zdHJpbmcgKz0gbmV4dDtcbiAgfVxuXG4gIHJldHVybiByZXN1bHRpbmdfc3RyaW5nO1xufTtcblxubW9kdWxlLmV4cG9ydHMuVG9rZW5pemVyID0gVG9rZW5pemVyO1xubW9kdWxlLmV4cG9ydHMuVE9LRU4gPSBUT0tFTjtcbm1vZHVsZS5leHBvcnRzLnBvc2l0aW9uYWJsZV9vcGVyYXRvcnMgPSBwb3NpdGlvbmFibGVfb3BlcmF0b3JzLnNsaWNlKCk7XG5tb2R1bGUuZXhwb3J0cy5saW5lX3N0YXJ0ZXJzID0gbGluZV9zdGFydGVycy5zbGljZSgpO1xuIiwiLy8gLmRpcm5hbWUsIC5iYXNlbmFtZSwgYW5kIC5leHRuYW1lIG1ldGhvZHMgYXJlIGV4dHJhY3RlZCBmcm9tIE5vZGUuanMgdjguMTEuMSxcbi8vIGJhY2twb3J0ZWQgYW5kIHRyYW5zcGxpdGVkIHdpdGggQmFiZWwsIHdpdGggYmFja3dhcmRzLWNvbXBhdCBmaXhlc1xuXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gcmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIGFycmF5IHdpdGggZGlyZWN0b3J5IG5hbWVzIHRoZXJlXG4vLyBtdXN0IGJlIG5vIHNsYXNoZXMsIGVtcHR5IGVsZW1lbnRzLCBvciBkZXZpY2UgbmFtZXMgKGM6XFwpIGluIHRoZSBhcnJheVxuLy8gKHNvIGFsc28gbm8gbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcyAtIGl0IGRvZXMgbm90IGRpc3Rpbmd1aXNoXG4vLyByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgcGF0aHMpXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheShwYXJ0cywgYWxsb3dBYm92ZVJvb3QpIHtcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGxhc3QgPSBwYXJ0c1tpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHBhcnRzLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG4vLyBwYXRoLnJlc29sdmUoW2Zyb20gLi4uXSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlc29sdmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc29sdmVkUGF0aCA9ICcnLFxuICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAtMSAmJiAhcmVzb2x2ZWRBYnNvbHV0ZTsgaS0tKSB7XG4gICAgdmFyIHBhdGggPSAoaSA+PSAwKSA/IGFyZ3VtZW50c1tpXSA6IHByb2Nlc3MuY3dkKCk7XG5cbiAgICAvLyBTa2lwIGVtcHR5IGFuZCBpbnZhbGlkIGVudHJpZXNcbiAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH0gZWxzZSBpZiAoIXBhdGgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJlc29sdmVkUGF0aCA9IHBhdGggKyAnLycgKyByZXNvbHZlZFBhdGg7XG4gICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IHBhdGguY2hhckF0KDApID09PSAnLyc7XG4gIH1cblxuICAvLyBBdCB0aGlzIHBvaW50IHRoZSBwYXRoIHNob3VsZCBiZSByZXNvbHZlZCB0byBhIGZ1bGwgYWJzb2x1dGUgcGF0aCwgYnV0XG4gIC8vIGhhbmRsZSByZWxhdGl2ZSBwYXRocyB0byBiZSBzYWZlIChtaWdodCBoYXBwZW4gd2hlbiBwcm9jZXNzLmN3ZCgpIGZhaWxzKVxuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICByZXNvbHZlZFBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocmVzb2x2ZWRQYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIXJlc29sdmVkQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICByZXR1cm4gKChyZXNvbHZlZEFic29sdXRlID8gJy8nIDogJycpICsgcmVzb2x2ZWRQYXRoKSB8fCAnLic7XG59O1xuXG4vLyBwYXRoLm5vcm1hbGl6ZShwYXRoKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5ub3JtYWxpemUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciBpc0Fic29sdXRlID0gZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpLFxuICAgICAgdHJhaWxpbmdTbGFzaCA9IHN1YnN0cihwYXRoLCAtMSkgPT09ICcvJztcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihwYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIWlzQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICBpZiAoIXBhdGggJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBwYXRoID0gJy4nO1xuICB9XG4gIGlmIChwYXRoICYmIHRyYWlsaW5nU2xhc2gpIHtcbiAgICBwYXRoICs9ICcvJztcbiAgfVxuXG4gIHJldHVybiAoaXNBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHBhdGg7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmlzQWJzb2x1dGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5qb2luID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXRocyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gIHJldHVybiBleHBvcnRzLm5vcm1hbGl6ZShmaWx0ZXIocGF0aHMsIGZ1bmN0aW9uKHAsIGluZGV4KSB7XG4gICAgaWYgKHR5cGVvZiBwICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGguam9pbiBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH0pLmpvaW4oJy8nKSk7XG59O1xuXG5cbi8vIHBhdGgucmVsYXRpdmUoZnJvbSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlbGF0aXZlID0gZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgZnJvbSA9IGV4cG9ydHMucmVzb2x2ZShmcm9tKS5zdWJzdHIoMSk7XG4gIHRvID0gZXhwb3J0cy5yZXNvbHZlKHRvKS5zdWJzdHIoMSk7XG5cbiAgZnVuY3Rpb24gdHJpbShhcnIpIHtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIGZvciAoOyBzdGFydCA8IGFyci5sZW5ndGg7IHN0YXJ0KyspIHtcbiAgICAgIGlmIChhcnJbc3RhcnRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGVuZCA9IGFyci5sZW5ndGggLSAxO1xuICAgIGZvciAoOyBlbmQgPj0gMDsgZW5kLS0pIHtcbiAgICAgIGlmIChhcnJbZW5kXSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA+IGVuZCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiBhcnIuc2xpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0ICsgMSk7XG4gIH1cblxuICB2YXIgZnJvbVBhcnRzID0gdHJpbShmcm9tLnNwbGl0KCcvJykpO1xuICB2YXIgdG9QYXJ0cyA9IHRyaW0odG8uc3BsaXQoJy8nKSk7XG5cbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGZyb21QYXJ0cy5sZW5ndGgsIHRvUGFydHMubGVuZ3RoKTtcbiAgdmFyIHNhbWVQYXJ0c0xlbmd0aCA9IGxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChmcm9tUGFydHNbaV0gIT09IHRvUGFydHNbaV0pIHtcbiAgICAgIHNhbWVQYXJ0c0xlbmd0aCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgb3V0cHV0UGFydHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IHNhbWVQYXJ0c0xlbmd0aDsgaSA8IGZyb21QYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFBhcnRzLnB1c2goJy4uJyk7XG4gIH1cblxuICBvdXRwdXRQYXJ0cyA9IG91dHB1dFBhcnRzLmNvbmNhdCh0b1BhcnRzLnNsaWNlKHNhbWVQYXJ0c0xlbmd0aCkpO1xuXG4gIHJldHVybiBvdXRwdXRQYXJ0cy5qb2luKCcvJyk7XG59O1xuXG5leHBvcnRzLnNlcCA9ICcvJztcbmV4cG9ydHMuZGVsaW1pdGVyID0gJzonO1xuXG5leHBvcnRzLmRpcm5hbWUgPSBmdW5jdGlvbiAocGF0aCkge1xuICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSBwYXRoID0gcGF0aCArICcnO1xuICBpZiAocGF0aC5sZW5ndGggPT09IDApIHJldHVybiAnLic7XG4gIHZhciBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KDApO1xuICB2YXIgaGFzUm9vdCA9IGNvZGUgPT09IDQ3IC8qLyovO1xuICB2YXIgZW5kID0gLTE7XG4gIHZhciBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICBmb3IgKHZhciBpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDE7IC0taSkge1xuICAgIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgZW5kID0gaTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yXG4gICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoZW5kID09PSAtMSkgcmV0dXJuIGhhc1Jvb3QgPyAnLycgOiAnLic7XG4gIGlmIChoYXNSb290ICYmIGVuZCA9PT0gMSkge1xuICAgIC8vIHJldHVybiAnLy8nO1xuICAgIC8vIEJhY2t3YXJkcy1jb21wYXQgZml4OlxuICAgIHJldHVybiAnLyc7XG4gIH1cbiAgcmV0dXJuIHBhdGguc2xpY2UoMCwgZW5kKTtcbn07XG5cbmZ1bmN0aW9uIGJhc2VuYW1lKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykgcGF0aCA9IHBhdGggKyAnJztcblxuICB2YXIgc3RhcnQgPSAwO1xuICB2YXIgZW5kID0gLTE7XG4gIHZhciBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICB2YXIgaTtcblxuICBmb3IgKGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgaWYgKHBhdGguY2hhckNvZGVBdChpKSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcbiAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93XG4gICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXG4gICAgICAvLyBwYXRoIGNvbXBvbmVudFxuICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICBlbmQgPSBpICsgMTtcbiAgICB9XG4gIH1cblxuICBpZiAoZW5kID09PSAtMSkgcmV0dXJuICcnO1xuICByZXR1cm4gcGF0aC5zbGljZShzdGFydCwgZW5kKTtcbn1cblxuLy8gVXNlcyBhIG1peGVkIGFwcHJvYWNoIGZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSwgYXMgZXh0IGJlaGF2aW9yIGNoYW5nZWRcbi8vIGluIG5ldyBOb2RlLmpzIHZlcnNpb25zLCBzbyBvbmx5IGJhc2VuYW1lKCkgYWJvdmUgaXMgYmFja3BvcnRlZCBoZXJlXG5leHBvcnRzLmJhc2VuYW1lID0gZnVuY3Rpb24gKHBhdGgsIGV4dCkge1xuICB2YXIgZiA9IGJhc2VuYW1lKHBhdGgpO1xuICBpZiAoZXh0ICYmIGYuc3Vic3RyKC0xICogZXh0Lmxlbmd0aCkgPT09IGV4dCkge1xuICAgIGYgPSBmLnN1YnN0cigwLCBmLmxlbmd0aCAtIGV4dC5sZW5ndGgpO1xuICB9XG4gIHJldHVybiBmO1xufTtcblxuZXhwb3J0cy5leHRuYW1lID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykgcGF0aCA9IHBhdGggKyAnJztcbiAgdmFyIHN0YXJ0RG90ID0gLTE7XG4gIHZhciBzdGFydFBhcnQgPSAwO1xuICB2YXIgZW5kID0gLTE7XG4gIHZhciBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICAvLyBUcmFjayB0aGUgc3RhdGUgb2YgY2hhcmFjdGVycyAoaWYgYW55KSB3ZSBzZWUgYmVmb3JlIG91ciBmaXJzdCBkb3QgYW5kXG4gIC8vIGFmdGVyIGFueSBwYXRoIHNlcGFyYXRvciB3ZSBmaW5kXG4gIHZhciBwcmVEb3RTdGF0ZSA9IDA7XG4gIGZvciAodmFyIGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgdmFyIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXG4gICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgIHN0YXJ0UGFydCA9IGkgKyAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXG4gICAgICAvLyBleHRlbnNpb25cbiAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgZW5kID0gaSArIDE7XG4gICAgfVxuICAgIGlmIChjb2RlID09PSA0NiAvKi4qLykge1xuICAgICAgICAvLyBJZiB0aGlzIGlzIG91ciBmaXJzdCBkb3QsIG1hcmsgaXQgYXMgdGhlIHN0YXJ0IG9mIG91ciBleHRlbnNpb25cbiAgICAgICAgaWYgKHN0YXJ0RG90ID09PSAtMSlcbiAgICAgICAgICBzdGFydERvdCA9IGk7XG4gICAgICAgIGVsc2UgaWYgKHByZURvdFN0YXRlICE9PSAxKVxuICAgICAgICAgIHByZURvdFN0YXRlID0gMTtcbiAgICB9IGVsc2UgaWYgKHN0YXJ0RG90ICE9PSAtMSkge1xuICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBhbmQgbm9uLXBhdGggc2VwYXJhdG9yIGJlZm9yZSBvdXIgZG90LCBzbyB3ZSBzaG91bGRcbiAgICAgIC8vIGhhdmUgYSBnb29kIGNoYW5jZSBhdCBoYXZpbmcgYSBub24tZW1wdHkgZXh0ZW5zaW9uXG4gICAgICBwcmVEb3RTdGF0ZSA9IC0xO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdGFydERvdCA9PT0gLTEgfHwgZW5kID09PSAtMSB8fFxuICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBjaGFyYWN0ZXIgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBkb3RcbiAgICAgIHByZURvdFN0YXRlID09PSAwIHx8XG4gICAgICAvLyBUaGUgKHJpZ2h0LW1vc3QpIHRyaW1tZWQgcGF0aCBjb21wb25lbnQgaXMgZXhhY3RseSAnLi4nXG4gICAgICBwcmVEb3RTdGF0ZSA9PT0gMSAmJiBzdGFydERvdCA9PT0gZW5kIC0gMSAmJiBzdGFydERvdCA9PT0gc3RhcnRQYXJ0ICsgMSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICByZXR1cm4gcGF0aC5zbGljZShzdGFydERvdCwgZW5kKTtcbn07XG5cbmZ1bmN0aW9uIGZpbHRlciAoeHMsIGYpIHtcbiAgICBpZiAoeHMuZmlsdGVyKSByZXR1cm4geHMuZmlsdGVyKGYpO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmKHhzW2ldLCBpLCB4cykpIHJlcy5wdXNoKHhzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gU3RyaW5nLnByb3RvdHlwZS5zdWJzdHIgLSBuZWdhdGl2ZSBpbmRleCBkb24ndCB3b3JrIGluIElFOFxudmFyIHN1YnN0ciA9ICdhYicuc3Vic3RyKC0xKSA9PT0gJ2InXG4gICAgPyBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7IHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pIH1cbiAgICA6IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHtcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSBzdHIubGVuZ3RoICsgc3RhcnQ7XG4gICAgICAgIHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pO1xuICAgIH1cbjtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJ2YXIgU291cmNlTWFwQ29uc3VtZXIgPSByZXF1aXJlKCdzb3VyY2UtbWFwJykuU291cmNlTWFwQ29uc3VtZXI7XG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcblxudmFyIGZzO1xudHJ5IHtcbiAgZnMgPSByZXF1aXJlKCdmcycpO1xuICBpZiAoIWZzLmV4aXN0c1N5bmMgfHwgIWZzLnJlYWRGaWxlU3luYykge1xuICAgIC8vIGZzIGRvZXNuJ3QgaGF2ZSBhbGwgbWV0aG9kcyB3ZSBuZWVkXG4gICAgZnMgPSBudWxsO1xuICB9XG59IGNhdGNoIChlcnIpIHtcbiAgLyogbm9wICovXG59XG5cbnZhciBidWZmZXJGcm9tID0gcmVxdWlyZSgnYnVmZmVyLWZyb20nKTtcblxuLy8gT25seSBpbnN0YWxsIG9uY2UgaWYgY2FsbGVkIG11bHRpcGxlIHRpbWVzXG52YXIgZXJyb3JGb3JtYXR0ZXJJbnN0YWxsZWQgPSBmYWxzZTtcbnZhciB1bmNhdWdodFNoaW1JbnN0YWxsZWQgPSBmYWxzZTtcblxuLy8gSWYgdHJ1ZSwgdGhlIGNhY2hlcyBhcmUgcmVzZXQgYmVmb3JlIGEgc3RhY2sgdHJhY2UgZm9ybWF0dGluZyBvcGVyYXRpb25cbnZhciBlbXB0eUNhY2hlQmV0d2Vlbk9wZXJhdGlvbnMgPSBmYWxzZTtcblxuLy8gU3VwcG9ydHMge2Jyb3dzZXIsIG5vZGUsIGF1dG99XG52YXIgZW52aXJvbm1lbnQgPSBcImF1dG9cIjtcblxuLy8gTWFwcyBhIGZpbGUgcGF0aCB0byBhIHN0cmluZyBjb250YWluaW5nIHRoZSBmaWxlIGNvbnRlbnRzXG52YXIgZmlsZUNvbnRlbnRzQ2FjaGUgPSB7fTtcblxuLy8gTWFwcyBhIGZpbGUgcGF0aCB0byBhIHNvdXJjZSBtYXAgZm9yIHRoYXQgZmlsZVxudmFyIHNvdXJjZU1hcENhY2hlID0ge307XG5cbi8vIFJlZ2V4IGZvciBkZXRlY3Rpbmcgc291cmNlIG1hcHNcbnZhciByZVNvdXJjZU1hcCA9IC9eZGF0YTphcHBsaWNhdGlvblxcL2pzb25bXixdK2Jhc2U2NCwvO1xuXG4vLyBQcmlvcml0eSBsaXN0IG9mIHJldHJpZXZlIGhhbmRsZXJzXG52YXIgcmV0cmlldmVGaWxlSGFuZGxlcnMgPSBbXTtcbnZhciByZXRyaWV2ZU1hcEhhbmRsZXJzID0gW107XG5cbmZ1bmN0aW9uIGlzSW5Ccm93c2VyKCkge1xuICBpZiAoZW52aXJvbm1lbnQgPT09IFwiYnJvd3NlclwiKVxuICAgIHJldHVybiB0cnVlO1xuICBpZiAoZW52aXJvbm1lbnQgPT09IFwibm9kZVwiKVxuICAgIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuICgodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpICYmICh0eXBlb2YgWE1MSHR0cFJlcXVlc3QgPT09ICdmdW5jdGlvbicpICYmICEod2luZG93LnJlcXVpcmUgJiYgd2luZG93Lm1vZHVsZSAmJiB3aW5kb3cucHJvY2VzcyAmJiB3aW5kb3cucHJvY2Vzcy50eXBlID09PSBcInJlbmRlcmVyXCIpKTtcbn1cblxuZnVuY3Rpb24gaGFzR2xvYmFsUHJvY2Vzc0V2ZW50RW1pdHRlcigpIHtcbiAgcmV0dXJuICgodHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnKSAmJiAocHJvY2VzcyAhPT0gbnVsbCkgJiYgKHR5cGVvZiBwcm9jZXNzLm9uID09PSAnZnVuY3Rpb24nKSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZXJFeGVjKGxpc3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHJldCA9IGxpc3RbaV0oYXJnKTtcbiAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG59XG5cbnZhciByZXRyaWV2ZUZpbGUgPSBoYW5kbGVyRXhlYyhyZXRyaWV2ZUZpbGVIYW5kbGVycyk7XG5cbnJldHJpZXZlRmlsZUhhbmRsZXJzLnB1c2goZnVuY3Rpb24ocGF0aCkge1xuICAvLyBUcmltIHRoZSBwYXRoIHRvIG1ha2Ugc3VyZSB0aGVyZSBpcyBubyBleHRyYSB3aGl0ZXNwYWNlLlxuICBwYXRoID0gcGF0aC50cmltKCk7XG4gIGlmICgvXmZpbGU6Ly50ZXN0KHBhdGgpKSB7XG4gICAgLy8gZXhpc3RzU3luYy9yZWFkRmlsZVN5bmMgY2FuJ3QgaGFuZGxlIGZpbGUgcHJvdG9jb2wsIGJ1dCBvbmNlIHN0cmlwcGVkLCBpdCB3b3Jrc1xuICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL2ZpbGU6XFwvXFwvXFwvKFxcdzopPy8sIGZ1bmN0aW9uKHByb3RvY29sLCBkcml2ZSkge1xuICAgICAgcmV0dXJuIGRyaXZlID9cbiAgICAgICAgJycgOiAvLyBmaWxlOi8vL0M6L2Rpci9maWxlIC0+IEM6L2Rpci9maWxlXG4gICAgICAgICcvJzsgLy8gZmlsZTovLy9yb290LWRpci9maWxlIC0+IC9yb290LWRpci9maWxlXG4gICAgfSk7XG4gIH1cbiAgaWYgKHBhdGggaW4gZmlsZUNvbnRlbnRzQ2FjaGUpIHtcbiAgICByZXR1cm4gZmlsZUNvbnRlbnRzQ2FjaGVbcGF0aF07XG4gIH1cblxuICB2YXIgY29udGVudHMgPSAnJztcbiAgdHJ5IHtcbiAgICBpZiAoIWZzKSB7XG4gICAgICAvLyBVc2UgU0pBWCBpZiB3ZSBhcmUgaW4gdGhlIGJyb3dzZXJcbiAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgIHhoci5vcGVuKCdHRVQnLCBwYXRoLCAvKiogYXN5bmMgKi8gZmFsc2UpO1xuICAgICAgeGhyLnNlbmQobnVsbCk7XG4gICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQgJiYgeGhyLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgIGNvbnRlbnRzID0geGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGZzLmV4aXN0c1N5bmMocGF0aCkpIHtcbiAgICAgIC8vIE90aGVyd2lzZSwgdXNlIHRoZSBmaWxlc3lzdGVtXG4gICAgICBjb250ZW50cyA9IGZzLnJlYWRGaWxlU3luYyhwYXRoLCAndXRmOCcpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXIpIHtcbiAgICAvKiBpZ25vcmUgYW55IGVycm9ycyAqL1xuICB9XG5cbiAgcmV0dXJuIGZpbGVDb250ZW50c0NhY2hlW3BhdGhdID0gY29udGVudHM7XG59KTtcblxuLy8gU3VwcG9ydCBVUkxzIHJlbGF0aXZlIHRvIGEgZGlyZWN0b3J5LCBidXQgYmUgY2FyZWZ1bCBhYm91dCBhIHByb3RvY29sIHByZWZpeFxuLy8gaW4gY2FzZSB3ZSBhcmUgaW4gdGhlIGJyb3dzZXIgKGkuZS4gZGlyZWN0b3JpZXMgbWF5IHN0YXJ0IHdpdGggXCJodHRwOi8vXCIgb3IgXCJmaWxlOi8vL1wiKVxuZnVuY3Rpb24gc3VwcG9ydFJlbGF0aXZlVVJMKGZpbGUsIHVybCkge1xuICBpZiAoIWZpbGUpIHJldHVybiB1cmw7XG4gIHZhciBkaXIgPSBwYXRoLmRpcm5hbWUoZmlsZSk7XG4gIHZhciBtYXRjaCA9IC9eXFx3KzpcXC9cXC9bXlxcL10qLy5leGVjKGRpcik7XG4gIHZhciBwcm90b2NvbCA9IG1hdGNoID8gbWF0Y2hbMF0gOiAnJztcbiAgdmFyIHN0YXJ0UGF0aCA9IGRpci5zbGljZShwcm90b2NvbC5sZW5ndGgpO1xuICBpZiAocHJvdG9jb2wgJiYgL15cXC9cXHdcXDovLnRlc3Qoc3RhcnRQYXRoKSkge1xuICAgIC8vIGhhbmRsZSBmaWxlOi8vL0M6LyBwYXRoc1xuICAgIHByb3RvY29sICs9ICcvJztcbiAgICByZXR1cm4gcHJvdG9jb2wgKyBwYXRoLnJlc29sdmUoZGlyLnNsaWNlKHByb3RvY29sLmxlbmd0aCksIHVybCkucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xuICB9XG4gIHJldHVybiBwcm90b2NvbCArIHBhdGgucmVzb2x2ZShkaXIuc2xpY2UocHJvdG9jb2wubGVuZ3RoKSwgdXJsKTtcbn1cblxuZnVuY3Rpb24gcmV0cmlldmVTb3VyY2VNYXBVUkwoc291cmNlKSB7XG4gIHZhciBmaWxlRGF0YTtcblxuICBpZiAoaXNJbkJyb3dzZXIoKSkge1xuICAgICB0cnkge1xuICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICB4aHIub3BlbignR0VUJywgc291cmNlLCBmYWxzZSk7XG4gICAgICAgeGhyLnNlbmQobnVsbCk7XG4gICAgICAgZmlsZURhdGEgPSB4aHIucmVhZHlTdGF0ZSA9PT0gNCA/IHhoci5yZXNwb25zZVRleHQgOiBudWxsO1xuXG4gICAgICAgLy8gU3VwcG9ydCBwcm92aWRpbmcgYSBzb3VyY2VNYXBwaW5nVVJMIHZpYSB0aGUgU291cmNlTWFwIGhlYWRlclxuICAgICAgIHZhciBzb3VyY2VNYXBIZWFkZXIgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJTb3VyY2VNYXBcIikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiWC1Tb3VyY2VNYXBcIik7XG4gICAgICAgaWYgKHNvdXJjZU1hcEhlYWRlcikge1xuICAgICAgICAgcmV0dXJuIHNvdXJjZU1hcEhlYWRlcjtcbiAgICAgICB9XG4gICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgfVxuICB9XG5cbiAgLy8gR2V0IHRoZSBVUkwgb2YgdGhlIHNvdXJjZSBtYXBcbiAgZmlsZURhdGEgPSByZXRyaWV2ZUZpbGUoc291cmNlKTtcbiAgdmFyIHJlID0gLyg/OlxcL1xcL1tAI11bXFxzXSpzb3VyY2VNYXBwaW5nVVJMPShbXlxccydcIl0rKVtcXHNdKiQpfCg/OlxcL1xcKltAI11bXFxzXSpzb3VyY2VNYXBwaW5nVVJMPShbXlxccyonXCJdKylbXFxzXSooPzpcXCpcXC8pW1xcc10qJCkvbWc7XG4gIC8vIEtlZXAgZXhlY3V0aW5nIHRoZSBzZWFyY2ggdG8gZmluZCB0aGUgKmxhc3QqIHNvdXJjZU1hcHBpbmdVUkwgdG8gYXZvaWRcbiAgLy8gcGlja2luZyB1cCBzb3VyY2VNYXBwaW5nVVJMcyBmcm9tIGNvbW1lbnRzLCBzdHJpbmdzLCBldGMuXG4gIHZhciBsYXN0TWF0Y2gsIG1hdGNoO1xuICB3aGlsZSAobWF0Y2ggPSByZS5leGVjKGZpbGVEYXRhKSkgbGFzdE1hdGNoID0gbWF0Y2g7XG4gIGlmICghbGFzdE1hdGNoKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIGxhc3RNYXRjaFsxXTtcbn07XG5cbi8vIENhbiBiZSBvdmVycmlkZGVuIGJ5IHRoZSByZXRyaWV2ZVNvdXJjZU1hcCBvcHRpb24gdG8gaW5zdGFsbC4gVGFrZXMgYVxuLy8gZ2VuZXJhdGVkIHNvdXJjZSBmaWxlbmFtZTsgcmV0dXJucyBhIHttYXAsIG9wdGlvbmFsIHVybH0gb2JqZWN0LCBvciBudWxsIGlmXG4vLyB0aGVyZSBpcyBubyBzb3VyY2UgbWFwLiAgVGhlIG1hcCBmaWVsZCBtYXkgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIHRoZSBwYXJzZWRcbi8vIEpTT04gb2JqZWN0IChpZSwgaXQgbXVzdCBiZSBhIHZhbGlkIGFyZ3VtZW50IHRvIHRoZSBTb3VyY2VNYXBDb25zdW1lclxuLy8gY29uc3RydWN0b3IpLlxudmFyIHJldHJpZXZlU291cmNlTWFwID0gaGFuZGxlckV4ZWMocmV0cmlldmVNYXBIYW5kbGVycyk7XG5yZXRyaWV2ZU1hcEhhbmRsZXJzLnB1c2goZnVuY3Rpb24oc291cmNlKSB7XG4gIHZhciBzb3VyY2VNYXBwaW5nVVJMID0gcmV0cmlldmVTb3VyY2VNYXBVUkwoc291cmNlKTtcbiAgaWYgKCFzb3VyY2VNYXBwaW5nVVJMKSByZXR1cm4gbnVsbDtcblxuICAvLyBSZWFkIHRoZSBjb250ZW50cyBvZiB0aGUgc291cmNlIG1hcFxuICB2YXIgc291cmNlTWFwRGF0YTtcbiAgaWYgKHJlU291cmNlTWFwLnRlc3Qoc291cmNlTWFwcGluZ1VSTCkpIHtcbiAgICAvLyBTdXBwb3J0IHNvdXJjZSBtYXAgVVJMIGFzIGEgZGF0YSB1cmxcbiAgICB2YXIgcmF3RGF0YSA9IHNvdXJjZU1hcHBpbmdVUkwuc2xpY2Uoc291cmNlTWFwcGluZ1VSTC5pbmRleE9mKCcsJykgKyAxKTtcbiAgICBzb3VyY2VNYXBEYXRhID0gYnVmZmVyRnJvbShyYXdEYXRhLCBcImJhc2U2NFwiKS50b1N0cmluZygpO1xuICAgIHNvdXJjZU1hcHBpbmdVUkwgPSBzb3VyY2U7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3VwcG9ydCBzb3VyY2UgbWFwIFVSTHMgcmVsYXRpdmUgdG8gdGhlIHNvdXJjZSBVUkxcbiAgICBzb3VyY2VNYXBwaW5nVVJMID0gc3VwcG9ydFJlbGF0aXZlVVJMKHNvdXJjZSwgc291cmNlTWFwcGluZ1VSTCk7XG4gICAgc291cmNlTWFwRGF0YSA9IHJldHJpZXZlRmlsZShzb3VyY2VNYXBwaW5nVVJMKTtcbiAgfVxuXG4gIGlmICghc291cmNlTWFwRGF0YSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB1cmw6IHNvdXJjZU1hcHBpbmdVUkwsXG4gICAgbWFwOiBzb3VyY2VNYXBEYXRhXG4gIH07XG59KTtcblxuZnVuY3Rpb24gbWFwU291cmNlUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgdmFyIHNvdXJjZU1hcCA9IHNvdXJjZU1hcENhY2hlW3Bvc2l0aW9uLnNvdXJjZV07XG4gIGlmICghc291cmNlTWFwKSB7XG4gICAgLy8gQ2FsbCB0aGUgKG92ZXJyaWRlYWJsZSkgcmV0cmlldmVTb3VyY2VNYXAgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzb3VyY2UgbWFwLlxuICAgIHZhciB1cmxBbmRNYXAgPSByZXRyaWV2ZVNvdXJjZU1hcChwb3NpdGlvbi5zb3VyY2UpO1xuICAgIGlmICh1cmxBbmRNYXApIHtcbiAgICAgIHNvdXJjZU1hcCA9IHNvdXJjZU1hcENhY2hlW3Bvc2l0aW9uLnNvdXJjZV0gPSB7XG4gICAgICAgIHVybDogdXJsQW5kTWFwLnVybCxcbiAgICAgICAgbWFwOiBuZXcgU291cmNlTWFwQ29uc3VtZXIodXJsQW5kTWFwLm1hcClcbiAgICAgIH07XG5cbiAgICAgIC8vIExvYWQgYWxsIHNvdXJjZXMgc3RvcmVkIGlubGluZSB3aXRoIHRoZSBzb3VyY2UgbWFwIGludG8gdGhlIGZpbGUgY2FjaGVcbiAgICAgIC8vIHRvIHByZXRlbmQgbGlrZSB0aGV5IGFyZSBhbHJlYWR5IGxvYWRlZC4gVGhleSBtYXkgbm90IGV4aXN0IG9uIGRpc2suXG4gICAgICBpZiAoc291cmNlTWFwLm1hcC5zb3VyY2VzQ29udGVudCkge1xuICAgICAgICBzb3VyY2VNYXAubWFwLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbihzb3VyY2UsIGkpIHtcbiAgICAgICAgICB2YXIgY29udGVudHMgPSBzb3VyY2VNYXAubWFwLnNvdXJjZXNDb250ZW50W2ldO1xuICAgICAgICAgIGlmIChjb250ZW50cykge1xuICAgICAgICAgICAgdmFyIHVybCA9IHN1cHBvcnRSZWxhdGl2ZVVSTChzb3VyY2VNYXAudXJsLCBzb3VyY2UpO1xuICAgICAgICAgICAgZmlsZUNvbnRlbnRzQ2FjaGVbdXJsXSA9IGNvbnRlbnRzO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNvdXJjZU1hcCA9IHNvdXJjZU1hcENhY2hlW3Bvc2l0aW9uLnNvdXJjZV0gPSB7XG4gICAgICAgIHVybDogbnVsbCxcbiAgICAgICAgbWFwOiBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlc29sdmUgdGhlIHNvdXJjZSBVUkwgcmVsYXRpdmUgdG8gdGhlIFVSTCBvZiB0aGUgc291cmNlIG1hcFxuICBpZiAoc291cmNlTWFwICYmIHNvdXJjZU1hcC5tYXAgJiYgdHlwZW9mIHNvdXJjZU1hcC5tYXAub3JpZ2luYWxQb3NpdGlvbkZvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBvcmlnaW5hbFBvc2l0aW9uID0gc291cmNlTWFwLm1hcC5vcmlnaW5hbFBvc2l0aW9uRm9yKHBvc2l0aW9uKTtcblxuICAgIC8vIE9ubHkgcmV0dXJuIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiBpZiBhIG1hdGNoaW5nIGxpbmUgd2FzIGZvdW5kLiBJZiBub1xuICAgIC8vIG1hdGNoaW5nIGxpbmUgaXMgZm91bmQgdGhlbiB3ZSByZXR1cm4gcG9zaXRpb24gaW5zdGVhZCwgd2hpY2ggd2lsbCBjYXVzZVxuICAgIC8vIHRoZSBzdGFjayB0cmFjZSB0byBwcmludCB0aGUgcGF0aCBhbmQgbGluZSBmb3IgdGhlIGNvbXBpbGVkIGZpbGUuIEl0IGlzXG4gICAgLy8gYmV0dGVyIHRvIGdpdmUgYSBwcmVjaXNlIGxvY2F0aW9uIGluIHRoZSBjb21waWxlZCBmaWxlIHRoYW4gYSB2YWd1ZVxuICAgIC8vIGxvY2F0aW9uIGluIHRoZSBvcmlnaW5hbCBmaWxlLlxuICAgIGlmIChvcmlnaW5hbFBvc2l0aW9uLnNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgb3JpZ2luYWxQb3NpdGlvbi5zb3VyY2UgPSBzdXBwb3J0UmVsYXRpdmVVUkwoXG4gICAgICAgIHNvdXJjZU1hcC51cmwsIG9yaWdpbmFsUG9zaXRpb24uc291cmNlKTtcbiAgICAgIHJldHVybiBvcmlnaW5hbFBvc2l0aW9uO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwb3NpdGlvbjtcbn1cblxuLy8gUGFyc2VzIGNvZGUgZ2VuZXJhdGVkIGJ5IEZvcm1hdEV2YWxPcmlnaW4oKSwgYSBmdW5jdGlvbiBpbnNpZGUgVjg6XG4vLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L3NvdXJjZS9icm93c2UvdHJ1bmsvc3JjL21lc3NhZ2VzLmpzXG5mdW5jdGlvbiBtYXBFdmFsT3JpZ2luKG9yaWdpbikge1xuICAvLyBNb3N0IGV2YWwoKSBjYWxscyBhcmUgaW4gdGhpcyBmb3JtYXRcbiAgdmFyIG1hdGNoID0gL15ldmFsIGF0IChbXihdKykgXFwoKC4rKTooXFxkKyk6KFxcZCspXFwpJC8uZXhlYyhvcmlnaW4pO1xuICBpZiAobWF0Y2gpIHtcbiAgICB2YXIgcG9zaXRpb24gPSBtYXBTb3VyY2VQb3NpdGlvbih7XG4gICAgICBzb3VyY2U6IG1hdGNoWzJdLFxuICAgICAgbGluZTogK21hdGNoWzNdLFxuICAgICAgY29sdW1uOiBtYXRjaFs0XSAtIDFcbiAgICB9KTtcbiAgICByZXR1cm4gJ2V2YWwgYXQgJyArIG1hdGNoWzFdICsgJyAoJyArIHBvc2l0aW9uLnNvdXJjZSArICc6JyArXG4gICAgICBwb3NpdGlvbi5saW5lICsgJzonICsgKHBvc2l0aW9uLmNvbHVtbiArIDEpICsgJyknO1xuICB9XG5cbiAgLy8gUGFyc2UgbmVzdGVkIGV2YWwoKSBjYWxscyB1c2luZyByZWN1cnNpb25cbiAgbWF0Y2ggPSAvXmV2YWwgYXQgKFteKF0rKSBcXCgoLispXFwpJC8uZXhlYyhvcmlnaW4pO1xuICBpZiAobWF0Y2gpIHtcbiAgICByZXR1cm4gJ2V2YWwgYXQgJyArIG1hdGNoWzFdICsgJyAoJyArIG1hcEV2YWxPcmlnaW4obWF0Y2hbMl0pICsgJyknO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIHdlIHN0aWxsIHJldHVybiB1c2VmdWwgaW5mb3JtYXRpb24gaWYgd2UgZGlkbid0IGZpbmQgYW55dGhpbmdcbiAgcmV0dXJuIG9yaWdpbjtcbn1cblxuLy8gVGhpcyBpcyBjb3BpZWQgYWxtb3N0IHZlcmJhdGltIGZyb20gdGhlIFY4IHNvdXJjZSBjb2RlIGF0XG4vLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L3NvdXJjZS9icm93c2UvdHJ1bmsvc3JjL21lc3NhZ2VzLmpzLiBUaGVcbi8vIGltcGxlbWVudGF0aW9uIG9mIHdyYXBDYWxsU2l0ZSgpIHVzZWQgdG8ganVzdCBmb3J3YXJkIHRvIHRoZSBhY3R1YWwgc291cmNlXG4vLyBjb2RlIG9mIENhbGxTaXRlLnByb3RvdHlwZS50b1N0cmluZyBidXQgdW5mb3J0dW5hdGVseSBhIG5ldyByZWxlYXNlIG9mIFY4XG4vLyBkaWQgc29tZXRoaW5nIHRvIHRoZSBwcm90b3R5cGUgY2hhaW4gYW5kIGJyb2tlIHRoZSBzaGltLiBUaGUgb25seSBmaXggSVxuLy8gY291bGQgZmluZCB3YXMgY29weS9wYXN0ZS5cbmZ1bmN0aW9uIENhbGxTaXRlVG9TdHJpbmcoKSB7XG4gIHZhciBmaWxlTmFtZTtcbiAgdmFyIGZpbGVMb2NhdGlvbiA9IFwiXCI7XG4gIGlmICh0aGlzLmlzTmF0aXZlKCkpIHtcbiAgICBmaWxlTG9jYXRpb24gPSBcIm5hdGl2ZVwiO1xuICB9IGVsc2Uge1xuICAgIGZpbGVOYW1lID0gdGhpcy5nZXRTY3JpcHROYW1lT3JTb3VyY2VVUkwoKTtcbiAgICBpZiAoIWZpbGVOYW1lICYmIHRoaXMuaXNFdmFsKCkpIHtcbiAgICAgIGZpbGVMb2NhdGlvbiA9IHRoaXMuZ2V0RXZhbE9yaWdpbigpO1xuICAgICAgZmlsZUxvY2F0aW9uICs9IFwiLCBcIjsgIC8vIEV4cGVjdGluZyBzb3VyY2UgcG9zaXRpb24gdG8gZm9sbG93LlxuICAgIH1cblxuICAgIGlmIChmaWxlTmFtZSkge1xuICAgICAgZmlsZUxvY2F0aW9uICs9IGZpbGVOYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTb3VyY2UgY29kZSBkb2VzIG5vdCBvcmlnaW5hdGUgZnJvbSBhIGZpbGUgYW5kIGlzIG5vdCBuYXRpdmUsIGJ1dCB3ZVxuICAgICAgLy8gY2FuIHN0aWxsIGdldCB0aGUgc291cmNlIHBvc2l0aW9uIGluc2lkZSB0aGUgc291cmNlIHN0cmluZywgZS5nLiBpblxuICAgICAgLy8gYW4gZXZhbCBzdHJpbmcuXG4gICAgICBmaWxlTG9jYXRpb24gKz0gXCI8YW5vbnltb3VzPlwiO1xuICAgIH1cbiAgICB2YXIgbGluZU51bWJlciA9IHRoaXMuZ2V0TGluZU51bWJlcigpO1xuICAgIGlmIChsaW5lTnVtYmVyICE9IG51bGwpIHtcbiAgICAgIGZpbGVMb2NhdGlvbiArPSBcIjpcIiArIGxpbmVOdW1iZXI7XG4gICAgICB2YXIgY29sdW1uTnVtYmVyID0gdGhpcy5nZXRDb2x1bW5OdW1iZXIoKTtcbiAgICAgIGlmIChjb2x1bW5OdW1iZXIpIHtcbiAgICAgICAgZmlsZUxvY2F0aW9uICs9IFwiOlwiICsgY29sdW1uTnVtYmVyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBsaW5lID0gXCJcIjtcbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IHRoaXMuZ2V0RnVuY3Rpb25OYW1lKCk7XG4gIHZhciBhZGRTdWZmaXggPSB0cnVlO1xuICB2YXIgaXNDb25zdHJ1Y3RvciA9IHRoaXMuaXNDb25zdHJ1Y3RvcigpO1xuICB2YXIgaXNNZXRob2RDYWxsID0gISh0aGlzLmlzVG9wbGV2ZWwoKSB8fCBpc0NvbnN0cnVjdG9yKTtcbiAgaWYgKGlzTWV0aG9kQ2FsbCkge1xuICAgIHZhciB0eXBlTmFtZSA9IHRoaXMuZ2V0VHlwZU5hbWUoKTtcbiAgICAvLyBGaXhlcyBzaGltIHRvIGJlIGJhY2t3YXJkIGNvbXBhdGFibGUgd2l0aCBOb2RlIHYwIHRvIHY0XG4gICAgaWYgKHR5cGVOYW1lID09PSBcIltvYmplY3QgT2JqZWN0XVwiKSB7XG4gICAgICB0eXBlTmFtZSA9IFwibnVsbFwiO1xuICAgIH1cbiAgICB2YXIgbWV0aG9kTmFtZSA9IHRoaXMuZ2V0TWV0aG9kTmFtZSgpO1xuICAgIGlmIChmdW5jdGlvbk5hbWUpIHtcbiAgICAgIGlmICh0eXBlTmFtZSAmJiBmdW5jdGlvbk5hbWUuaW5kZXhPZih0eXBlTmFtZSkgIT0gMCkge1xuICAgICAgICBsaW5lICs9IHR5cGVOYW1lICsgXCIuXCI7XG4gICAgICB9XG4gICAgICBsaW5lICs9IGZ1bmN0aW9uTmFtZTtcbiAgICAgIGlmIChtZXRob2ROYW1lICYmIGZ1bmN0aW9uTmFtZS5pbmRleE9mKFwiLlwiICsgbWV0aG9kTmFtZSkgIT0gZnVuY3Rpb25OYW1lLmxlbmd0aCAtIG1ldGhvZE5hbWUubGVuZ3RoIC0gMSkge1xuICAgICAgICBsaW5lICs9IFwiIFthcyBcIiArIG1ldGhvZE5hbWUgKyBcIl1cIjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGluZSArPSB0eXBlTmFtZSArIFwiLlwiICsgKG1ldGhvZE5hbWUgfHwgXCI8YW5vbnltb3VzPlwiKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNDb25zdHJ1Y3Rvcikge1xuICAgIGxpbmUgKz0gXCJuZXcgXCIgKyAoZnVuY3Rpb25OYW1lIHx8IFwiPGFub255bW91cz5cIik7XG4gIH0gZWxzZSBpZiAoZnVuY3Rpb25OYW1lKSB7XG4gICAgbGluZSArPSBmdW5jdGlvbk5hbWU7XG4gIH0gZWxzZSB7XG4gICAgbGluZSArPSBmaWxlTG9jYXRpb247XG4gICAgYWRkU3VmZml4ID0gZmFsc2U7XG4gIH1cbiAgaWYgKGFkZFN1ZmZpeCkge1xuICAgIGxpbmUgKz0gXCIgKFwiICsgZmlsZUxvY2F0aW9uICsgXCIpXCI7XG4gIH1cbiAgcmV0dXJuIGxpbmU7XG59XG5cbmZ1bmN0aW9uIGNsb25lQ2FsbFNpdGUoZnJhbWUpIHtcbiAgdmFyIG9iamVjdCA9IHt9O1xuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPYmplY3QuZ2V0UHJvdG90eXBlT2YoZnJhbWUpKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBvYmplY3RbbmFtZV0gPSAvXig/OmlzfGdldCkvLnRlc3QobmFtZSkgPyBmdW5jdGlvbigpIHsgcmV0dXJuIGZyYW1lW25hbWVdLmNhbGwoZnJhbWUpOyB9IDogZnJhbWVbbmFtZV07XG4gIH0pO1xuICBvYmplY3QudG9TdHJpbmcgPSBDYWxsU2l0ZVRvU3RyaW5nO1xuICByZXR1cm4gb2JqZWN0O1xufVxuXG5mdW5jdGlvbiB3cmFwQ2FsbFNpdGUoZnJhbWUsIHN0YXRlKSB7XG4gIC8vIHByb3ZpZGVzIGludGVyZmFjZSBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gIGlmIChzdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhdGUgPSB7IG5leHRQb3NpdGlvbjogbnVsbCwgY3VyUG9zaXRpb246IG51bGwgfVxuICB9XG4gIGlmKGZyYW1lLmlzTmF0aXZlKCkpIHtcbiAgICBzdGF0ZS5jdXJQb3NpdGlvbiA9IG51bGw7XG4gICAgcmV0dXJuIGZyYW1lO1xuICB9XG5cbiAgLy8gTW9zdCBjYWxsIHNpdGVzIHdpbGwgcmV0dXJuIHRoZSBzb3VyY2UgZmlsZSBmcm9tIGdldEZpbGVOYW1lKCksIGJ1dCBjb2RlXG4gIC8vIHBhc3NlZCB0byBldmFsKCkgZW5kaW5nIGluIFwiLy8jIHNvdXJjZVVSTD0uLi5cIiB3aWxsIHJldHVybiB0aGUgc291cmNlIGZpbGVcbiAgLy8gZnJvbSBnZXRTY3JpcHROYW1lT3JTb3VyY2VVUkwoKSBpbnN0ZWFkXG4gIHZhciBzb3VyY2UgPSBmcmFtZS5nZXRGaWxlTmFtZSgpIHx8IGZyYW1lLmdldFNjcmlwdE5hbWVPclNvdXJjZVVSTCgpO1xuICBpZiAoc291cmNlKSB7XG4gICAgdmFyIGxpbmUgPSBmcmFtZS5nZXRMaW5lTnVtYmVyKCk7XG4gICAgdmFyIGNvbHVtbiA9IGZyYW1lLmdldENvbHVtbk51bWJlcigpIC0gMTtcblxuICAgIC8vIEZpeCBwb3NpdGlvbiBpbiBOb2RlIHdoZXJlIHNvbWUgKGludGVybmFsKSBjb2RlIGlzIHByZXBlbmRlZC5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2V2YW53L25vZGUtc291cmNlLW1hcC1zdXBwb3J0L2lzc3Vlcy8zNlxuICAgIC8vIEhlYWRlciByZW1vdmVkIGluIG5vZGUgYXQgXjEwLjE2IHx8ID49MTEuMTEuMFxuICAgIC8vIHYxMSBpcyBub3QgYW4gTFRTIGNhbmRpZGF0ZSwgd2UgY2FuIGp1c3QgdGVzdCB0aGUgb25lIHZlcnNpb24gd2l0aCBpdC5cbiAgICAvLyBUZXN0IG5vZGUgdmVyc2lvbnMgZm9yOiAxMC4xNi0xOSwgMTAuMjArLCAxMi0xOSwgMjAtOTksIDEwMCssIG9yIDExLjExXG4gICAgdmFyIG5vSGVhZGVyID0gL152KDEwXFwuMVs2LTldfDEwXFwuWzItOV1bMC05XXwxMFxcLlswLTldezMsfXwxWzItOV1cXGQqfFsyLTldXFxkfFxcZHszLH18MTFcXC4xMSkvO1xuICAgIHZhciBoZWFkZXJMZW5ndGggPSBub0hlYWRlci50ZXN0KHByb2Nlc3MudmVyc2lvbikgPyAwIDogNjI7XG4gICAgaWYgKGxpbmUgPT09IDEgJiYgY29sdW1uID4gaGVhZGVyTGVuZ3RoICYmICFpc0luQnJvd3NlcigpICYmICFmcmFtZS5pc0V2YWwoKSkge1xuICAgICAgY29sdW1uIC09IGhlYWRlckxlbmd0aDtcbiAgICB9XG5cbiAgICB2YXIgcG9zaXRpb24gPSBtYXBTb3VyY2VQb3NpdGlvbih7XG4gICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgIGxpbmU6IGxpbmUsXG4gICAgICBjb2x1bW46IGNvbHVtblxuICAgIH0pO1xuICAgIHN0YXRlLmN1clBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgZnJhbWUgPSBjbG9uZUNhbGxTaXRlKGZyYW1lKTtcbiAgICB2YXIgb3JpZ2luYWxGdW5jdGlvbk5hbWUgPSBmcmFtZS5nZXRGdW5jdGlvbk5hbWU7XG4gICAgZnJhbWUuZ2V0RnVuY3Rpb25OYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoc3RhdGUubmV4dFBvc2l0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsRnVuY3Rpb25OYW1lKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhdGUubmV4dFBvc2l0aW9uLm5hbWUgfHwgb3JpZ2luYWxGdW5jdGlvbk5hbWUoKTtcbiAgICB9O1xuICAgIGZyYW1lLmdldEZpbGVOYW1lID0gZnVuY3Rpb24oKSB7IHJldHVybiBwb3NpdGlvbi5zb3VyY2U7IH07XG4gICAgZnJhbWUuZ2V0TGluZU51bWJlciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gcG9zaXRpb24ubGluZTsgfTtcbiAgICBmcmFtZS5nZXRDb2x1bW5OdW1iZXIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHBvc2l0aW9uLmNvbHVtbiArIDE7IH07XG4gICAgZnJhbWUuZ2V0U2NyaXB0TmFtZU9yU291cmNlVVJMID0gZnVuY3Rpb24oKSB7IHJldHVybiBwb3NpdGlvbi5zb3VyY2U7IH07XG4gICAgcmV0dXJuIGZyYW1lO1xuICB9XG5cbiAgLy8gQ29kZSBjYWxsZWQgdXNpbmcgZXZhbCgpIG5lZWRzIHNwZWNpYWwgaGFuZGxpbmdcbiAgdmFyIG9yaWdpbiA9IGZyYW1lLmlzRXZhbCgpICYmIGZyYW1lLmdldEV2YWxPcmlnaW4oKTtcbiAgaWYgKG9yaWdpbikge1xuICAgIG9yaWdpbiA9IG1hcEV2YWxPcmlnaW4ob3JpZ2luKTtcbiAgICBmcmFtZSA9IGNsb25lQ2FsbFNpdGUoZnJhbWUpO1xuICAgIGZyYW1lLmdldEV2YWxPcmlnaW4gPSBmdW5jdGlvbigpIHsgcmV0dXJuIG9yaWdpbjsgfTtcbiAgICByZXR1cm4gZnJhbWU7XG4gIH1cblxuICAvLyBJZiB3ZSBnZXQgaGVyZSB0aGVuIHdlIHdlcmUgdW5hYmxlIHRvIGNoYW5nZSB0aGUgc291cmNlIHBvc2l0aW9uXG4gIHJldHVybiBmcmFtZTtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBwYXJ0IG9mIHRoZSBWOCBzdGFjayB0cmFjZSBBUEksIGZvciBtb3JlIGluZm8gc2VlOlxuLy8gaHR0cHM6Ly92OC5kZXYvZG9jcy9zdGFjay10cmFjZS1hcGlcbmZ1bmN0aW9uIHByZXBhcmVTdGFja1RyYWNlKGVycm9yLCBzdGFjaykge1xuICBpZiAoZW1wdHlDYWNoZUJldHdlZW5PcGVyYXRpb25zKSB7XG4gICAgZmlsZUNvbnRlbnRzQ2FjaGUgPSB7fTtcbiAgICBzb3VyY2VNYXBDYWNoZSA9IHt9O1xuICB9XG5cbiAgdmFyIG5hbWUgPSBlcnJvci5uYW1lIHx8ICdFcnJvcic7XG4gIHZhciBtZXNzYWdlID0gZXJyb3IubWVzc2FnZSB8fCAnJztcbiAgdmFyIGVycm9yU3RyaW5nID0gbmFtZSArIFwiOiBcIiArIG1lc3NhZ2U7XG5cbiAgdmFyIHN0YXRlID0geyBuZXh0UG9zaXRpb246IG51bGwsIGN1clBvc2l0aW9uOiBudWxsIH07XG4gIHZhciBwcm9jZXNzZWRTdGFjayA9IFtdO1xuICBmb3IgKHZhciBpID0gc3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBwcm9jZXNzZWRTdGFjay5wdXNoKCdcXG4gICAgYXQgJyArIHdyYXBDYWxsU2l0ZShzdGFja1tpXSwgc3RhdGUpKTtcbiAgICBzdGF0ZS5uZXh0UG9zaXRpb24gPSBzdGF0ZS5jdXJQb3NpdGlvbjtcbiAgfVxuICBzdGF0ZS5jdXJQb3NpdGlvbiA9IHN0YXRlLm5leHRQb3NpdGlvbiA9IG51bGw7XG4gIHJldHVybiBlcnJvclN0cmluZyArIHByb2Nlc3NlZFN0YWNrLnJldmVyc2UoKS5qb2luKCcnKTtcbn1cblxuLy8gR2VuZXJhdGUgcG9zaXRpb24gYW5kIHNuaXBwZXQgb2Ygb3JpZ2luYWwgc291cmNlIHdpdGggcG9pbnRlclxuZnVuY3Rpb24gZ2V0RXJyb3JTb3VyY2UoZXJyb3IpIHtcbiAgdmFyIG1hdGNoID0gL1xcbiAgICBhdCBbXihdKyBcXCgoLiopOihcXGQrKTooXFxkKylcXCkvLmV4ZWMoZXJyb3Iuc3RhY2spO1xuICBpZiAobWF0Y2gpIHtcbiAgICB2YXIgc291cmNlID0gbWF0Y2hbMV07XG4gICAgdmFyIGxpbmUgPSArbWF0Y2hbMl07XG4gICAgdmFyIGNvbHVtbiA9ICttYXRjaFszXTtcblxuICAgIC8vIFN1cHBvcnQgdGhlIGlubGluZSBzb3VyY2VDb250ZW50cyBpbnNpZGUgdGhlIHNvdXJjZSBtYXBcbiAgICB2YXIgY29udGVudHMgPSBmaWxlQ29udGVudHNDYWNoZVtzb3VyY2VdO1xuXG4gICAgLy8gU3VwcG9ydCBmaWxlcyBvbiBkaXNrXG4gICAgaWYgKCFjb250ZW50cyAmJiBmcyAmJiBmcy5leGlzdHNTeW5jKHNvdXJjZSkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnRlbnRzID0gZnMucmVhZEZpbGVTeW5jKHNvdXJjZSwgJ3V0ZjgnKTtcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIGNvbnRlbnRzID0gJyc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRm9ybWF0IHRoZSBsaW5lIGZyb20gdGhlIG9yaWdpbmFsIHNvdXJjZSBjb2RlIGxpa2Ugbm9kZSBkb2VzXG4gICAgaWYgKGNvbnRlbnRzKSB7XG4gICAgICB2YXIgY29kZSA9IGNvbnRlbnRzLnNwbGl0KC8oPzpcXHJcXG58XFxyfFxcbikvKVtsaW5lIC0gMV07XG4gICAgICBpZiAoY29kZSkge1xuICAgICAgICByZXR1cm4gc291cmNlICsgJzonICsgbGluZSArICdcXG4nICsgY29kZSArICdcXG4nICtcbiAgICAgICAgICBuZXcgQXJyYXkoY29sdW1uKS5qb2luKCcgJykgKyAnXic7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBwcmludEVycm9yQW5kRXhpdCAoZXJyb3IpIHtcbiAgdmFyIHNvdXJjZSA9IGdldEVycm9yU291cmNlKGVycm9yKTtcblxuICAvLyBFbnN1cmUgZXJyb3IgaXMgcHJpbnRlZCBzeW5jaHJvbm91c2x5IGFuZCBub3QgdHJ1bmNhdGVkXG4gIGlmIChwcm9jZXNzLnN0ZGVyci5faGFuZGxlICYmIHByb2Nlc3Muc3RkZXJyLl9oYW5kbGUuc2V0QmxvY2tpbmcpIHtcbiAgICBwcm9jZXNzLnN0ZGVyci5faGFuZGxlLnNldEJsb2NraW5nKHRydWUpO1xuICB9XG5cbiAgaWYgKHNvdXJjZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoKTtcbiAgICBjb25zb2xlLmVycm9yKHNvdXJjZSk7XG4gIH1cblxuICBjb25zb2xlLmVycm9yKGVycm9yLnN0YWNrKTtcbiAgcHJvY2Vzcy5leGl0KDEpO1xufVxuXG5mdW5jdGlvbiBzaGltRW1pdFVuY2F1Z2h0RXhjZXB0aW9uICgpIHtcbiAgdmFyIG9yaWdFbWl0ID0gcHJvY2Vzcy5lbWl0O1xuXG4gIHByb2Nlc3MuZW1pdCA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT09ICd1bmNhdWdodEV4Y2VwdGlvbicpIHtcbiAgICAgIHZhciBoYXNTdGFjayA9IChhcmd1bWVudHNbMV0gJiYgYXJndW1lbnRzWzFdLnN0YWNrKTtcbiAgICAgIHZhciBoYXNMaXN0ZW5lcnMgPSAodGhpcy5saXN0ZW5lcnModHlwZSkubGVuZ3RoID4gMCk7XG5cbiAgICAgIGlmIChoYXNTdGFjayAmJiAhaGFzTGlzdGVuZXJzKSB7XG4gICAgICAgIHJldHVybiBwcmludEVycm9yQW5kRXhpdChhcmd1bWVudHNbMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvcmlnRW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG52YXIgb3JpZ2luYWxSZXRyaWV2ZUZpbGVIYW5kbGVycyA9IHJldHJpZXZlRmlsZUhhbmRsZXJzLnNsaWNlKDApO1xudmFyIG9yaWdpbmFsUmV0cmlldmVNYXBIYW5kbGVycyA9IHJldHJpZXZlTWFwSGFuZGxlcnMuc2xpY2UoMCk7XG5cbmV4cG9ydHMud3JhcENhbGxTaXRlID0gd3JhcENhbGxTaXRlO1xuZXhwb3J0cy5nZXRFcnJvclNvdXJjZSA9IGdldEVycm9yU291cmNlO1xuZXhwb3J0cy5tYXBTb3VyY2VQb3NpdGlvbiA9IG1hcFNvdXJjZVBvc2l0aW9uO1xuZXhwb3J0cy5yZXRyaWV2ZVNvdXJjZU1hcCA9IHJldHJpZXZlU291cmNlTWFwO1xuXG5leHBvcnRzLmluc3RhbGwgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmIChvcHRpb25zLmVudmlyb25tZW50KSB7XG4gICAgZW52aXJvbm1lbnQgPSBvcHRpb25zLmVudmlyb25tZW50O1xuICAgIGlmIChbXCJub2RlXCIsIFwiYnJvd3NlclwiLCBcImF1dG9cIl0uaW5kZXhPZihlbnZpcm9ubWVudCkgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbnZpcm9ubWVudCBcIiArIGVudmlyb25tZW50ICsgXCIgd2FzIHVua25vd24uIEF2YWlsYWJsZSBvcHRpb25zIGFyZSB7YXV0bywgYnJvd3Nlciwgbm9kZX1cIilcbiAgICB9XG4gIH1cblxuICAvLyBBbGxvdyBzb3VyY2VzIHRvIGJlIGZvdW5kIGJ5IG1ldGhvZHMgb3RoZXIgdGhhbiByZWFkaW5nIHRoZSBmaWxlc1xuICAvLyBkaXJlY3RseSBmcm9tIGRpc2suXG4gIGlmIChvcHRpb25zLnJldHJpZXZlRmlsZSkge1xuICAgIGlmIChvcHRpb25zLm92ZXJyaWRlUmV0cmlldmVGaWxlKSB7XG4gICAgICByZXRyaWV2ZUZpbGVIYW5kbGVycy5sZW5ndGggPSAwO1xuICAgIH1cblxuICAgIHJldHJpZXZlRmlsZUhhbmRsZXJzLnVuc2hpZnQob3B0aW9ucy5yZXRyaWV2ZUZpbGUpO1xuICB9XG5cbiAgLy8gQWxsb3cgc291cmNlIG1hcHMgdG8gYmUgZm91bmQgYnkgbWV0aG9kcyBvdGhlciB0aGFuIHJlYWRpbmcgdGhlIGZpbGVzXG4gIC8vIGRpcmVjdGx5IGZyb20gZGlzay5cbiAgaWYgKG9wdGlvbnMucmV0cmlldmVTb3VyY2VNYXApIHtcbiAgICBpZiAob3B0aW9ucy5vdmVycmlkZVJldHJpZXZlU291cmNlTWFwKSB7XG4gICAgICByZXRyaWV2ZU1hcEhhbmRsZXJzLmxlbmd0aCA9IDA7XG4gICAgfVxuXG4gICAgcmV0cmlldmVNYXBIYW5kbGVycy51bnNoaWZ0KG9wdGlvbnMucmV0cmlldmVTb3VyY2VNYXApO1xuICB9XG5cbiAgLy8gU3VwcG9ydCBydW50aW1lIHRyYW5zcGlsZXJzIHRoYXQgaW5jbHVkZSBpbmxpbmUgc291cmNlIG1hcHNcbiAgaWYgKG9wdGlvbnMuaG9va1JlcXVpcmUgJiYgIWlzSW5Ccm93c2VyKCkpIHtcbiAgICB2YXIgTW9kdWxlO1xuICAgIHRyeSB7XG4gICAgICBNb2R1bGUgPSByZXF1aXJlKCdtb2R1bGUnKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIE5PUDogTG9hZGluZyBpbiBjYXRjaCBibG9jayB0byBjb252ZXJ0IHdlYnBhY2sgZXJyb3IgdG8gd2FybmluZy5cbiAgICB9XG4gICAgdmFyICRjb21waWxlID0gTW9kdWxlLnByb3RvdHlwZS5fY29tcGlsZTtcblxuICAgIGlmICghJGNvbXBpbGUuX19zb3VyY2VNYXBTdXBwb3J0KSB7XG4gICAgICBNb2R1bGUucHJvdG90eXBlLl9jb21waWxlID0gZnVuY3Rpb24oY29udGVudCwgZmlsZW5hbWUpIHtcbiAgICAgICAgZmlsZUNvbnRlbnRzQ2FjaGVbZmlsZW5hbWVdID0gY29udGVudDtcbiAgICAgICAgc291cmNlTWFwQ2FjaGVbZmlsZW5hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gJGNvbXBpbGUuY2FsbCh0aGlzLCBjb250ZW50LCBmaWxlbmFtZSk7XG4gICAgICB9O1xuXG4gICAgICBNb2R1bGUucHJvdG90eXBlLl9jb21waWxlLl9fc291cmNlTWFwU3VwcG9ydCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gQ29uZmlndXJlIG9wdGlvbnNcbiAgaWYgKCFlbXB0eUNhY2hlQmV0d2Vlbk9wZXJhdGlvbnMpIHtcbiAgICBlbXB0eUNhY2hlQmV0d2Vlbk9wZXJhdGlvbnMgPSAnZW1wdHlDYWNoZUJldHdlZW5PcGVyYXRpb25zJyBpbiBvcHRpb25zID9cbiAgICAgIG9wdGlvbnMuZW1wdHlDYWNoZUJldHdlZW5PcGVyYXRpb25zIDogZmFsc2U7XG4gIH1cblxuICAvLyBJbnN0YWxsIHRoZSBlcnJvciByZWZvcm1hdHRlclxuICBpZiAoIWVycm9yRm9ybWF0dGVySW5zdGFsbGVkKSB7XG4gICAgZXJyb3JGb3JtYXR0ZXJJbnN0YWxsZWQgPSB0cnVlO1xuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJlcGFyZVN0YWNrVHJhY2U7XG4gIH1cblxuICBpZiAoIXVuY2F1Z2h0U2hpbUluc3RhbGxlZCkge1xuICAgIHZhciBpbnN0YWxsSGFuZGxlciA9ICdoYW5kbGVVbmNhdWdodEV4Y2VwdGlvbnMnIGluIG9wdGlvbnMgP1xuICAgICAgb3B0aW9ucy5oYW5kbGVVbmNhdWdodEV4Y2VwdGlvbnMgOiB0cnVlO1xuXG4gICAgLy8gUHJvdmlkZSB0aGUgb3B0aW9uIHRvIG5vdCBpbnN0YWxsIHRoZSB1bmNhdWdodCBleGNlcHRpb24gaGFuZGxlci4gVGhpcyBpc1xuICAgIC8vIHRvIHN1cHBvcnQgb3RoZXIgdW5jYXVnaHQgZXhjZXB0aW9uIGhhbmRsZXJzIChpbiB0ZXN0IGZyYW1ld29ya3MsIGZvclxuICAgIC8vIGV4YW1wbGUpLiBJZiB0aGlzIGhhbmRsZXIgaXMgbm90IGluc3RhbGxlZCBhbmQgdGhlcmUgYXJlIG5vIG90aGVyIHVuY2F1Z2h0XG4gICAgLy8gZXhjZXB0aW9uIGhhbmRsZXJzLCB1bmNhdWdodCBleGNlcHRpb25zIHdpbGwgYmUgY2F1Z2h0IGJ5IG5vZGUncyBidWlsdC1pblxuICAgIC8vIGV4Y2VwdGlvbiBoYW5kbGVyIGFuZCB0aGUgcHJvY2VzcyB3aWxsIHN0aWxsIGJlIHRlcm1pbmF0ZWQuIEhvd2V2ZXIsIHRoZVxuICAgIC8vIGdlbmVyYXRlZCBKYXZhU2NyaXB0IGNvZGUgd2lsbCBiZSBzaG93biBhYm92ZSB0aGUgc3RhY2sgdHJhY2UgaW5zdGVhZCBvZlxuICAgIC8vIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29kZS5cbiAgICBpZiAoaW5zdGFsbEhhbmRsZXIgJiYgaGFzR2xvYmFsUHJvY2Vzc0V2ZW50RW1pdHRlcigpKSB7XG4gICAgICB1bmNhdWdodFNoaW1JbnN0YWxsZWQgPSB0cnVlO1xuICAgICAgc2hpbUVtaXRVbmNhdWdodEV4Y2VwdGlvbigpO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0cy5yZXNldFJldHJpZXZlSGFuZGxlcnMgPSBmdW5jdGlvbigpIHtcbiAgcmV0cmlldmVGaWxlSGFuZGxlcnMubGVuZ3RoID0gMDtcbiAgcmV0cmlldmVNYXBIYW5kbGVycy5sZW5ndGggPSAwO1xuXG4gIHJldHJpZXZlRmlsZUhhbmRsZXJzID0gb3JpZ2luYWxSZXRyaWV2ZUZpbGVIYW5kbGVycy5zbGljZSgwKTtcbiAgcmV0cmlldmVNYXBIYW5kbGVycyA9IG9yaWdpbmFsUmV0cmlldmVNYXBIYW5kbGVycy5zbGljZSgwKTtcblxuICByZXRyaWV2ZVNvdXJjZU1hcCA9IGhhbmRsZXJFeGVjKHJldHJpZXZlTWFwSGFuZGxlcnMpO1xuICByZXRyaWV2ZUZpbGUgPSBoYW5kbGVyRXhlYyhyZXRyaWV2ZUZpbGVIYW5kbGVycyk7XG59XG4iLCJcbmltcG9ydCB7IGJvdCB9IGZyb20gXCIuL0xhYmVsXCI7XG5pbXBvcnQgeyBWYWx1ZSB9IGZyb20gXCIuL1ZhbHVlXCI7XG5cbmV4cG9ydCB2YXIgaW5kZXggPSBuZXcgVmFsdWUoJ2luZGV4JywgYm90KTtcbmV4cG9ydCB2YXIgaW5wdXQgPSBuZXcgVmFsdWUoJ2lucHV0JywgYm90KTtcbmV4cG9ydCB2YXIgdmFsdWUgPSBuZXcgVmFsdWUoJ3ZhbHVlJywgYm90KTtcbmV4cG9ydCB2YXIgd3JpdGFibGUgPSBuZXcgVmFsdWUoJ3dyaXRhYmxlJywgYm90KTtcbmV4cG9ydCB2YXIgZW51bWVyYWJsZSA9IG5ldyBWYWx1ZSgnZW51bWVyYWJsZScsIGJvdCk7XG5leHBvcnQgdmFyIGNvbmZpZ3VyYWJsZSA9IG5ldyBWYWx1ZSgnY29uZmlndXJhYmxlJywgYm90KTtcbmV4cG9ydCB2YXIgZ2V0ID0gbmV3IFZhbHVlKCdnZXQnLCBib3QpO1xuZXhwb3J0IHZhciBzZXQgPSBuZXcgVmFsdWUoJ3NldCcsIGJvdCk7XG5leHBvcnQgdmFyIHByaW50ID0gbmV3IFZhbHVlKCdwcmludCcsIGJvdCk7XG5leHBvcnQgdmFyIGNvbnNvbGUgPSBuZXcgVmFsdWUoJ2NvbnNvbGUnLCBib3QpO1xuZXhwb3J0IHZhciBhbGVydCA9IG5ldyBWYWx1ZSgnYWxlcnQnLCBib3QpO1xuZXhwb3J0IHZhciBwcm90b3R5cGUgPSBuZXcgVmFsdWUoJ3Byb3RvdHlwZScsIGJvdCk7XG5leHBvcnQgdmFyIGNvbnN0cnVjdG9yID0gbmV3IFZhbHVlKCdjb25zdHJ1Y3RvcicsIGJvdCk7XG5leHBvcnQgdmFyIGxlbmd0aCA9IG5ldyBWYWx1ZSgnbGVuZ3RoJywgYm90KTtcbi8vQHRzLWlnbm9yZSBUWVBFU1xuZXhwb3J0IHZhciBhcmd1bWVudHMgPSBuZXcgVmFsdWUoJ2FyZ3VtZW50cycsIGJvdCk7XG5leHBvcnQgdmFyIHVwZyA9IG5ldyBWYWx1ZSgndXBnJywgYm90KTtcbmV4cG9ydCB2YXIgdXBndiA9IG5ldyBWYWx1ZSgndXBndicsIGJvdCk7XG5leHBvcnQgdmFyIHVwZ2YgPSBuZXcgVmFsdWUoJ3VwZ2YnLCBib3QpO1xuZXhwb3J0IHZhciB1cGdzID0gbmV3IFZhbHVlKCd1cGdzJywgYm90KTtcbmV4cG9ydCB2YXIgZ2V0UHJvdG90eXBlT2YgPSBuZXcgVmFsdWUoJ2dldFByb3RvdHlwZU9mJywgYm90KTtcbmV4cG9ydCB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gbmV3IFZhbHVlKCdnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3InLCBib3QpO1xuZXhwb3J0IHZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzID0gbmV3IFZhbHVlKCdnZXRPd25Qcm9wZXJ0eU5hbWVzJywgYm90KTtcbmV4cG9ydCB2YXIgY3JlYXRlID0gbmV3IFZhbHVlKCdjcmVhdGUnLCBib3QpO1xuLy9AdHMtaWdub3JlIFRZUEVTXG5leHBvcnQgdmFyIHJlcXVpcmUgPSBuZXcgVmFsdWUoJ3JlcXVpcmUnLCBib3QpO1xuZXhwb3J0IHZhciBkZWZpbmVQcm9wZXJ0eSA9IG5ldyBWYWx1ZSgnZGVmaW5lUHJvcGVydHknLCBib3QpO1xuZXhwb3J0IHZhciBkZWZpbmVQcm9wZXJ0aWVzID0gbmV3IFZhbHVlKCdkZWZpbmVQcm9wZXJ0aWVzJywgYm90KTtcbmV4cG9ydCB2YXIgc2VhbCA9IG5ldyBWYWx1ZSgnc2VhbCcsIGJvdCk7XG5leHBvcnQgdmFyIGZyZWV6ZSA9IG5ldyBWYWx1ZSgnZnJlZXplJywgYm90KTtcbmV4cG9ydCB2YXIgcHJldmVudEV4dGVuc2lvbnMgPSBuZXcgVmFsdWUoJ3ByZXZlbnRFeHRlbnNpb25zJywgYm90KTtcbmV4cG9ydCB2YXIgaXNTZWFsZWQgPSBuZXcgVmFsdWUoJ2lzU2VhbGVkJywgYm90KTtcbmV4cG9ydCB2YXIgaXNGcm96ZW4gPSBuZXcgVmFsdWUoJ2lzRnJvemVuJywgYm90KTtcbmV4cG9ydCB2YXIgaXNFeHRlbnNpYmxlID0gbmV3IFZhbHVlKCdpc0V4dGVuc2libGUnLCBib3QpO1xuZXhwb3J0IHZhciBrZXlzID0gbmV3IFZhbHVlKCdrZXlzJywgYm90KTtcbmV4cG9ydCB2YXIgdG9TdHJpbmcgPSBuZXcgVmFsdWUoJ3RvU3RyaW5nJywgYm90KTtcbmV4cG9ydCB2YXIgdG9Mb2NhbGVTdHJpbmcgPSBuZXcgVmFsdWUoJ3RvTG9jYWxlU3RyaW5nJywgYm90KTtcbmV4cG9ydCB2YXIgdmFsdWVPZiA9IG5ldyBWYWx1ZSgndmFsdWVPZicsIGJvdCk7XG5leHBvcnQgdmFyIGhhc093blByb3BlcnR5ID0gbmV3IFZhbHVlKCdoYXNPd25Qcm9wZXJ0eScsIGJvdCk7XG5leHBvcnQgdmFyIGlzUHJvdG90eXBlT2YgPSBuZXcgVmFsdWUoJ2lzUHJvdG90eXBlT2YnLCBib3QpO1xuZXhwb3J0IHZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG5ldyBWYWx1ZSgncHJvcGVydHlJc0VudW1lcmFibGUnLCBib3QpO1xuZXhwb3J0IHZhciBhcHBseSA9IG5ldyBWYWx1ZSgnYXBwbHknLCBib3QpO1xuZXhwb3J0IHZhciBjYWxsID0gbmV3IFZhbHVlKCdjYWxsJywgYm90KTtcbmV4cG9ydCB2YXIgY2FsbGVyID0gbmV3IFZhbHVlKCdjYWxsZXInLCBib3QpO1xuZXhwb3J0IHZhciBiaW5kID0gbmV3IFZhbHVlKCdiaW5kJywgYm90KTtcbmV4cG9ydCB2YXIgTmFOID0gbmV3IFZhbHVlKCdOYU4nLCBib3QpO1xuZXhwb3J0IHZhciBJbmZpbml0eSA9IG5ldyBWYWx1ZSgnSW5maW5pdHknLCBib3QpO1xuZXhwb3J0IHZhciB1bmRlZmluZWQgPSBuZXcgVmFsdWUoJ3VuZGVmaW5lZCcsIGJvdCk7XG4vL0B0cy1pZ25vcmUgVFlQRVNcbmV4cG9ydCB2YXIgZXZhbCA9IG5ldyBWYWx1ZSgnZXZhbCcsIGJvdCk7XG5leHBvcnQgdmFyIHBhcnNlSW50ID0gbmV3IFZhbHVlKCdwYXJzZUludCcsIGJvdCk7XG5leHBvcnQgdmFyIHBhcnNlRmxvYXQgPSBuZXcgVmFsdWUoJ3BhcnNlRmxvYXQnLCBib3QpO1xuZXhwb3J0IHZhciBpc05hTiA9IG5ldyBWYWx1ZSgnaXNOYU4nLCBib3QpO1xuZXhwb3J0IHZhciBpc0Zpbml0ZSA9IG5ldyBWYWx1ZSgnaXNGaW5pdGUnLCBib3QpO1xuZXhwb3J0IHZhciBkZWNvZGVVUkkgPSBuZXcgVmFsdWUoJ2RlY29kZVVSSScsIGJvdCk7XG5leHBvcnQgdmFyIGRlY29kZVVSSUNvbXBvbmVudCA9IG5ldyBWYWx1ZSgnZGVjb2RlVVJJQ29tcG9uZW50JywgYm90KTtcbmV4cG9ydCB2YXIgZW5jb2RlVVJJID0gbmV3IFZhbHVlKCdlbmNvZGVVUkknLCBib3QpO1xuZXhwb3J0IHZhciBlbmNvZGVVUklDb21wb25lbnQgPSBuZXcgVmFsdWUoJ2VuY29kZVVSSUNvbXBvbmVudCcsIGJvdCk7XG5leHBvcnQgdmFyIE9iamVjdCA9IG5ldyBWYWx1ZSgnT2JqZWN0JywgYm90KTtcbmV4cG9ydCB2YXIgRnVuY3Rpb24gPSBuZXcgVmFsdWUoJ0Z1bmN0aW9uJywgYm90KTtcbmV4cG9ydCB2YXIgQXJyYXkgPSBuZXcgVmFsdWUoJ0FycmF5JywgYm90KTtcbmV4cG9ydCB2YXIgU3RyaW5nID0gbmV3IFZhbHVlKCdTdHJpbmcnLCBib3QpO1xuZXhwb3J0IHZhciBCb29sZWFuID0gbmV3IFZhbHVlKCdCb29sZWFuJywgYm90KTtcbmV4cG9ydCB2YXIgTnVtYmVyID0gbmV3IFZhbHVlKCdOdW1iZXInLCBib3QpO1xuZXhwb3J0IHZhciBEYXRlID0gbmV3IFZhbHVlKCdEYXRlJywgYm90KTtcbmV4cG9ydCB2YXIgUmVnRXhwID0gbmV3IFZhbHVlKCdSZWdFeHAnLCBib3QpO1xuZXhwb3J0IHZhciBFcnJvciA9IG5ldyBWYWx1ZSgnRXJyb3InLCBib3QpO1xuZXhwb3J0IHZhciBFdmFsRXJyb3IgPSBuZXcgVmFsdWUoJ0V2YWxFcnJvcicsIGJvdCk7XG5leHBvcnQgdmFyIFJhbmdlRXJyb3IgPSBuZXcgVmFsdWUoJ1JhbmdlRXJyb3InLCBib3QpO1xuZXhwb3J0IHZhciBSZWZlcmVuY2VFcnJvciA9IG5ldyBWYWx1ZSgnUmVmZXJlbmNlRXJyb3InLCBib3QpO1xuZXhwb3J0IHZhciBTeW50YXhFcnJvciA9IG5ldyBWYWx1ZSgnU3ludGF4RXJyb3InLCBib3QpO1xuZXhwb3J0IHZhciBUeXBlRXJyb3IgPSBuZXcgVmFsdWUoJ1R5cGVFcnJvcicsIGJvdCk7XG5leHBvcnQgdmFyIFVSSUVycm9yID0gbmV3IFZhbHVlKCdVUklFcnJvcicsIGJvdCk7XG5leHBvcnQgdmFyIE1hdGggPSBuZXcgVmFsdWUoJ01hdGgnLCBib3QpO1xuZXhwb3J0IHZhciBKU09OID0gbmV3IFZhbHVlKCdKU09OJywgYm90KTtcbmV4cG9ydCB2YXIgcGFyc2UgPSBuZXcgVmFsdWUoJ3BhcnNlJywgYm90KTtcbmV4cG9ydCB2YXIgc3RyaW5naWZ5ID0gbmV3IFZhbHVlKCdzdHJpbmdpZnknLCBib3QpO1xuZXhwb3J0IHZhciBuYW1lID0gbmV3IFZhbHVlKCduYW1lJywgYm90KTtcbmV4cG9ydCB2YXIgbWVzc2FnZSA9IG5ldyBWYWx1ZSgnbWVzc2FnZScsIGJvdCk7XG5leHBvcnQgdmFyIGlzQXJyYXkgPSBuZXcgVmFsdWUoJ2lzQXJyYXknLCBib3QpO1xuZXhwb3J0IHZhciBjb25jYXQgPSBuZXcgVmFsdWUoJ2NvbmNhdCcsIGJvdCk7XG5leHBvcnQgdmFyIGpvaW4gPSBuZXcgVmFsdWUoJ2pvaW4nLCBib3QpO1xuZXhwb3J0IHZhciBwb3AgPSBuZXcgVmFsdWUoJ3BvcCcsIGJvdCk7XG5leHBvcnQgdmFyIHB1c2ggPSBuZXcgVmFsdWUoJ3B1c2gnLCBib3QpO1xuZXhwb3J0IHZhciByZXZlcnNlID0gbmV3IFZhbHVlKCdyZXZlcnNlJywgYm90KTtcbmV4cG9ydCB2YXIgc2hpZnQgPSBuZXcgVmFsdWUoJ3NoaWZ0JywgYm90KTtcbmV4cG9ydCB2YXIgc2xpY2UgPSBuZXcgVmFsdWUoJ3NsaWNlJywgYm90KTtcbmV4cG9ydCB2YXIgc29ydCA9IG5ldyBWYWx1ZSgnc29ydCcsIGJvdCk7XG5leHBvcnQgdmFyIHNwbGljZSA9IG5ldyBWYWx1ZSgnc3BsaWNlJywgYm90KTtcbmV4cG9ydCB2YXIgdW5zaGlmdCA9IG5ldyBWYWx1ZSgndW5zaGlmdCcsIGJvdCk7XG5leHBvcnQgdmFyIGluZGV4T2YgPSBuZXcgVmFsdWUoJ2luZGV4T2YnLCBib3QpO1xuZXhwb3J0IHZhciBsYXN0SW5kZXhPZiA9IG5ldyBWYWx1ZSgnbGFzdEluZGV4T2YnLCBib3QpO1xuZXhwb3J0IHZhciBldmVyeSA9IG5ldyBWYWx1ZSgnZXZlcnknLCBib3QpO1xuZXhwb3J0IHZhciBzb21lID0gbmV3IFZhbHVlKCdzb21lJywgYm90KTtcbmV4cG9ydCB2YXIgZm9yRWFjaCA9IG5ldyBWYWx1ZSgnZm9yRWFjaCcsIGJvdCk7XG5leHBvcnQgdmFyIG1hcCA9IG5ldyBWYWx1ZSgnbWFwJywgYm90KTtcbmV4cG9ydCB2YXIgZmlsdGVyID0gbmV3IFZhbHVlKCdmaWx0ZXInLCBib3QpO1xuZXhwb3J0IHZhciByZWR1Y2UgPSBuZXcgVmFsdWUoJ3JlZHVjZScsIGJvdCk7XG5leHBvcnQgdmFyIHJlZHVjZVJpZ2h0ID0gbmV3IFZhbHVlKCdyZWR1Y2VSaWdodCcsIGJvdCk7XG5leHBvcnQgdmFyIGZyb21DaGFyQ29kZSA9IG5ldyBWYWx1ZSgnZnJvbUNoYXJDb2RlJywgYm90KTtcbmV4cG9ydCB2YXIgY2hhckF0ID0gbmV3IFZhbHVlKCdjaGFyQXQnLCBib3QpO1xuZXhwb3J0IHZhciBjaGFyQ29kZUF0ID0gbmV3IFZhbHVlKCdjaGFyQ29kZUF0JywgYm90KTtcbmV4cG9ydCB2YXIgbG9jYWxlQ29tcGFyZSA9IG5ldyBWYWx1ZSgnbG9jYWxlQ29tcGFyZScsIGJvdCk7XG5leHBvcnQgdmFyIG1hdGNoID0gbmV3IFZhbHVlKCdtYXRjaCcsIGJvdCk7XG5leHBvcnQgdmFyIHJlcGxhY2UgPSBuZXcgVmFsdWUoJ3JlcGxhY2UnLCBib3QpO1xuZXhwb3J0IHZhciBzZWFyY2ggPSBuZXcgVmFsdWUoJ3NlYXJjaCcsIGJvdCk7XG5leHBvcnQgdmFyIHNwbGl0ID0gbmV3IFZhbHVlKCdzcGxpdCcsIGJvdCk7XG5leHBvcnQgdmFyIHN1YnN0cmluZyA9IG5ldyBWYWx1ZSgnc3Vic3RyaW5nJywgYm90KTtcbmV4cG9ydCB2YXIgc3Vic3RyID0gbmV3IFZhbHVlKCdzdWJzdHInLCBib3QpO1xuZXhwb3J0IHZhciB0b0xvd2VyQ2FzZSA9IG5ldyBWYWx1ZSgndG9Mb3dlckNhc2UnLCBib3QpO1xuZXhwb3J0IHZhciB0b0xvY2FsZUxvd2VyQ2FzZSA9IG5ldyBWYWx1ZSgndG9Mb2NhbGVMb3dlckNhc2UnLCBib3QpO1xuZXhwb3J0IHZhciB0b1VwcGVyQ2FzZSA9IG5ldyBWYWx1ZSgndG9VcHBlckNhc2UnLCBib3QpO1xuZXhwb3J0IHZhciB0b0xvY2FsZVVwcGVyQ2FzZSA9IG5ldyBWYWx1ZSgndG9Mb2NhbGVVcHBlckNhc2UnLCBib3QpO1xuZXhwb3J0IHZhciB0cmltID0gbmV3IFZhbHVlKCd0cmltJywgYm90KTtcbmV4cG9ydCB2YXIgTUFYX1ZBTFVFID0gbmV3IFZhbHVlKCdNQVhfVkFMVUUnLCBib3QpO1xuZXhwb3J0IHZhciBNSU5fVkFMVUUgPSBuZXcgVmFsdWUoJ01JTl9WQUxVRScsIGJvdCk7XG5leHBvcnQgdmFyIE5FR0FUSVZFX0lORklOSVRZID0gbmV3IFZhbHVlKCdORUdBVElWRV9JTkZJTklUWScsIGJvdCk7XG5leHBvcnQgdmFyIFBPU0lUSVZFX0lORklOSVRZID0gbmV3IFZhbHVlKCdQT1NJVElWRV9JTkZJTklUWScsIGJvdCk7XG5leHBvcnQgdmFyIHRvRml4ZWQgPSBuZXcgVmFsdWUoJ3RvRml4ZWQnLCBib3QpO1xuZXhwb3J0IHZhciB0b0V4cG9uZW50aWFsID0gbmV3IFZhbHVlKCd0b0V4cG9uZW50aWFsJywgYm90KTtcbmV4cG9ydCB2YXIgdG9QcmVjaXNpb24gPSBuZXcgVmFsdWUoJ3RvUHJlY2lzaW9uJywgYm90KTtcbmV4cG9ydCB2YXIgRSA9IG5ldyBWYWx1ZSgnRScsIGJvdCk7XG5leHBvcnQgdmFyIExOMTAgPSBuZXcgVmFsdWUoJ0xOMTAnLCBib3QpO1xuZXhwb3J0IHZhciBMTjIgPSBuZXcgVmFsdWUoJ0xOMicsIGJvdCk7XG5leHBvcnQgdmFyIExPRzJFID0gbmV3IFZhbHVlKCdMT0cyRScsIGJvdCk7XG5leHBvcnQgdmFyIExPRzEwRSA9IG5ldyBWYWx1ZSgnTE9HMTBFJywgYm90KTtcbmV4cG9ydCB2YXIgUEkgPSBuZXcgVmFsdWUoJ1BJJywgYm90KTtcbmV4cG9ydCB2YXIgU1FSVDFfMiA9IG5ldyBWYWx1ZSgnU1FSVDFfMicsIGJvdCk7XG5leHBvcnQgdmFyIFNRUlQyID0gbmV3IFZhbHVlKCdTUVJUMicsIGJvdCk7XG5leHBvcnQgdmFyIGFicyA9IG5ldyBWYWx1ZSgnYWJzJywgYm90KTtcbmV4cG9ydCB2YXIgYWNvcyA9IG5ldyBWYWx1ZSgnYWNvcycsIGJvdCk7XG5leHBvcnQgdmFyIGFzaW4gPSBuZXcgVmFsdWUoJ2FzaW4nLCBib3QpO1xuZXhwb3J0IHZhciBhdGFuID0gbmV3IFZhbHVlKCdhdGFuJywgYm90KTtcbmV4cG9ydCB2YXIgYXRhbjIgPSBuZXcgVmFsdWUoJ2F0YW4yJywgYm90KTtcbmV4cG9ydCB2YXIgY2VpbCA9IG5ldyBWYWx1ZSgnY2VpbCcsIGJvdCk7XG5leHBvcnQgdmFyIGNvcyA9IG5ldyBWYWx1ZSgnY29zJywgYm90KTtcbmV4cG9ydCB2YXIgZXhwID0gbmV3IFZhbHVlKCdleHAnLCBib3QpO1xuZXhwb3J0IHZhciBmbG9vciA9IG5ldyBWYWx1ZSgnZmxvb3InLCBib3QpO1xuZXhwb3J0IHZhciBsb2cgPSBuZXcgVmFsdWUoJ2xvZycsIGJvdCk7XG5leHBvcnQgdmFyIG1heCA9IG5ldyBWYWx1ZSgnbWF4JywgYm90KTtcbmV4cG9ydCB2YXIgbWluID0gbmV3IFZhbHVlKCdtaW4nLCBib3QpO1xuZXhwb3J0IHZhciBwb3cgPSBuZXcgVmFsdWUoJ3BvdycsIGJvdCk7XG5leHBvcnQgdmFyIHJhbmRvbSA9IG5ldyBWYWx1ZSgncmFuZG9tJywgYm90KTtcbmV4cG9ydCB2YXIgcm91bmQgPSBuZXcgVmFsdWUoJ3JvdW5kJywgYm90KTtcbmV4cG9ydCB2YXIgc2luID0gbmV3IFZhbHVlKCdzaW4nLCBib3QpO1xuZXhwb3J0IHZhciBzcXJ0ID0gbmV3IFZhbHVlKCdzcXJ0JywgYm90KTtcbmV4cG9ydCB2YXIgdGFuID0gbmV3IFZhbHVlKCd0YW4nLCBib3QpO1xuZXhwb3J0IHZhciB0b0RhdGVTdHJpbmcgPSBuZXcgVmFsdWUoJ3RvRGF0ZVN0cmluZycsIGJvdCk7XG5leHBvcnQgdmFyIHRvVGltZVN0cmluZyA9IG5ldyBWYWx1ZSgndG9UaW1lU3RyaW5nJywgYm90KTtcbmV4cG9ydCB2YXIgdG9Mb2NhbGVEYXRlU3RyaW5nID0gbmV3IFZhbHVlKCd0b0xvY2FsZURhdGVTdHJpbmcnLCBib3QpO1xuZXhwb3J0IHZhciB0b0xvY2FsZVRpbWVTdHJpbmcgPSBuZXcgVmFsdWUoJ3RvTG9jYWxlVGltZVN0cmluZycsIGJvdCk7XG5leHBvcnQgdmFyIGdldFRpbWUgPSBuZXcgVmFsdWUoJ2dldFRpbWUnLCBib3QpO1xuZXhwb3J0IHZhciBnZXRGdWxsWWVhciA9IG5ldyBWYWx1ZSgnZ2V0RnVsbFllYXInLCBib3QpO1xuZXhwb3J0IHZhciBnZXRVVENGdWxsWWVhciA9IG5ldyBWYWx1ZSgnZ2V0VVRDRnVsbFllYXInLCBib3QpO1xuZXhwb3J0IHZhciBnZXRNb250aCA9IG5ldyBWYWx1ZSgnZ2V0TW9udGgnLCBib3QpO1xuZXhwb3J0IHZhciBnZXRVVENNb250aCA9IG5ldyBWYWx1ZSgnZ2V0VVRDTW9udGgnLCBib3QpO1xuZXhwb3J0IHZhciBnZXREYXRlID0gbmV3IFZhbHVlKCdnZXREYXRlJywgYm90KTtcbmV4cG9ydCB2YXIgZ2V0VVRDRGF0ZSA9IG5ldyBWYWx1ZSgnZ2V0VVRDRGF0ZScsIGJvdCk7XG5leHBvcnQgdmFyIGdldERheSA9IG5ldyBWYWx1ZSgnZ2V0RGF5JywgYm90KTtcbmV4cG9ydCB2YXIgZ2V0VVRDRGF5ID0gbmV3IFZhbHVlKCdnZXRVVENEYXknLCBib3QpO1xuZXhwb3J0IHZhciBnZXRIb3VycyA9IG5ldyBWYWx1ZSgnZ2V0SG91cnMnLCBib3QpO1xuZXhwb3J0IHZhciBnZXRVVENIb3VycyA9IG5ldyBWYWx1ZSgnZ2V0VVRDSG91cnMnLCBib3QpO1xuZXhwb3J0IHZhciBnZXRNaW51dGVzID0gbmV3IFZhbHVlKCdnZXRNaW51dGVzJywgYm90KTtcbmV4cG9ydCB2YXIgZ2V0VVRDTWludXRlcyA9IG5ldyBWYWx1ZSgnZ2V0VVRDTWludXRlcycsIGJvdCk7XG5leHBvcnQgdmFyIGdldFNlY29uZHMgPSBuZXcgVmFsdWUoJ2dldFNlY29uZHMnLCBib3QpO1xuZXhwb3J0IHZhciBnZXRVVENTZWNvbmRzID0gbmV3IFZhbHVlKCdnZXRVVENTZWNvbmRzJywgYm90KTtcbmV4cG9ydCB2YXIgZ2V0TWlsbGlzZWNvbmRzID0gbmV3IFZhbHVlKCdnZXRNaWxsaXNlY29uZHMnLCBib3QpO1xuZXhwb3J0IHZhciBnZXRVVENNaWxsaXNlY29uZHMgPSBuZXcgVmFsdWUoJ2dldFVUQ01pbGxpc2Vjb25kcycsIGJvdCk7XG5leHBvcnQgdmFyIGdldFRpbWV6b25lT2Zmc2V0ID0gbmV3IFZhbHVlKCdnZXRUaW1lem9uZU9mZnNldCcsIGJvdCk7XG5leHBvcnQgdmFyIHNldFRpbWUgPSBuZXcgVmFsdWUoJ3NldFRpbWUnLCBib3QpO1xuZXhwb3J0IHZhciBzZXRNaWxsaXNlY29uZHMgPSBuZXcgVmFsdWUoJ3NldE1pbGxpc2Vjb25kcycsIGJvdCk7XG5leHBvcnQgdmFyIHNldFVUQ01pbGxpc2Vjb25kcyA9IG5ldyBWYWx1ZSgnc2V0VVRDTWlsbGlzZWNvbmRzJywgYm90KTtcbmV4cG9ydCB2YXIgc2V0U2Vjb25kcyA9IG5ldyBWYWx1ZSgnc2V0U2Vjb25kcycsIGJvdCk7XG5leHBvcnQgdmFyIHNldFVUQ1NlY29uZHMgPSBuZXcgVmFsdWUoJ3NldFVUQ1NlY29uZHMnLCBib3QpO1xuZXhwb3J0IHZhciBzZXRNaW51dGVzID0gbmV3IFZhbHVlKCdzZXRNaW51dGVzJywgYm90KTtcbmV4cG9ydCB2YXIgc2V0VVRDTWludXRlcyA9IG5ldyBWYWx1ZSgnc2V0VVRDTWludXRlcycsIGJvdCk7XG5leHBvcnQgdmFyIHNldEhvdXJzID0gbmV3IFZhbHVlKCdzZXRIb3VycycsIGJvdCk7XG5leHBvcnQgdmFyIHNldFVUQ0hvdXJzID0gbmV3IFZhbHVlKCdzZXRVVENIb3VycycsIGJvdCk7XG5leHBvcnQgdmFyIHNldERhdGUgPSBuZXcgVmFsdWUoJ3NldERhdGUnLCBib3QpO1xuZXhwb3J0IHZhciBzZXRVVENEYXRlID0gbmV3IFZhbHVlKCdzZXRVVENEYXRlJywgYm90KTtcbmV4cG9ydCB2YXIgc2V0TW9udGggPSBuZXcgVmFsdWUoJ3NldE1vbnRoJywgYm90KTtcbmV4cG9ydCB2YXIgc2V0VVRDTW9udGggPSBuZXcgVmFsdWUoJ3NldFVUQ01vbnRoJywgYm90KTtcbmV4cG9ydCB2YXIgc2V0RnVsbFllYXIgPSBuZXcgVmFsdWUoJ3NldEZ1bGxZZWFyJywgYm90KTtcbmV4cG9ydCB2YXIgc2V0VVRDRnVsbFllYXIgPSBuZXcgVmFsdWUoJ3NldFVUQ0Z1bGxZZWFyJywgYm90KTtcbmV4cG9ydCB2YXIgdG9VVENTdHJpbmcgPSBuZXcgVmFsdWUoJ3RvVVRDU3RyaW5nJywgYm90KTtcbmV4cG9ydCB2YXIgdG9JU09TdHJpbmcgPSBuZXcgVmFsdWUoJ3RvSVNPU3RyaW5nJywgYm90KTtcbmV4cG9ydCB2YXIgdG9KU09OID0gbmV3IFZhbHVlKCd0b0pTT04nLCBib3QpO1xuZXhwb3J0IHZhciBVVEMgPSBuZXcgVmFsdWUoJ1VUQycsIGJvdCk7XG5leHBvcnQgdmFyIG5vdyA9IG5ldyBWYWx1ZSgnbm93JywgYm90KTtcbmV4cG9ydCB2YXIgZXhlYyA9IG5ldyBWYWx1ZSgnZXhlYycsIGJvdCk7XG5leHBvcnQgdmFyIHRlc3QgPSBuZXcgVmFsdWUoJ3Rlc3QnLCBib3QpO1xuZXhwb3J0IHZhciBzb3VyY2UgPSBuZXcgVmFsdWUoJ3NvdXJjZScsIGJvdCk7XG5leHBvcnQgdmFyIGdsb2JhbCA9IG5ldyBWYWx1ZSgnZ2xvYmFsJywgYm90KTtcbmV4cG9ydCB2YXIgaWdub3JlQ2FzZSA9IG5ldyBWYWx1ZSgnaWdub3JlQ2FzZScsIGJvdCk7XG5leHBvcnQgdmFyIG11bHRpbGluZSA9IG5ldyBWYWx1ZSgnbXVsdGlsaW5lJywgYm90KTtcbmV4cG9ydCB2YXIgbGFzdEluZGV4ID0gbmV3IFZhbHVlKCdsYXN0SW5kZXgnLCBib3QpO1xuZXhwb3J0IHZhciBnZXRZZWFyID0gbmV3IFZhbHVlKCdnZXRZZWFyJywgYm90KTtcbmV4cG9ydCB2YXIgc2V0WWVhciA9IG5ldyBWYWx1ZSgnc2V0WWVhcicsIGJvdCk7XG5leHBvcnQgdmFyIHRvR01UU3RyaW5nID0gbmV3IFZhbHVlKCd0b0dNVFN0cmluZycsIGJvdCk7XG5leHBvcnQgdmFyIGVzY2FwZSA9IG5ldyBWYWx1ZSgnZXNjYXBlJywgYm90KTtcbmV4cG9ydCB2YXIgdW5lc2NhcGUgPSBuZXcgVmFsdWUoJ3VuZXNjYXBlJywgYm90KTtcbmV4cG9ydCB2YXIgb2YgPSBuZXcgVmFsdWUoJ29mJywgYm90KTsiLCJpbXBvcnQgeyBWYWx1ZSB9IGZyb20gXCIuLi9WYWx1ZVwiO1xuaW1wb3J0ICogYXMgY29uc3RhbnRzIGZyb20gJy4uL0NvbnN0YW50cyc7XG5pbXBvcnQgeyBCdWlsdGluRnVuY3Rpb25PYmplY3QgfSBmcm9tIFwiLi4vT2JqZWN0cy9CdWlsdGluRnVuY3Rpb25PYmplY3RcIjtcbmltcG9ydCB7IGJvdCwgTGFiZWwsIGx1YiB9IGZyb20gJy4uL0xhYmVsJztcbmltcG9ydCB7IERlZmluZUZGRiwgRGVmaW5lVEZUIH0gZnJvbSAnLi4vRGVmaW5lJztcbmltcG9ydCB7IEVjbWFPYmplY3QgfSBmcm9tICcuLi9PYmplY3RzL0VjbWFPYmplY3QnO1xuaW1wb3J0IHsgQXJyYXlPYmplY3QgfSBmcm9tICcuLi9PYmplY3RzL0FycmF5T2JqZWN0JztcbmltcG9ydCB7IEhhc0luc3RhbmNlIH0gZnJvbSAnLi4vSGFzSW5zdGFuY2UnO1xuXG5pbXBvcnQgeyBNb25pdG9yQmFzZSB9IGZyb20gJy4uL01vbml0b3JCYXNlJztcbmltcG9ydCB7IElFY21hRnVuY3Rpb24sIFZhbHVlVHlwZXMsIElFY21hT2JqZWN0IH0gZnJvbSAnLi4vSW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBJc0NvbnN0cnVjdG9yIH0gZnJvbSBcIi4uL1V0aWxpdHkvSXNDb25zdHJ1Y3RvclwiO1xuaW1wb3J0IHsgVG9TdHJpbmcgfSBmcm9tIFwiLi4vQ29udmVyc2lvbi9Ub1N0cmluZ1wiO1xuZGVjbGFyZSB2YXIgbW9uaXRvcjogTW9uaXRvckJhc2U7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gMTUuNC4zIFxuXG5leHBvcnQgY2xhc3MgQXJyYXlDb25zdHJ1Y3RvciBleHRlbmRzIEVjbWFPYmplY3QgaW1wbGVtZW50cyBJRWNtYUZ1bmN0aW9uIHtcblxuICAgIGhvc3Q6IGFueTtcblxuICAgIGNvbnN0cnVjdG9yKGhvc3Q6IEFycmF5PGFueT4pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5DbGFzcyA9ICdGdW5jdGlvbic7XG4gICAgICAgIHRoaXMuRXh0ZW5zaWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgfVxuXG4gICAgU2V0dXAoKSB7XG4gICAgICAgIHRoaXMuUHJvdG90eXBlID0gbmV3IFZhbHVlKG1vbml0b3IuaW5zdGFuY2VzLkZ1bmN0aW9uUHJvdG90eXBlLCBib3QpO1xuXG4gICAgICAgIERlZmluZUZGRih0aGlzLCBjb25zdGFudHMubGVuZ3RoLCAxKTtcbiAgICAgICAgRGVmaW5lRkZGKHRoaXMsIGNvbnN0YW50cy5wcm90b3R5cGUsIG1vbml0b3IuaW5zdGFuY2VzLkFycmF5UHJvdG90eXBlKTtcblxuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLmlzQXJyYXksIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3QoaXNBcnJheSwgMSwgQXJyYXkuaXNBcnJheSkpO1xuXG4gICAgICAgIC8vIEVTNiwgMjIuMS4yLjNcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5vZiwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChvZiwgMSwgQXJyYXkub2YpKTtcbiAgICB9XG5cblxuICAgIEhhc0luc3RhbmNlKFY6IFZhbHVlPFZhbHVlVHlwZXM+KTogVmFsdWU8Ym9vbGVhbj4ge1xuICAgICAgICByZXR1cm4gSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBWKTtcbiAgICB9XG5cbiAgICBDYWxsKHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8QXJyYXlPYmplY3Q+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ29uc3RydWN0KGFyZ3MpO1xuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgQ29uc3RydWN0KGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxBcnJheU9iamVjdD4ge1xuXG4gICAgICAgIGxldCBhcnJheTogQXJyYXlPYmplY3Q7XG4gICAgICAgIGxldCBsZW4gPSBhcmdzLmxlbmd0aDtcblxuICAgICAgICBpZiAobGVuID09PSAwIHx8IGxlbiA+PSAyKSB7XG4gICAgICAgICAgICBhcnJheSA9IEFycmF5T2JqZWN0LmZyb21WYWx1ZUFycmF5KGFyZ3MsIGJvdCk7XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGxldCBhcmcgPSBhcmdzWzBdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmcudmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgYXJyYXkgPSBuZXcgQXJyYXlPYmplY3QoKTtcbiAgICAgICAgICAgICAgICBhcnJheS5wcm9wZXJ0aWVzLmxlbmd0aCA9IGFyZy52YWx1ZTtcbiAgICAgICAgICAgICAgICBhcnJheS5sYWJlbHMubGVuZ3RoID0ge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYXJnLmxhYmVsLFxuICAgICAgICAgICAgICAgICAgICBleGlzdGVuY2U6IGJvdFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFycmF5ID0gQXJyYXlPYmplY3QuZnJvbVZhbHVlQXJyYXkoYXJncywgYm90KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgVmFsdWUoYXJyYXksIGJvdCk7XG4gICAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGlzQXJyYXksIDE1LjQuMy4xXG5cbmZ1bmN0aW9uIGlzQXJyYXkodGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pIHtcbiAgICBsZXQgYXJnID0gYXJnc1swXSB8fCBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuXG4gICAgaWYgKGFyZy52YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgYXJnLnZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFZhbHVlKGZhbHNlLCBhcmcubGFiZWwpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgVmFsdWUoYXJnLnZhbHVlLkNsYXNzID09PSAnQXJyYXknLCBhcmcubGFiZWwpO1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBFUzY6IG9mLCAyMi4xLjIuM1xuXG5mdW5jdGlvbiBvZih0aGlzQXJnOiBWYWx1ZTxWYWx1ZVR5cGVzPiwgYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSkge1xuICAgIGxldCBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgICBsZXQgbGJsID0gbmV3IExhYmVsKCk7XG4gICAgZm9yIChsZXQgYXJnIG9mIGFyZ3MpIHtcbiAgICAgICAgbGJsID0gbHViKGxibCwgYXJnLmxhYmVsKTtcbiAgICB9XG5cbiAgICBsZXQgQTtcbiAgICBpZiAoSXNDb25zdHJ1Y3Rvcih0aGlzQXJnKSkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIEEgPSB0aGlzQXJnLnZhbHVlLkNvbnN0cnVjdChbbmV3IFZhbHVlKGxlbiwgbGJsKV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIEEgPSBuZXcgQXJyYXlPYmplY3QoKTtcbiAgICAgICAgQS5wcm9wZXJ0aWVzLmxlbmd0aCA9IGxlbjtcbiAgICAgICAgQS5sYWJlbHMubGVuZ3RoID0ge1xuICAgICAgICAgICAgdmFsdWU6IGxibCxcbiAgICAgICAgICAgIGV4aXN0ZW5jZTogYm90XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgbGV0IGsgPSAwO1xuICAgIHdoaWxlIChrIDwgbGVuKSB7XG4gICAgICAgIGxldCBrVmFsdWUgPSBhcmdzW2tdO1xuICAgICAgICBsZXQgUGsgPSBUb1N0cmluZyhuZXcgVmFsdWUoaywga1ZhbHVlLmxhYmVsKSk7XG5cbiAgICAgICAgLy8gNy4zLjQgaW4gRVM2IHdpbGwgbWFrZSB0aGlzLi5cbiAgICAgICAgbGV0IGRlc2MgPSB7XG4gICAgICAgICAgICB2YWx1ZToga1ZhbHVlLnZhbHVlLFxuICAgICAgICAgICAgbGFiZWw6IGtWYWx1ZS5sYWJlbCxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9O1xuXG4gICAgICAgIEEuRGVmaW5lT3duUHJvcGVydHkoUGssIGRlc2MpO1xuICAgICAgICBrKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIEE7XG59O1xuIiwiaW1wb3J0IHsgVmFsdWUgfSBmcm9tIFwiLi4vVmFsdWVcIjtcbmltcG9ydCAqIGFzIGNvbnN0YW50cyBmcm9tICcuLi9Db25zdGFudHMnO1xuaW1wb3J0IHsgSGFzSW5zdGFuY2UgfSBmcm9tICcuLi9IYXNJbnN0YW5jZSc7XG5pbXBvcnQgeyBEZWZpbmVGRkYgfSBmcm9tICcuLi9EZWZpbmUnO1xuaW1wb3J0IHsgRWNtYU9iamVjdCB9IGZyb20gJy4uL09iamVjdHMvRWNtYU9iamVjdCc7XG5pbXBvcnQgeyBib3QgfSBmcm9tICcuLi9MYWJlbCc7XG5pbXBvcnQgeyBCb29sZWFuT2JqZWN0IH0gZnJvbSAnLi4vT2JqZWN0cy9Cb29sZWFuT2JqZWN0JztcbmltcG9ydCB7IFRvQm9vbGVhbiB9IGZyb20gJy4uL0NvbnZlcnNpb24vVG9Cb29sZWFuJztcblxuaW1wb3J0IHsgTW9uaXRvckJhc2UgfSBmcm9tICcuLi9Nb25pdG9yQmFzZSc7XG5pbXBvcnQgeyBWYWx1ZVR5cGVzIH0gZnJvbSBcIi4uL0ludGVyZmFjZXNcIjtcbmRlY2xhcmUgdmFyIG1vbml0b3I6IE1vbml0b3JCYXNlO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIDE1LjYuMiBcblxuZXhwb3J0IGNsYXNzIEJvb2xlYW5Db25zdHJ1Y3RvciBleHRlbmRzIEVjbWFPYmplY3Qge1xuXG4gICAgaG9zdDogYW55O1xuXG4gICAgY29uc3RydWN0b3IoaG9zdDogQm9vbGVhbikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLkNsYXNzID0gJ0Z1bmN0aW9uJztcbiAgICAgICAgdGhpcy5FeHRlbnNpYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5ob3N0ID0gaG9zdDtcbiAgICB9XG5cbiAgICBTZXR1cCgpIHtcbiAgICAgICAgdGhpcy5Qcm90b3R5cGUgPSBuZXcgVmFsdWUobW9uaXRvci5pbnN0YW5jZXMuRnVuY3Rpb25Qcm90b3R5cGUsIGJvdCk7XG4gICAgICAgIERlZmluZUZGRih0aGlzLCBjb25zdGFudHMubGVuZ3RoLCAxKTsgLy9SRU1PVkUgP1xuICAgICAgICBEZWZpbmVGRkYodGhpcywgY29uc3RhbnRzLnByb3RvdHlwZSwgbW9uaXRvci5pbnN0YW5jZXMuQm9vbGVhblByb3RvdHlwZSk7XG4gICAgfVxuXG4gICAgSGFzSW5zdGFuY2UoVjogVmFsdWU8VmFsdWVUeXBlcz4pOiBWYWx1ZTxib29sZWFuPiB7XG4gICAgICAgIHJldHVybiBIYXNJbnN0YW5jZS5jYWxsKHRoaXMsIFYpO1xuICAgIH1cblxuICAgIC8vIDE1LjYuMS4xXG4gICAgQ2FsbCh0aGlzQXJnOiBWYWx1ZTxWYWx1ZVR5cGVzPiwgYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPGJvb2xlYW4+IHtcbiAgICAgICAgbGV0IGFyZzAgPSBhcmdzWzBdID8gYXJnc1swXSA6IG5ldyBWYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG5cbiAgICAgICAgcmV0dXJuIFRvQm9vbGVhbihhcmcwKTtcbiAgICB9XG5cbiAgICAvLyAxNS42LjIuMVxuICAgIENvbnN0cnVjdChhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8Qm9vbGVhbk9iamVjdD4ge1xuICAgICAgICBsZXQgYXJnMCA9IGFyZ3NbMF0gPyBhcmdzWzBdIDogbmV3IFZhbHVlKHVuZGVmaW5lZCwgYm90KTtcblxuICAgICAgICBsZXQgYiA9IFRvQm9vbGVhbihhcmcwKTtcbiAgICAgICAgbGV0IG9iaiA9IG5ldyBCb29sZWFuT2JqZWN0KGIudmFsdWUsIGIubGFiZWwpO1xuXG4gICAgICAgIHJldHVybiBuZXcgVmFsdWUob2JqLCBib3QpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBWYWx1ZSB9IGZyb20gXCIuLi9WYWx1ZVwiO1xuaW1wb3J0ICogYXMgY29uc3RhbnRzIGZyb20gJy4uL0NvbnN0YW50cyc7XG5pbXBvcnQgeyBCdWlsdGluRnVuY3Rpb25PYmplY3QgfSBmcm9tIFwiLi4vT2JqZWN0cy9CdWlsdGluRnVuY3Rpb25PYmplY3RcIjtcbmltcG9ydCB7IEhhc0luc3RhbmNlIH0gZnJvbSAnLi4vSGFzSW5zdGFuY2UnO1xuaW1wb3J0IHsgVG9QcmltaXRpdmUgfSBmcm9tICcuLi9Db252ZXJzaW9uL1RvUHJpbWl0aXZlJztcbmltcG9ydCB7IFRvTnVtYmVyIH0gZnJvbSAnLi4vQ29udmVyc2lvbi9Ub051bWJlcic7XG5pbXBvcnQgeyBUb1N0cmluZyB9IGZyb20gJy4uL0NvbnZlcnNpb24vVG9TdHJpbmcnO1xuaW1wb3J0IHsgRGVmaW5lRkZGLCBEZWZpbmVURlQgfSBmcm9tICcuLi9EZWZpbmUnO1xuaW1wb3J0IHsgRWNtYU9iamVjdCB9IGZyb20gJy4uL09iamVjdHMvRWNtYU9iamVjdCc7XG5pbXBvcnQgeyBib3QsIExhYmVsLCBsdWIgfSBmcm9tICcuLi9MYWJlbCc7XG5pbXBvcnQgeyBEYXRlT2JqZWN0IH0gZnJvbSAnLi4vT2JqZWN0cy9EYXRlT2JqZWN0JztcblxuaW1wb3J0IHsgTW9uaXRvckJhc2UgfSBmcm9tICcuLi9Nb25pdG9yQmFzZSc7XG5pbXBvcnQgeyBWYWx1ZVR5cGVzIH0gZnJvbSBcIi4uL0ludGVyZmFjZXNcIjtcbmRlY2xhcmUgdmFyIG1vbml0b3I6IE1vbml0b3JCYXNlO1xuXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVGhlIERhdGUgQ29uc3RydWN0b3IsIDE1LjkuM1xuXG5leHBvcnQgY2xhc3MgRGF0ZUNvbnN0cnVjdG9yIGV4dGVuZHMgRWNtYU9iamVjdCB7XG5cbiAgICBob3N0OiBhbnk7XG5cbiAgICBjb25zdHJ1Y3Rvcihob3N0OiBEYXRlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuQ2xhc3MgPSAnRnVuY3Rpb24nO1xuICAgICAgICB0aGlzLkV4dGVuc2libGUgPSB0cnVlO1xuICAgICAgICB0aGlzLmhvc3QgPSBob3N0O1xuICAgIH1cblxuICAgIFNldHVwKCkge1xuICAgICAgICB0aGlzLlByb3RvdHlwZSA9IG5ldyBWYWx1ZShtb25pdG9yLmluc3RhbmNlcy5GdW5jdGlvblByb3RvdHlwZSwgYm90KTtcblxuICAgICAgICBEZWZpbmVGRkYodGhpcywgY29uc3RhbnRzLmxlbmd0aCwgNyk7XG4gICAgICAgIERlZmluZUZGRih0aGlzLCBjb25zdGFudHMucHJvdG90eXBlLCBtb25pdG9yLmluc3RhbmNlcy5EYXRlUHJvdG90eXBlKTtcblxuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLnBhcnNlLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHBhcnNlLCAwLCBEYXRlLnBhcnNlKSk7XG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuVVRDLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KFVUQywgMCwgRGF0ZS5VVEMpKTtcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5ub3csIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3Qobm93LCAwLCBEYXRlLm5vdykpO1xuICAgIH1cblxuICAgIEhhc0luc3RhbmNlKFY6IFZhbHVlPFZhbHVlVHlwZXM+KTogVmFsdWU8Ym9vbGVhbj4ge1xuICAgICAgICByZXR1cm4gSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBWKTtcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyAxNS45LjEuMVxuICAgIENhbGwodGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxzdHJpbmc+IHtcbiAgICAgICAgbGV0IHN0ciA9IHRoaXMuaG9zdCgpO1xuICAgICAgICByZXR1cm4gbmV3IFZhbHVlKHN0ciwgYm90KTtcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIDE1LjkuMy4xXG4gICAgQ29uc3RydWN0KGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxEYXRlT2JqZWN0PiB7XG4gICAgICAgIGxldCBfYXJnczogbnVtYmVyW10gPSBbXTtcbiAgICAgICAgbGV0IGxhYmVsID0gbmV3IExhYmVsKCk7XG4gICAgICAgIGxldCBvYmo6IERhdGVPYmplY3Q7XG5cbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuXG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgb2JqID0gbmV3IERhdGVPYmplY3QobmV3IHRoaXMuaG9zdCgpLCBuZXcgTGFiZWwoJ0RhdGUnKSk7XG5cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGxldCB2ID0gVG9QcmltaXRpdmUoYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2LnZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB2ID0gVG9OdW1iZXIodik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgb2JqID0gbmV3IERhdGVPYmplY3QobmV3IHRoaXMuaG9zdCh2LnZhbHVlKSwgdi5sYWJlbCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgbGV0IGxlbiA9IGFyZ3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWwgPSBUb051bWJlcihhcmdzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgX2FyZ3NbaV0gPSB2YWwudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGx1Yih2YWwubGFiZWwpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChsZW4gPT0gMikge1xuICAgICAgICAgICAgICAgICAgICBfYXJnc1syXSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgX2FyZ3NbaV0gPSAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCBkYXRlID0gbmV3IHRoaXMuaG9zdChcbiAgICAgICAgICAgICAgICAgICAgX2FyZ3NbMF0sIF9hcmdzWzFdLCBfYXJnc1syXSwgX2FyZ3NbM10sIF9hcmdzWzRdLCBfYXJnc1s1XSwgX2FyZ3NbNl1cbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgb2JqID0gbmV3IERhdGVPYmplY3QoZGF0ZSwgbGFiZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZShvYmosIGJvdCk7XG4gICAgfTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBwYXJzZSwgMTUuOS40LjJcbmZ1bmN0aW9uIHBhcnNlKHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8bnVtYmVyPiB7XG4gICAgbGV0IGFyZyA9IGFyZ3NbMF0gfHwgbmV3IFZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgICBsZXQgc3RyaW5nID0gVG9TdHJpbmcoYXJnKTtcblxuICAgIGxldCBudW1iZXIgPSBtb25pdG9yLmluc3RhbmNlcy5EYXRlQ29uc3RydWN0b3IuaG9zdC5wYXJzZShzdHJpbmcudmFsdWUpO1xuICAgIHJldHVybiBuZXcgVmFsdWUobnVtYmVyLCBzdHJpbmcubGFiZWwpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFVUQywgMTUuOS40LjNcbmZ1bmN0aW9uIFVUQyh0aGlzQXJnOiBWYWx1ZTxWYWx1ZVR5cGVzPiwgYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPG51bWJlcj4ge1xuICAgIGxldCBfYXJnczogbnVtYmVyW10gPSBbXTtcbiAgICBsZXQgbGFiZWwgPSBuZXcgTGFiZWwoKTtcblxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBhcmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGxldCB2YWwgPSBUb051bWJlcihhcmdzW2ldKTtcbiAgICAgICAgX2FyZ3NbaV0gPSB2YWwudmFsdWU7XG4gICAgICAgIGx1Yih2YWwubGFiZWwpO1xuICAgIH1cblxuICAgIGxldCBudW1iZXIgPSBtb25pdG9yLmluc3RhbmNlcy5EYXRlQ29uc3RydWN0b3IuaG9zdC5VVEMuYXBwbHkobnVsbCwgX2FyZ3MpO1xuICAgIHJldHVybiBuZXcgVmFsdWUobnVtYmVyLCBsYWJlbCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gbm93LCAxNS45LjQuNFxuZnVuY3Rpb24gbm93KHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8bnVtYmVyPntcbiAgICBsZXQgbnVtYmVyID0gbW9uaXRvci5pbnN0YW5jZXMuRGF0ZUNvbnN0cnVjdG9yLmhvc3Qubm93KCk7XG4gICAgcmV0dXJuIG5ldyBWYWx1ZShudW1iZXIsIGJvdC8qdG9wKi8pO1xufVxuIiwiaW1wb3J0IHsgVmFsdWUgfSBmcm9tIFwiLi4vVmFsdWVcIjtcbmltcG9ydCAqIGFzIGNvbnN0YW50cyBmcm9tICcuLi9Db25zdGFudHMnO1xuaW1wb3J0IHsgSGFzSW5zdGFuY2UgfSBmcm9tICcuLi9IYXNJbnN0YW5jZSc7XG5pbXBvcnQgeyBNb25pdG9yQmFzZSB9IGZyb20gJy4uL01vbml0b3JCYXNlJztcbmltcG9ydCB7IEVjbWFPYmplY3QgfSBmcm9tICcuLi9PYmplY3RzL0VjbWFPYmplY3QnO1xuaW1wb3J0IHsgRGVmaW5lRkZGIH0gZnJvbSAnLi4vRGVmaW5lJztcbmltcG9ydCB7IGJvdCB9IGZyb20gJy4uL0xhYmVsJztcbmltcG9ydCB7IEVycm9yT2JqZWN0IH0gZnJvbSAnLi4vT2JqZWN0cy9FcnJvck9iamVjdCc7XG5pbXBvcnQgeyBFcnJvclByb3RvdHlwZSB9IGZyb20gJy4uL1Byb3RvdHlwZXMvRXJyb3JQcm90b3R5cGUnO1xuaW1wb3J0IHsgVmFsdWVUeXBlcyB9IGZyb20gXCIuLi9JbnRlcmZhY2VzXCI7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5kZWNsYXJlIHZhciBtb25pdG9yOiBNb25pdG9yQmFzZTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAxNS4xMSAtIFRoZSBFcnJvciBDb25zdHJ1Y3RvclxuXG5leHBvcnQgY2xhc3MgRXJyb3JDb25zdHJ1Y3RvciBleHRlbmRzIEVjbWFPYmplY3Qge1xuXG4gICAgaG9zdDogYW55O1xuICAgIG5hbWU6IFN0cmluZztcblxuICAgIGNvbnN0cnVjdG9yKGhvc3QgOiBFcnJvcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLkNsYXNzID0gJ0Z1bmN0aW9uJztcbiAgICAgICAgdGhpcy5ob3N0ID0gaG9zdDtcbiAgICAgICAgdGhpcy5FeHRlbnNpYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0Vycm9yJztcbiAgICB9XG5cbiAgICBTZXR1cCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5TZXR1cEJhc2UobW9uaXRvci5pbnN0YW5jZXMuRXJyb3JQcm90b3R5cGUpO1xuICAgIH1cblxuICAgIFNldHVwQmFzZShwcm90b3R5cGUgOiBFcnJvclByb3RvdHlwZSk6IHZvaWQge1xuICAgICAgICB0aGlzLlByb3RvdHlwZSA9IG5ldyBWYWx1ZShtb25pdG9yLmluc3RhbmNlcy5GdW5jdGlvblByb3RvdHlwZSwgYm90KTtcblxuICAgICAgICBEZWZpbmVGRkYodGhpcywgY29uc3RhbnRzLmxlbmd0aCwgMSk7XG4gICAgICAgIERlZmluZUZGRih0aGlzLCBjb25zdGFudHMucHJvdG90eXBlLCBwcm90b3R5cGUpO1xuICAgIH1cblxuICAgIEhhc0luc3RhbmNlKFY6IFZhbHVlPFZhbHVlVHlwZXM+KTogVmFsdWU8Ym9vbGVhbj4ge1xuICAgICAgICByZXR1cm4gSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBWKTtcbiAgICB9XG5cbiAgICAvLyAxNS4xMS4yXG4gICAgQ2FsbCh0aGlzQXJnOiBWYWx1ZTxWYWx1ZVR5cGVzPiwgYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPEVycm9yT2JqZWN0PiB7XG4gICAgICAgIHJldHVybiB0aGlzLkNvbnN0cnVjdChhcmdzKTtcbiAgICB9XG5cbiAgICAvLyAxNS4xMS4yLjFcbiAgICBDb25zdHJ1Y3QoYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPEVycm9yT2JqZWN0PiB7XG4gICAgICAgIHZhciBhcmcwID0gYXJnc1swXSA/IGFyZ3NbMF0gOiBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgICAgICB2YXIgbyA9IG5ldyBFcnJvck9iamVjdChhcmcwKTtcbiAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZShvLCBib3QpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IEVycm9yQ29uc3RydWN0b3IgfSBmcm9tIFwiLi9FcnJvckNvbnN0cnVjdG9yXCI7XG5pbXBvcnQgeyBib3QgfSBmcm9tIFwiLi4vTGFiZWxcIjtcbmltcG9ydCB7IFZhbHVlIH0gZnJvbSBcIi4uL1ZhbHVlXCI7XG5pbXBvcnQgeyBFdmFsRXJyb3JPYmplY3QgfSBmcm9tIFwiLi4vT2JqZWN0cy9FdmFsRXJyb3JPYmplY3RcIjtcbmltcG9ydCB7IE1vbml0b3JCYXNlIH0gZnJvbSBcIi4uL01vbml0b3JCYXNlXCI7XG5pbXBvcnQgeyBWYWx1ZVR5cGVzIH0gZnJvbSBcIi4uL0ludGVyZmFjZXNcIjtcblxuZGVjbGFyZSB2YXIgbW9uaXRvcjogTW9uaXRvckJhc2U7XG5cbmV4cG9ydCBjbGFzcyBFdmFsRXJyb3JDb25zdHJ1Y3RvciBleHRlbmRzIEVycm9yQ29uc3RydWN0b3Ige1xuXG4gICAgY29uc3RydWN0b3IoaG9zdCA6IEV2YWxFcnJvcikge1xuICAgICAgICBzdXBlcihob3N0KTtcbiAgICB9XG5cbiAgICBTZXR1cCgpIDogdm9pZCB7XG4gICAgICAgIHRoaXMuU2V0dXBCYXNlKG1vbml0b3IuaW5zdGFuY2VzLkV2YWxFcnJvclByb3RvdHlwZSk7XG4gICAgfVxuXG4gICAgQ29uc3RydWN0KGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxFdmFsRXJyb3JPYmplY3Q+e1xuICAgICAgICB2YXIgbWVzc2FnZSA9IGFyZ3NbMF0gfHwgbmV3IFZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgICAgICAgdmFyIG8gPSBuZXcgRXZhbEVycm9yT2JqZWN0KG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gbmV3IFZhbHVlKG8sIGJvdCk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgbHViLCBib3QgfSBmcm9tICcuLi9MYWJlbCc7XG5pbXBvcnQgeyBWYWx1ZSB9IGZyb20gXCIuLi9WYWx1ZVwiO1xuaW1wb3J0IHsgRGVmaW5lRkZGIH0gZnJvbSAnLi4vRGVmaW5lJztcbmltcG9ydCB7IEVjbWFPYmplY3QgfSBmcm9tICcuLi9PYmplY3RzL0VjbWFPYmplY3QnO1xuaW1wb3J0ICogYXMgY29uc3RhbnRzIGZyb20gJy4uL0NvbnN0YW50cyc7XG5pbXBvcnQgeyBNb25pdG9yQmFzZSB9IGZyb20gJy4uL01vbml0b3JCYXNlJztcblxuaW1wb3J0IHsgRnVuY3Rpb25PYmplY3QgfSBmcm9tICcuLi9PYmplY3RzL0Z1bmN0aW9uT2JqZWN0JztcbmltcG9ydCB7IEhhc0luc3RhbmNlIH0gZnJvbSAnLi4vSGFzSW5zdGFuY2UnO1xuXG5pbXBvcnQgKiBhcyBlc3ByaW1hIGZyb20gJ2VzcHJpbWEnO1xuaW1wb3J0IHsgVG9TdHJpbmcgfSBmcm9tICcuLi9Db252ZXJzaW9uL1RvU3RyaW5nJztcbmltcG9ydCB7IFZhbHVlVHlwZXMgfSBmcm9tICcuLi9JbnRlcmZhY2VzJztcbmltcG9ydCB7IGV4aXN0cyB9IGZyb20gJ2ZzJztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmRlY2xhcmUgdmFyIG1vbml0b3I6IE1vbml0b3JCYXNlO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEZ1bmN0aW9uIENvbnN0cnVjdG9yLCAxNS4zLjIgKDE1LjMuMSwgMTUuMy4xLjEpXG5cbmV4cG9ydCBjbGFzcyBGdW5jdGlvbkNvbnN0cnVjdG9yIGV4dGVuZHMgRWNtYU9iamVjdCB7XG5cbiAgICBob3N0IDogYW55O1xuXG4gICAgY29uc3RydWN0b3IoaG9zdCA6IEZ1bmN0aW9uKSB7XG4gICAgICBzdXBlcigpO1xuICBcbiAgICAgIC8vIFByb3BlcnRpZXMsIDE1LjMuMy5cbiAgICAgIHRoaXMuQ2xhc3MgPSAnRnVuY3Rpb24nO1xuICAgICAgdGhpcy5ob3N0ID0gaG9zdDtcbiAgICAgIHRoaXMuRXh0ZW5zaWJsZSA9IHRydWU7XG4gIFxuICAgIH1cbiAgXG4gICAgU2V0dXAoKSA6IHZvaWQge1xuICAgICAgLy8gMTUuMy4zLjEgXG4gICAgICBEZWZpbmVGRkYodGhpcywgY29uc3RhbnRzLnByb3RvdHlwZSwgbW9uaXRvci5pbnN0YW5jZXMuRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgICAgdGhpcy5Qcm90b3R5cGUgPSBuZXcgVmFsdWUobW9uaXRvci5pbnN0YW5jZXMuRnVuY3Rpb25Qcm90b3R5cGUsIGJvdCk7XG4gIFxuICAgICAgLy8gMTUuMy4zLjIgXG4gICAgICBEZWZpbmVGRkYodGhpcywgY29uc3RhbnRzLmxlbmd0aCwgMSk7XG4gICAgfVxuICBcbiAgXG4gICAgLy8gLS0tXG4gIFxuICAgIEhhc0luc3RhbmNlKFY6IFZhbHVlPFZhbHVlVHlwZXM+KTogVmFsdWU8Ym9vbGVhbj4ge1xuICAgICAgcmV0dXJuIEhhc0luc3RhbmNlLmNhbGwodGhpcywgVik7XG4gICAgfVxuICBcbiAgICAvLyAxNS4zLjFcbiAgICBDYWxsKHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8RnVuY3Rpb25PYmplY3Q+IHtcbiAgICAgIHJldHVybiB0aGlzLkNvbnN0cnVjdChhcmdzKTtcbiAgICB9XG4gIFxuICAgIC8vIDE1LjMuMlxuICAgIENvbnN0cnVjdChhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8RnVuY3Rpb25PYmplY3Q+IHtcbiAgICAgIHZhciBhcmdDb3VudCA9IGFyZ3MubGVuZ3RoO1xuICAgICAgdmFyIFAgPSAnJztcbiAgICAgIHZhciBib2R5IDogIFZhbHVlPFZhbHVlVHlwZXM+O1xuICAgICAgdmFyIGxhYmVsID0gYm90O1xuICBcbiAgICAgIGlmIChhcmdDb3VudCA9PT0gMCkge1xuICAgICAgICBib2R5ID0gbmV3IFZhbHVlKCcnLCBib3QpO1xuICAgICAgfSBlbHNlIGlmIChhcmdDb3VudCA9PT0gMSkge1xuICAgICAgICBib2R5ID0gYXJnc1swXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBmaXJzdEFyZyA9IFRvU3RyaW5nKGFyZ3NbMF0pO1xuICAgICAgICBsYWJlbCA9IGx1YihsYWJlbCwgZmlyc3RBcmcubGFiZWwpO1xuICAgICAgICBQID0gZmlyc3RBcmcudmFsdWU7XG4gIFxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ0NvdW50IC0gMTsgaSsrKSB7XG4gICAgICAgICAgdmFyIG5leHRBcmcgPSBUb1N0cmluZyhhcmdzW2ldKTtcbiAgICAgICAgICBsYWJlbCA9IGx1YihsYWJlbCwgZmlyc3RBcmcubGFiZWwpO1xuICAgICAgICAgIFAgKz0gJywgJyArIG5leHRBcmcudmFsdWU7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIGJvZHkgPSBhcmdzW2FyZ0NvdW50IC0gMV07XG4gICAgICB9XG4gIFxuICAgICAgbGV0IHN0cmJvZHkgPSBUb1N0cmluZyhib2R5KTtcbiAgICAgIGxhYmVsID0gbHViKGxhYmVsLCBzdHJib2R5LmxhYmVsKTtcblxuICAgICAgLy8gdHJhbnNmb3JtIG1heSB1c2UgYSBwYXJzZXIsIHdoaWNoIG1lYW5zIHdlIGNhbm5vdCB0cmFuc2Zvcm0gdGhlIGJvZHlcbiAgICAgIC8vIGluIGlzb2xhdGlvbiAoZS5nLiwgaXQgbWF5IGNvbnRhaW4gcmV0dXJuKSwgYW5kIHdlIGNhbm5vdCBhc3N1bWUgdGhhdCB0aGVcbiAgICAgIC8vIHRyYW5zZm9ybWF0aW9uIHJldHVybnMgYSBmdW5jdGlvblxuICAgICAgdmFyIHRyYW5zZm9ybWVkID0gbW9uaXRvci50cmFuc2Zvcm0oYGZ1bmN0aW9uIF9fanNmbG93X3RyYW5zZm9ybWVkKCkge1xuICAgICAgICBhcmd1bWVudHMuY2FsbGVlID0gX19qc2Zsb3dfY2FsbGVlO1xuICAgICAgICBhcmd1bWVudHMuY2FsbGVyID0gX19qc2Zsb3dfY2FsbGVyO1xuICAgICAgICAke3N0cmJvZHkudmFsdWV9XG4gICAgICB9YCk7XG5cbiAgICAgIFAgPSBgKGZ1bmN0aW9uICggJHtQfSApIHtcbiAgICAgICAgbGV0IF9fanNmbG93X2NhbGxlZSA9IGFyZ3VtZW50cy5jYWxsZWU7XG4gICAgICAgIGxldCBfX2pzZmxvd19jYWxsZXIgPSBhcmd1bWVudHMuY2FsbGVyO1xuICAgICAgICAke3RyYW5zZm9ybWVkfTtcbiAgICAgICAgcmV0dXJuIF9fanNmbG93X3RyYW5zZm9ybWVkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9KWA7XG5cbiAgICAgIHZhciBwcm9nO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcHJvZyA9IGVzcHJpbWEucGFyc2UoUCwgeyBsb2M6IHRydWUgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIG1vbml0b3IuVGhyb3coXG4gICAgICAgICAgXCJTeW50YXhFcnJvclwiLFxuICAgICAgICAgIGUubWVzc2FnZSxcbiAgICAgICAgICBsYWJlbFxuICAgICAgICApO1xuICAgICAgfVxuICBcbiAgICAgIC8vIHBhcnNpbmcgcmV0dXJucyBhIHByb2dyYW0gLS0tIHdlIGFyZSBpbnRlcmVzdGVkIGluIGZ1bmN0aW9uIGRlY2xhcmF0aW9uXG4gICAgICB2YXIgZnVuYyA9IHByb2cuYm9keVswXS5leHByZXNzaW9uO1xuICBcbiAgICAgIHZhciBGID0gbmV3IEZ1bmN0aW9uT2JqZWN0KFxuICAgICAgICBmdW5jLnBhcmFtcyxcbiAgICAgICAgZnVuYy5ib2R5LFxuICAgICAgICBuZXcgVmFsdWUobW9uaXRvci5HbG9iYWxFbnZpcm9ubWVudCwgYm90KVxuICAgICAgKTtcbiAgXG4gICAgICAvLyBGb3IgcHJldHR5IHByaW50aW5nXG4gICAgICBGLlNvdXJjZSA9IGZ1bmM7XG4gIFxuICAgICAgcmV0dXJuIG5ldyBWYWx1ZShGLCBsYWJlbCk7XG4gICAgfVxuICB9IiwiXG5pbXBvcnQgeyBib3QgfSBmcm9tICcuLi9MYWJlbCc7XG5pbXBvcnQgeyBWYWx1ZSB9IGZyb20gXCIuLi9WYWx1ZVwiO1xuaW1wb3J0IHsgRGVmaW5lRkZGIH0gZnJvbSAnLi4vRGVmaW5lJztcbmltcG9ydCB7IEVjbWFPYmplY3QgfSBmcm9tICcuLi9PYmplY3RzL0VjbWFPYmplY3QnO1xuaW1wb3J0ICogYXMgY29uc3RhbnRzIGZyb20gJy4uL0NvbnN0YW50cyc7XG5pbXBvcnQgeyBIYXNJbnN0YW5jZSB9IGZyb20gJy4uL0hhc0luc3RhbmNlJztcbmltcG9ydCB7IE51bWJlck9iamVjdCB9IGZyb20gJy4uL09iamVjdHMvTnVtYmVyT2JqZWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmltcG9ydCB7IE1vbml0b3JCYXNlIH0gZnJvbSAnLi4vTW9uaXRvckJhc2UnO1xuXG5pbXBvcnQgeyBUb051bWJlciB9IGZyb20gJy4uL0NvbnZlcnNpb24vVG9OdW1iZXInO1xuaW1wb3J0IHsgVmFsdWVUeXBlcyB9IGZyb20gJy4uL0ludGVyZmFjZXMnO1xuZGVjbGFyZSB2YXIgbW9uaXRvcjogTW9uaXRvckJhc2U7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVGhlIE51bWJlciBDb25zdHJ1Y3RvciwgMTUuNy4yXG5cbmV4cG9ydCBjbGFzcyBOdW1iZXJDb25zdHJ1Y3RvciBleHRlbmRzIEVjbWFPYmplY3Qge1xuXG4gICAgaG9zdDogYW55O1xuXG4gICAgY29uc3RydWN0b3IoaG9zdDogTnVtYmVyKSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5DbGFzcyA9ICdGdW5jdGlvbic7XG4gICAgICAgIC8vIG5vdCBtYW5kYXRlZCBieSBzdGFuZGFyZFxuICAgICAgICB0aGlzLkV4dGVuc2libGUgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3RcbiAgICB9XG5cbiAgICBTZXR1cCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5Qcm90b3R5cGUgPSBuZXcgVmFsdWUobW9uaXRvci5pbnN0YW5jZXMuRnVuY3Rpb25Qcm90b3R5cGUsIGJvdCk7XG5cbiAgICAgICAgRGVmaW5lRkZGKHRoaXMsIGNvbnN0YW50cy5wcm90b3R5cGUsIG1vbml0b3IuaW5zdGFuY2VzLk51bWJlclByb3RvdHlwZSk7XG4gICAgICAgIERlZmluZUZGRih0aGlzLCBjb25zdGFudHMubGVuZ3RoLCAxKTtcbiAgICAgICAgRGVmaW5lRkZGKHRoaXMsIGNvbnN0YW50cy5NQVhfVkFMVUUsIHRoaXMuaG9zdC5NQVhfVkFMVUUpO1xuICAgICAgICBEZWZpbmVGRkYodGhpcywgY29uc3RhbnRzLk1JTl9WQUxVRSwgdGhpcy5ob3N0Lk1JTl9WQUxVRSk7XG4gICAgICAgIERlZmluZUZGRih0aGlzLCBjb25zdGFudHMuTmFOLCB0aGlzLmhvc3QuTmFOKTtcbiAgICAgICAgRGVmaW5lRkZGKHRoaXMsIGNvbnN0YW50cy5ORUdBVElWRV9JTkZJTklUWSwgdGhpcy5ob3N0Lk5FR0FUSVZFX0lORklOSVRZKTtcbiAgICAgICAgRGVmaW5lRkZGKHRoaXMsIGNvbnN0YW50cy5QT1NJVElWRV9JTkZJTklUWSwgdGhpcy5ob3N0LlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICB9XG5cbiAgICBIYXNJbnN0YW5jZShWOiBWYWx1ZTxWYWx1ZVR5cGVzPik6IFZhbHVlPGJvb2xlYW4+IHtcbiAgICAgICAgcmV0dXJuIEhhc0luc3RhbmNlLmNhbGwodGhpcywgVik7XG4gICAgfVxuXG4gICAgLy8gMTUuNy4xLjFcbiAgICBDYWxsKHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8bnVtYmVyPiB7XG4gICAgICAgIGlmICghYXJnc1swXSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZSgwLCBib3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFRvTnVtYmVyKGFyZ3NbMF0pO1xuICAgIH1cblxuICAgIC8vIDE1LjcuMi4xXG4gICAgQ29uc3RydWN0KGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxOdW1iZXJPYmplY3Q+IHtcbiAgICAgICAgbGV0IGFyZzAgPSBhcmdzWzBdID8gVG9OdW1iZXIoYXJnc1swXSkgOiBuZXcgVmFsdWUoMCwgYm90KTtcbiAgICAgICAgbGV0IHJlcyA9IG5ldyBOdW1iZXJPYmplY3QoYXJnMC52YWx1ZSwgYXJnMC5sYWJlbCk7XG4gICAgICAgIHJldHVybiBuZXcgVmFsdWUocmVzLCBib3QpO1xuICAgIH1cbn0iLCJcbmltcG9ydCB7IExhYmVsLCBsdWIsIGxlLCBib3QgfSBmcm9tICcuLi9MYWJlbCc7XG5pbXBvcnQgeyBWYWx1ZSB9IGZyb20gXCIuLi9WYWx1ZVwiO1xuaW1wb3J0IHsgRGVmaW5lVEZULCBEZWZpbmVGRkYgfSBmcm9tICcuLi9EZWZpbmUnO1xuaW1wb3J0IHsgRWNtYU9iamVjdCB9IGZyb20gJy4uL09iamVjdHMvRWNtYU9iamVjdCc7XG5cbmltcG9ydCAqIGFzIGNvbnN0YW50cyBmcm9tICcuLi9Db25zdGFudHMnO1xuaW1wb3J0IHsgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0IH0gZnJvbSBcIi4uL09iamVjdHMvQnVpbHRpbkZ1bmN0aW9uT2JqZWN0XCI7XG5pbXBvcnQgeyBNb25pdG9yQmFzZSB9IGZyb20gJy4uL01vbml0b3JCYXNlJztcblxuaW1wb3J0IHsgT2JqZWN0T2JqZWN0IH0gZnJvbSAnLi4vT2JqZWN0cy9PYmplY3RPYmplY3QnO1xuaW1wb3J0IHsgQXJyYXlPYmplY3QgfSBmcm9tICcuLi9PYmplY3RzL0FycmF5T2JqZWN0JztcbmltcG9ydCB7IFRvQm9vbGVhbiB9IGZyb20gJy4uL0NvbnZlcnNpb24vVG9Cb29sZWFuJztcbmltcG9ydCB7IEhhc0luc3RhbmNlIH0gZnJvbSAnLi4vSGFzSW5zdGFuY2UnO1xuaW1wb3J0IHsgVG9TdHJpbmcgfSBmcm9tICcuLi9Db252ZXJzaW9uL1RvU3RyaW5nJztcbmltcG9ydCB7IFRvT2JqZWN0IH0gZnJvbSAnLi4vQ29udmVyc2lvbi9Ub09iamVjdCc7XG5pbXBvcnQgeyBJc0RhdGFEZXNjcmlwdG9yLCBKU0ZQcm9wZXJ0eURlc2NyaXB0b3IgfSBmcm9tICcuLi9Qcm9wZXJ0eURlc2NyaXB0b3InO1xuaW1wb3J0IHsgVmFsdWVUeXBlcywgSUVjbWFPYmplY3QsIElzSUVjbWFPYmplY3QgfSBmcm9tICcuLi9JbnRlcmZhY2VzJztcblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZGVjbGFyZSB2YXIgbW9uaXRvcjogTW9uaXRvckJhc2U7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT2JqZWN0IENvbnN0cnVjdG9yLCAxNS4yLjNcblxuZXhwb3J0IGNsYXNzIE9iamVjdENvbnN0cnVjdG9yIGV4dGVuZHMgRWNtYU9iamVjdCB7XG5cbiAgaG9zdDogYW55O1xuXG4gIGNvbnN0cnVjdG9yKGhvc3Q6IE9iamVjdCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLkNsYXNzID0gJ0Z1bmN0aW9uJztcbiAgICB0aGlzLmhvc3QgPSBob3N0O1xuICB9XG5cbiAgU2V0dXAoKTogdm9pZCB7XG5cbiAgICBEZWZpbmVGRkYodGhpcywgY29uc3RhbnRzLmxlbmd0aCwgMSk7XG5cbiAgICAvLyAxNS4yLjNcbiAgICB0aGlzLlByb3RvdHlwZSA9IG5ldyBWYWx1ZShtb25pdG9yLmluc3RhbmNlcy5GdW5jdGlvblByb3RvdHlwZSwgYm90KTtcbiAgICAvLyAxNS4yLjMuMVxuICAgIERlZmluZUZGRih0aGlzLCBjb25zdGFudHMucHJvdG90eXBlLCBtb25pdG9yLmluc3RhbmNlcy5PYmplY3RQcm90b3R5cGUpO1xuXG4gICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5nZXRQcm90b3R5cGVPZiwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChnZXRQcm90b3R5cGVPZiwgMSwgT2JqZWN0LmdldFByb3RvdHlwZU9mKSk7XG4gICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3QoZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLCAyLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKSk7XG4gICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5nZXRPd25Qcm9wZXJ0eU5hbWVzLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KGdldE93blByb3BlcnR5TmFtZXMsIDEsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKSk7XG4gICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5jcmVhdGUsIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3QoY3JlYXRlLCAyLCBPYmplY3QuY3JlYXRlKSk7XG4gICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5kZWZpbmVQcm9wZXJ0eSwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChkZWZpbmVQcm9wZXJ0eSwgMywgT2JqZWN0LmRlZmluZVByb3BlcnR5KSk7XG4gICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5kZWZpbmVQcm9wZXJ0aWVzLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KGRlZmluZVByb3BlcnRpZXMsIDIsIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKSk7XG4gICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5zZWFsLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHNlYWwsIDEsIE9iamVjdC5zZWFsKSk7XG4gICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5mcmVlemUsIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3QoZnJlZXplLCAxLCBPYmplY3QuZnJlZXplKSk7XG4gICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5wcmV2ZW50RXh0ZW5zaW9ucywgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChwcmV2ZW50RXh0ZW5zaW9ucywgMSwgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKSk7XG4gICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5pc1NlYWxlZCwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChpc1NlYWxlZCwgMSwgT2JqZWN0LmlzU2VhbGVkKSk7XG4gICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5pc0Zyb3plbiwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChpc0Zyb3plbiwgMSwgT2JqZWN0LmlzRnJvemVuKSk7XG4gICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5pc0V4dGVuc2libGUsIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3QoaXNFeHRlbnNpYmxlLCAxLCBPYmplY3QuaXNFeHRlbnNpYmxlKSk7XG4gICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5rZXlzLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KGtleXMsIDEsIE9iamVjdC5rZXlzKSk7XG5cbiAgfVxuXG4gIEhhc0luc3RhbmNlKFY6IFZhbHVlPFZhbHVlVHlwZXM+KTogVmFsdWU8Ym9vbGVhbj4ge1xuICAgIHJldHVybiBIYXNJbnN0YW5jZS5jYWxsKHRoaXMsIFYpO1xuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIDE1LjIuMS4xXG4gIENhbGwodGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxFY21hT2JqZWN0PiB7XG4gICAgbGV0IGFyZzAgPSBhcmdzWzBdIHx8IG5ldyBWYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG5cbiAgICBsZXQgcmVzOiBWYWx1ZTxFY21hT2JqZWN0PjtcbiAgICBtb25pdG9yLmNvbnRleHQucHVzaFBDKGFyZzAubGFiZWwpO1xuICAgIGlmIChhcmcwLnZhbHVlID09PSB1bmRlZmluZWQgfHwgYXJnMC52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmVzID0gdGhpcy5Db25zdHJ1Y3QoYXJncyk7XG4gICAgICByZXMucmFpc2UoYXJnMC5sYWJlbCk7XG4gICAgICBtb25pdG9yLmNvbnRleHQucG9wUEMoKTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgcmVzID0gVG9PYmplY3QoYXJnMCk7XG4gICAgbW9uaXRvci5jb250ZXh0LnBvcFBDKCk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyAxNS4yLjIuMVxuICBDb25zdHJ1Y3QoYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPE9iamVjdE9iamVjdD4ge1xuXG4gICAgbGV0IGFyZzAgPSBhcmdzWzBdIHx8IG5ldyBWYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG5cbiAgICBtb25pdG9yLmNvbnRleHQucHVzaFBDKGFyZzAubGFiZWwpO1xuXG4gICAgbGV0IHJlczogVmFsdWU8T2JqZWN0T2JqZWN0PjtcbiAgICBpZiAoYXJnMC52YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IGFyZzAudmFsdWUgPT09IG51bGwpIHtcbiAgICAgIGxldCBvID0gbmV3IE9iamVjdE9iamVjdCgpO1xuXG4gICAgICByZXMgPSBuZXcgVmFsdWUobywgYXJnMC5sYWJlbCk7XG4gICAgICBtb25pdG9yLmNvbnRleHQucG9wUEMoKTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBhcmcwLnZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgcmVzID0gbmV3IFZhbHVlKGFyZzAudmFsdWUsIGFyZzAubGFiZWwpO1xuICAgICAgbW9uaXRvci5jb250ZXh0LnBvcFBDKCk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIHJlcyA9IFRvT2JqZWN0KGFyZzApO1xuICAgIG1vbml0b3IuY29udGV4dC5wb3BQQygpO1xuICAgIHJldHVybiByZXM7XG4gIH1cbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIEFzc2VydE9iamVjdChhcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBjYWxsZWU6IHN0cmluZyk6IHZvaWQge1xuXG4gIG1vbml0b3IuY29udGV4dC5wdXNoUEMoYXJnLmxhYmVsKTtcblxuICBtb25pdG9yLlRocm93KFxuICAgIFwiVHlwZUVycm9yXCIsXG4gICAgY2FsbGVlICsgJyBjYWxsZWQgb24gbm9uLW9iamVjdCAoJyArIFN0cmluZyhhcmcudmFsdWUpICsgJyknLCBcbiAgICBhcmcubGFiZWxcbiAgKTtcbn1cblxuXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gMTUuMi4zLjJcbmZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8SUVjbWFPYmplY3QgfCBudWxsPiB7XG4gIGxldCBPID0gYXJnc1swXSB8fCBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuXG4gIGlmICghSXNJRWNtYU9iamVjdChPKSkge1xuICAgIEFzc2VydE9iamVjdChPLCAnT2JqZWN0LmdldFByb3RvdHlwZU9mJyk7XG4gICAgdGhyb3cgJ1R5cGVTY3JpcHQnO1xuICB9XG5cbiAgbGV0IHByb3RvID0gTy52YWx1ZS5Qcm90b3R5cGU7XG4gIHJldHVybiBuZXcgVmFsdWUocHJvdG8udmFsdWUsIGx1Yihwcm90by5sYWJlbCwgTy5sYWJlbCkpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIDE1LjIuMy4zXG5cbmxldCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiAodGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxPYmplY3RPYmplY3QgfCB1bmRlZmluZWQ+IHtcbiAgbGV0IE8gPSBhcmdzWzBdIHx8IG5ldyBWYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG4gIGxldCBQID0gYXJnc1sxXSB8fCBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuXG4gIGlmICghSXNJRWNtYU9iamVjdChPKSkge1xuICAgIEFzc2VydE9iamVjdChPLCAnT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcicpO1xuICAgIHRocm93ICdUeXBlU2NyaXB0JztcbiAgfVxuXG4gIGxldCBuYW1lID0gVG9TdHJpbmcoUCk7XG4gIGxldCBkZXNjID0gTy5HZXRPd25Qcm9wZXJ0eShuYW1lKTtcblxuICBpZiAoZGVzYy52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG5ldyBWYWx1ZSh1bmRlZmluZWQsIGRlc2MubGFiZWwpO1xuICB9XG5cbiAgbGV0IG9iaiA9IG5ldyBPYmplY3RPYmplY3QoKTtcbiAgaWYgKElzRGF0YURlc2NyaXB0b3IoZGVzYy52YWx1ZSkpIHtcbiAgICBvYmouRGVmaW5lT3duUHJvcGVydHkoXG4gICAgICBjb25zdGFudHMudmFsdWUsXG4gICAgICB7XG4gICAgICAgIHZhbHVlOiBkZXNjLnZhbHVlLnZhbHVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBsYWJlbDogZGVzYy52YWx1ZS5sYWJlbFxuICAgICAgfSxcbiAgICAgIGZhbHNlXG4gICAgKTtcblxuICAgIG9iai5EZWZpbmVPd25Qcm9wZXJ0eShcbiAgICAgIGNvbnN0YW50cy53cml0YWJsZSxcbiAgICAgIHtcbiAgICAgICAgdmFsdWU6IGRlc2MudmFsdWUud3JpdGFibGUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGxhYmVsOiBkZXNjLnZhbHVlLmxhYmVsXG4gICAgICB9LFxuICAgICAgZmFsc2VcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIC8vQHRzLWlnbm9yZSBERVNDIEhFTExcbiAgICBsZXQgZ2V0ID0gZGVzYy52YWx1ZS5nZXQgPyBkZXNjLnZhbHVlLmdldC5hY3R1YWxGdW5jdGlvbiA6IGRlc2MudmFsdWUuZ2V0O1xuICAgIG9iai5EZWZpbmVPd25Qcm9wZXJ0eShcbiAgICAgIGNvbnN0YW50cy5nZXQsXG4gICAgICB7XG4gICAgICAgIHZhbHVlOiBnZXQsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGxhYmVsOiBkZXNjLnZhbHVlLmxhYmVsXG4gICAgICB9LFxuICAgICAgZmFsc2VcbiAgICApO1xuXG4gICAgLy9AdHMtaWdub3JlIERFU0MgSEVMTFxuICAgIGxldCBzZXQgPSBkZXNjLnZhbHVlLnNldCA/IGRlc2MudmFsdWUuc2V0LmFjdHVhbEZ1bmN0aW9uIDogZGVzYy52YWx1ZS5zZXQ7XG4gICAgb2JqLkRlZmluZU93blByb3BlcnR5KFxuICAgICAgY29uc3RhbnRzLnNldCxcbiAgICAgIHtcbiAgICAgICAgdmFsdWU6IHNldCxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgbGFiZWw6IGRlc2MudmFsdWUubGFiZWxcbiAgICAgIH0sXG4gICAgICBmYWxzZVxuICAgICk7XG4gIH1cblxuICBvYmouRGVmaW5lT3duUHJvcGVydHkoXG4gICAgY29uc3RhbnRzLmVudW1lcmFibGUsXG4gICAge1xuICAgICAgdmFsdWU6IGRlc2MudmFsdWUuZW51bWVyYWJsZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBsYWJlbDogZGVzYy52YWx1ZS5sYWJlbFxuICAgIH0sXG4gICAgZmFsc2VcbiAgKTtcblxuICBvYmouRGVmaW5lT3duUHJvcGVydHkoXG4gICAgY29uc3RhbnRzLmNvbmZpZ3VyYWJsZSxcbiAgICB7XG4gICAgICB2YWx1ZTogZGVzYy52YWx1ZS5jb25maWd1cmFibGUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgbGFiZWw6IGRlc2MudmFsdWUubGFiZWxcbiAgICB9LFxuICAgIGZhbHNlXG4gICk7XG5cbiAgcmV0dXJuIG5ldyBWYWx1ZShvYmosIGRlc2MubGFiZWwpO1xufTtcblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIDE1LjIuMy40XG5cbmZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXModGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxBcnJheU9iamVjdD4ge1xuICBsZXQgTyA9IGFyZ3NbMF0gfHwgbmV3IFZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgaWYgKCFJc0lFY21hT2JqZWN0KE8pKSB7XG4gICAgQXNzZXJ0T2JqZWN0KE8sICdPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcycpO1xuICAgIHRocm93ICdUeXBlU2NyaXB0JztcbiAgfVxuXG4gIGxldCBwcm9wZXJ0eU5hbWVzID0gTy52YWx1ZS5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8ubGFiZWwpO1xuICBsZXQgYXJyYXkgPSBBcnJheU9iamVjdC5mcm9tUHJvcGVydHlBcnJheShwcm9wZXJ0eU5hbWVzLCBPLnZhbHVlLnN0cnVjdCk7XG4gIHJldHVybiBuZXcgVmFsdWUoYXJyYXksIGJvdCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gMTUuMi4zLjVcblxuZnVuY3Rpb24gY3JlYXRlKHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8T2JqZWN0T2JqZWN0PiB7XG4gIGxldCBPID0gYXJnc1swXSB8fCBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICBsZXQgUHJvcGVydGllcyA9IGFyZ3NbMV0gfHwgbmV3IFZhbHVlKHVuZGVmaW5lZCwgYm90KTtcblxuICBpZiAoTy52YWx1ZSAhPT0gbnVsbCAmJiAhSXNJRWNtYU9iamVjdChPKSkge1xuICAgIEFzc2VydE9iamVjdChPLCAnT2JqZWN0LmNyZWF0ZScpO1xuICAgIHRocm93ICdUeXBlU2NyaXB0JztcbiAgfVxuXG4gIGxldCBvYmogPSBuZXcgT2JqZWN0T2JqZWN0KCk7XG4gIG9iai5Qcm90b3R5cGUgPSBPO1xuICBsZXQgb2JqVmFsdWUgPSBuZXcgVmFsdWUob2JqLCBib3QpO1xuXG4gIGlmIChQcm9wZXJ0aWVzLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXNBcmcsIFtvYmpWYWx1ZSwgUHJvcGVydGllc10pO1xuICB9XG4gIHJldHVybiBvYmpWYWx1ZTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIFRvUHJvcGVydHlEZXNjcmlwdG9yKE9iajogVmFsdWU8RWNtYU9iamVjdD4pOiBKU0ZQcm9wZXJ0eURlc2NyaXB0b3Ige1xuICBpZiAoIUlzSUVjbWFPYmplY3QoT2JqKSkge1xuICAgIEFzc2VydE9iamVjdChPYmosICdPYmplY3QuVG9Qcm9wZXJ0eURlc2NyaXB0b3InKTtcbiAgICB0aHJvdyAnVHlwZVNjcmlwdCc7XG4gIH1cblxuICBsZXQgYyA9IG1vbml0b3IuY29udGV4dDtcblxuICBsZXQgbGJsID0gbmV3IExhYmVsKCk7XG4gIGxldCBkZXNjOiBKU0ZQcm9wZXJ0eURlc2NyaXB0b3IgPSB7IGxhYmVsOiBib3QgfTtcblxuICBsZXQgYjogVmFsdWU8Ym9vbGVhbj47XG4gIGxldCB4OiBWYWx1ZTxWYWx1ZVR5cGVzPjtcbiAgbGV0IHByb3BlcnR5TmFtZTogVmFsdWU8c3RyaW5nIHwgbnVtYmVyPjtcblxuICAvLyBlbnVtZXJhYmxlXG4gIHByb3BlcnR5TmFtZSA9IGNvbnN0YW50cy5lbnVtZXJhYmxlO1xuICBiID0gT2JqLkhhc1Byb3BlcnR5KHByb3BlcnR5TmFtZSk7XG5cbiAgbGJsID0gbHViKGxibCwgYi5sYWJlbCk7XG4gIGlmIChiLnZhbHVlKSB7XG4gICAgYy5wdXNoUEMoYi5sYWJlbCk7XG4gICAgeCA9IFRvQm9vbGVhbihPYmouR2V0KHByb3BlcnR5TmFtZSkpO1xuICAgIGMucG9wUEMoKTtcbiAgICBsYmwgPSBsdWIobGJsLCB4LmxhYmVsKTtcbiAgICBkZXNjW3Byb3BlcnR5TmFtZS52YWx1ZV0gPSB4LnZhbHVlO1xuICB9XG5cbiAgLy8gY29uZmlndXJhYmxlXG4gIHByb3BlcnR5TmFtZSA9IGNvbnN0YW50cy5jb25maWd1cmFibGU7XG4gIGIgPSBPYmouSGFzUHJvcGVydHkocHJvcGVydHlOYW1lKTtcblxuICBsYmwgPSBsdWIobGJsLCBiLmxhYmVsKTtcbiAgaWYgKGIudmFsdWUpIHtcbiAgICBjLnB1c2hQQyhiLmxhYmVsKTtcbiAgICB4ID0gVG9Cb29sZWFuKE9iai5HZXQocHJvcGVydHlOYW1lKSk7XG4gICAgYy5wb3BQQygpO1xuICAgIGxibCA9IGx1YihsYmwsIHgubGFiZWwpO1xuICAgIGRlc2NbcHJvcGVydHlOYW1lLnZhbHVlXSA9IHgudmFsdWU7XG4gIH1cblxuICAvLyB2YWx1ZVxuICBwcm9wZXJ0eU5hbWUgPSBjb25zdGFudHMudmFsdWU7XG4gIGIgPSBPYmouSGFzUHJvcGVydHkocHJvcGVydHlOYW1lKTtcblxuICBsYmwgPSBsdWIobGJsLCBiLmxhYmVsKTtcbiAgaWYgKGIudmFsdWUpIHtcbiAgICBjLnB1c2hQQyhiLmxhYmVsKTtcbiAgICB4ID0gT2JqLkdldChwcm9wZXJ0eU5hbWUpO1xuICAgIGMucG9wUEMoKTtcbiAgICBsYmwgPSBsdWIobGJsLCB4LmxhYmVsKTtcbiAgICBkZXNjW3Byb3BlcnR5TmFtZS52YWx1ZV0gPSB4LnZhbHVlO1xuICB9XG5cbiAgLy8gd3JpdGFibGVcbiAgcHJvcGVydHlOYW1lID0gY29uc3RhbnRzLndyaXRhYmxlO1xuICBiID0gT2JqLkhhc1Byb3BlcnR5KHByb3BlcnR5TmFtZSk7XG5cbiAgbGJsID0gbHViKGxibCwgYi5sYWJlbCk7XG4gIGlmIChiLnZhbHVlKSB7XG4gICAgYy5wdXNoUEMoYi5sYWJlbCk7XG4gICAgeCA9IFRvQm9vbGVhbihPYmouR2V0KHByb3BlcnR5TmFtZSkpO1xuICAgIGMucG9wUEMoKTtcbiAgICBsYmwgPSBsdWIobGJsLCB4LmxhYmVsKTtcbiAgICBkZXNjW3Byb3BlcnR5TmFtZS52YWx1ZV0gPSB4LnZhbHVlO1xuICB9XG5cbiAgLy8gZ2V0XG4gIHByb3BlcnR5TmFtZSA9IGNvbnN0YW50cy5nZXQ7XG4gIGIgPSBPYmouSGFzUHJvcGVydHkocHJvcGVydHlOYW1lKTtcblxuICBsYmwgPSBsdWIobGJsLCBiLmxhYmVsKTtcbiAgaWYgKGIudmFsdWUpIHtcbiAgICBjLnB1c2hQQyhiLmxhYmVsKTtcbiAgICB4ID0gT2JqLkdldChwcm9wZXJ0eU5hbWUpO1xuICAgIGMucG9wUEMoKTtcbiAgICBsYmwgPSBsdWIobGJsLCB4LmxhYmVsKTtcbiAgICBkZXNjW3Byb3BlcnR5TmFtZS52YWx1ZV0gPSB4LnZhbHVlO1xuICB9XG5cbiAgLy8gc2V0XG4gIHByb3BlcnR5TmFtZSA9IGNvbnN0YW50cy5zZXQ7XG4gIGIgPSBPYmouSGFzUHJvcGVydHkocHJvcGVydHlOYW1lKTtcblxuICBsYmwgPSBsdWIobGJsLCBiLmxhYmVsKTtcbiAgaWYgKGIudmFsdWUpIHtcbiAgICBjLnB1c2hQQyhiLmxhYmVsKTtcbiAgICB4ID0gT2JqLkdldChwcm9wZXJ0eU5hbWUpO1xuICAgIGMucG9wUEMoKTtcbiAgICBsYmwgPSBsdWIobGJsLCB4LmxhYmVsKTtcbiAgICBkZXNjW3Byb3BlcnR5TmFtZS52YWx1ZV0gPSB4LnZhbHVlO1xuICB9XG5cbiAgZGVzYy5sYWJlbCA9IGxibDtcbiAgcmV0dXJuIGRlc2M7XG59XG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAxNS4yLjMuNlxuXG5mdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eSh0aGlzQXJnOiBWYWx1ZTxWYWx1ZVR5cGVzPiwgYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPElFY21hT2JqZWN0PiB7XG4gIGxldCBPID0gYXJnc1swXSB8fCBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICBsZXQgUCA9IGFyZ3NbMV0gfHwgbmV3IFZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgbGV0IEF0dHJpYnV0ZXMgPSBhcmdzWzJdIHx8IG5ldyBWYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG5cbiAgaWYgKCFJc0lFY21hT2JqZWN0KE8pKSB7XG4gICAgQXNzZXJ0T2JqZWN0KE8sICdPYmplY3QuZGVmaW5lUHJvcGVydHknKTtcbiAgICB0aHJvdyAnVHlwZVNjcmlwdCc7XG4gIH1cblxuICBsZXQgbmFtZSA9IFRvU3RyaW5nKFApO1xuICBsZXQgZGVzYyA9IFRvUHJvcGVydHlEZXNjcmlwdG9yKEF0dHJpYnV0ZXMpO1xuICBPLkRlZmluZU93blByb3BlcnR5KG5hbWUsIGRlc2MsIHRydWUpO1xuICByZXR1cm4gTztcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAxNS4yLjMuN1xuXG5mdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8SUVjbWFPYmplY3Q+IHtcbiAgbGV0IE8gPSBhcmdzWzBdIHx8IG5ldyBWYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG4gIGxldCBQcm9wZXJ0aWVzID0gYXJnc1sxXSB8fCBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuXG4gIGlmICghSXNJRWNtYU9iamVjdChPKSkge1xuICAgIEFzc2VydE9iamVjdChPLCAnT2JqZWN0LmRlZmluZVByb3BlcnRpZXMnKTtcbiAgICB0aHJvdyAnVHlwZVNjcmlwdCc7XG4gIH1cblxuICBsZXQgcHJvcHMgPSBUb09iamVjdChQcm9wZXJ0aWVzKTtcbiAgbGV0IG5hbWVzID0gcHJvcHMudmFsdWUuZ2V0T3duRW51bWVyYWJsZVByb3BlcnR5TmFtZXMocHJvcHMubGFiZWwpO1xuXG4gIGxldCBkZXNjcmlwdG9yczogeyBuYW1lOiBWYWx1ZTxzdHJpbmc+LCBkZXNjcmlwdG9yOiBKU0ZQcm9wZXJ0eURlc2NyaXB0b3IgfVtdID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbGV0IFAgPSBuYW1lc1tpXTtcbiAgICBsZXQgZGVzY09iamVjdCA9IHByb3BzLkdldChQKTtcbiAgICAvL0B0cy1pZ25vcmUgREVDIEhFTExcbiAgICBsZXQgZGVzYyA9IFRvUHJvcGVydHlEZXNjcmlwdG9yKGRlc2NPYmplY3QpO1xuXG4gICAgZGVzY3JpcHRvcnMucHVzaCh7IG5hbWU6IFAsIGRlc2NyaXB0b3I6IGRlc2MgfSk7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gZGVzY3JpcHRvcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBsZXQgUCA9IGRlc2NyaXB0b3JzW2ldLm5hbWU7XG4gICAgbGV0IGRlc2MgPSBkZXNjcmlwdG9yc1tpXS5kZXNjcmlwdG9yO1xuICAgIE8uRGVmaW5lT3duUHJvcGVydHkoUCwgZGVzYywgdHJ1ZSk7XG4gIH1cblxuICByZXR1cm4gTztcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAxNS4yLjMuOFxuXG5mdW5jdGlvbiBzZWFsKHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8SUVjbWFPYmplY3Q+IHtcbiAgbGV0IE8gPSBhcmdzWzBdIHx8IG5ldyBWYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG5cbiAgaWYgKCFJc0lFY21hT2JqZWN0KE8pKSB7XG4gICAgQXNzZXJ0T2JqZWN0KE8sICdPYmplY3QuZGVmaW5lUHJvcGVydGllcycpO1xuICAgIHRocm93ICdUeXBlU2NyaXB0JztcbiAgfVxuXG4gIGxldCBjb250ZXh0ID0gbHViKG1vbml0b3IuY29udGV4dC5lZmZlY3RpdmVQQywgTy5sYWJlbCk7XG5cbiAgbW9uaXRvci5hc3NlcnQoXG4gICAgbGUoY29udGV4dCwgTy52YWx1ZS5zdHJ1Y3QpLFxuICAgICdPYmplY3Quc2VhbDogY29udGV4dCBsYWJlbCAnICsgY29udGV4dCArICcgbm90IGJlbG93IHN0cnVjdHVyYWwgbGFiZWwgJyArIE8udmFsdWUuc3RydWN0ICsgJyBvZiBvYmplY3QnXG4gICk7XG5cbiAgbGV0IGxhYmVscyA9IE8udmFsdWUubGFiZWxzO1xuICBmb3IgKGxldCB4IGluIGxhYmVscykge1xuICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChsYWJlbHMsIHgpKSB7XG4gICAgICBtb25pdG9yLmFzc2VydChcbiAgICAgICAgbGUoY29udGV4dCwgbGFiZWxzW3hdLnZhbHVlKSxcbiAgICAgICAgJ09iamVjdC5zZWFsOiBjb250ZXh0IGxhYmVsICcgKyBjb250ZXh0ICsgJyBub3QgYmVsb3cgbGFiZWwgJyArIGxhYmVsc1t4XS52YWx1ZSArICcgb2YgJyArIHhcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgT2JqZWN0LnNlYWwoTy52YWx1ZS5wcm9wZXJ0aWVzKTtcbiAgTy52YWx1ZS5FeHRlbnNpYmxlID0gZmFsc2U7XG4gIHJldHVybiBPO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIDE1LjIuMy45XG5cbmZ1bmN0aW9uIGZyZWV6ZSh0aGlzQXJnOiBWYWx1ZTxWYWx1ZVR5cGVzPiwgYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPElFY21hT2JqZWN0PiB7XG4gIGxldCBPID0gYXJnc1swXSB8fCBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICBpZiAoIUlzSUVjbWFPYmplY3QoTykpIHtcbiAgICBBc3NlcnRPYmplY3QoTywgJ09iamVjdC5mcmVlemUnKTtcbiAgICB0aHJvdyAnVHlwZVNjcmlwdCc7XG4gIH1cblxuICBsZXQgY29udGV4dCA9IGx1Yihtb25pdG9yLmNvbnRleHQuZWZmZWN0aXZlUEMsIE8ubGFiZWwpO1xuXG4gIG1vbml0b3IuYXNzZXJ0KFxuICAgIGxlKGNvbnRleHQsIE8udmFsdWUuc3RydWN0KSxcbiAgICAnT2JqZWN0LmZyZWV6ZTogY29udGV4dCBsYWJlbCAnICsgY29udGV4dCArICcgbm90IGJlbG93IHN0cnVjdHVyYWwgbGFiZWwgJyArIE8udmFsdWUuc3RydWN0ICsgJyBvZiBvYmplY3QnXG4gICk7XG5cbiAgbGV0IGxhYmVscyA9IE8udmFsdWUubGFiZWxzO1xuICBsZXQgcHJvcGVydGllcyA9IE8udmFsdWUucHJvcGVydGllcztcblxuICBmb3IgKGxldCB4IGluIHByb3BlcnRpZXMpIHtcbiAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwocHJvcGVydGllcywgeCkpIHtcbiAgICAgIGxldCBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm9wZXJ0aWVzLCB4KTtcbiAgICAgIGlmIChkZXNjLmVudW1lcmFibGUpIHtcbiAgICAgICAgbW9uaXRvci5hc3NlcnQoXG4gICAgICAgICAgbGUoY29udGV4dCwgbGFiZWxzW3hdLnZhbHVlKSxcbiAgICAgICAgICAnT2JqZWN0LmZyZWV6ZTogY29udGV4dCBsYWJlbCAnICsgY29udGV4dCArICcgbm90IGJlbG93IGxhYmVsICcgKyBsYWJlbHNbeF0udmFsdWUgKyAnIG9mICcgKyB4XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgT2JqZWN0LmZyZWV6ZShPLnZhbHVlLnByb3BlcnRpZXMpO1xuICBPLnZhbHVlLkV4dGVuc2libGUgPSBmYWxzZTtcbiAgcmV0dXJuIE87XG5cbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAxNS4yLjMuMTBcblxuZnVuY3Rpb24gcHJldmVudEV4dGVuc2lvbnModGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxJRWNtYU9iamVjdD4ge1xuICBsZXQgTyA9IGFyZ3NbMF0gfHwgbmV3IFZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgaWYgKCFJc0lFY21hT2JqZWN0KE8pKSB7XG4gICAgQXNzZXJ0T2JqZWN0KE8sICdPYmplY3QucHJldmVudEV4dGVuc2lvbnMnKTtcbiAgICB0aHJvdyAnVHlwZVNjcmlwdCc7XG4gIH1cblxuICBsZXQgY29udGV4dCA9IGx1Yihtb25pdG9yLmNvbnRleHQuZWZmZWN0aXZlUEMsIE8ubGFiZWwpO1xuXG4gIG1vbml0b3IuYXNzZXJ0KFxuICAgIGxlKGNvbnRleHQsIE8udmFsdWUuc3RydWN0KSxcbiAgICAnT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zOiBjb250ZXh0IGxhYmVsICcgKyBjb250ZXh0ICsgJyBub3QgYmVsb3cgc3RydWN0dXJhbCBsYWJlbCAnICsgTy52YWx1ZS5zdHJ1Y3QgKyAnIG9mIG9iamVjdCdcbiAgKTtcblxuICBPYmplY3QucHJldmVudEV4dGVuc2lvbnMoTy52YWx1ZS5wcm9wZXJ0aWVzKTtcbiAgTy52YWx1ZS5FeHRlbnNpYmxlID0gZmFsc2U7XG4gIHJldHVybiBPO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIDE1LjIuMy4xMVxuXG5mdW5jdGlvbiBpc1NlYWxlZCh0aGlzQXJnOiBWYWx1ZTxWYWx1ZVR5cGVzPiwgYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPGJvb2xlYW4+IHtcbiAgbGV0IE8gPSBhcmdzWzBdIHx8IG5ldyBWYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG4gIGlmICghSXNJRWNtYU9iamVjdChPKSkge1xuICAgIEFzc2VydE9iamVjdChPLCAnT2JqZWN0LmlzU2VhbGVkJyk7XG4gICAgdGhyb3cgJ1R5cGVTY3JpcHQnO1xuICB9XG5cbiAgbGV0IHJlc3VsdCA9IE9iamVjdC5pc1NlYWxlZChPLnZhbHVlLnByb3BlcnRpZXMpO1xuICByZXR1cm4gbmV3IFZhbHVlKHJlc3VsdCwgbHViKE8ubGFiZWwsIE8udmFsdWUuc3RydWN0KSk7XG59XG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAxNS4yLjMuMTJcblxuZnVuY3Rpb24gaXNGcm96ZW4odGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxib29sZWFuPiB7XG4gIGxldCBPID0gYXJnc1swXSB8fCBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICBpZiAoIUlzSUVjbWFPYmplY3QoTykpIHtcbiAgICBBc3NlcnRPYmplY3QoTywgJ09iamVjdC5pc0Zyb3plbicpO1xuICAgIHRocm93ICdUeXBlU2NyaXB0JztcbiAgfVxuXG4gIGxldCByZXN1bHQgPSBPYmplY3QuaXNGcm96ZW4oTy52YWx1ZS5wcm9wZXJ0aWVzKTtcbiAgcmV0dXJuIG5ldyBWYWx1ZShyZXN1bHQsIGx1YihPLmxhYmVsLCBPLnZhbHVlLnN0cnVjdCkpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIDE1LjIuMy4xM1xuXG5mdW5jdGlvbiBpc0V4dGVuc2libGUodGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxib29sZWFuPiB7XG4gIGxldCBPID0gYXJnc1swXSB8fCBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICBpZiAoIUlzSUVjbWFPYmplY3QoTykpIHtcbiAgICBBc3NlcnRPYmplY3QoTywgJ09iamVjdC5pc0V4dGVuc2libGUnKTtcbiAgICB0aHJvdyAnVHlwZVNjcmlwdCc7XG4gIH1cblxuICBsZXQgcmVzdWx0ID0gT2JqZWN0LmlzRXh0ZW5zaWJsZShPLnZhbHVlLnByb3BlcnRpZXMpO1xuICByZXR1cm4gbmV3IFZhbHVlKHJlc3VsdCwgbHViKE8ubGFiZWwsIE8udmFsdWUuc3RydWN0KSk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gMTUuMi4zLjE0XG5mdW5jdGlvbiBrZXlzKHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8QXJyYXlPYmplY3Q+IHtcbiAgbGV0IE89IGFyZ3NbMF0gfHwgbmV3IFZhbHVlKHVuZGVmaW5lZCwgYm90KTtcblxuICBpZiAoIUlzSUVjbWFPYmplY3QoTykpIHtcbiAgICBBc3NlcnRPYmplY3QoTywgJ09iamVjdC5pc0V4dGVuc2libGUnKTtcbiAgICB0aHJvdyAnVHlwZVNjcmlwdCc7XG4gIH1cblxuICBsZXQgZW51bWVyYWJsZSA9IE8udmFsdWUuZ2V0T3duRW51bWVyYWJsZVByb3BlcnR5TmFtZXMoTy5sYWJlbCk7XG4gIGxldCBhcnJheSA9IEFycmF5T2JqZWN0LmZyb21Qcm9wZXJ0eUFycmF5KGVudW1lcmFibGUsIE8udmFsdWUuc3RydWN0KTtcblxuICByZXR1cm4gbmV3IFZhbHVlKGFycmF5LCBib3QpO1xufSIsImltcG9ydCB7IEVycm9yQ29uc3RydWN0b3IgfSBmcm9tIFwiLi9FcnJvckNvbnN0cnVjdG9yXCI7XG5pbXBvcnQgeyBib3QgfSBmcm9tIFwiLi4vTGFiZWxcIjtcbmltcG9ydCB7IFZhbHVlIH0gZnJvbSBcIi4uL1ZhbHVlXCI7XG5pbXBvcnQgeyBSYW5nZUVycm9yT2JqZWN0IH0gZnJvbSBcIi4uL09iamVjdHMvUmFuZ2VFcnJvck9iamVjdFwiO1xuaW1wb3J0IHsgTW9uaXRvckJhc2UgfSBmcm9tIFwiLi4vTW9uaXRvckJhc2VcIjtcbmltcG9ydCB7IFZhbHVlVHlwZXMgfSBmcm9tIFwiLi4vSW50ZXJmYWNlc1wiO1xuXG5kZWNsYXJlIHZhciBtb25pdG9yOiBNb25pdG9yQmFzZTtcblxuZXhwb3J0IGNsYXNzIFJhbmdlRXJyb3JDb25zdHJ1Y3RvciBleHRlbmRzIEVycm9yQ29uc3RydWN0b3Ige1xuXG4gICAgY29uc3RydWN0b3IoaG9zdCA6IFJhbmdlRXJyb3IpIHtcbiAgICAgICAgc3VwZXIoaG9zdCk7XG4gICAgfVxuXG4gICAgU2V0dXAoKSA6IHZvaWQge1xuICAgICAgICB0aGlzLlNldHVwQmFzZShtb25pdG9yLmluc3RhbmNlcy5SYW5nZUVycm9yUHJvdG90eXBlKTtcbiAgICB9XG5cbiAgICBDb25zdHJ1Y3QoYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPFJhbmdlRXJyb3JPYmplY3Q+IHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBhcmdzWzBdIHx8IG5ldyBWYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG4gICAgICAgIHZhciBvID0gbmV3IFJhbmdlRXJyb3JPYmplY3QobWVzc2FnZSk7XG4gICAgICAgIHJldHVybiBuZXcgVmFsdWUobywgYm90KTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBFcnJvckNvbnN0cnVjdG9yIH0gZnJvbSBcIi4vRXJyb3JDb25zdHJ1Y3RvclwiO1xuaW1wb3J0IHsgYm90IH0gZnJvbSBcIi4uL0xhYmVsXCI7XG5pbXBvcnQgeyBWYWx1ZSB9IGZyb20gXCIuLi9WYWx1ZVwiO1xuaW1wb3J0IHsgUmVmZXJlbmNlRXJyb3JPYmplY3QgfSBmcm9tIFwiLi4vT2JqZWN0cy9SZWZlcmVuY2VFcnJvck9iamVjdFwiO1xuaW1wb3J0IHsgTW9uaXRvckJhc2UgfSBmcm9tIFwiLi4vTW9uaXRvckJhc2VcIjtcbmltcG9ydCB7IFZhbHVlVHlwZXMgfSBmcm9tIFwiLi4vSW50ZXJmYWNlc1wiO1xuXG5kZWNsYXJlIHZhciBtb25pdG9yOiBNb25pdG9yQmFzZTtcblxuZXhwb3J0IGNsYXNzIFJlZmVyZW5jZUVycm9yQ29uc3RydWN0b3IgZXh0ZW5kcyBFcnJvckNvbnN0cnVjdG9yIHtcblxuICAgIGNvbnN0cnVjdG9yKGhvc3QgOiBSZWZlcmVuY2VFcnJvcikge1xuICAgICAgICBzdXBlcihob3N0KTtcbiAgICB9XG5cbiAgICBTZXR1cCgpIDogdm9pZCB7XG4gICAgICAgIHRoaXMuU2V0dXBCYXNlKG1vbml0b3IuaW5zdGFuY2VzLlJlZmVyZW5jZUVycm9yUHJvdG90eXBlKTtcbiAgICB9XG5cbiAgICBDb25zdHJ1Y3QoYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPFJlZmVyZW5jZUVycm9yT2JqZWN0PiB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gYXJnc1swXSB8fCBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgICAgICB2YXIgbyA9IG5ldyBSZWZlcmVuY2VFcnJvck9iamVjdChtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZShvLCBib3QpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IFZhbHVlIH0gZnJvbSBcIi4uL1ZhbHVlXCI7XG5pbXBvcnQgKiBhcyBjb25zdGFudHMgZnJvbSAnLi4vQ29uc3RhbnRzJztcbmltcG9ydCB7IEhhc0luc3RhbmNlIH0gZnJvbSAnLi4vSGFzSW5zdGFuY2UnO1xuaW1wb3J0IHsgVG9TdHJpbmcgfSBmcm9tICcuLi9Db252ZXJzaW9uL1RvU3RyaW5nJztcbmltcG9ydCB7IE1vbml0b3JCYXNlIH0gZnJvbSAnLi4vTW9uaXRvckJhc2UnO1xuXG5pbXBvcnQgeyBib3QsIGx1YiB9IGZyb20gJy4uL0xhYmVsJztcbmltcG9ydCB7IFJlZ0V4cE9iamVjdCwgSXNSZWdFeHBPYmplY3QgfSBmcm9tICcuLi9PYmplY3RzL1JlZ0V4cE9iamVjdCc7XG5pbXBvcnQgeyBEZWZpbmVGRkYgfSBmcm9tICcuLi9EZWZpbmUnO1xuaW1wb3J0IHsgRWNtYU9iamVjdCB9IGZyb20gXCIuLi9PYmplY3RzL0VjbWFPYmplY3RcIjtcbmltcG9ydCB7IFZhbHVlVHlwZXMgfSBmcm9tIFwiLi4vSW50ZXJmYWNlc1wiO1xuXG5kZWNsYXJlIHZhciBtb25pdG9yOiBNb25pdG9yQmFzZTtcblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFRoZSBSZWdFeHAgQ29uc3RydWN0b3IsIDE1LjEwLjVcblxuZXhwb3J0IGNsYXNzIFJlZ0V4cENvbnN0cnVjdG9yIGV4dGVuZHMgRWNtYU9iamVjdCB7XG5cbiAgICBob3N0OiBhbnk7XG5cbiAgICBjb25zdHJ1Y3Rvcihob3N0OiBSZWdFeHApIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5DbGFzcyA9ICdGdW5jdGlvbic7XG4gICAgICAgIC8vIG5vdCBtYW5kYXRlZCBieSBzdGFuZGFyZFxuICAgICAgICB0aGlzLkV4dGVuc2libGUgPSB0cnVlO1xuICAgICAgICB0aGlzLmhvc3QgPSBob3N0O1xuICAgIH1cblxuICAgIFNldHVwKCk6IHZvaWQge1xuICAgICAgICB0aGlzLlByb3RvdHlwZSA9IG5ldyBWYWx1ZShtb25pdG9yLmluc3RhbmNlcy5GdW5jdGlvblByb3RvdHlwZSwgYm90KTtcblxuICAgICAgICBEZWZpbmVGRkYodGhpcywgY29uc3RhbnRzLmxlbmd0aCwgMik7XG4gICAgICAgIERlZmluZUZGRih0aGlzLCBjb25zdGFudHMucHJvdG90eXBlLCBtb25pdG9yLmluc3RhbmNlcy5SZWdFeHBQcm90b3R5cGUpO1xuICAgIH1cblxuXG4gICAgSGFzSW5zdGFuY2UoVjogVmFsdWU8VmFsdWVUeXBlcz4pOiBWYWx1ZTxib29sZWFuPiB7XG4gICAgICAgIHJldHVybiBIYXNJbnN0YW5jZS5jYWxsKHRoaXMsIFYpO1xuICAgIH1cblxuXG4gICAgLy8gMTUuMTAuMy4xXG4gICAgQ2FsbCh0aGlzQXJnOiBWYWx1ZTxWYWx1ZVR5cGVzPiwgYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPFJlZ0V4cE9iamVjdD4ge1xuICAgICAgICB2YXIgcGF0dGVybiA9IGFyZ3NbMF0gfHwgbmV3IFZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgICAgICAgdmFyIGZsYWdzID0gYXJnc1sxXSB8fCBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuXG4gICAgICAgIGlmIChJc1JlZ0V4cE9iamVjdChwYXR0ZXJuKSAmJiBmbGFncy52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF0dGVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLkNvbnN0cnVjdChhcmdzKTtcbiAgICB9XG5cbiAgICAvLyAxNS4xMC40LjFcbiAgICBDb25zdHJ1Y3QoYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPFJlZ0V4cE9iamVjdD4ge1xuICAgICAgICB2YXIgYyA9IG1vbml0b3IuY29udGV4dDtcblxuICAgICAgICB2YXIgcGF0dGVybiA9IGFyZ3NbMF0gfHwgbmV3IFZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgICAgICAgdmFyIGZsYWdzID0gYXJnc1sxXSB8fCBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuXG4gICAgICAgIHZhciBQID0gXCJcIjtcbiAgICAgICAgdmFyIEYgPSBcIlwiO1xuXG4gICAgICAgIHZhciBsID0gbHViKHBhdHRlcm4ubGFiZWwsIGZsYWdzLmxhYmVsKTtcbiAgICAgICAgYy5wdXNoUEMobCk7XG5cbiAgICAgICAgaWYgKElzUmVnRXhwT2JqZWN0KHBhdHRlcm4pKSB7XG4gICAgICAgICAgICBpZiAoZmxhZ3MudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciByeCA9IHBhdHRlcm4udmFsdWUuUHJpbWl0aXZlVmFsdWU7XG4gICAgICAgICAgICAgICAgUCA9IHJ4LnNvdXJjZTtcbiAgICAgICAgICAgICAgICBGID0gKHJ4Lmdsb2JhbCA/ICdnJyA6ICcnKSArIChyeC5pZ25vcmVDYXNlID8gJ2knIDogJycpICsgKHJ4Lm11bHRpbGluZSA/ICdtJyA6ICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vbml0b3IuVGhyb3coXG4gICAgICAgICAgICAgICAgICAgIFwiVHlwZUVycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgICAgICAgICBib3RcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIF9QID0gcGF0dGVybi52YWx1ZSA9PT0gdW5kZWZpbmVkID8gbmV3IFZhbHVlKFwiXCIsIGwpIDogVG9TdHJpbmcocGF0dGVybik7XG4gICAgICAgICAgICB2YXIgX0YgPSBmbGFncy52YWx1ZSA9PT0gdW5kZWZpbmVkID8gbmV3IFZhbHVlKFwiXCIsIGwpIDogVG9TdHJpbmcoZmxhZ3MpO1xuXG4gICAgICAgICAgICBsID0gbHViKGwsIF9QLmxhYmVsLCBfRi5sYWJlbCk7XG4gICAgICAgICAgICBQID0gX1AudmFsdWU7XG4gICAgICAgICAgICBGID0gX0YudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzIDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXMgPSBuZXcgUmVnRXhwT2JqZWN0KG5ldyBSZWdFeHAoUCwgRiksIGwpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBtb25pdG9yLnRyeVJldGhyb3coZSx0cnVlKTtcbiAgICAgICAgICAgIG1vbml0b3IuZmF0YWwoYFJlZ0V4cC5Db25zdHJ1Y3QsIHVuYWJsZSB0byBsaWZ0ICR7ZX0gb2YgdHlwZSAke3R5cGVvZiBlfSBmb3IgUmVnRXhwKCR7UH0sICR7Rn0pYCk7XG4gICAgICAgIH1cbiAgICAgICAgYy5wb3BQQygpO1xuICAgICAgICByZXR1cm4gbmV3IFZhbHVlKHJlcywgYm90KTtcbiAgICB9XG59XG4iLCJcbmltcG9ydCB7IFZhbHVlIH0gZnJvbSBcIi4uL1ZhbHVlXCI7XG5pbXBvcnQgKiBhcyBjb25zdGFudHMgZnJvbSAnLi4vQ29uc3RhbnRzJztcbmltcG9ydCB7IEJ1aWx0aW5GdW5jdGlvbk9iamVjdCB9IGZyb20gXCIuLi9PYmplY3RzL0J1aWx0aW5GdW5jdGlvbk9iamVjdFwiO1xuaW1wb3J0IHsgSGFzSW5zdGFuY2UgfSBmcm9tICcuLi9IYXNJbnN0YW5jZSc7XG5pbXBvcnQgeyBUb1VJbnQxNiB9IGZyb20gJy4uL0NvbnZlcnNpb24vVG9VSW50MTYnO1xuaW1wb3J0IHsgVG9TdHJpbmcgfSBmcm9tICcuLi9Db252ZXJzaW9uL1RvU3RyaW5nJztcbmltcG9ydCB7IE1vbml0b3JCYXNlIH0gZnJvbSAnLi4vTW9uaXRvckJhc2UnO1xuaW1wb3J0IHsgRGVmaW5lRkZGLCBEZWZpbmVURlQgfSBmcm9tICcuLi9EZWZpbmUnO1xuaW1wb3J0IHsgRWNtYU9iamVjdCB9IGZyb20gJy4uL09iamVjdHMvRWNtYU9iamVjdCc7XG5pbXBvcnQgeyBib3QsIExhYmVsLCBsdWIgfSBmcm9tICcuLi9MYWJlbCc7XG5pbXBvcnQgeyBTdHJpbmdPYmplY3QgfSBmcm9tICcuLi9PYmplY3RzL1N0cmluZ09iamVjdCc7XG5pbXBvcnQgeyBWYWx1ZVR5cGVzIH0gZnJvbSBcIi4uL0ludGVyZmFjZXNcIjtcblxuZGVjbGFyZSB2YXIgbW9uaXRvcjogTW9uaXRvckJhc2U7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVGhlIFN0cmluZyBDb25zdHJ1Y3RvciwgMTUuNS4yXG5cbmV4cG9ydCBjbGFzcyBTdHJpbmdDb25zdHJ1Y3RvciBleHRlbmRzIEVjbWFPYmplY3Qge1xuXG4gICAgaG9zdDogYW55O1xuXG4gICAgY29uc3RydWN0b3IoaG9zdDogU3RyaW5nKSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5DbGFzcyA9ICdGdW5jdGlvbic7XG4gICAgICAgIC8vIG5vdCBtYW5kYXRlZCBieSBzdGFuZGFyZFxuICAgICAgICB0aGlzLkV4dGVuc2libGUgPSB0cnVlO1xuICAgICAgICB0aGlzLmhvc3QgPSBob3N0O1xuICAgIH1cblxuICAgIFNldHVwKCk6IHZvaWQge1xuICAgICAgICB0aGlzLlByb3RvdHlwZSA9IG5ldyBWYWx1ZShtb25pdG9yLmluc3RhbmNlcy5GdW5jdGlvblByb3RvdHlwZSwgYm90KTtcblxuICAgICAgICBEZWZpbmVGRkYodGhpcywgY29uc3RhbnRzLmxlbmd0aCwgMSk7XG4gICAgICAgIERlZmluZUZGRih0aGlzLCBjb25zdGFudHMucHJvdG90eXBlLCBtb25pdG9yLmluc3RhbmNlcy5TdHJpbmdQcm90b3R5cGUpO1xuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLmZyb21DaGFyQ29kZSwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChmcm9tQ2hhckNvZGUsIDEsIHRoaXMuaG9zdC5mcm9tQ2hhckNvZGUpKTtcbiAgICB9XG5cbiAgICBIYXNJbnN0YW5jZShWOiBWYWx1ZTxWYWx1ZVR5cGVzPik6IFZhbHVlPGJvb2xlYW4+IHtcbiAgICAgICAgcmV0dXJuIEhhc0luc3RhbmNlLmNhbGwodGhpcywgVik7XG4gICAgfVxuXG4gICAgLy8gMTUuNS4xLjEgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBDYWxsKHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8c3RyaW5nPiB7XG5cbiAgICAgICAgaWYgKCFhcmdzWzBdKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFZhbHVlKCcnLCBib3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0ciA9IFRvU3RyaW5nKGFyZ3NbMF0pO1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIC8vIDE1LjUuMi4xIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFxuICAgIENvbnN0cnVjdChhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8U3RyaW5nT2JqZWN0PiB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFyZ3NbMF07XG5cbiAgICAgICAgdmFyIHN0ciA6IFN0cmluZ09iamVjdDtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgeCA9IFRvU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIHN0ciA9IG5ldyBTdHJpbmdPYmplY3QoeC52YWx1ZSwgeC5sYWJlbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHIgPSBuZXcgU3RyaW5nT2JqZWN0KCcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFZhbHVlKHN0ciwgYm90KTtcbiAgICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBmcm9tQ2hhckNvZGUsIDE1LjUuMy4yIFxuXG5mdW5jdGlvbiBmcm9tQ2hhckNvZGUodGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxzdHJpbmc+IHtcblxuICAgIHZhciBsYmwgPSBuZXcgTGFiZWwoKTtcbiAgICB2YXIgX2FyZ3M6IG51bWJlcltdID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGFyZyA9IFRvVUludDE2KGFyZ3NbaV0pO1xuICAgICAgICBsYmwgPSBsdWIobGJsLCBhcmcubGFiZWwpO1xuICAgICAgICBfYXJnc1tpXSA9IGFyZy52YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgX1N0cmluZyA9IG1vbml0b3IuaW5zdGFuY2VzLlN0cmluZ0NvbnN0cnVjdG9yLmhvc3Q7XG4gICAgdmFyIHYgPSBfU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShfU3RyaW5nLCBfYXJncyk7XG4gICAgcmV0dXJuIG5ldyBWYWx1ZSh2LCBsYmwpO1xufSIsImltcG9ydCB7IEVycm9yQ29uc3RydWN0b3IgfSBmcm9tIFwiLi9FcnJvckNvbnN0cnVjdG9yXCI7XG5pbXBvcnQgeyBib3QgfSBmcm9tIFwiLi4vTGFiZWxcIjtcbmltcG9ydCB7IFZhbHVlIH0gZnJvbSBcIi4uL1ZhbHVlXCI7XG5pbXBvcnQgeyBTeW50YXhFcnJvck9iamVjdCB9IGZyb20gXCIuLi9PYmplY3RzL1N5bnRheEVycm9yT2JqZWN0XCI7XG5pbXBvcnQgeyBWYWx1ZVR5cGVzIH0gZnJvbSBcIi4uL0ludGVyZmFjZXNcIjtcbmltcG9ydCB7IE1vbml0b3JCYXNlIH0gZnJvbSBcIi4uL01vbml0b3JCYXNlXCI7XG5cbmRlY2xhcmUgdmFyIG1vbml0b3I6IE1vbml0b3JCYXNlO1xuXG5leHBvcnQgY2xhc3MgU3ludGF4RXJyb3JDb25zdHJ1Y3RvciBleHRlbmRzIEVycm9yQ29uc3RydWN0b3Ige1xuXG4gICAgY29uc3RydWN0b3IoaG9zdCA6IFN5bnRheEVycm9yKSB7XG4gICAgICAgIHN1cGVyKGhvc3QpO1xuICAgIH1cblxuICAgIFNldHVwKCkgOiB2b2lkIHtcbiAgICAgICAgdGhpcy5TZXR1cEJhc2UobW9uaXRvci5pbnN0YW5jZXMuU3ludGF4RXJyb3JQcm90b3R5cGUpO1xuICAgIH1cblxuICAgIENvbnN0cnVjdChhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8U3ludGF4RXJyb3JPYmplY3Q+IHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBhcmdzWzBdIHx8IG5ldyBWYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG4gICAgICAgIHZhciBvID0gbmV3IFN5bnRheEVycm9yT2JqZWN0KG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gbmV3IFZhbHVlKG8sIGJvdCk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgRXJyb3JDb25zdHJ1Y3RvciB9IGZyb20gXCIuL0Vycm9yQ29uc3RydWN0b3JcIjtcbmltcG9ydCB7IGJvdCB9IGZyb20gXCIuLi9MYWJlbFwiO1xuaW1wb3J0IHsgVmFsdWUgfSBmcm9tIFwiLi4vVmFsdWVcIjtcbmltcG9ydCB7IFR5cGVFcnJvck9iamVjdCB9IGZyb20gXCIuLi9PYmplY3RzL1R5cGVFcnJvck9iamVjdFwiO1xuaW1wb3J0IHsgVmFsdWVUeXBlcyB9IGZyb20gXCIuLi9JbnRlcmZhY2VzXCI7XG5pbXBvcnQgeyBNb25pdG9yQmFzZSB9IGZyb20gXCIuLi9Nb25pdG9yQmFzZVwiO1xuXG5kZWNsYXJlIHZhciBtb25pdG9yOiBNb25pdG9yQmFzZTtcblxuZXhwb3J0IGNsYXNzIFR5cGVFcnJvckNvbnN0cnVjdG9yIGV4dGVuZHMgRXJyb3JDb25zdHJ1Y3RvciB7XG5cbiAgICBjb25zdHJ1Y3Rvcihob3N0IDogVHlwZUVycm9yKSB7XG4gICAgICAgIHN1cGVyKGhvc3QpO1xuICAgIH1cblxuICAgIFNldHVwKCkgOiB2b2lkIHtcbiAgICAgICAgdGhpcy5TZXR1cEJhc2UobW9uaXRvci5pbnN0YW5jZXMuVHlwZUVycm9yUHJvdG90eXBlKTtcbiAgICB9XG5cbiAgICBDb25zdHJ1Y3QoYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPFR5cGVFcnJvck9iamVjdD4ge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IGFyZ3NbMF0gfHwgbmV3IFZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgICAgICAgdmFyIG8gPSBuZXcgVHlwZUVycm9yT2JqZWN0KG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gbmV3IFZhbHVlKG8sIGJvdCk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgRXJyb3JDb25zdHJ1Y3RvciB9IGZyb20gXCIuL0Vycm9yQ29uc3RydWN0b3JcIjtcbmltcG9ydCB7IGJvdCB9IGZyb20gXCIuLi9MYWJlbFwiO1xuaW1wb3J0IHsgVmFsdWUgfSBmcm9tIFwiLi4vVmFsdWVcIjtcbmltcG9ydCB7IFVSSUVycm9yT2JqZWN0IH0gZnJvbSBcIi4uL09iamVjdHMvVVJJRXJyb3JPYmplY3RcIjtcbmltcG9ydCB7IE1vbml0b3JCYXNlIH0gZnJvbSBcIi4uL01vbml0b3JCYXNlXCI7XG5pbXBvcnQgeyBWYWx1ZVR5cGVzIH0gZnJvbSBcIi4uL0ludGVyZmFjZXNcIjtcblxuZGVjbGFyZSB2YXIgbW9uaXRvcjogTW9uaXRvckJhc2U7XG5cbmV4cG9ydCBjbGFzcyBVUklFcnJvckNvbnN0cnVjdG9yIGV4dGVuZHMgRXJyb3JDb25zdHJ1Y3RvciB7XG5cbiAgICBjb25zdHJ1Y3Rvcihob3N0KSB7XG4gICAgICAgIHN1cGVyKGhvc3QpO1xuICAgIH1cblxuICAgIFNldHVwKCkgOiB2b2lkIHtcbiAgICAgICAgdGhpcy5TZXR1cEJhc2UobW9uaXRvci5pbnN0YW5jZXMuVVJJRXJyb3JQcm90b3R5cGUpO1xuICAgIH1cblxuICAgIENvbnN0cnVjdChhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8VVJJRXJyb3JPYmplY3Q+e1xuICAgICAgICB2YXIgbWVzc2FnZSA9IGFyZ3NbMF0gfHwgbmV3IFZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgICAgICAgdmFyIG8gPSBuZXcgVVJJRXJyb3JPYmplY3QobWVzc2FnZSk7XG4gICAgICAgIHJldHVybiBuZXcgVmFsdWUobywgYm90KTtcbiAgICB9XG59XG4iLCIvKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLiAqL1xuXG5pbXBvcnQgeyBMYWJlbCwgbHViLCBib3QgfSBmcm9tIFwiLi9MYWJlbFwiO1xuaW1wb3J0IHsgU3RhY2ssIFN0YWNrTWFya2VyIH0gZnJvbSBcIi4vU3RhY2tcIjtcbmltcG9ydCB7IHByZXR0eSB9IGZyb20gXCIuL1BQXCI7XG5pbXBvcnQgeyBWYWx1ZSB9IGZyb20gXCIuL1ZhbHVlXCI7XG5pbXBvcnQgeyBFY21hT2JqZWN0IH0gZnJvbSAnLi9PYmplY3RzL0VjbWFPYmplY3QnO1xuaW1wb3J0IHsgTW9uaXRvckJhc2UgfSBmcm9tIFwiLi9Nb25pdG9yQmFzZVwiO1xuaW1wb3J0IHsgTGV4aWNhbEVudmlyb25tZW50IH0gZnJvbSBcIi4vTGV4aWNhbEVudmlyb25tZW50XCI7XG5pbXBvcnQgeyBSZXN1bHQgfSBmcm9tIFwiLi9SZXN1bHRcIjtcbmltcG9ydCAqIGFzIGVzdHJlZSBmcm9tICdlc3RyZWUnO1xuaW1wb3J0IHsgVmFsdWVUeXBlcywgSUVjbWFGdW5jdGlvbiwgSUVjbWFPYmplY3QgfSBmcm9tIFwiLi9JbnRlcmZhY2VzXCI7XG5pbXBvcnQgeyBSZWZlcmVuY2UgfSBmcm9tIFwiLi9SZWZlcmVuY2VcIjtcbmltcG9ydCB7IEFycmF5T2JqZWN0IH0gZnJvbSBcIi4vT2JqZWN0cy9BcnJheU9iamVjdFwiO1xuaW1wb3J0IHsgT2JqZWN0T2JqZWN0IH0gZnJvbSBcIi4vT2JqZWN0cy9PYmplY3RPYmplY3RcIjtcbmltcG9ydCB7IFRhc2sgfSBmcm9tIFwiLi9FbmdpbmUvVGFza1wiO1xuaW1wb3J0IHsgTm9kZSB9IGZyb20gXCJlc3RyZWVcIjtcblxuLy8gLS0tIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmRlY2xhcmUgdmFyIG1vbml0b3I6IE1vbml0b3JCYXNlO1xuXG4vLyAtLS0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY2xhc3MgQnVja2V0PFQ+IHtcbiAgZWxlbWVudDogVDtcbiAgbmV4dDogQnVja2V0PFQ+IHwgbnVsbDtcbiAgcHJldjogQnVja2V0PFQ+IHwgbnVsbDtcblxuICBjb25zdHJ1Y3RvcihlbGVtZW50IDogVCwgcHJldiA6IEJ1Y2tldDxUPiB8IG51bGwsIG5leHQgOiBCdWNrZXQ8VD4gfCBudWxsKSB7XG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLm5leHQgPSBuZXh0IHx8IG51bGw7XG4gICAgdGhpcy5wcmV2ID0gcHJldiB8fCBudWxsO1xuICB9XG59XG5cbi8vIC0tLSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgaW50ZXJmYWNlIEZ1bmN0aW9uR3VhcmQge1xuICB0aHJvdz86IGJvb2xlYW4sXG4gIGNvbnRpbnVlPzogYm9vbGVhbixcbiAgYnJlYWs/OiBib29sZWFuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR3VhcmRlZEZ1bmN0aW9uIGV4dGVuZHMgRnVuY3Rpb24ge1xuICBydW5mb3I/OiBGdW5jdGlvbkd1YXJkO1xufVxuXG5leHBvcnQgdHlwZSBBcnJheUV4cHJlc3Npb25DbG9zdXJlRGF0YSA9IHsgYXJyYXkgOiBWYWx1ZTxBcnJheU9iamVjdD4sIGluZGV4IDogbnVtYmVyIH07XG5leHBvcnQgdHlwZSBPYmplY3RFeHByZXNzaW9uQ2xvc3VyZURhdGEgPSB7IHByb3BlcnRpZXM6IGVzdHJlZS5Qcm9wZXJ0eVtdLCBvYmplY3Q6IFZhbHVlPE9iamVjdE9iamVjdD4sIGluZGV4OiBudW1iZXIgfTtcbmV4cG9ydCB0eXBlIFNlcXVlbmNlRXhwcmVzc2lvbkNsb3N1cmVEYXRhID0geyBsZW5ndGggOiBudW1iZXIgfTtcbmV4cG9ydCB0eXBlIENvbmRpdGlvbmFsRXhwcmVzc2lvbkNob2ljZURhdGEgPSB7IG5vZGUgOiBlc3RyZWUuQ29uZGl0aW9uYWxFeHByZXNzaW9uIH07XG5leHBvcnQgdHlwZSBDb25kaXRpb25hbEV4cHJlc3Npb25DbG9zdXJlRGF0YSA9IHsgdGVzdCA6IFZhbHVlPFZhbHVlVHlwZXM+IH07IFxuZXhwb3J0IHR5cGUgQ2FsbEV4cHJlc3Npb25FeGVjdXRlQ2xvc3VyZURhdGEgPSB7IGxlbmd0aCA6IG51bWJlciwgbm9kZSA6IGVzdHJlZS5DYWxsRXhwcmVzc2lvbiB9O1xuZXhwb3J0IHR5cGUgQ2FsbEV4cHJlc3Npb25DbG9zdXJlRGF0YSA9IHsgbGFiZWwgOiBMYWJlbCB9O1xuZXhwb3J0IHR5cGUgTWVtYmVyRXhwcmVzc2lvbkNsb3N1cmVEYXRhID0geyBub2RlIDogZXN0cmVlLk1lbWJlckV4cHJlc3Npb24gfTtcbmV4cG9ydCB0eXBlIElmU3RhdGVtZW50Q2hvaWNlRGF0YSA9IHsgbm9kZSA6IGVzdHJlZS5JZlN0YXRlbWVudCB9O1xuZXhwb3J0IHR5cGUgSWZTdGF0ZW1lbnRDbG9zdXJlRGF0YSA9IHsgbGFiZWwgOiBMYWJlbCB9O1xuZXhwb3J0IHR5cGUgU3dpdGNoU3RhdGVtZW50Q2xvc3VyZURhdGEgPSB7IG5vZGUgOiBlc3RyZWUuU3dpdGNoU3RhdGVtZW50LCBvdXRlckVtcHR5TGFiZWxEYXRhIDogeyBsYWJlbCA6IExhYmVsLCBwY21hcmtlciA6U3RhY2tNYXJrZXJ9LCBkZWZhdWx0Q2FzZUluZGV4IDogbnVtYmVyIHwgbnVsbCwgbmV4dENhc2UgOiBudW1iZXIgfTtcbmV4cG9ydCB0eXBlIExhYmVsZWRTdGF0ZW1lbnRDbG9zdXJlRGF0YSA9IHsgbmFtZSA6IHN0cmluZywgb3V0ZXJsYWJlbCA6IExhYmVsLCBwY21hcmtlciA6U3RhY2tNYXJrZXIsIHZzbWFya2VyOiBTdGFja01hcmtlciB9O1xuZXhwb3J0IHR5cGUgV2l0aFN0YXRlbWVudEJvZHlDbG9zdXJlRGF0YSA9IHsgbm9kZSA6IGVzdHJlZS5XaXRoU3RhdGVtZW50IH07XG5leHBvcnQgdHlwZSBXaXRoU3RhdGVtZW50Q2xvc3VyZURhdGEgPSB7IGxleGljYWxFbnYgOiBWYWx1ZTxMZXhpY2FsRW52aXJvbm1lbnQ+IH07XG5leHBvcnQgdHlwZSBUcnlTdGF0ZW1lbnRDYXRjaENsb3N1cmVEYXRhID0geyBoYW5kbGVyIDogZXN0cmVlLkNhdGNoQ2xhdXNlLCBwY21hcmtlciA6U3RhY2tNYXJrZXIsIHZzbWFya2VyOiBTdGFja01hcmtlciwgZXhjIDogTGFiZWwgfTtcbmV4cG9ydCB0eXBlIFRyeVN0YXRlbWVudEZpbmFsbHlDbG9zdXJlRGF0YSA9IHsgYm9keSA6IGVzdHJlZS5CbG9ja1N0YXRlbWVudCB8IG51bGwgfCB1bmRlZmluZWQsIHBjbWFya2VyIDpTdGFja01hcmtlciwgdnNtYXJrZXI6IFN0YWNrTWFya2VyLCBsZXhpY2FsRW52IDogVmFsdWU8TGV4aWNhbEVudmlyb25tZW50PiB9O1xuZXhwb3J0IHR5cGUgVHJ5U3RhdGVtZW50Q2xvc3VyZURhdGEgPSB7IHJlc3VsdCA6IFJlc3VsdCB9O1xuZXhwb3J0IHR5cGUgV2hpbGVTdGF0ZW1lbnRDbG9zdXJlRGF0YSA9IHsgbm9kZSA6IGVzdHJlZS5XaGlsZVN0YXRlbWVudCB8IGVzdHJlZS5Eb1doaWxlU3RhdGVtZW50LCBvdXRlckVtcHR5TGFiZWxEYXRhIDogeyBsYWJlbCA6IExhYmVsLCBwY21hcmtlciA6IFN0YWNrTWFya2VyIH19O1xuZXhwb3J0IHR5cGUgRm9yU3RhdGVtZW50TWFpbkNsb3N1cmVEYXRhID0geyBub2RlIDogZXN0cmVlLkZvclN0YXRlbWVudCB9O1xuZXhwb3J0IHR5cGUgRm9yU3RhdGVtZW50Q2xvc3VyZURhdGEgPSB7IG91dGVyRW1wdHlMYWJlbERhdGEgOiB7IGxhYmVsIDogTGFiZWwsIHBjbWFya2VyIDogU3RhY2tNYXJrZXIgfX07XG5leHBvcnQgdHlwZSBGb3JJblN0YXRlbWVudFNldHVwQ2xvc3VyZURhdGEgPSB7IG5vZGUgOiBlc3RyZWUuRm9ySW5TdGF0ZW1lbnQsIGxlZnQgOiBlc3RyZWUuUGF0dGVybn07XG5leHBvcnQgdHlwZSBGb3JJbkV4ZWN1dGVDbG9zdXJlRGF0YSA9IHsgbm9kZSA6IGVzdHJlZS5Gb3JJblN0YXRlbWVudCwgbGVmdCA6IGVzdHJlZS5QYXR0ZXJuLCBwcm9wZXJ0aWVzOiAgVmFsdWU8c3RyaW5nPltdLCBvdXRlckVtcHR5TGFiZWxEYXRhIDogeyBsYWJlbCA6IExhYmVsLCBwY21hcmtlciA6IFN0YWNrTWFya2VyIH19O1xuZXhwb3J0IHR5cGUgVmFyaWFibGVEZWNsYXJhdGlvbkNsb3N1cmVEYXRhID0geyBsaHMgOiBSZWZlcmVuY2UgfTtcbmV4cG9ydCB0eXBlIEFzeW5jQ29uc3RydWN0Q2xvc3VyZURhdGEgPSB7IG9iamVjdDogRWNtYU9iamVjdCB9O1xuXG50eXBlIENsb3N1cmVEYXRhID0gXG4gICAgQXJyYXlFeHByZXNzaW9uQ2xvc3VyZURhdGFcbiAgfCBPYmplY3RFeHByZXNzaW9uQ2xvc3VyZURhdGFcbiAgfCBTZXF1ZW5jZUV4cHJlc3Npb25DbG9zdXJlRGF0YVxuICB8IENvbmRpdGlvbmFsRXhwcmVzc2lvbkNob2ljZURhdGEgXG4gIHwgQ29uZGl0aW9uYWxFeHByZXNzaW9uQ2xvc3VyZURhdGFcbiAgfCBDYWxsRXhwcmVzc2lvbkV4ZWN1dGVDbG9zdXJlRGF0YVxuICB8IENhbGxFeHByZXNzaW9uQ2xvc3VyZURhdGFcbiAgfCBNZW1iZXJFeHByZXNzaW9uQ2xvc3VyZURhdGFcbiAgfCBJZlN0YXRlbWVudENob2ljZURhdGFcbiAgfCBJZlN0YXRlbWVudENsb3N1cmVEYXRhXG4gIHwgU3dpdGNoU3RhdGVtZW50Q2xvc3VyZURhdGFcbiAgfCBMYWJlbGVkU3RhdGVtZW50Q2xvc3VyZURhdGFcbiAgfCBXaXRoU3RhdGVtZW50Qm9keUNsb3N1cmVEYXRhXG4gIHwgV2l0aFN0YXRlbWVudENsb3N1cmVEYXRhXG4gIHwgVHJ5U3RhdGVtZW50Q2F0Y2hDbG9zdXJlRGF0YSBcbiAgfCBUcnlTdGF0ZW1lbnRGaW5hbGx5Q2xvc3VyZURhdGFcbiAgfCBUcnlTdGF0ZW1lbnRDbG9zdXJlRGF0YVxuICB8IFdoaWxlU3RhdGVtZW50Q2xvc3VyZURhdGFcbiAgfCBGb3JTdGF0ZW1lbnRNYWluQ2xvc3VyZURhdGFcbiAgfCBGb3JTdGF0ZW1lbnRDbG9zdXJlRGF0YVxuICB8IEZvckluU3RhdGVtZW50U2V0dXBDbG9zdXJlRGF0YVxuICB8IEZvckluRXhlY3V0ZUNsb3N1cmVEYXRhXG4gIHwgVmFyaWFibGVEZWNsYXJhdGlvbkNsb3N1cmVEYXRhXG4gIHwgQXN5bmNDb25zdHJ1Y3RDbG9zdXJlRGF0YTtcblxuXG5leHBvcnQgdHlwZSBWYWx1ZVN0YWNrID0gU3RhY2s8VmFsdWU8VmFsdWVUeXBlcz4gfCBSZWZlcmVuY2UgfCBSZXN1bHQ+O1xuXG5leHBvcnQgaW50ZXJmYWNlIENsb3N1cmUge1xuICBmdW5jOiBHdWFyZGVkRnVuY3Rpb24gLyp8IGVzdHJlZS5TdGF0ZW1lbnQgfCBlc3RyZWUuRXhwcmVzc2lvbiovLCBkYXRhOiBDbG9zdXJlRGF0YVxufVxuXG50eXBlIFdvcmtMaXN0U291cmNlVHlwZSA9IFxuICAgIGVzdHJlZS5Qcm9ncmFtIFxuICB8IGVzdHJlZS5TdGF0ZW1lbnQgXG4gIHwgZXN0cmVlLkV4cHJlc3Npb24gXG4gIHwgZXN0cmVlLlNwcmVhZEVsZW1lbnQgXG4gIHwgZXN0cmVlLk9iamVjdFBhdHRlcm5cbiAgfCBlc3RyZWUuQXJyYXlQYXR0ZXJuXG4gIHwgZXN0cmVlLlJlc3RFbGVtZW50XG4gIHwgZXN0cmVlLkFzc2lnbm1lbnRQYXR0ZXJuXG4gIHwgZXN0cmVlLlN1cGVyXG4gIDtcblxuZXhwb3J0IHR5cGUgV29ya0xpc3RFbGVtZW50VHlwZSA9XG4gICAgR3VhcmRlZEZ1bmN0aW9uIFxuICB8IENsb3N1cmVcbiAgfCBXb3JrTGlzdFNvdXJjZVR5cGVcbiAgfCBUYXNrXG4gIDtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzR3VhcmRlZEZ1bmN0aW9uKGVsOiBXb3JrTGlzdEVsZW1lbnRUeXBlKTogZWwgaXMgR3VhcmRlZEZ1bmN0aW9uIHtcbiAgcmV0dXJuICg8R3VhcmRlZEZ1bmN0aW9uPmVsKS5ydW5mb3IgIT09IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQ2xvc3VyZShlbDogV29ya0xpc3RFbGVtZW50VHlwZSk6IGVsIGlzIENsb3N1cmUge1xuICByZXR1cm4gKDxDbG9zdXJlPmVsKS5mdW5jICE9PSB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBjbGFzcyBXb3JrTGlzdCB7XG5cbiAgbGVuZ3RoOiBudW1iZXIgPSAwO1xuICBoZWFkOiBCdWNrZXQ8V29ya0xpc3RFbGVtZW50VHlwZT4gfCBudWxsID0gbnVsbDtcbiAgdGhlbmxvYzogQnVja2V0PFdvcmtMaXN0RWxlbWVudFR5cGU+IHwgbnVsbCA9IG51bGw7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gIH1cblxuICAvLyAtLS1cblxuICB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgIHZhciBwb3MgPSB0aGlzLmhlYWQ7XG4gICAgdmFyIHN0ciA9ICd3b3JrbGlzdDonO1xuICAgIHZhciBjbnQgPSAxO1xuICAgIHdoaWxlIChwb3MpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gcG9zLmVsZW1lbnQ7XG4gICAgICB2YXIgbGluZTtcbiAgICAgIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBsaW5lID0gY250ICsgJzogJyArIFN0cmluZyhlbGVtZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoJ2Z1bmMnIGluIGVsZW1lbnQgJiYgJ2RhdGEnIGluIGVsZW1lbnQpIHtcbiAgICAgICAgbGluZSA9IGNudCArICc6ICcgKyBTdHJpbmcoZWxlbWVudC5mdW5jKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vQHRzLWlnbm9yZSBUWVBFU1xuICAgICAgICBsaW5lID0gY250ICsgJzogJyArIGVsZW1lbnQudHlwZSArICcgJyArIHByZXR0eShlbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgbGV0IGl4ID0gbGluZS5pbmRleE9mKCdcXG4nKTtcbiAgICAgIGlmIChpeCA+IDApIHtcbiAgICAgICAgbGluZSA9IGxpbmUuc2xpY2UoMCwgaXgpO1xuICAgICAgfVxuXG4gICAgICBzdHIgPSBzdHIgKyAnXFxuJyArIGxpbmU7XG4gICAgICBwb3MgPSBwb3MubmV4dDtcbiAgICAgIGNudCsrO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgLy8gLS0tXG5cbiAgcHVzaChlbGVtZW50OiBXb3JrTGlzdEVsZW1lbnRUeXBlKTogdm9pZCB7XG4gICAgdGhpcy5oZWFkID0gbmV3IEJ1Y2tldChlbGVtZW50LCBudWxsLCB0aGlzLmhlYWQpO1xuXG4gICAgaWYgKHRoaXMuaGVhZC5uZXh0ICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmhlYWQubmV4dC5wcmV2ID0gdGhpcy5oZWFkO1xuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoKys7XG4gIH1cblxuICAvLyAtLS1cblxuICBwcmVwZW5kKGVsZW1lbnRzOiBXb3JrTGlzdEVsZW1lbnRUeXBlW10pIHtcbiAgICBmb3IgKHZhciBpID0gZWxlbWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHRoaXMucHVzaChlbGVtZW50c1tpXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gLS0tXG5cbiAgcGVlaygpOiBXb3JrTGlzdEVsZW1lbnRUeXBlIHtcbiAgICBpZiAodGhpcy5oZWFkID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbW9uaXRvci5mYXRhbChcIldvcmtMaXN0LnBlZWsoKSBlbXB0eSB3b3JrIGxpc3RcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmhlYWQuZWxlbWVudDtcbiAgfVxuXG4gIC8vIC0tLVxuXG4gIHBvcCgpOiBXb3JrTGlzdEVsZW1lbnRUeXBlIHtcbiAgICBpZiAodGhpcy5oZWFkID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbW9uaXRvci5mYXRhbChcIldvcmtMaXN0LnBvcCgpIGVtcHR5IHdvcmsgbGlzdFwiKTtcbiAgICB9XG4gICAgbGV0IGVsZW1lbnQgPSB0aGlzLmhlYWQuZWxlbWVudDtcbiAgICB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcbiAgICB0aGlzLmxlbmd0aC0tO1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgLy8gLS0tXG5cbiAgZW1wdHkoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICh0aGlzLmhlYWQgPT09IG51bGwpO1xuICB9XG5cbiAgLy8gLS0tXG5cbiAgdG9wKCk6IFdvcmtMaXN0UHRyIHtcbiAgICByZXR1cm4gbmV3IFdvcmtMaXN0UHRyKHRoaXMsIG51bGwpO1xuICB9XG5cbiAgLy8gLS0tXG5cbiAgZmlyc3QoZWxlbWVudD86IFdvcmtMaXN0RWxlbWVudFR5cGUpOiB2b2lkIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdGhpcy5wdXNoKGVsZW1lbnQpO1xuICAgICAgdGhpcy50aGVubG9jID0gdGhpcy5oZWFkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBubyBlbGVtZW50IGdpdmVuLCByZXNldCB0aGVubG9jIHRvIGZvcmNlIG5leHQgY2FsbGVkICd0aGVuJ1xuICAgICAgLy8gdG8gYmUgYSAnZmlyc3QnXG4gICAgICB0aGlzLnRoZW5sb2MgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8vIC0tLVxuXG4gIHRoZW4oZWxlbWVudDogV29ya0xpc3RFbGVtZW50VHlwZSk6IHZvaWQge1xuICAgIGlmICghdGhpcy50aGVubG9jKSB7XG5cbiAgICAgIHRoaXMuZmlyc3QoZWxlbWVudCk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBsZXQgYmVmb3JlID0gdGhpcy50aGVubG9jO1xuICAgICAgbGV0IGFmdGVyID0gdGhpcy50aGVubG9jLm5leHQ7XG5cbiAgICAgIGxldCBidWNrZXQgPSBuZXcgQnVja2V0PFdvcmtMaXN0RWxlbWVudFR5cGU+KGVsZW1lbnQsIGJlZm9yZSwgYWZ0ZXIpO1xuXG4gICAgICBiZWZvcmUubmV4dCA9IGJ1Y2tldDtcbiAgICAgIHRoaXMudGhlbmxvYyA9IGJlZm9yZS5uZXh0O1xuXG4gICAgICBpZiAoYWZ0ZXIpIHtcbiAgICAgICAgYWZ0ZXIucHJldiA9IGJlZm9yZS5uZXh0O1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH1cbiAgfVxuXG59XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjbGFzcyBXb3JrTGlzdFB0ciB7XG5cbiAgd29ya2xpc3Q6IFdvcmtMaXN0O1xuICBwb3M6IEJ1Y2tldDxXb3JrTGlzdEVsZW1lbnRUeXBlPiB8IG51bGw7XG5cbiAgY29uc3RydWN0b3Iod29ya2xpc3Q6IFdvcmtMaXN0LCBwb3M6IEJ1Y2tldDxGdW5jdGlvbj4gfCBudWxsKSB7XG4gICAgdGhpcy53b3JrbGlzdCA9IHdvcmtsaXN0O1xuICAgIHRoaXMucG9zID0gcG9zO1xuICB9XG5cbiAgdGhlbihlbGVtZW50OiBXb3JrTGlzdEVsZW1lbnRUeXBlLCBkYXRhPzogQ2xvc3VyZURhdGEpIDogV29ya0xpc3RQdHIge1xuXG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICB0aHJvdyBFcnJvcigpO1xuICAgIH1cblxuICAgIGxldCB0aGluZzogV29ya0xpc3RFbGVtZW50VHlwZSA9IGVsZW1lbnQ7XG4gICAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnZnVuY3Rpb24nICYmIGRhdGEpIHtcbiAgICAgIHRoaW5nID0geyBmdW5jOiBlbGVtZW50LCBkYXRhOiBkYXRhIH07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucG9zKSB7XG4gICAgICBsZXQgYmVmb3JlID0gdGhpcy5wb3M7XG4gICAgICBsZXQgYWZ0ZXIgPSB0aGlzLnBvcy5uZXh0O1xuXG4gICAgICBsZXQgYnVja2V0ID0gbmV3IEJ1Y2tldDxXb3JrTGlzdEVsZW1lbnRUeXBlPih0aGluZywgYmVmb3JlLCBhZnRlcik7XG5cbiAgICAgIGJlZm9yZS5uZXh0ID0gYnVja2V0O1xuICAgICAgdGhpcy5wb3MgPSBiZWZvcmUubmV4dDtcblxuICAgICAgaWYgKGFmdGVyKSB7XG4gICAgICAgIGFmdGVyLnByZXYgPSBiZWZvcmUubmV4dDtcbiAgICAgIH1cblxuICAgICAgdGhpcy53b3JrbGlzdC5sZW5ndGgrKztcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHRoaXMud29ya2xpc3QucHVzaCh0aGluZyk7XG4gICAgICB0aGlzLnBvcyA9IHRoaXMud29ya2xpc3QuaGVhZDtcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFRoZSBFeGVjdXRpb24gQ29udGV4dFxuXG5cbmV4cG9ydCBjbGFzcyBDb250ZXh0IHtcblxuICB0aGlzVmFsdWU6IFZhbHVlPElFY21hT2JqZWN0PjtcbiAgdmFyaWFibGVFbnY6IFZhbHVlPExleGljYWxFbnZpcm9ubWVudD47XG4gIGxleGljYWxFbnY6IFZhbHVlPExleGljYWxFbnZpcm9ubWVudD47XG5cbiAgcGNTdGFjazogU3RhY2s8TGFiZWw+O1xuXG4gIC8vIGZvciBzdGFjayB0cmFjZVxuICBvd25lcj86IHN0cmluZztcblxuICBjb2RlU3RhY2sgOiBTdGFjazxOb2RlPjtcblxuICAvLyB3aHkgYm90aD9cbiAgY3VycmVudENhbGw/IDogeyBcbiAgICByZWZlcmVuY2UgOiBWYWx1ZTxWYWx1ZVR5cGVzPiB8IFJlZmVyZW5jZSxcbiAgICB0YXJnZXQgOiBJRWNtYUZ1bmN0aW9uLFxuICAgIHNvdXJjZSA6IGVzdHJlZS5DYWxsRXhwcmVzc2lvblxuICB9XG5cbiAgLy8gd2h5IGJvdGg/XG4gIGNhbGw/IDoge1xuICAgIHJlZiA6IFZhbHVlPFZhbHVlVHlwZXM+IHwgUmVmZXJlbmNlLFxuICAgIGZ1bmMgOiBWYWx1ZTxJRWNtYUZ1bmN0aW9uPlxuICB9XG5cbiAgbGFiZWxzID0gbmV3IGNsYXNzIHtcblxuICAgIHByaXZhdGUgZXhjTGJsOiBMYWJlbCA9IGJvdDtcbiAgICBwcml2YXRlIHJldExibDogTGFiZWwgPSBib3Q7XG5cbiAgICBsYWJlbG1hcDogeyBba2V5OiBzdHJpbmddOiB7IGxhYmVsIDogTGFiZWwsIHBjbWFya2VyIDogU3RhY2tNYXJrZXJ9IH0gPSB7fTtcblxuICAgIG91dGVyOiBDb250ZXh0O1xuXG4gICAgY29uc3RydWN0b3Iob3V0ZXI6IENvbnRleHQpIHtcbiAgICAgIHRoaXMub3V0ZXIgPSBvdXRlcjtcbiAgICB9XG5cbiAgICBnZXQgZXhjKCk6IExhYmVsIHtcbiAgICAgIGlmIChtb25pdG9yLm9wdGlvbnMuZ2V0KCdtb25pdG9yLnRhaW50TW9kZScpKSB7XG4gICAgICAgIHJldHVybiBib3Q7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmV4Y0xibDtcbiAgICB9XG5cbiAgICBzZXQgZXhjKGw6IExhYmVsKSB7XG4gICAgICB0aGlzLmV4Y0xibCA9IGw7XG4gICAgfVxuXG4gICAgZ2V0IHJldCgpOiBMYWJlbCB7XG4gICAgICBpZiAobW9uaXRvci5vcHRpb25zLmdldCgnbW9uaXRvci50YWludE1vZGUnKSkge1xuICAgICAgICByZXR1cm4gYm90O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5yZXRMYmw7XG4gICAgfVxuXG4gICAgc2V0IHJldChsOiBMYWJlbCkge1xuICAgICAgdGhpcy5yZXRMYmwgPSBsO1xuICAgIH1cblxuICAgIGdldCBwYygpOiBMYWJlbCB7XG4gICAgICBpZiAobW9uaXRvci5vcHRpb25zLmdldCgnbW9uaXRvci50YWludE1vZGUnKSkge1xuICAgICAgICByZXR1cm4gYm90O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5vdXRlci5wY1N0YWNrLnBlZWsoKTtcbiAgICB9XG5cbiAgICBzZXQgcGMobDogTGFiZWwpIHtcbiAgICAgIHRoaXMub3V0ZXIucGNTdGFjay5wb3AoKTtcbiAgICAgIHRoaXMub3V0ZXIucGNTdGFjay5wdXNoKGwpO1xuICAgIH1cbiAgfSh0aGlzKTtcblxuXG4gIHdvcmtMaXN0OiBXb3JrTGlzdDtcbiAgLy8gVE9ETzogbWFrZSBhbnkgbW9yZSBwcmVjaXNlXG4gIHJlc3VsdDogUmVzdWx0O1xuICB2YWx1ZVN0YWNrOiBTdGFjazxWYWx1ZTxWYWx1ZVR5cGVzPiB8IFJlZmVyZW5jZSB8IFJlc3VsdD47XG5cblxuICBjb25zdHJ1Y3Rvcih0aGlzVmFsdWU6IFZhbHVlPElFY21hT2JqZWN0PiwgdmFyaWFibGVFbnY6IFZhbHVlPExleGljYWxFbnZpcm9ubWVudD4sIGxleGljYWxFbnY6IFZhbHVlPExleGljYWxFbnZpcm9ubWVudD4pIHtcblxuICAgIHRoaXMudGhpc1ZhbHVlID0gdGhpc1ZhbHVlO1xuICAgIHRoaXMudmFyaWFibGVFbnYgPSB2YXJpYWJsZUVudjtcbiAgICB0aGlzLmxleGljYWxFbnYgPSBsZXhpY2FsRW52O1xuXG4gICAgdGhpcy5wY1N0YWNrID0gbmV3IFN0YWNrKCk7XG4gICAgdGhpcy5wY1N0YWNrLnB1c2goYm90KTtcblxuICAgIHRoaXMud29ya0xpc3QgPSBuZXcgV29ya0xpc3QoKTtcbiAgICB0aGlzLnJlc3VsdCA9IG5ldyBSZXN1bHQoKTtcbiAgICB0aGlzLnZhbHVlU3RhY2sgPSBuZXcgU3RhY2soKTtcblxuICAgIHRoaXMuY29kZVN0YWNrID0gbmV3IFN0YWNrKCk7XG4gIH1cblxuICAvLyAtLS1cblxuICBnZXQgZWZmZWN0aXZlUEMoKTogTGFiZWwge1xuICAgIGlmIChtb25pdG9yLm9wdGlvbnMuZ2V0KCdtb25pdG9yLnRhaW50TW9kZScpKSB7XG4gICAgICByZXR1cm4gYm90O1xuICAgIH1cblxuICAgIHJldHVybiBsdWIodGhpcy5sYWJlbHMucGMsIHRoaXMubGFiZWxzLmV4YywgdGhpcy5sYWJlbHMucmV0KTtcbiAgfVxuXG4gIC8vIC0tLVxuXG4gIGNsb25lKHRoaXNWYWx1ZT86IFZhbHVlPElFY21hT2JqZWN0PiwgdmFyaWFibGVFbnY/OiBWYWx1ZTxMZXhpY2FsRW52aXJvbm1lbnQ+LCBsZXhpY2FsRW52PzogVmFsdWU8TGV4aWNhbEVudmlyb25tZW50Pikge1xuXG4gICAgbGV0IHRWID0gdGhpc1ZhbHVlIHx8IHRoaXMudGhpc1ZhbHVlO1xuICAgIGxldCBsRSA9IGxleGljYWxFbnYgfHwgdGhpcy5sZXhpY2FsRW52O1xuICAgIGxldCB2RSA9IHZhcmlhYmxlRW52IHx8IHRoaXMudmFyaWFibGVFbnY7XG5cbiAgICBsZXQgbmV3Q3R4ID0gbmV3IENvbnRleHQodFYsIHZFLCBsRSk7XG4gICAgbmV3Q3R4LmxhYmVscy5wYyA9IHRoaXMuZWZmZWN0aXZlUEM7XG4gICAgbmV3Q3R4LmxhYmVscy5leGMgPSB0aGlzLmxhYmVscy5leGM7XG4gICAgbmV3Q3R4LmxhYmVscy5yZXQgPSB0aGlzLmxhYmVscy5yZXQ7XG4gICAgcmV0dXJuIG5ld0N0eDtcbiAgfVxuXG4gIC8vIC0tLVxuXG4gIHB1c2hQQyhsOiBMYWJlbCk6IHZvaWQge1xuICAgIHRoaXMucGNTdGFjay5wdXNoKGx1YihsLCB0aGlzLmxhYmVscy5wYykpO1xuICB9XG5cbiAgLy8gLS0tXG5cbiAgcmFpc2VQQyhsOiBMYWJlbCk6IHZvaWQge1xuICAgIHRoaXMubGFiZWxzLnBjID0gbHViKHRoaXMubGFiZWxzLnBjLCBsKTtcbiAgfVxuXG4gIC8vIC0tLVxuXG4gIHBvcFBDKCk6IExhYmVsIHtcbiAgICByZXR1cm4gdGhpcy5wY1N0YWNrLnBvcCgpO1xuICB9XG5cbn0iLCJpbXBvcnQgeyBWYWx1ZSB9IGZyb20gXCIuLi9WYWx1ZVwiO1xuaW1wb3J0IHsgVmFsdWVUeXBlcyB9IGZyb20gXCIuLi9JbnRlcmZhY2VzXCI7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFRvQm9vbGVhbiwgOS4yXG5cbmV4cG9ydCBmdW5jdGlvbiBUb0Jvb2xlYW4oeDogVmFsdWU8VmFsdWVUeXBlcz4pOiBWYWx1ZTxib29sZWFuPiB7XG4gIHJldHVybiBuZXcgVmFsdWUoQm9vbGVhbih4LnZhbHVlKSwgeC5sYWJlbCk7XG59IiwiaW1wb3J0IHsgVG9OdW1iZXIgfSBmcm9tIFwiLi9Ub051bWJlclwiO1xuaW1wb3J0IHsgVmFsdWUgfSBmcm9tIFwiLi4vVmFsdWVcIjtcbmltcG9ydCB7IFZhbHVlVHlwZXMgfSBmcm9tIFwiLi4vSW50ZXJmYWNlc1wiO1xuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gVG9JbnQzMiwgOS41XG5cbiAgZXhwb3J0IGZ1bmN0aW9uIFRvSW50MzIoeCA6IFZhbHVlPFZhbHVlVHlwZXM+KSA6IFZhbHVlPG51bWJlcj4ge1xuICAgIHJldHVybiBUb051bWJlcih4KTtcbiAgfVxuIiwiaW1wb3J0IHsgVmFsdWUgfSBmcm9tIFwiLi4vVmFsdWVcIjtcbmltcG9ydCB7IFRvTnVtYmVyIH0gZnJvbSBcIi4vVG9OdW1iZXJcIjtcbmltcG9ydCB7IFZhbHVlVHlwZXMgfSBmcm9tIFwiLi4vSW50ZXJmYWNlc1wiO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBUb0ludGVnZXIsIDkuNFxuLy8gICAgICAgIFVzaW5nIFRvTnVtYmVyIHRvIGNhcHR1cmUgdGhlIFRvUHJpbWl0aXZlXG4vLyAgICAgICAgYW5kIHJlbHkgb24gdGhlIGludGVybmFsIGNvbnZlcnNpb24gYXQgdGhlIHBvaW50IG9mIHVzZVxuLy8gICAgICAgIHNob3VsZCBzdWZmaWNlLlxuXG5leHBvcnQgZnVuY3Rpb24gVG9JbnRlZ2VyKHg6IFZhbHVlPFZhbHVlVHlwZXM+KTogVmFsdWU8bnVtYmVyPiB7XG4gIGxldCBudW1iZXIgPSBUb051bWJlcih4KTtcblxuICBpZiAoaXNOYU4obnVtYmVyLnZhbHVlKSkge1xuICAgIHJldHVybiBuZXcgVmFsdWUoMCwgbnVtYmVyLmxhYmVsKTtcbiAgfVxuICBlbHNlIGlmIChudW1iZXIudmFsdWUgPT09IDAgfHxcbiAgICBudW1iZXIudmFsdWUgPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSB8fFxuICAgIG51bWJlci52YWx1ZSA9PT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKSB7XG4gICAgcmV0dXJuIG51bWJlcjtcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gbmV3IFZhbHVlKFxuICAgICAgc2lnbihudW1iZXIudmFsdWUpICogTWF0aC5mbG9vcihNYXRoLmFicyhudW1iZXIudmFsdWUpKSxcbiAgICAgIG51bWJlci5sYWJlbFxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2lnbihuOiBudW1iZXIpOiAxIHwgMCB8IC0xIHtcbiAgaWYgKG4gPiAwKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgZWxzZSBpZiAobiA8IDApIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICByZXR1cm4gMDtcbn0iLCJpbXBvcnQgeyBWYWx1ZSB9IGZyb20gXCIuLi9WYWx1ZVwiO1xuaW1wb3J0IHsgTW9uaXRvckJhc2UgfSBmcm9tICcuLi9Nb25pdG9yQmFzZSc7XG5cbmltcG9ydCB7IFRvUHJpbWl0aXZlIH0gZnJvbSAnLi9Ub1ByaW1pdGl2ZSc7XG5pbXBvcnQgeyBWYWx1ZVR5cGVzIH0gZnJvbSBcIi4uL0ludGVyZmFjZXNcIjtcblxuZGVjbGFyZSB2YXIgbW9uaXRvcjogTW9uaXRvckJhc2U7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFRvTnVtYmVyLCA5LjNcblxuZXhwb3J0IGZ1bmN0aW9uIFRvTnVtYmVyKHggOiBWYWx1ZTxWYWx1ZVR5cGVzPikge1xuICAgIGlmICh0eXBlb2YgeC52YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZShOdW1iZXIoeC52YWx1ZSksIHgubGFiZWwpO1xuICAgIH1cblxuICAgIG1vbml0b3IuY29udGV4dC5wdXNoUEMoeC5sYWJlbCk7XG4gICAgdmFyIHByaW1WYWx1ZSA9IFRvUHJpbWl0aXZlKHgsICdudW1iZXInKTtcbiAgICBtb25pdG9yLmNvbnRleHQucG9wUEMoKTtcblxuICAgIHJldHVybiBuZXcgVmFsdWUoTnVtYmVyKHByaW1WYWx1ZS52YWx1ZSksIHByaW1WYWx1ZS5sYWJlbCk7XG59IiwiaW1wb3J0IHsgVmFsdWUgfSBmcm9tIFwiLi4vVmFsdWVcIjtcbmltcG9ydCB7IE1vbml0b3JCYXNlIH0gZnJvbSAnLi4vTW9uaXRvckJhc2UnO1xuXG5pbXBvcnQgeyBib3QgfSBmcm9tICcuLi9MYWJlbCc7XG5pbXBvcnQgeyBCb29sZWFuT2JqZWN0IH0gZnJvbSAnLi4vT2JqZWN0cy9Cb29sZWFuT2JqZWN0JztcbmltcG9ydCB7IE51bWJlck9iamVjdCB9IGZyb20gJy4uL09iamVjdHMvTnVtYmVyT2JqZWN0JztcbmltcG9ydCB7IFN0cmluZ09iamVjdCB9IGZyb20gJy4uL09iamVjdHMvU3RyaW5nT2JqZWN0JztcbmltcG9ydCB7IFZhbHVlVHlwZXMgfSBmcm9tIFwiLi4vSW50ZXJmYWNlc1wiO1xuaW1wb3J0IHsgRWNtYU9iamVjdCB9IGZyb20gXCIuLi9PYmplY3RzL0VjbWFPYmplY3RcIjtcblxuZGVjbGFyZSB2YXIgbW9uaXRvcjogTW9uaXRvckJhc2U7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFRvT2JqZWN0LCA5LjlcblxuZXhwb3J0IGZ1bmN0aW9uIFRvT2JqZWN0KHg6IFZhbHVlPFZhbHVlVHlwZXM+KTogVmFsdWU8RWNtYU9iamVjdD4ge1xuICAgIC8vIG51bGwgb3IgdW5kZWZpbmVkLCBoZW5jZSA9PVxuICAgIGxldCB2YWx1ZSA9IHgudmFsdWU7XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbW9uaXRvci5jb250ZXh0LnB1c2hQQyh4LmxhYmVsKTtcblxuICAgICAgICBtb25pdG9yLlRocm93KFxuICAgICAgICAgICAgXCJUeXBlRXJyb3JcIixcbiAgICAgICAgICAgICdjYW5ub3QgY29udmVydCAnICsgU3RyaW5nKHgudmFsdWUpICsgJyB0byBvYmplY3QnLFxuICAgICAgICAgICAgYm90XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgbW9uaXRvci5jb250ZXh0LnB1c2hQQyh4LmxhYmVsKTtcbiAgICBsZXQgcmVzOiBWYWx1ZTxFY21hT2JqZWN0PiA9IHVuZGVmaW5lZDtcbiAgICBzd2l0Y2ggKHR5cGVvZiB4LnZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgcmVzID0gbmV3IFZhbHVlKG5ldyBCb29sZWFuT2JqZWN0KHgudmFsdWUsIHgubGFiZWwpLCB4LmxhYmVsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgcmVzID0gbmV3IFZhbHVlKG5ldyBOdW1iZXJPYmplY3QoeC52YWx1ZSwgeC5sYWJlbCksIHgubGFiZWwpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAvL0B0cy1pZ25vcmVcbiAgICAgICAgICAgIHJlcyA9IG5ldyBWYWx1ZShuZXcgU3RyaW5nT2JqZWN0KHgudmFsdWUsIHgubGFiZWwpLCB4LmxhYmVsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIG1vbml0b3IuY29udGV4dC5wb3BQQygpO1xuICAgIGlmIChyZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gbmV3IFZhbHVlKHgudmFsdWUsIHgubGFiZWwpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBWYWx1ZVR5cGVzLCBQcmltaXRpdmVWYWx1ZVR5cGVzIH0gZnJvbSBcIi4uL0ludGVyZmFjZXNcIjtcbmltcG9ydCB7IFZhbHVlIH0gZnJvbSBcIi4uL1ZhbHVlXCI7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFRvUHJpbWl0aXZlLCA5LjEgIFxuXG5leHBvcnQgZnVuY3Rpb24gVG9QcmltaXRpdmUoeCA6IFZhbHVlPFZhbHVlVHlwZXM+LCBQcmVmZXJyZWRUeXBlPzogXCJzdHJpbmdcIiB8IFwibnVtYmVyXCIpIDogVmFsdWU8UHJpbWl0aXZlVmFsdWVUeXBlcz4ge1xuICAgIGlmICh4LnZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB4LnZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cblxuICAgIC8vIHdpbGwgcnVuIGludCB0aGUgY29udGV4dCBvZiB4IGR1ZSB0byB2YWx1ZSBsaWZ0aW5nXG4gICAgdmFyIHJlcyA9IHguRGVmYXVsdFZhbHVlKFByZWZlcnJlZFR5cGUpO1xuICAgIHJldHVybiByZXM7XG59IiwiaW1wb3J0IHsgVmFsdWUgfSBmcm9tIFwiLi4vVmFsdWVcIjtcbmltcG9ydCB7IFRvUHJpbWl0aXZlIH0gZnJvbSBcIi4vVG9QcmltaXRpdmVcIjtcbmltcG9ydCB7IE1vbml0b3JCYXNlIH0gZnJvbSBcIi4uL01vbml0b3JCYXNlXCI7XG5pbXBvcnQgeyBWYWx1ZVR5cGVzIH0gZnJvbSBcIi4uL0ludGVyZmFjZXNcIjtcblxuZGVjbGFyZSB2YXIgbW9uaXRvcjogTW9uaXRvckJhc2U7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFRvU3RyaW5nLCA5LjhcblxuZXhwb3J0IGZ1bmN0aW9uIFRvU3RyaW5nKHg6IFZhbHVlPFZhbHVlVHlwZXM+KTogVmFsdWU8c3RyaW5nPiB7XG4gIGlmICh0eXBlb2YgeC52YWx1ZSAhPT0gJ29iamVjdCcpXG4gICAgcmV0dXJuIG5ldyBWYWx1ZShTdHJpbmcoeC52YWx1ZSksIHgubGFiZWwpO1xuXG4gIG1vbml0b3IuY29udGV4dC5wdXNoUEMoeC5sYWJlbCk7XG4gIHZhciBwcmltVmFsdWUgPSBUb1ByaW1pdGl2ZSh4LCAnc3RyaW5nJyk7XG4gIG1vbml0b3IuY29udGV4dC5wb3BQQygpO1xuICByZXR1cm4gbmV3IFZhbHVlKFN0cmluZyhwcmltVmFsdWUudmFsdWUpLCBwcmltVmFsdWUubGFiZWwpO1xufSIsImltcG9ydCB7IFZhbHVlIH0gZnJvbSBcIi4uL1ZhbHVlXCI7XG5pbXBvcnQgeyBUb051bWJlciB9IGZyb20gXCIuL1RvTnVtYmVyXCI7XG5pbXBvcnQgeyBWYWx1ZVR5cGVzIH0gZnJvbSBcIi4uL0ludGVyZmFjZXNcIjtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVG9VSW50MTYsIDkuN1xuXG5leHBvcnQgZnVuY3Rpb24gVG9VSW50MTYoeDogVmFsdWU8VmFsdWVUeXBlcz4pOiBWYWx1ZTxudW1iZXI+IHtcbiAgbGV0IG51bWJlciA9IFRvTnVtYmVyKHgpO1xuICBpZiAoaXNOYU4obnVtYmVyLnZhbHVlKSB8fFxuICAgIG51bWJlci52YWx1ZSA9PT0gMCB8fFxuICAgIG51bWJlci52YWx1ZSA9PT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIHx8XG4gICAgbnVtYmVyLnZhbHVlID09PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpIHtcbiAgICByZXR1cm4gbmV3IFZhbHVlKDAsIG51bWJlci5sYWJlbCk7XG4gIH1cblxuICBsZXQgcG9zSW50ID0gc2lnbihudW1iZXIudmFsdWUpICogTWF0aC5mbG9vcihNYXRoLmFicyhudW1iZXIudmFsdWUpKTtcbiAgbGV0IGludDE2Yml0ID0gcG9zSW50ICUgTWF0aC5wb3coMiwgMTYpO1xuICByZXR1cm4gbmV3IFZhbHVlKGludDE2Yml0LCBudW1iZXIubGFiZWwpO1xufVxuXG5mdW5jdGlvbiBzaWduKG46IG51bWJlcik6IDEgfCAwIHwgLTEge1xuICBpZiAobiA+IDApIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICBlbHNlIGlmIChuIDwgMCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIHJldHVybiAwO1xufTtcbiIsImltcG9ydCB7IFRvTnVtYmVyIH0gZnJvbSBcIi4vVG9OdW1iZXJcIjtcbmltcG9ydCB7IFZhbHVlIH0gZnJvbSBcIi4uL1ZhbHVlXCI7XG5pbXBvcnQgeyBWYWx1ZVR5cGVzIH0gZnJvbSBcIi4uL0ludGVyZmFjZXNcIjtcblxuIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gVG9VSW50MzIsIDkuNlxuXG4gIGV4cG9ydCBmdW5jdGlvbiBUb1VJbnQzMih4IDogVmFsdWU8VmFsdWVUeXBlcz4pIDogVmFsdWU8bnVtYmVyPiB7XG4gICAgcmV0dXJuIFRvTnVtYmVyKHgpO1xuICB9XG4iLCJpbXBvcnQgeyBib3QgfSBmcm9tIFwiLi9MYWJlbFwiO1xuaW1wb3J0IHsgVmFsdWUgfSBmcm9tIFwiLi9WYWx1ZVwiO1xuaW1wb3J0IHsgRWNtYU9iamVjdCB9IGZyb20gJy4vT2JqZWN0cy9FY21hT2JqZWN0JztcbmltcG9ydCB7IFZhbHVlVHlwZXMsIElFbnZpcm9ubWVudFJlY29yZCwgSUVjbWFPYmplY3QgfSBmcm9tIFwiLi9JbnRlcmZhY2VzXCI7XG5pbXBvcnQgeyBMZXhpY2FsRW52aXJvbm1lbnQgfSBmcm9tIFwiLi9MZXhpY2FsRW52aXJvbm1lbnRcIjtcbmltcG9ydCB7IE1vbml0b3JCYXNlIH0gZnJvbSBcIi4vTW9uaXRvckJhc2VcIjtcblxuZGVjbGFyZSB2YXIgbW9uaXRvcjogTW9uaXRvckJhc2U7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gMTAuMi4yLjJcblxuZXhwb3J0IGZ1bmN0aW9uIE5ld0RlY2xhcmF0aXZlRW52aXJvbm1lbnQoZSA6IFZhbHVlPExleGljYWxFbnZpcm9ubWVudD4pIHtcbiAgICB2YXIgZW52UmVjID0gbmV3IERlY2xhcmF0aXZlRW52aXJvbm1lbnRSZWNvcmQoKTtcbiAgICB2YXIgZW52ID0gbmV3IExleGljYWxFbnZpcm9ubWVudChlbnZSZWMsIGUpO1xuICAgIHJldHVybiBlbnY7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRGVjbGFyYXRpdmUgRW52aXJvbm1lbnQgUmVjb3JkLCAxMC4yLjEuMVxuXG5leHBvcnQgY2xhc3MgRGVjbGFyYXRpdmVFbnZpcm9ubWVudFJlY29yZCBleHRlbmRzIEVjbWFPYmplY3QgaW1wbGVtZW50cyBJRW52aXJvbm1lbnRSZWNvcmQge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxuXG4gICAgLy8gSGFzQmluZGluZywgMTAuMi4xLjEuMVxuICAgIEhhc0JpbmRpbmcoczogVmFsdWU8c3RyaW5nPik6IFZhbHVlPGJvb2xlYW4+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuSGFzUHJvcGVydHkocyk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlTXV0YWJsZUJpbmRpbmcsIDEwLjIuMS4xLjJcbiAgICBDcmVhdGVNdXRhYmxlQmluZGluZyhwOiBWYWx1ZTxzdHJpbmc+LCBkPzogYm9vbGVhbik6IHZvaWQge1xuXG4gICAgICAgIHZhciBkZXNjID0ge1xuICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGxhYmVsOiBtb25pdG9yLmNvbnRleHQuZWZmZWN0aXZlUEMsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IGRcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLkRlZmluZU93blByb3BlcnR5KHAsIGRlc2MsIHRydWUpO1xuICAgIH1cblxuICAgIC8vIEdldEJpbmRpbmdWYWx1ZSAxMC4yLjEuMS40XG4gICAgR2V0QmluZGluZ1ZhbHVlKHA6IFZhbHVlPHN0cmluZz4sIHM/OiBib29sZWFuKTogVmFsdWU8VmFsdWVUeXBlcz4ge1xuICAgICAgICByZXR1cm4gdGhpcy5HZXQocCk7XG4gICAgfVxuXG4gICAgLy8gU2V0TXV0YWJsZUJpbmRpbmcsIDEwLjIuMS4xLjNcbiAgICBTZXRNdXRhYmxlQmluZGluZyhwOiBWYWx1ZTxzdHJpbmc+LCB2OiBWYWx1ZTxWYWx1ZVR5cGVzPiwgcz86IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5QdXQocCwgdiwgcyA9PT0gdHJ1ZSk7XG4gICAgfVxuXG4gICAgLy8gRGVsZXRlQmluZGluZywgMTAuMi4xLjEuNVxuICAgIERlbGV0ZUJpbmRpbmcocDogVmFsdWU8c3RyaW5nPik6IFZhbHVlPGJvb2xlYW4+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuRGVsZXRlKHApO1xuICAgIH1cblxuICAgIC8vIEltcGxpY2l0VGhpc1ZhbGllLiAxMC4yLjEuMS42XG4gICAgSW1wbGljaXRUaGlzVmFsdWUoKTogVmFsdWU8SUVjbWFPYmplY3QgfCB1bmRlZmluZWQ+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlSW1tdXRhYmxlQmluZGluZywgMTAuMi4xLjEuN1xuICAgIENyZWF0ZUltbXV0YWJsZUJpbmRpbmcocDogVmFsdWU8c3RyaW5nPik6IHZvaWQge1xuXG4gICAgICAgIHZhciBkZXNjID0ge1xuICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGxhYmVsOiBib3QsXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5EZWZpbmVPd25Qcm9wZXJ0eShwLCBkZXNjLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZUltbXV0YWJsZUJpbmRpbmcsIDEwLjIuMS4xLjhcbiAgICBJbml0aWFsaXplSW1tdXRhYmxlQmluZGluZyhwOiBWYWx1ZTxzdHJpbmc+LCB2OiBWYWx1ZTxWYWx1ZVR5cGVzPik6IHZvaWQge1xuICAgICAgICB2YXIgZGVzYyA9IHRoaXMuR2V0T3duUHJvcGVydHkocCkudmFsdWU7XG4gICAgICAgIGlmIChkZXNjID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG1vbml0b3IuZmF0YWwoYEluaXRpYWxpemVJbW11dGFibGVCaW5kaW5nOiBubyBiaW5kaW5naW5nIGZvciB7cC52YWx1ZX1gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlc2MudmFsdWUgPSB2LnZhbHVlO1xuICAgICAgICAgICAgZGVzYy5sYWJlbCA9IHYubGFiZWw7XG5cbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgZGVzYyBzaG91bGQgYmUgYSBkYXRhIGRlc2NyaXB0b3IgY3JlYXRlZCBieSBDcmVhdGVJbW11dGFibGVCaW5kaW5nXG4gICAgICAgICAgICB0aGlzLkRlZmluZU93blByb3BlcnR5KHAsIGRlc2MsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbn0iLCIvKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLiAqL1xuXG5pbXBvcnQgeyBib3QsIExhYmVsIH0gZnJvbSAnLi9MYWJlbCc7XG5cbmltcG9ydCB7IElFY21hT2JqZWN0LCBWYWx1ZVR5cGVzIH0gZnJvbSAnLi9JbnRlcmZhY2VzJztcbmltcG9ydCB7IFZhbHVlIH0gZnJvbSAnLi9WYWx1ZSc7XG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmludGVyZmFjZSBMYWJlbE9wdGlvbnMge1xuICBsYWJlbD86IExhYmVsLFxuICBleGlzdGVuY2U/OiBMYWJlbFxufVxuXG5pbnRlcmZhY2UgRGVmaW5lT3B0aW9ucyBleHRlbmRzIExhYmVsT3B0aW9ucyB7XG4gIGVudW1lcmFibGU/OiBib29sZWFuLFxuICBjb25maWd1cmFibGU/OiBib29sZWFuLFxuICB3cml0YWJsZT86IGJvb2xlYW5cbn1cblxuLy8gVE9ETzogbGFiZWwgb2YgbmFtZSBub3QgdXNlZDsgb25seSBWYWx1ZSB0byBiZSBjb21wYXRpYmxlIHdpdGggY29uc3RhbnRzIC0gcmVhc29uYWJsZT9cbmV4cG9ydCBmdW5jdGlvbiBEZWZpbmUoX3RoaXM6IElFY21hT2JqZWN0LCBuYW1lOiBWYWx1ZTxzdHJpbmc+LCB2OiBWYWx1ZVR5cGVzLCBvcHRzPzogRGVmaW5lT3B0aW9ucyk6IHZvaWQge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICB2YXIgcGQ6IFByb3BlcnR5RGVzY3JpcHRvciA9XG4gIHtcbiAgICB2YWx1ZTogdixcbiAgICB3cml0YWJsZTogb3B0cy53cml0YWJsZSA9PT0gdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBvcHRzLmVudW1lcmFibGUgPT09IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiBvcHRzLmNvbmZpZ3VyYWJsZSA9PT0gdHJ1ZVxuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLnByb3BlcnRpZXMsIG5hbWUudmFsdWUsIHBkKTtcbiAgX3RoaXMubGFiZWxzW25hbWUudmFsdWVdID0geyB2YWx1ZTogb3B0cy5sYWJlbCB8fCBib3QsIGV4aXN0ZW5jZTogb3B0cy5leGlzdGVuY2UgfHwgYm90IH07XG59XG5cbi8vIC0tLVxuXG5leHBvcnQgZnVuY3Rpb24gRGVmaW5lRkZUKF90aGlzOiBJRWNtYU9iamVjdCwgbmFtZTogVmFsdWU8c3RyaW5nPiwgdjogVmFsdWVUeXBlcywgb3B0cz86IExhYmVsT3B0aW9ucyk6IHZvaWQge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLnByb3BlcnRpZXMsIG5hbWUudmFsdWUsXG4gICAge1xuICAgICAgdmFsdWU6IHYsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gICk7XG4gIF90aGlzLmxhYmVsc1tuYW1lLnZhbHVlXSA9IHsgdmFsdWU6IG9wdHMubGFiZWwgfHwgYm90LCBleGlzdGVuY2U6IG9wdHMuZXhpc3RlbmNlIHx8IGJvdCB9O1xufVxuXG4vLyAtLS1cblxuZXhwb3J0IGZ1bmN0aW9uIERlZmluZUZGRihfdGhpczogSUVjbWFPYmplY3QsIG5hbWU6IFZhbHVlPHN0cmluZz4sIHY6IFZhbHVlVHlwZXMsIG9wdHM/OiBMYWJlbE9wdGlvbnMpOiB2b2lkIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcy5wcm9wZXJ0aWVzLCBuYW1lLnZhbHVlLCB7IHZhbHVlOiB2IH0pO1xuICBfdGhpcy5sYWJlbHNbbmFtZS52YWx1ZV0gPSB7IHZhbHVlOiBvcHRzLmxhYmVsIHx8IGJvdCwgZXhpc3RlbmNlOiBvcHRzLmV4aXN0ZW5jZSB8fCBib3QgfTtcbn1cblxuLy8gLS0tXG5cbmV4cG9ydCBmdW5jdGlvbiBEZWZpbmVURkYoX3RoaXM6IElFY21hT2JqZWN0LCBuYW1lOiBWYWx1ZTxzdHJpbmc+LCB2OiBWYWx1ZVR5cGVzLCBvcHRzPzogTGFiZWxPcHRpb25zKTogdm9pZCB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMucHJvcGVydGllcywgbmFtZS52YWx1ZSxcbiAgICB7XG4gICAgICB2YWx1ZTogdixcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfVxuICApO1xuICBfdGhpcy5sYWJlbHNbbmFtZS52YWx1ZV0gPSB7IHZhbHVlOiBvcHRzLmxhYmVsIHx8IGJvdCwgZXhpc3RlbmNlOiBvcHRzLmV4aXN0ZW5jZSB8fCBib3QgfTtcbn1cblxuLy8gLS0tXG5cbmV4cG9ydCBmdW5jdGlvbiBEZWZpbmVURlQoX3RoaXM6IElFY21hT2JqZWN0LCBuYW1lOiBWYWx1ZTxzdHJpbmc+LCB2OiBWYWx1ZVR5cGVzLCBvcHRzPzogTGFiZWxPcHRpb25zKTogdm9pZCB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMucHJvcGVydGllcywgbmFtZS52YWx1ZSxcbiAgICB7XG4gICAgICB2YWx1ZTogdixcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICApO1xuICBfdGhpcy5sYWJlbHNbbmFtZS52YWx1ZV0gPSB7IHZhbHVlOiBvcHRzLmxhYmVsIHx8IGJvdCwgZXhpc3RlbmNlOiBvcHRzLmV4aXN0ZW5jZSB8fCBib3QgfTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4iLCJpbXBvcnQgeyBXb3JrTGlzdCwgVmFsdWVTdGFjayB9IGZyb20gXCIuLi9Db250ZXh0XCI7XG5pbXBvcnQgeyBWYWx1ZSB9IGZyb20gXCIuLi9WYWx1ZVwiO1xuaW1wb3J0IHsgVmFsdWVUeXBlcyB9IGZyb20gXCIuLi9JbnRlcmZhY2VzXCI7XG5pbXBvcnQgeyBsdWIgfSBmcm9tIFwiLi4vTGFiZWxcIjtcbmltcG9ydCB7IFRvTnVtYmVyIH0gZnJvbSBcIi4uL0NvbnZlcnNpb24vVG9OdW1iZXJcIjtcbmltcG9ydCB7IFRvUHJpbWl0aXZlIH0gZnJvbSBcIi4uL0NvbnZlcnNpb24vVG9QcmltaXRpdmVcIjtcbmltcG9ydCB7IFRvVUludDMyIH0gZnJvbSBcIi4uL0NvbnZlcnNpb24vVG9VSW50MzJcIjtcbmltcG9ydCB7IFRvSW50MzIgfSBmcm9tIFwiLi4vQ29udmVyc2lvbi9Ub0ludDMyXCI7XG5pbXBvcnQgeyBUb1N0cmluZyB9IGZyb20gXCIuLi9Db252ZXJzaW9uL1RvU3RyaW5nXCI7XG5pbXBvcnQgeyBNb25pdG9yQmFzZSB9IGZyb20gXCIuLi9Nb25pdG9yQmFzZVwiO1xuaW1wb3J0IHsgR2V0VmFsdWUgfSBmcm9tIFwiLi4vR2V0VmFsdWVcIjtcbmltcG9ydCB7IFRvQm9vbGVhbiB9IGZyb20gXCIuLi9Db252ZXJzaW9uL1RvQm9vbGVhblwiO1xuXG5cbmRlY2xhcmUgdmFyIG1vbml0b3I6IE1vbml0b3JCYXNlO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBFcXVhbGl0eSBPcGVyYXRvcnMsIDExLjlcblxuZnVuY3Rpb24gYmluYXJ5RXFzKG9wOiBcIj09XCIgfCBcIiE9XCIsIHdsOiBXb3JrTGlzdCwgdnM6IFZhbHVlU3RhY2spOiB2b2lkIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgbGV0IHJ2YWw6IFZhbHVlPFZhbHVlVHlwZXM+ID0gdnMucG9wKCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGxldCBsdmFsOiBWYWx1ZTxWYWx1ZVR5cGVzPiA9IHZzLnBvcCgpO1xuICBcbiAgICBsZXQgcmVzOiBWYWx1ZTxib29sZWFuPjtcbiAgXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGxldCBsdDogXCJzdHJpbmdcIiB8IFwibnVtYmVyXCIgfCBcImJpZ2ludFwiIHwgXCJib29sZWFuXCIgfCBcInN5bWJvbFwiIHwgXCJ1bmRlZmluZWRcIiB8IFwib2JqZWN0XCIgfCBcImZ1bmN0aW9uXCIgfCBcIm51bGxcIiA9IHR5cGVvZiBsdmFsLnZhbHVlO1xuICAgICAgbGV0IHJ0OiBcInN0cmluZ1wiIHwgXCJudW1iZXJcIiB8IFwiYmlnaW50XCIgfCBcImJvb2xlYW5cIiB8IFwic3ltYm9sXCIgfCBcInVuZGVmaW5lZFwiIHwgXCJvYmplY3RcIiB8IFwiZnVuY3Rpb25cIiB8IFwibnVsbFwiID0gdHlwZW9mIHJ2YWwudmFsdWU7XG4gIFxuICAgICAgbHQgPSBsdmFsLnZhbHVlID09PSB1bmRlZmluZWQgPyAndW5kZWZpbmVkJyA6IGx0O1xuICAgICAgcnQgPSBydmFsLnZhbHVlID09PSB1bmRlZmluZWQgPyAndW5kZWZpbmVkJyA6IHJ0O1xuICBcbiAgICAgIGx0ID0gbHZhbC52YWx1ZSA9PT0gbnVsbCA/ICdudWxsJyA6IGx0O1xuICAgICAgcnQgPSBydmFsLnZhbHVlID09PSBudWxsID8gJ251bGwnIDogcnQ7XG4gIFxuICAgICAgLy8gbXVzdCB1c2Ugc3RyaWN0IGluIG9yZGVyIG5vdCB0byB0cmlnZ2VyIGNvbnZlcnNpb25cbiAgICAgIC8vICAgYnV0IHRoZW4gbnVsbCBhbmQgdW5kZWZpbmVkIG11c3QgYmUgaGFuZGxlZCBzZXBhcmF0ZWx5XG4gICAgICBpZiAobHQgPT09IHJ0KSB7XG4gICAgICAgIHJlcyA9IG5ldyBWYWx1ZShsdmFsLnZhbHVlID09PSBydmFsLnZhbHVlLFxuICAgICAgICAgIGx1YihsdmFsLmxhYmVsLCBydmFsLmxhYmVsKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICBcbiAgICAgIGlmICgobHZhbC52YWx1ZSA9PT0gbnVsbCAmJiBydmFsLnZhbHVlID09PSB1bmRlZmluZWQpIHx8XG4gICAgICAgIChsdmFsLnZhbHVlID09PSB1bmRlZmluZWQgJiYgcnZhbC52YWx1ZSA9PT0gbnVsbCkpIHtcbiAgICAgICAgcmVzID0gbmV3IFZhbHVlKHRydWUsIGx1YihsdmFsLmxhYmVsLCBydmFsLmxhYmVsKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICBcbiAgICAgIGlmIChsdCA9PT0gJ251bWJlcicgJiYgcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJ2YWwgPSBUb051bWJlcihydmFsKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gIFxuICAgICAgaWYgKGx0ID09PSAnc3RyaW5nJyAmJiBydCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgbHZhbCA9IFRvTnVtYmVyKGx2YWwpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgXG4gICAgICBpZiAobHQgPT09ICdib29sZWFuJykge1xuICAgICAgICBsdmFsID0gVG9OdW1iZXIobHZhbCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICBcbiAgICAgIGlmIChydCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJ2YWwgPSBUb051bWJlcihydmFsKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gIFxuICAgICAgaWYgKChsdCA9PT0gJ3N0cmluZycgfHwgbHQgPT09ICdudW1iZXInKSAmJlxuICAgICAgICBydCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcnZhbCA9IFRvUHJpbWl0aXZlKHJ2YWwpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgXG4gICAgICBpZiAobHQgPT09ICdvYmplY3QnICYmXG4gICAgICAgIChydCA9PT0gJ3N0cmluZycgfHwgcnQgPT09ICdudW1iZXInKSkge1xuICAgICAgICBsdmFsID0gVG9QcmltaXRpdmUobHZhbCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmVzID0gbmV3IFZhbHVlKGZhbHNlLCBsdWIobHZhbC5sYWJlbCwgcnZhbC5sYWJlbCkpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICBcbiAgICBpZiAob3AgPT09ICchPScpIHtcbiAgICAgIHJlcy52YWx1ZSA9ICFyZXMudmFsdWU7XG4gICAgfVxuICBcbiAgICB2cy5wdXNoKHJlcyk7XG4gIH1cbiAgXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gU3RyaWN0IEVxdWFsaXR5IE9wZXJhdG9ycywgMTEuOS40LCAxMS45LjVcbiAgXG4gIGV4cG9ydCBmdW5jdGlvbiBiaW5hcnlTdHJpY3RFcXMob3A6IFwiPT09XCIgfCBcIiE9PVwiLCB3bDogV29ya0xpc3QsIHZzOiBWYWx1ZVN0YWNrKTogdm9pZCB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGxldCBydmFsOiBWYWx1ZTxWYWx1ZVR5cGVzPiA9IHZzLnBvcCgpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBsZXQgbHZhbDogVmFsdWU8VmFsdWVUeXBlcz4gPSB2cy5wb3AoKTtcbiAgXG4gICAgbGV0IHJlcyA9IG5ldyBWYWx1ZShsdmFsLnZhbHVlID09PSBydmFsLnZhbHVlLFxuICAgICAgbHViKGx2YWwubGFiZWwsIHJ2YWwubGFiZWwpKTtcbiAgXG4gICAgaWYgKG9wID09PSAnIT09Jykge1xuICAgICAgcmVzLnZhbHVlID0gIXJlcy52YWx1ZTtcbiAgICB9XG4gIFxuICAgIHZzLnB1c2gocmVzKTtcbiAgfVxuICBcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBSZWxhdGlvbmFsIE9wZXJhdG9ycywgMTEuOFxuICAvLyAgVGhlIGV2YWx1YXRpb24gb3JkZXIgaXMgaW1wb3J0YW50LCAxMS44LjVcbiAgXG4gIGZ1bmN0aW9uIGJpbmFyeU9yZHMoXG4gICAgb3A6IFwiPFwiIHwgXCI+XCIgfCBcIjw9XCIgfCBcIj49XCIgfCBcImluc3RhbmNlb2ZcIiB8IFwiaW5cIixcbiAgICB3bDogV29ya0xpc3QsXG4gICAgdnM6IFZhbHVlU3RhY2tcbiAgKTogdm9pZCB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGxldCBydmFsOiBWYWx1ZTxWYWx1ZVR5cGVzPiA9IHZzLnBvcCgpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBsZXQgbHZhbDogVmFsdWU8VmFsdWVUeXBlcz4gPSB2cy5wb3AoKTtcblxuICAgIGxldCBscHJpbSwgcnByaW07XG4gICAgaWYgKG9wLmNoYXJBdCgwKSA9PT0gJzwnIHx8IG9wLmNoYXJBdCgwKSA9PT0gJz4nKSB7XG4gICAgICBscHJpbSA9IFRvUHJpbWl0aXZlKGx2YWwsICdudW1iZXInKTtcbiAgICAgIHJwcmltID0gVG9QcmltaXRpdmUocnZhbCwgJ251bWJlcicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBscHJpbSA9IFRvUHJpbWl0aXZlKGx2YWwpO1xuICAgICAgcnByaW0gPSBUb1ByaW1pdGl2ZShydmFsKTtcbiAgICB9XG5cblxuICAgIGxldCByZXM6IFZhbHVlPGJvb2xlYW4+O1xuXG4gICAgaWYgKHR5cGVvZiBscHJpbS52YWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAgICAgIHR5cGVvZiBycHJpbS52YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGxldCBsbnVtID0gVG9OdW1iZXIobHByaW0pO1xuICAgICAgbGV0IHJudW0gPSBUb051bWJlcihycHJpbSk7XG4gICAgICBsZXQgdmFsID0gZXZhbCgnbG51bS52YWx1ZSAnICsgb3AgKyAnIHJudW0udmFsdWUnKTtcbiAgICAgIHJlcyA9IG5ldyBWYWx1ZSh2YWwsIGx1YihsbnVtLmxhYmVsLCBybnVtLmxhYmVsKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCB2YWwgPSBldmFsKCdscHJpbS52YWx1ZSAnICsgb3AgKyAnIHJwcmltLnZhbHVlJyk7XG4gICAgICByZXMgPSBuZXcgVmFsdWUodmFsLCBsdWIobHByaW0ubGFiZWwsIHJwcmltLmxhYmVsKSk7XG4gICAgfVxuXG4gICAgdnMucHVzaChyZXMpO1xuICB9XG4gIFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIEJpdHdpc2UgU2hpZnQgT3BlcmF0b3JzLCAxMS43XG4gIFxuICBmdW5jdGlvbiBiaW5hcnlTaGlmdHMoXG4gICAgb3A6IFwiPDxcIiB8IFwiPj5cIiB8IFwiPj4+XCIsXG4gICAgd2w6IFdvcmtMaXN0LFxuICAgIHZzOiBWYWx1ZVN0YWNrXG4gICk6IHZvaWQge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBsZXQgcnZhbDogVmFsdWU8VmFsdWVUeXBlcz4gPSB2cy5wb3AoKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgbGV0IGx2YWw6IFZhbHVlPFZhbHVlVHlwZXM+ID0gdnMucG9wKCk7XG4gIFxuICAgIGxldCBsbnVtID0gKG9wID09PSAnPj4+JykgPyBUb1VJbnQzMihsdmFsKSA6IFRvSW50MzIobHZhbCk7XG4gICAgbGV0IHJudW0gPSBUb1VJbnQzMihydmFsKTtcbiAgICBsZXQgdmFsID0gZXZhbCgnbG51bS52YWx1ZSAnICsgb3AgKyAnIHJudW0udmFsdWUnKTtcbiAgXG4gICAgdnMucHVzaChuZXcgVmFsdWUodmFsLCBsdWIobG51bS5sYWJlbCwgcm51bS5sYWJlbCkpKTtcbiAgfVxuICBcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBCaW5hcnkgQml0d2lzZSBPcGVyYXRvcnMsIDExLjEwXG4gIFxuICBmdW5jdGlvbiBiaW5hcnlCaXR3aXNlT3BzKFxuICAgIG9wOiBcIiZcIiB8IFwiXlwiIHwgXCJ8XCIsXG4gICAgd2w6IFdvcmtMaXN0LFxuICAgIHZzOiBWYWx1ZVN0YWNrXG4gICk6IHZvaWQge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBsZXQgcnZhbDogVmFsdWU8VmFsdWVUeXBlcz4gPSB2cy5wb3AoKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgbGV0IGx2YWw6IFZhbHVlPFZhbHVlVHlwZXM+ID0gdnMucG9wKCk7XG4gIFxuICAgIGxldCBsbnVtID0gVG9JbnQzMihsdmFsKTtcbiAgICBsZXQgcm51bSA9IFRvSW50MzIocnZhbCk7XG4gICAgbGV0IHZhbCA9IGV2YWwoJ2xudW0udmFsdWUgJyArIG9wICsgJyBybnVtLnZhbHVlJyk7XG4gIFxuICAgIHZzLnB1c2gobmV3IFZhbHVlKHZhbCwgbHViKGxudW0ubGFiZWwsIHJudW0ubGFiZWwpKSk7XG4gIH1cbiAgXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gUGx1cywgMTEuNlxuICBcbiAgZnVuY3Rpb24gYmluYXJ5UGx1cyhcbiAgICB3bDogV29ya0xpc3QsXG4gICAgdnM6IFZhbHVlU3RhY2tcbiAgKTogdm9pZCB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGxldCBydmFsOiBWYWx1ZTxWYWx1ZVR5cGVzPiA9IHZzLnBvcCgpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBsZXQgbHZhbDogVmFsdWU8VmFsdWVUeXBlcz4gPSB2cy5wb3AoKTtcbiAgXG4gICAgbGV0IGxwcmltID0gVG9QcmltaXRpdmUobHZhbCk7XG4gICAgbGV0IHJwcmltID0gVG9QcmltaXRpdmUocnZhbCk7XG4gICAgbGV0IHJlczogVmFsdWU8bnVtYmVyIHwgc3RyaW5nPjtcbiAgXG4gICAgaWYgKCh0eXBlb2YgbHByaW0udmFsdWUpID09PSAnc3RyaW5nJyB8fFxuICAgICAgKHR5cGVvZiBycHJpbS52YWx1ZSkgPT09ICdzdHJpbmcnKSB7XG4gICAgICBsZXQgbHN0ciA9IFRvU3RyaW5nKGxwcmltKTtcbiAgICAgIGxldCByc3RyID0gVG9TdHJpbmcocnByaW0pO1xuICAgICAgcmVzID0gbmV3IFZhbHVlKGxzdHIudmFsdWUgKyByc3RyLnZhbHVlLFxuICAgICAgICBsdWIobHByaW0ubGFiZWwsIHJwcmltLmxhYmVsKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBsbnVtID0gVG9OdW1iZXIobHByaW0pO1xuICAgICAgbGV0IHJudW0gPSBUb051bWJlcihycHJpbSk7XG4gICAgICByZXMgPSBuZXcgVmFsdWUobG51bS52YWx1ZSArIHJudW0udmFsdWUsXG4gICAgICAgIGx1YihsbnVtLmxhYmVsLCBybnVtLmxhYmVsKSk7XG4gICAgfVxuICBcbiAgICB2cy5wdXNoKHJlcyk7XG4gIH1cbiAgXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gTXVsdGlwbGljYXRpdmUgb3BlcmF0b3JzLCAxMS41LCBhbmQgbWludXMsIDExLjZcbiAgXG4gIGZ1bmN0aW9uIGJpbmFyeUFyaXRobWV0aWNPcHMoXG4gICAgb3A6IFwiLVwiIHwgXCIqXCIgfCBcIi9cIiB8IFwiJVwiLFxuICAgIHdsOiBXb3JrTGlzdCxcbiAgICB2czogVmFsdWVTdGFja1xuICApOiB2b2lkIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgbGV0IHJ2YWw6IFZhbHVlPFZhbHVlVHlwZXM+ID0gdnMucG9wKCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGxldCBsdmFsOiBWYWx1ZTxWYWx1ZVR5cGVzPiA9IHZzLnBvcCgpO1xuICBcbiAgICBsZXQgbGVmdE51bSA9IFRvTnVtYmVyKGx2YWwpO1xuICAgIGxldCByaWdodE51bSA9IFRvTnVtYmVyKHJ2YWwpO1xuICAgIGxldCB2YWwgPSBldmFsKCdsZWZ0TnVtLnZhbHVlICcgKyBvcCArICcgcmlnaHROdW0udmFsdWUnKTtcbiAgXG4gICAgdnMucHVzaChuZXcgVmFsdWUodmFsLCBsdWIobGVmdE51bS5sYWJlbCwgcmlnaHROdW0ubGFiZWwpKSk7XG4gIH1cbiAgXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gVGhlIGluIG9wZXJhdG9yLCAxMS44LjdcbiAgXG4gIGZ1bmN0aW9uIGJpbmFyeUluKFxuICAgIHdsOiBXb3JrTGlzdCxcbiAgICB2czogVmFsdWVTdGFja1xuICApOiB2b2lkIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgbGV0IHJ2YWw6IFZhbHVlPFZhbHVlVHlwZXM+ID0gdnMucG9wKCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGxldCBsdmFsOiBWYWx1ZTxWYWx1ZVR5cGVzPiA9IHZzLnBvcCgpO1xuICBcbiAgICBpZiAodHlwZW9mIHJ2YWwudmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoZmFsc2UpIHsgLy8gU0lMRU5UIEVSUk9SXG4gICAgICAgIHZzLnB1c2gobmV3IFZhbHVlKGZhbHNlLCBsdWIobHZhbC5sYWJlbCwgcnZhbC5sYWJlbCkpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICBcbiAgICAgIG1vbml0b3IuVGhyb3coXG4gICAgICAgIFwiVHlwZUVycm9yXCIsXG4gICAgICAgIFwiaW52YWxpZCAnaW4nIHBhcmFtZXRlclwiLFxuICAgICAgICBydmFsLmxhYmVsXG4gICAgICApO1xuICAgIH1cbiAgICB2cy5wdXNoKHJ2YWwuSGFzUHJvcGVydHkoVG9TdHJpbmcobHZhbCkpKTtcbiAgfVxuICBcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBUaGUgaW5zdGFuY2VvZiBvcGVyYXRvciwgMTEuOC42XG4gIFxuICBmdW5jdGlvbiBiaW5hcnlJbnN0YW5jZW9mKFxuICAgIHdsOiBXb3JrTGlzdCxcbiAgICB2czogVmFsdWVTdGFja1xuICApOiB2b2lkIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgbGV0IHJ2YWw6IFZhbHVlPFZhbHVlVHlwZXM+ID0gdnMucG9wKCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGxldCBsdmFsOiBWYWx1ZTxWYWx1ZVR5cGVzPiA9IHZzLnBvcCgpO1xuICBcbiAgICBpZiAocnZhbC52YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgcnZhbC52YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChmYWxzZSkgeyAvLyBTSUxFTlQgRVJST1JcbiAgICAgICAgdnMucHVzaChuZXcgVmFsdWUoZmFsc2UsIGx1YihsdmFsLmxhYmVsLCBydmFsLmxhYmVsKSkpO1xuICAgICAgfVxuICBcbiAgICAgIG1vbml0b3IuVGhyb3coXG4gICAgICAgIFwiVHlwZUVycm9yXCIsXG4gICAgICAgIFwiaW52YWxpZCAnaW5zdGFuY2VvZicgcGFyYW1ldGVyXCIsXG4gICAgICAgIHJ2YWwubGFiZWxcbiAgICAgICk7XG4gIFxuICAgICAgdGhyb3cgJ1R5cGVTY3JpcHQnO1xuICAgIH1cbiAgXG4gICAgaWYgKCEoJ0hhc0luc3RhbmNlJyBpbiBydmFsLnZhbHVlKSkge1xuICAgICAgaWYgKGZhbHNlKSB7IC8vIFNJTEVOVCBFUlJPUlxuICAgICAgICB2cy5wdXNoKG5ldyBWYWx1ZShmYWxzZSwgbHViKGx2YWwubGFiZWwsIHJ2YWwubGFiZWwpKSk7XG4gICAgICB9XG4gIFxuICAgICAgbW9uaXRvci5UaHJvdyhcbiAgICAgICAgXCJUeXBlRXJyb3JcIixcbiAgICAgICAgXCJpbnZhbGlkICdpbnN0YW5jZW9mJyBwYXJhbWV0ZXJcIixcbiAgICAgICAgcnZhbC5sYWJlbFxuICAgICAgKTtcbiAgICB9XG4gIFxuICAgIHZzLnB1c2gocnZhbC5IYXNJbnN0YW5jZShsdmFsKSk7XG4gIH1cbiAgXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgXG4gIGV4cG9ydCB2YXIgYmluYXJ5dGJsID0ge1xuICAgICc9PSc6IGJpbmFyeUVxcy5iaW5kKG51bGwsICc9PScpLFxuICAgICchPSc6IGJpbmFyeUVxcy5iaW5kKG51bGwsICchPScpLFxuICAgICc9PT0nOiBiaW5hcnlTdHJpY3RFcXMuYmluZChudWxsLCAnPT09JyksXG4gICAgJyE9PSc6IGJpbmFyeVN0cmljdEVxcy5iaW5kKG51bGwsICchPT0nKSxcbiAgICAnPCc6IGJpbmFyeU9yZHMuYmluZChudWxsLCAnPCcpLFxuICAgICc8PSc6IGJpbmFyeU9yZHMuYmluZChudWxsLCAnPD0nKSxcbiAgICAnPic6IGJpbmFyeU9yZHMuYmluZChudWxsLCAnPicpLFxuICAgICc+PSc6IGJpbmFyeU9yZHMuYmluZChudWxsLCAnPj0nKSxcbiAgICAnPDwnOiBiaW5hcnlTaGlmdHMuYmluZChudWxsLCAnPDwnKSxcbiAgICAnPj4nOiBiaW5hcnlTaGlmdHMuYmluZChudWxsLCAnPj4nKSxcbiAgICAnPj4+JzogYmluYXJ5U2hpZnRzLmJpbmQobnVsbCwgJz4+PicpLFxuICAgICcrJzogYmluYXJ5UGx1cyxcbiAgICAnLSc6IGJpbmFyeUFyaXRobWV0aWNPcHMuYmluZChudWxsLCAnLScpLFxuICAgICcqJzogYmluYXJ5QXJpdGhtZXRpY09wcy5iaW5kKG51bGwsICcqJyksXG4gICAgJy8nOiBiaW5hcnlBcml0aG1ldGljT3BzLmJpbmQobnVsbCwgJy8nKSxcbiAgICAnJSc6IGJpbmFyeUFyaXRobWV0aWNPcHMuYmluZChudWxsLCAnJScpLFxuICAgICd8JzogYmluYXJ5Qml0d2lzZU9wcy5iaW5kKG51bGwsICd8JyksXG4gICAgJyYnOiBiaW5hcnlCaXR3aXNlT3BzLmJpbmQobnVsbCwgJyYnKSxcbiAgICAnXic6IGJpbmFyeUJpdHdpc2VPcHMuYmluZChudWxsLCAnXicpLFxuICAgICdpbic6IGJpbmFyeUluLFxuICAgICdpbnN0YW5jZW9mJzogYmluYXJ5SW5zdGFuY2VvZlxuICB9O1xuXG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gQmluYXJ5IExvZ2ljYWwgfHwsIDExLjExXG5cbmZ1bmN0aW9uIGJpbmFyeUxvZ2ljYWxPcihcbiAgICB3bDogV29ya0xpc3QsXG4gICAgdnM6IFZhbHVlU3RhY2tcbiAgKTogdm9pZCB7XG4gIFxuICAgIC8vQHRzLWlnbm9yZSBTVEFDS1xuICAgIGxldCBsdmFsID0gR2V0VmFsdWUodnMucG9wKCkpO1xuICAgIHZzLnB1c2gobHZhbCk7XG4gIFxuICAgIGxldCBsYiA9IFRvQm9vbGVhbihsdmFsKTtcbiAgICBsZXQgcmlnaHQgPSB3bC5wb3AoKTtcbiAgXG4gICAgaWYgKGxiLnZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICBcbiAgICBtb25pdG9yLmNvbnRleHQucHVzaFBDKGxiLmxhYmVsKTtcbiAgXG4gICAgbGV0IGlwID0gd2wudG9wKCk7XG4gICAgaXAudGhlbihyaWdodCk7XG4gICAgaXAudGhlbihiaW5hcnlMb2dpY2FsT3JfZW5kKTtcbiAgfVxuICBcbiAgLy8gLS0tXG4gIFxuICBmdW5jdGlvbiBiaW5hcnlMb2dpY2FsT3JfZW5kKFxuICAgIHdsOiBXb3JrTGlzdCxcbiAgICB2czogVmFsdWVTdGFja1xuICApOiB2b2lkIHtcbiAgICAvL0B0cy1pZ25vcmUgU1RBQ0tcbiAgICBsZXQgcnZhbCA9IEdldFZhbHVlKHZzLnBvcCgpKTtcbiAgICAvL0B0cy1pZ25vcmVcbiAgICBsZXQgbHZhbDogVmFsdWU8VmFsdWVUeXBlcz4gPSB2cy5wb3AoKTtcbiAgXG4gICAgbW9uaXRvci5jb250ZXh0LnBvcFBDKCk7XG4gIFxuICAgIHZzLnB1c2gobmV3IFZhbHVlKHJ2YWwudmFsdWUsIGx1YihydmFsLmxhYmVsLCBsdmFsLmxhYmVsKSkpO1xuICB9XG4gIFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIEJpbmFyeSBMb2dpY2FsICYmLCAxMS4xMVxuICBcbiAgZnVuY3Rpb24gYmluYXJ5TG9naWNhbEFuZChcbiAgICB3bDogV29ya0xpc3QsXG4gICAgdnM6IFZhbHVlU3RhY2tcbiAgKTogdm9pZCB7XG4gICAgLy9AdHMtaWdub3JlIFNUQUNLXG4gICAgbGV0IGx2YWwgPSBHZXRWYWx1ZSh2cy5wb3AoKSk7XG4gICAgdnMucHVzaChsdmFsKTtcbiAgICBsZXQgbGIgPSBUb0Jvb2xlYW4obHZhbCk7XG4gICAgbGV0IHJpZ2h0ID0gd2wucG9wKCk7XG4gIFxuICAgIGlmICghbGIudmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIFxuICAgIG1vbml0b3IuY29udGV4dC5wdXNoUEMobGIubGFiZWwpO1xuICBcbiAgICBsZXQgaXAgPSB3bC50b3AoKTtcbiAgICBpcC50aGVuKHJpZ2h0KTtcbiAgICBpcC50aGVuKGJpbmFyeUxvZ2ljYWxBbmRfZW5kKTtcbiAgfVxuICBcbiAgLy8gLS0tXG4gIFxuICBmdW5jdGlvbiBiaW5hcnlMb2dpY2FsQW5kX2VuZChcbiAgICB3bDogV29ya0xpc3QsXG4gICAgdnM6IFZhbHVlU3RhY2tcbiAgKTogdm9pZCB7XG4gICAgLy9AdHMtaWdub3JlIFNUQUNLXG4gICAgbGV0IHJ2YWwgPSBHZXRWYWx1ZSh2cy5wb3AoKSk7XG4gICAgLy9AdHMtaWdub3JlIFNUQUNLXG4gICAgbGV0IGx2YWw6IFZhbHVlPFZhbHVlVHlwZXM+ID0gdnMucG9wKCk7XG4gIFxuICAgIG1vbml0b3IuY29udGV4dC5wb3BQQygpO1xuICBcbiAgICB2cy5wdXNoKG5ldyBWYWx1ZShydmFsLnZhbHVlLCBsdWIocnZhbC5sYWJlbCwgbHZhbC5sYWJlbCkpKTtcbiAgfVxuICBcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBcbiAgZXhwb3J0IHZhciBsb2dpY2FsdGJsID0ge1xuICAgICd8fCc6IGJpbmFyeUxvZ2ljYWxPcixcbiAgICAnJiYnOiBiaW5hcnlMb2dpY2FsQW5kXG4gIH07XG4gIFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIFxuICBmdW5jdGlvbiBhc3NpZ25tZW50T3BzKFxuICAgIG9wOiBcIitcIiB8IFwiLVwiIHwgXCIqXCIgfCBcIi9cIiB8IFwiJVwiIHwgXCI+PlwiIHwgXCI8PFwiIHwgXCI+Pj5cIiB8IFwifFwiIHwgXCImXCIgfCBcIl5cIiB8IG51bGwsXG4gICAgd2w6IFdvcmtMaXN0LFxuICAgIHZzOiBWYWx1ZVN0YWNrXG4gICk6IHZvaWQge1xuICAgIC8vQHRzLWlnbm9yZSBTVEFDS1xuICAgIGxldCBydmFsID0gR2V0VmFsdWUodnMucG9wKCkpO1xuICAgIGxldCBscmVmID0gdnMucG9wKCk7XG4gIFxuICAgIGlmIChvcCAhPT0gbnVsbCkge1xuICAgICAgdnMucHVzaChscmVmKTtcbiAgICAgIC8vQHRzLWlnbm9yZSBTVEFDS1xuICAgICAgdnMucHVzaChHZXRWYWx1ZShscmVmKSk7XG4gICAgICB2cy5wdXNoKHJ2YWwpO1xuICAgICAgYmluYXJ5dGJsW29wXSh3bCwgdnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2cy5wdXNoKGxyZWYpO1xuICAgICAgdnMucHVzaChydmFsKTtcbiAgICB9XG4gIH1cbiAgXG4gIGV4cG9ydCB2YXIgYXNzaWdubWVudHRibCA9IHtcbiAgICAnPSc6IGFzc2lnbm1lbnRPcHMuYmluZChudWxsLCBudWxsKSxcbiAgICAnKz0nOiBhc3NpZ25tZW50T3BzLmJpbmQobnVsbCwgJysnKSxcbiAgICAnLT0nOiBhc3NpZ25tZW50T3BzLmJpbmQobnVsbCwgJy0nKSxcbiAgICAnKj0nOiBhc3NpZ25tZW50T3BzLmJpbmQobnVsbCwgJyonKSxcbiAgICAnLz0nOiBhc3NpZ25tZW50T3BzLmJpbmQobnVsbCwgJy8nKSxcbiAgICAnJT0nOiBhc3NpZ25tZW50T3BzLmJpbmQobnVsbCwgJyUnKSxcbiAgICAnPj49JzogYXNzaWdubWVudE9wcy5iaW5kKG51bGwsICc+PicpLFxuICAgICc8PD0nOiBhc3NpZ25tZW50T3BzLmJpbmQobnVsbCwgJzw8JyksXG4gICAgJz4+Pj0nOiBhc3NpZ25tZW50T3BzLmJpbmQobnVsbCwgJz4+PicpLFxuICAgICd8PSc6IGFzc2lnbm1lbnRPcHMuYmluZChudWxsLCAnfCcpLFxuICAgICcmPSc6IGFzc2lnbm1lbnRPcHMuYmluZChudWxsLCAnJicpLFxuICAgICdePSc6IGFzc2lnbm1lbnRPcHMuYmluZChudWxsLCAnXicpXG4gIH07IiwiaW1wb3J0IHsgTW9uaXRvckJhc2UgfSBmcm9tIFwiLi4vTW9uaXRvckJhc2VcIjtcbmltcG9ydCB7IEZ1bmN0aW9uT2JqZWN0IH0gZnJvbSBcIi4uL09iamVjdHMvRnVuY3Rpb25PYmplY3RcIjtcbmltcG9ydCB7IENyZWF0ZUFyZ3VtZW50c09iamVjdCB9IGZyb20gXCIuLi9PYmplY3RzL0FyZ3VtZW50c09iamVjdFwiO1xuaW1wb3J0IHsgVmFsdWUgfSBmcm9tIFwiLi4vVmFsdWVcIjtcbmltcG9ydCB7IGJvdCB9IGZyb20gXCIuLi9MYWJlbFwiO1xuXG5pbXBvcnQgKiBhcyBjb25zdGFudHMgZnJvbSBcIi4uL0NvbnN0YW50c1wiO1xuaW1wb3J0ICogYXMgZXN0cmF2ZXJzZSBmcm9tIFwiZXN0cmF2ZXJzZVwiO1xuXG5kZWNsYXJlIHZhciBtb25pdG9yOiBNb25pdG9yQmFzZTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAxMC41IC0gc3RyaWN0IGlnbm9yZWRcblxuZXhwb3J0IGZ1bmN0aW9uIERlY2xhcmF0aW9uQmluZGluZ0luc3RhbnRpYXRpb24oY29udGV4dCwgRiwgYXJncykge1xuXG4gICAgdmFyIGlzRnVuY3Rpb25Db2RlLCBpc0V2YWxDb2RlLCBjb2RlO1xuICAgIGlmIChGIGluc3RhbmNlb2YgRnVuY3Rpb25PYmplY3QpIHtcbiAgICAgIGlzRnVuY3Rpb25Db2RlID0gdHJ1ZTtcbiAgICAgIGlzRXZhbENvZGUgPSBmYWxzZTtcbiAgICAgIGNvZGUgPSBGLkNvZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlzRnVuY3Rpb25Db2RlID0gZmFsc2U7XG4gICAgICBpc0V2YWxDb2RlID0gdHJ1ZTtcbiAgICAgIGNvZGUgPSBGO1xuICAgIH1cbiAgXG4gICAgdmFyIGVudiA9IGNvbnRleHQudmFyaWFibGVFbnY7XG4gICAgdmFyIGNvbmZpZ3VyYWJsZUJpbmRpbmdzID0gaXNFdmFsQ29kZTtcbiAgXG4gICAgaWYgKGlzRnVuY3Rpb25Db2RlKSB7XG4gICAgICBCaW5kQXJndW1lbnRzKGVudiwgRi5Gb3JtYWxQYXJhbWV0ZXJzLCBhcmdzKTtcbiAgICB9XG4gIFxuICAgIHZhciBwYyA9IGNvbnRleHQuZWZmZWN0aXZlUEM7XG4gIFxuICAgIEhvaXN0RnVuY3Rpb25zKGVudiwgY29kZSwgY29uZmlndXJhYmxlQmluZGluZ3MsIHBjKTtcbiAgXG4gICAgdmFyIGFyZ3VtZW50c0FscmVhZHlEZWNsYXJlZCA9IGVudi5IYXNCaW5kaW5nKGNvbnN0YW50c1snYXJndW1lbnRzJ10pO1xuICBcbiAgICBpZiAoaXNGdW5jdGlvbkNvZGUgJiYgIWFyZ3VtZW50c0FscmVhZHlEZWNsYXJlZC52YWx1ZSkge1xuICAgICAgLy8gbWFrZSBzdXJlIGl0IHJldHVybnMgYSBWYWx1ZVxuICAgICAgdmFyIGFyZ3NPYmogPSBDcmVhdGVBcmd1bWVudHNPYmplY3QoZW52LCBGLCBhcmdzKTtcbiAgXG4gICAgICAvLyBTaG91bGQgbm8gbG9uZ2VyIGJlIHN1cHBvcnRlZFxuICAgICAgLy8gRi5EZWZpbmVPd25Qcm9wZXJ0eShjb25zdGFudHNbJ2FyZ3VtZW50cyddLCBhcmdzT2JqLCBmYWxzZSk7XG4gIFxuICAgICAgZW52LkNyZWF0ZU11dGFibGVCaW5kaW5nKGNvbnN0YW50c1snYXJndW1lbnRzJ10pO1xuICAgICAgZW52LlNldE11dGFibGVCaW5kaW5nKGNvbnN0YW50c1snYXJndW1lbnRzJ10sIGFyZ3NPYmosIGZhbHNlKTtcbiAgICB9XG4gIFxuICAgIEhvaXN0VmFyaWFibGVzKGVudiwgY29kZSwgY29uZmlndXJhYmxlQmluZGluZ3MsIHBjKTtcbiAgfVxuICBcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIEZ1bmN0aW9uIGhvaXN0aW5nLCBwYXJ0IG9mIDEwLjVcbiAgXG4gIGV4cG9ydCBmdW5jdGlvbiBIb2lzdEZ1bmN0aW9ucyhlbnYsIHNjcmlwdCwgY29uZmlndXJhYmxlQmluZGluZywgcGMpIHtcbiAgXG4gICAgaWYgKCFzY3JpcHQuZnVuY3Rpb25EZWNsYXJhdGlvbnMpIHtcbiAgICAgIC8vIFxuICAgICAgc2NyaXB0LmZ1bmN0aW9uRGVjbGFyYXRpb25zID0gW107XG4gIFxuICAgICAgdmFyIHZpc2l0b3IgPSB7fTtcbiAgICAgIC8vQHRzLWlnbm9yZSBTWU5UQVhcbiAgICAgIHZpc2l0b3IubGVhdmUgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAvL0B0cy1pZ25vcmUgU1lOVEFYXG4gICAgICB2aXNpdG9yLmVudGVyID0gZnVuY3Rpb24gKFxuICAgICAgICB0aGlzIDoge1xuICAgICAgICAgICAgc2tpcCAoKSA6IHZvaWRcbiAgICAgICAgICB9LFxuICAgICAgICAgIG5vZGVcbiAgICAgICAgKSB7XG4gIFxuICAgICAgICBpZiAobm9kZS50eXBlID09PSAnRnVuY3Rpb25EZWNsYXJhdGlvbicpIHtcbiAgICAgICAgICBzY3JpcHQuZnVuY3Rpb25EZWNsYXJhdGlvbnMucHVzaChub2RlKTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgLy8gRG8gbm90IGhvaXN0IGluc2lkZSBmdW5jdGlvbnNcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ0Z1bmN0aW9uRGVjbGFyYXRpb24nIHx8XG4gICAgICAgICAgbm9kZS50eXBlID09PSAnRnVuY3Rpb25FeHByZXNzaW9uJykge1xuICAgICAgICAgIHRoaXMuc2tpcCgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICBcbiAgICAgIGVzdHJhdmVyc2UudHJhdmVyc2Uoc2NyaXB0LCB2aXNpdG9yKTtcbiAgICB9XG4gIFxuICAgIHZhciBkcyA9IHNjcmlwdC5mdW5jdGlvbkRlY2xhcmF0aW9ucztcbiAgICB2YXIgaTtcbiAgXG4gICAgdmFyIGxlbiA9IGRzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgXG4gICAgICB2YXIgZm4gPSBuZXcgVmFsdWUoZHNbaV0uaWQubmFtZSwgYm90KTtcbiAgICAgIHZhciBmbyA9IG5ldyBGdW5jdGlvbk9iamVjdChkc1tpXS5wYXJhbXMsIGRzW2ldLmJvZHksIGVudik7XG4gIFxuICAgICAgZm8uTmFtZSA9IGRzW2ldLmlkLm5hbWU7XG4gICAgICBmby5Tb3VyY2UgPSBkc1tpXTtcbiAgXG4gICAgICB2YXIgZnVuY0FscmVhZHlEZWNsYXJlZCA9IGVudi5IYXNCaW5kaW5nKGZuKTtcbiAgICAgIGlmICghZnVuY0FscmVhZHlEZWNsYXJlZC52YWx1ZSkge1xuICAgICAgICBlbnYuQ3JlYXRlTXV0YWJsZUJpbmRpbmcoZm4sIGNvbmZpZ3VyYWJsZUJpbmRpbmcpO1xuICAgICAgfVxuICBcbiAgICAgIGVudi5TZXRNdXRhYmxlQmluZGluZyhmbiwgbmV3IFZhbHVlKGZvLCBwYykpO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFZhcmlhYmxlIGhvaXN0aW5nLCBwYXJ0IG9mIDEwLjVcbiAgXG4gIGV4cG9ydCBmdW5jdGlvbiBIb2lzdFZhcmlhYmxlcyhlbnYsIHNjcmlwdCwgY29uZmlndXJhYmxlQmluZGluZ3MsIHBjKSB7XG4gIFxuICAgIGlmICghc2NyaXB0LnZhcmlhYmxlRGVjbGFyYXRpb25zKSB7XG4gIFxuICAgICAgc2NyaXB0LnZhcmlhYmxlRGVjbGFyYXRpb25zID0gW107XG4gIFxuICAgICAgdmFyIHZpc2l0b3IgPSB7fTtcbiAgICAgIC8vQHRzLWlnbm9yZSBTWU5UQVhcbiAgICAgIHZpc2l0b3IubGVhdmUgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAvL0B0cy1pZ25vcmUgU1lOVEFYXG4gICAgICB2aXNpdG9yLmVudGVyID0gZnVuY3Rpb24gKFxuICAgICAgICB0aGlzIDogeyBcbiAgICAgICAgICAgIHNraXAoKTp2b2lkXG4gICAgICAgICAgfSxcbiAgICAgICAgICBub2RlXG4gICAgICAgICkge1xuICBcbiAgICAgICAgLy8gRG8gbm90IGhvaXN0IGluc2lkZSBmdW5jdGlvbnNcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ0Z1bmN0aW9uRGVjbGFyYXRpb24nIHx8XG4gICAgICAgICAgbm9kZS50eXBlID09PSAnRnVuY3Rpb25FeHByZXNzaW9uJykge1xuICAgICAgICAgIHRoaXMuc2tpcCgpO1xuICAgICAgICB9XG4gIFxuICAgICAgICBpZiAobm9kZS50eXBlID09PSAnVmFyaWFibGVEZWNsYXJhdGlvbicpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbm9kZS5kZWNsYXJhdGlvbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkZWNsYXJhdG9yID0gbm9kZS5kZWNsYXJhdGlvbnNbaV07XG4gICAgICAgICAgICB2YXIgcGF0dGVybiA9IGRlY2xhcmF0b3IuaWQ7XG4gICAgICAgICAgICBzY3JpcHQudmFyaWFibGVEZWNsYXJhdGlvbnMucHVzaChwYXR0ZXJuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gIFxuICAgICAgZXN0cmF2ZXJzZS50cmF2ZXJzZShzY3JpcHQsIHZpc2l0b3IpO1xuICAgIH1cbiAgXG4gICAgdmFyIGRzID0gc2NyaXB0LnZhcmlhYmxlRGVjbGFyYXRpb25zO1xuICAgIHZhciBpO1xuICBcbiAgICB2YXIgbGVuID0gZHMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICBcbiAgICAgIGlmIChkc1tpXS50eXBlICE9PSAnSWRlbnRpZmllcicpIHtcbiAgICAgICAgbW9uaXRvci5mYXRhbCgnUGF0dGVycyBpcyB2YXJpYWJsZSBkZWNsYXJhdGlvbnMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgfVxuICAgICAgLy8gZGVjbGFyYXRpb25zIGFyZSBpbmRlbnRpZmllcnMsIG5vdCBnZW5lcmFsIHBhdHRlcm5zXG4gICAgICB2YXIgZG4gPSBuZXcgVmFsdWUoZHNbaV0ubmFtZSwgYm90KTtcbiAgXG4gICAgICB2YXIgdmFyQWxyZWFkeURlY2xhcmVkID0gZW52Lkhhc0JpbmRpbmcoZG4pO1xuICAgICAgaWYgKCF2YXJBbHJlYWR5RGVjbGFyZWQudmFsdWUpIHtcbiAgICAgICAgZW52LkNyZWF0ZU11dGFibGVCaW5kaW5nKGRuLCBjb25maWd1cmFibGVCaW5kaW5ncyk7XG4gICAgICAgIGVudi5TZXRNdXRhYmxlQmluZGluZyhkbiwgbmV3IFZhbHVlKHVuZGVmaW5lZCwgcGMpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBCaW5kIEFyZ3VtZW50cywgXG5leHBvcnQgZnVuY3Rpb24gQmluZEFyZ3VtZW50cyhlbnYsIG5hbWVzLCBhcmdzKSB7XG4gICAgaWYgKGFyZ3MgPT0gdW5kZWZpbmVkKSByZXR1cm47XG4gIFxuICAgIHZhciBhcmdDb3VudCA9IGFyZ3MubGVuZ3RoO1xuICAgIHZhciBuYW1lQ291bnQgPSBuYW1lcy5sZW5ndGg7XG4gIFxuICAgIG1vbml0b3IuY29udGV4dC5wdXNoUEMoYm90KTtcbiAgICBmb3IgKHZhciBuID0gMDsgbiA8IG5hbWVDb3VudDsgbisrKSB7XG4gICAgICB2YXIgdjtcbiAgICAgIGlmIChuID49IGFyZ0NvdW50KVxuICAgICAgICB2ID0gbmV3IFZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgICAgIGVsc2VcbiAgICAgICAgdiA9IGFyZ3Nbbl07XG4gIFxuICAgICAgdmFyIGlkID0gbmFtZXNbbl07XG4gICAgICBpZiAoaWQudHlwZSAhPT0gJ0lkZW50aWZpZXInKSB7XG4gICAgICAgIG1vbml0b3IuZmF0YWwoaWQudHlwZSArICcgaXMgbm90IHN1cHBvcnRlZCBpbiBCaW5kQXJndW1lbnRzJyk7XG4gICAgICB9XG4gIFxuICAgICAgdmFyIGFyZ05hbWUgPSBuZXcgVmFsdWUoaWQubmFtZSwgYm90KTtcbiAgICAgIHZhciBhcmdBbHJlYWR5RGVjbGFyZWQgPSBlbnYuSGFzQmluZGluZyhhcmdOYW1lKTtcbiAgXG4gICAgICBtb25pdG9yLmNvbnRleHQucmFpc2VQQyhhcmdBbHJlYWR5RGVjbGFyZWQubGFiZWwpO1xuICAgICAgaWYgKCFhcmdBbHJlYWR5RGVjbGFyZWQudmFsdWUpIHtcbiAgICAgICAgZW52LkNyZWF0ZU11dGFibGVCaW5kaW5nKGFyZ05hbWUpO1xuICAgICAgfVxuICBcbiAgICAgIGVudi5TZXRNdXRhYmxlQmluZGluZyhhcmdOYW1lLCB2KTtcbiAgICB9XG4gICAgbW9uaXRvci5jb250ZXh0LnBvcFBDKCk7XG4gIH0iLCJpbXBvcnQgeyBXb3JrTGlzdCwgVmFsdWVTdGFjayB9IGZyb20gXCIuLi9Db250ZXh0XCI7XG5cbmV4cG9ydCBjbGFzcyBKU0Zsb3dEZWJ1Z0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3M6IGFueVtdKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEFzc2VydFZhbHVlU3RhY2tTaXplKGV4cGVjdGVkU2l6ZTogbnVtYmVyLCB2czogVmFsdWVTdGFjayk6IHZvaWQge1xuICAgIGlmICh2cy5zaXplKCkgIT09IGV4cGVjdGVkU2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgSlNGbG93RGVidWdFcnJvcihgRXhwZWN0ZWQgc2l6ZSBvZiB2YWx1ZSBzdGFjayB0byBiZSAke2V4cGVjdGVkU2l6ZX0gYnV0IGl0IGlzICR7dnMuc2l6ZSgpfWApO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIENoZWNrVmFsdWVTdGFja1NpemUoZXhwZWN0ZWRTaXplOiBudW1iZXIsIG1zZz86IHN0cmluZyk6ICh3bDogV29ya0xpc3QsIHZzOiBWYWx1ZVN0YWNrKSA9PiB2b2lkIHtcbiAgICBsZXQgZXhjID0gbmV3IEpTRmxvd0RlYnVnRXJyb3IoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHdsOiBXb3JrTGlzdCwgdnM6IFZhbHVlU3RhY2spOiB2b2lkIHtcbiAgICAgICAgaWYgKHZzLnNpemUoKSAhPT0gZXhwZWN0ZWRTaXplKSB7XG4gICAgICAgICAgICBleGMubWVzc2FnZSA9IGBFeHBlY3RlZCBzaXplIG9mIHZhbHVlIHN0YWNrIHRvIGJlICR7ZXhwZWN0ZWRTaXplfSBidXQgaXQgaXMgJHt2cy5zaXplKCl9YDtcbiAgICAgICAgICAgIHRocm93IGV4YztcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IHR5cGUgQ2FuYXJ5ID0geyB0b2tlbiA6IG51bWJlciwgb3duZXIgOiBzdHJpbmcsIHZzc2l6ZSA6IG51bWJlciB9O1xuXG5mdW5jdGlvbiBJc0NhbmFyeSh4IDogYW55KSA6IHggaXMgQ2FuYXJ5IHtcbiAgICByZXR1cm4gdHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGwgJiYgeC50b2tlbiAhPT0gdW5kZWZpbmVkICYmIHgudnNzaXplICE9PSB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBQdXNoQ2FuYXJ5KHZzIDogVmFsdWVTdGFjaywgb3duZXIgOiBzdHJpbmcpIHtcbiAgICBsZXQgY2FuYXJ5ID0geyB0b2tlbiA6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSwgb3duZXIgOiBvd25lciwgdnNzaXplIDogdnMuc2l6ZSgpIH07XG4gICAgLy9AdHMtaWdub3JlIENBTkFSWVxuICAgIHZzLnB1c2goY2FuYXJ5KTtcbiAgICByZXR1cm4gY2FuYXJ5O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gQXNzZXJ0VmFsaWRDYW5hcnkodnMgOiBWYWx1ZVN0YWNrLCBleHBlY3RlZCA6IENhbmFyeSkge1xuICAgIGxldCB4ID0gdnMucG9wKCk7XG4gICAgaWYgKCFJc0NhbmFyeSh4KSB8fCB4LnRva2VuICE9PSBleHBlY3RlZC50b2tlbikge1xuICAgICAgICB2cy5wdXNoKHgpO1xuICAgICAgICBjb25zb2xlLmxvZygnW0pTRmxvdyBGQVRBTF0gQ2FuYXJ5IHZlcmlmaWNhdGlvbiBmYWlsZWQ6JywgRXJyb3IoKS5zdGFjayk7XG4gICAgICAgIHRocm93IG5ldyBKU0Zsb3dEZWJ1Z0Vycm9yKGBDYW5ub3QgdmVyaWZ5IGNhbmFyeWApO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBSZXN1bHQgfSBmcm9tIFwiLi4vUmVzdWx0XCI7XG5pbXBvcnQgeyBWYWx1ZSB9IGZyb20gXCIuLi9WYWx1ZVwiO1xuaW1wb3J0IHsgYm90LCBsZSwgbHViIH0gZnJvbSBcIi4uL0xhYmVsXCI7XG5pbXBvcnQgeyBTeW50YXhFcnJvck9iamVjdCB9IGZyb20gXCIuLi9PYmplY3RzL1N5bnRheEVycm9yT2JqZWN0XCI7XG5pbXBvcnQgeyBpc0d1YXJkZWRGdW5jdGlvbiwgaXNDbG9zdXJlLCBXb3JrTGlzdCwgVmFsdWVTdGFjayB9IGZyb20gXCIuLi9Db250ZXh0XCI7XG5pbXBvcnQgeyBleHByZXNzaW9udGJsIH0gZnJvbSBcIi4vRXhwcmVzc2lvblwiO1xuaW1wb3J0IHsgc3RhdGVtZW50dGJsIH0gZnJvbSBcIi4vU3RhdGVtZW50XCI7XG5pbXBvcnQgeyBNb25pdG9yQmFzZSB9IGZyb20gXCIuLi9Nb25pdG9yQmFzZVwiO1xuXG5pbXBvcnQgKiBhcyBlc3ByaW1hIGZyb20gJ2VzcHJpbWEnO1xuaW1wb3J0ICogYXMgZXN0cmVlIGZyb20gJ2VzdHJlZSc7XG5pbXBvcnQgeyBIb2lzdEZ1bmN0aW9ucywgSG9pc3RWYXJpYWJsZXMsIERlY2xhcmF0aW9uQmluZGluZ0luc3RhbnRpYXRpb24gfSBmcm9tIFwiLi9CaW5kaW5nXCI7XG5pbXBvcnQgeyBEZWNsYXJhdGl2ZUVudmlyb25tZW50UmVjb3JkIH0gZnJvbSBcIi4uL0RlY2xhcmF0aXZlRW52aXJvbm1lbnRSZWNvcmRcIjtcbmltcG9ydCB7IE9iamVjdEVudmlyb25tZW50UmVjb3JkIH0gZnJvbSBcIi4uL09iamVjdEVudmlyb25tZW50UmVjb3JkXCI7XG5pbXBvcnQgeyBUYXNrIH0gZnJvbSBcIi4vVGFza1wiO1xuaW1wb3J0IHsgUHJvZ3JhbSB9IGZyb20gXCJlc3RyZWVcIjtcbmltcG9ydCB7IElzQ3Jhd2xlciB9IGZyb20gXCIuLi9Ub3BsZXZlbC9jcmF3bGVyL0NyYXdsZXJVdGlsXCI7XG5cblxuZGVjbGFyZSB2YXIgbW9uaXRvcjogTW9uaXRvckJhc2U7XG5kZWNsYXJlIHZhciBKU0ZMT1dfU1RBQ0tfQ0hFQ0s6IGJvb2xlYW47XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZnVuY3Rpb24gcnVubmluZygpIHtcbiAgICByZXR1cm4gIW1vbml0b3IuY29udGV4dC53b3JrTGlzdC5lbXB0eSgpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4ZWN1dGUoXG4gICAgYXN0OiBlc3RyZWUuUHJvZ3JhbSB8IGVzdHJlZS5TdGF0ZW1lbnQgfCBlc3RyZWUuRXhwcmVzc2lvbixcbiAgICBkZWJ1Z0VuYWJsZWQ/OiBib29sZWFuXG4pOiBSZXN1bHQge1xuXG4gICAgbW9uaXRvci5jb250ZXh0LndvcmtMaXN0LnB1c2goYXN0KTtcbiAgICBtb25pdG9yLmNvbnRleHQucmVzdWx0ID0gbmV3IFJlc3VsdCgpO1xuXG4gICAgaWYgKGRlYnVnRW5hYmxlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlYnVnRW5hYmxlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgbGV0IGNvbnQgPSB0cnVlO1xuXG4gICAgZG8ge1xuICAgICAgICBpZiAoZGVidWdFbmFibGVkICYmIG1vbml0b3IuZGVidWcuYWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9uaXRvci5jb250ZXh0LnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBjb250ID0gc3RlcCgpO1xuICAgICAgICBtb25pdG9yLmV4ZWN1dGlvbkluZm8uc3RlcCgpO1xuICAgICAgIFxuICAgIH0gd2hpbGUgKGNvbnQpO1xuXG4gICAgLy8gI0NSQVdMRVJcbiAgICBpZiAoSXNDcmF3bGVyKG1vbml0b3IpKSB7XG4gICAgICAgIG1vbml0b3IuQ3Jhd2xlckRhdGEuRHVtcFRvQ3Jhd2xlcigpO1xuICAgIH1cblxuICAgIHJldHVybiBtb25pdG9yLmNvbnRleHQucmVzdWx0O1xufVxuXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzdW1lKCk6IFJlc3VsdCB7XG5cbiAgICBsZXQgY29udCA9IHRydWU7XG4gICAgZG8ge1xuICAgICAgICBjb250ID0gc3RlcCgpO1xuICAgICAgICBpZiAobW9uaXRvci5kZWJ1Zy5hY3RpdmUpIHtcbiAgICAgICAgICAgIHJldHVybiBtb25pdG9yLmNvbnRleHQucmVzdWx0O1xuICAgICAgICB9XG4gICAgfSB3aGlsZSAoY29udCk7XG5cbiAgICByZXR1cm4gbW9uaXRvci5jb250ZXh0LnJlc3VsdDtcbn1cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZnVuY3Rpb24gZXhlY3V0ZUdsb2JhbENvZGUoY29kZTogc3RyaW5nLCBvcmlnaW46IHN0cmluZywgb3B0aW9ucz86IHsgZGVidWdFbmFibGVkPzogYm9vbGVhbiB9KTogUmVzdWx0IHtcblxuICAgIHRyeSB7XG4gICAgICAgIC8qIGNvbnZlcnQgY29kZSB0byBlczUsIHVzaW5nIHNvdXJjZVR5cGUgJ3VuYW1iaWdpb3VzJywgbWVhbmluZyBpdCB3aWxsIGJlXG4gICAgICAgICAqIGludGVycHJldGVkIGFzIHNjcmlwdCBpbiBhIGJyb3dzZXIgYW5kIF9ub3RfIGFkZCBcInVzZSBzdHJpY3RcIiwgYW5kXG4gICAgICAgICAqIGVpdGhlciBhIHNjcmlwdCBvciBtb2R1bGUgaW4gbm9kZWpzIChhbmQgYWRkIFwidXNlIHN0cmljdFwiIGlmIGl0IGlzIGFcbiAgICAgICAgICogbW9kdWxlKSAqL1xuXG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkID0gbW9uaXRvci50cmFuc2Zvcm0oY29kZSk7XG4gICAgICAgIG1vbml0b3IuY29kZSA9IGNvZGU7XG4gICAgICAgIG1vbml0b3IuYXN0ID0gZXNwcmltYS5wYXJzZSh0cmFuc2Zvcm1lZCwgeyBsb2M6IHRydWUsIHJhbmdlOiB0cnVlLCB0b2xlcmFudDogdHJ1ZSB9KTtcblxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbGV0IG1zZyA9IG5ldyBWYWx1ZShgJHtlLmRlc2NyaXB0aW9ufSBpbiAke29yaWdpbn0gOiAke2UubGluZU51bWJlcn0gOiAke2UuY29sdW1ufWAsIGJvdCk7XG5cbiAgICAgICAgbGV0IG9iaiA9IG5ldyBTeW50YXhFcnJvck9iamVjdChtc2cpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gbmV3IFJlc3VsdCgpO1xuICAgICAgICByZXN1bHQudHlwZSA9ICd0aHJvdyc7XG4gICAgICAgIHJlc3VsdC52YWx1ZSA9IG5ldyBWYWx1ZShvYmosIGJvdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgbGV0IGRlYnVnRW5hYmxlZCA9IHRydWU7XG4gICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMuZGVidWdFbmFibGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBkZWJ1Z0VuYWJsZWQgPSBvcHRpb25zLmRlYnVnRW5hYmxlZDtcbiAgICB9XG5cbiAgICBlbnRlckdsb2JhbENvZGUobW9uaXRvci5hc3QpO1xuICAgIGxldCByZXN1bHQgPSBleGVjdXRlKG1vbml0b3IuYXN0LCBkZWJ1Z0VuYWJsZWQpO1xuICAgIG1vbml0b3IuZXhlY3V0aW9uSW5mby5yZXBvcnQoKTtcbiAgICBcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vICAgY29udGFpbnMgdGhlIGRlY2xhcmF0aW9uIGJpbmRpbmcgKDEwLjUpIG9mIGdsb2JhbCBjb2RlXG5cbmV4cG9ydCBmdW5jdGlvbiBlbnRlckdsb2JhbENvZGUoYXN0OiBlc3RyZWUuUHJvZ3JhbSk6IHZvaWQge1xuXG4gICAgbGV0IGMgPSBtb25pdG9yLmNvbnRleHQ7XG5cbiAgICAvLyAxMC41IC0gaG9pc3RpbmdcbiAgICBIb2lzdEZ1bmN0aW9ucyhjLnZhcmlhYmxlRW52LCBhc3QsIGZhbHNlLCBib3QpO1xuICAgIEhvaXN0VmFyaWFibGVzKGMudmFyaWFibGVFbnYsIGFzdCwgZmFsc2UsIGJvdCk7XG5cbn1cblxuXG5cbi8vIC0tLVxuXG5leHBvcnQgZnVuY3Rpb24gZW50ZXJFdmFsQ29kZShjb2RlOiBQcm9ncmFtLCBfZXZhbCkge1xuICAgIHZhciBjID0gbW9uaXRvci5jb250ZXh0O1xuXG4gICAgLy8gMTUuMS4yLjEuMSwgaXMgZGlyZWN0IGNhbGxcbiAgICB2YXIgaXNEaXJlY3Q7XG5cbiAgICAvL0B0cy1pZ25vcmUgVFlQRVNcbiAgICBpc0RpcmVjdCA9IGMuY3VycmVudENhbGwucmVmZXJlbmNlLmJhc2UudmFsdWUgaW5zdGFuY2VvZiBPYmplY3RFbnZpcm9ubWVudFJlY29yZCB8fFxuICAgICAgICAvL0B0cy1pZ25vcmUgVFlQRVNcbiAgICAgICAgYy5jdXJyZW50Q2FsbC5yZWZlcmVuY2UuYmFzZS52YWx1ZSBpbnN0YW5jZW9mIERlY2xhcmF0aXZlRW52aXJvbm1lbnRSZWNvcmQ7XG5cbiAgICAvL0B0cy1pZ25vcmUgVFlQRVNcbiAgICBpc0RpcmVjdCA9IGlzRGlyZWN0ICYmIGMuY3VycmVudENhbGwucmVmZXJlbmNlLnByb3BlcnR5TmFtZS52YWx1ZSA9PT0gJ2V2YWwnO1xuICAgIC8vQHRzLWlnbm9yZSBUWVBFU1xuICAgIGlzRGlyZWN0ID0gaXNEaXJlY3QgJiYgYy5jdXJyZW50Q2FsbC50YXJnZXQuYWN0dWFsRnVuY3Rpb24gPT09IF9ldmFsO1xuXG4gICAgdmFyIGNvbnRleHQgPSBjLmNsb25lKCk7XG5cbiAgICAvLyAxMC40LjIgLSBubyBjYWxsaW5nIGNvbnRleHQgb3Igbm90IGRpcmVjdCBjYWxsXG4gICAgaWYgKCFpc0RpcmVjdCkge1xuICAgICAgICB2YXIgZ2xvYmFsID0gbW9uaXRvci5HbG9iYWxPYmplY3Q7XG4gICAgICAgIHZhciBnbG9iYWxFbnYgPSBtb25pdG9yLkdsb2JhbEVudmlyb25tZW50O1xuXG4gICAgICAgIGNvbnRleHQudGhpc1ZhbHVlID0gbmV3IFZhbHVlKGdsb2JhbCwgYm90KTtcbiAgICAgICAgY29udGV4dC5sZXhpY2FsRW52ID0gbmV3IFZhbHVlKGdsb2JhbEVudiwgYm90KTtcbiAgICAgICAgY29udGV4dC52YXJpYWJsZUVudiA9IG5ldyBWYWx1ZShnbG9iYWxFbnYsIGJvdCk7XG4gICAgfVxuXG4gICAgLy9AdHMtaWdub3JlIFRZUEVTXG4gICAgRGVjbGFyYXRpb25CaW5kaW5nSW5zdGFudGlhdGlvbihjb250ZXh0LCBjb2RlKTtcblxuICAgIC8vIGZvciBzdGFjayB0cmFjZSBcbiAgICBjb250ZXh0Lm93bmVyID0gJ2V2YWwnO1xuXG4gICAgcmV0dXJuIGNvbnRleHQ7XG59XG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbmZ1bmN0aW9uIHN0ZXAoKTogYm9vbGVhbiB7XG5cbiAgICAvL0B0cy1pZ25vcmUgLkxBU1RcbiAgICBpZiAobW9uaXRvci5sYXN0ID09PSB1bmRlZmluZWQpIG1vbml0b3IubGFzdCA9IFtdO1xuXG4gICAgbGV0IGMgPSBtb25pdG9yLmNvbnRleHQ7XG4gICAgbGV0IHdsID0gYy53b3JrTGlzdDtcbiAgICBsZXQgdnMgPSBjLnZhbHVlU3RhY2s7XG5cbiAgICBsZXQgcmVzdWx0ID0gYy5yZXN1bHQ7XG5cbiAgICBpZiAod2wuZW1wdHkoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IHRhc2sgPSB3bC5wb3AoKTtcbiAgICAvL0B0cy1pZ25vcmUgLkxBU1RcbiAgICBpZiAobW9uaXRvci5sYXN0Lmxlbmd0aCA+IDEwMCkge1xuICAgICAgICAvL0B0cy1pZ25vcmUgLkxBU1RcbiAgICAgICAgbW9uaXRvci5sYXN0LnNoaWZ0KCk7XG4gICAgfVxuICAgIC8vQHRzLWlnbm9yZSAuTEFTVFxuICAgIG1vbml0b3IubGFzdC5wdXNoKHRhc2spO1xuXG4gICAgdHJ5IHtcblxuICAgICAgICAvLyB0aHJvdywgY29udGludWUsIG9yIGJyZWFrIHN0YXRlXG5cbiAgICAgICAgaWYgKHJlc3VsdC50eXBlICE9PSAnbm9ybWFsJykge1xuXG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHRhc2sgaW5zdGFuY2VvZiBUYXNrICYmIHRhc2suUnVuRm9yKHJlc3VsdC50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB0YXNrLkV4ZWN1dGUod2wsIHZzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGlzR3VhcmRlZEZ1bmN0aW9uKHRhc2spICYmIHRhc2sucnVuZm9yICE9PSB1bmRlZmluZWQgJiYgcmVzdWx0LnR5cGUgaW4gdGFzay5ydW5mb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyh0YXNrLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB0YXNrKHdsLCB2cyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgaWYgKGlzQ2xvc3VyZSh0YXNrKSAmJiB0YXNrLmZ1bmMucnVuZm9yICE9PSB1bmRlZmluZWQgJiYgcmVzdWx0LnR5cGUgaW4gdGFzay5mdW5jLnJ1bmZvcikge1xuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKHRhc2suZnVuYy5uYW1lKTtcblxuXG4gICAgICAgICAgICAgICAgICAgIHRhc2suZnVuYy5jYWxsKHRhc2suZGF0YSwgd2wsIHZzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHdsLmVtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vICAgICAgY29uc29sZS5sb2coJ3NraXBwaW5nJywgdGFzayk7XG5cbiAgICAgICAgICAgICAgICB0YXNrID0gd2wucG9wKCk7XG4gICAgICAgICAgICAgICAgLy9AdHMtaWdub3JlIC5MQVNUXG4gICAgICAgICAgICAgICAgaWYgKG1vbml0b3IubGFzdC5sZW5ndGggPiAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy9AdHMtaWdub3JlIC5MQVNUXG4gICAgICAgICAgICAgICAgICAgIG1vbml0b3IubGFzdC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL0B0cy1pZ25vcmUgLkxBU1RcbiAgICAgICAgICAgICAgICBtb25pdG9yLmxhc3QucHVzaCh0YXNrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRhc2sgaW5zdGFuY2VvZiBUYXNrKSB7XG4gICAgICAgICAgICB0YXNrLkV4ZWN1dGUod2wsIHZzKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZnVuY3Rpb24/XG4gICAgICAgIGlmICh0eXBlb2YgdGFzayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyh0YXNrLm5hbWUpO1xuXG4gICAgICAgICAgICB0YXNrKHdsLCB2cyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsb3N1cmU/XG5cbiAgICAgICAgaWYgKCdmdW5jJyBpbiB0YXNrICYmICdkYXRhJyBpbiB0YXNrKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKHRhc2suZnVuYy5uYW1lKTtcblxuICAgICAgICAgICAgdGFzay5mdW5jLmNhbGwodGFzay5kYXRhLCB3bCwgdnMpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIG90aGVyd2lzZSwgc3ludGF4XG4gICAgICAgIGxldCBub2RlID0gdGFzaztcblxuXG5cbiAgICAgICAgLy8gZXhwcmVzc2lvbnNcbiAgICAgICAgaWYgKG5vZGUudHlwZSBpbiBleHByZXNzaW9udGJsKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdleHByZXNzaW9uJywgbm9kZS50eXBlKTtcbiAgICAgICAgICAgIGV4cHJlc3Npb250Ymxbbm9kZS50eXBlXShub2RlLCB3bCwgdnMpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzdGF0ZW1lbnQgXG5cbiAgICAgICAgLy8gZm9yIHN0YWNrIHRyYWNlXG4gICAgICAgIGMuY29kZVN0YWNrLnB1c2gobm9kZSk7XG4gICAgICAgIHdsLnRvcCgpLnRoZW4oUG9wQ29kZVN0YWNrLkluc3RhbmNlKTtcblxuICAgICAgICBpZiAobm9kZS50eXBlIGluIHN0YXRlbWVudHRibCkge1xuICAgICAgICAgICAgLy8gICBjb25zb2xlLmxvZygnc3RhdGVtZW50Jywgbm9kZS50eXBlKTtcbiAgICAgICAgICAgIHN0YXRlbWVudHRibFtub2RlLnR5cGVdKG5vZGUsIHdsLCB2cyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1vbml0b3IuZmF0YWwobm9kZS50eXBlICsgJyBub3QgaW1wbGVtZW50ZWQnKTtcblxuICAgIH0gY2F0Y2ggKGUpIHtcblxuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFZhbHVlKSB7XG5cbiAgICAgICAgICAgIC8vIFZlcmZpeSB0aGF0IHRoZSBleGNlcHRpb24gaXMgYWxsb3dlZCBcbiAgICAgICAgICAgIG1vbml0b3IuYXNzZXJ0KGxlKGMuZWZmZWN0aXZlUEMsIGMubGFiZWxzLmV4YyksXG4gICAgICAgICAgICAgICAgXCJleGNlcHRpb24gaW4gXCIgKyBjLmVmZmVjdGl2ZVBDICsgXCIgbm90IGFsbG93ZWQgd2l0aCBleGNlcHRpb24gbGFiZWwgXCIgKyBjLmxhYmVscy5leGMpO1xuXG4gICAgICAgICAgICAvLyBGb3Igb2JzZXJ2YWJsZSBmbG93c1xuICAgICAgICAgICAgYy5sYWJlbHMuZXhjID0gbHViKGMubGFiZWxzLmV4YywgYy5lZmZlY3RpdmVQQyk7XG5cbiAgICAgICAgICAgIHJlc3VsdC50eXBlID0gJ3Rocm93JztcbiAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IGU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5cbmNsYXNzIFBvcENvZGVTdGFjayBleHRlbmRzIFRhc2sge1xuICAgIHN0YXRpYyBJbnN0YW5jZSA9IG5ldyBQb3BDb2RlU3RhY2soKTtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoVGFzay5ydW5mb3JfYWxsKTtcbiAgICB9XG5cbiAgICBFeGVjdXRlKHdsOiBXb3JrTGlzdCwgdnM6IFZhbHVlU3RhY2spOiB2b2lkIHtcbiAgICAgICAgbW9uaXRvci5jb250ZXh0LmNvZGVTdGFjay5wb3AoKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgV29ya0xpc3QsIFZhbHVlU3RhY2sgfSBmcm9tIFwiLi4vQ29udGV4dFwiO1xuaW1wb3J0IHsgVmFsdWUgfSBmcm9tIFwiLi4vVmFsdWVcIjtcbmltcG9ydCB7IFZhbHVlVHlwZXMgfSBmcm9tIFwiLi4vSW50ZXJmYWNlc1wiO1xuaW1wb3J0IHsgUmVmZXJlbmNlLCBSZWZlcmVuY2VUeXBlIH0gZnJvbSBcIi4uL1JlZmVyZW5jZVwiO1xuaW1wb3J0IHsgQXJyYXlPYmplY3QgfSBmcm9tIFwiLi4vT2JqZWN0cy9BcnJheU9iamVjdFwiO1xuaW1wb3J0IHsgYm90LCBsdWIsIGxlLCBMYWJlbCB9IGZyb20gXCIuLi9MYWJlbFwiO1xuaW1wb3J0IHsgR2V0VmFsdWUgfSBmcm9tIFwiLi4vR2V0VmFsdWVcIjtcbmltcG9ydCB7IE9iamVjdE9iamVjdCB9IGZyb20gXCIuLi9PYmplY3RzL09iamVjdE9iamVjdFwiO1xuaW1wb3J0IHsgSlNGUHJvcGVydHlEZXNjcmlwdG9yLCBJc0RhdGFEZXNjcmlwdG9yLCBJc0FjY2Vzc29yRGVzY3JpcHRvciB9IGZyb20gXCIuLi9Qcm9wZXJ0eURlc2NyaXB0b3JcIjtcbmltcG9ydCB7IEZ1bmN0aW9uT2JqZWN0IH0gZnJvbSBcIi4uL09iamVjdHMvRnVuY3Rpb25PYmplY3RcIjtcbmltcG9ydCB7IE5ld0RlY2xhcmF0aXZlRW52aXJvbm1lbnQgfSBmcm9tIFwiLi4vRGVjbGFyYXRpdmVFbnZpcm9ubWVudFJlY29yZFwiO1xuaW1wb3J0IHsgdW5hcnl0YmwsIHByZWZpeHRibCwgcG9zdGZpeHRibCB9IGZyb20gXCIuL1VuYXJ5T3BlcmF0b3JzXCI7XG5pbXBvcnQgeyBiaW5hcnl0YmwsIGxvZ2ljYWx0YmwsIGFzc2lnbm1lbnR0YmwgfSBmcm9tIFwiLi9CaW5hcnlPcGVyYXRvcnNcIjtcbmltcG9ydCB7IFB1dFZhbHVlIH0gZnJvbSBcIi4uL1B1dFZhbHVlXCI7XG5pbXBvcnQgeyBUb0Jvb2xlYW4gfSBmcm9tIFwiLi4vQ29udmVyc2lvbi9Ub0Jvb2xlYW5cIjtcbmltcG9ydCB7IElzQ2FsbGFibGUgfSBmcm9tIFwiLi4vVXRpbGl0eS9Jc0NhbGxhYmxlXCI7XG5pbXBvcnQgeyBDaGVja09iamVjdENvZXJjaWJsZSB9IGZyb20gXCIuLi9VdGlsaXR5L0NoZWNrT2JqZWN0Q29lcmNpYmxlXCI7XG5pbXBvcnQgeyBUb1N0cmluZyB9IGZyb20gXCIuLi9Db252ZXJzaW9uL1RvU3RyaW5nXCI7XG5pbXBvcnQgeyBHZXRJZGVudGlmaWVyUmVmZXJlbmNlIH0gZnJvbSBcIi4uL0dldElkZW50aWZpZXJSZWZlcmVuY2VcIjtcbmltcG9ydCB7IFJlZ0V4cE9iamVjdCB9IGZyb20gXCIuLi9PYmplY3RzL1JlZ0V4cE9iamVjdFwiO1xuaW1wb3J0IHsgTW9uaXRvckJhc2UgfSBmcm9tIFwiLi4vTW9uaXRvckJhc2VcIjtcblxuaW1wb3J0ICogYXMgcHAgZnJvbSAnLi4vUFAnO1xuaW1wb3J0ICogYXMgZXN0cmVlIGZyb20gJ2VzdHJlZSc7XG5pbXBvcnQgKiBhcyBjb25zdGFudHMgZnJvbSAnLi4vQ29uc3RhbnRzJztcbmltcG9ydCB7IENhbmFyeSwgUHVzaENhbmFyeSwgQXNzZXJ0VmFsaWRDYW5hcnkgfSBmcm9tIFwiLi9EZWJ1Z1wiO1xuXG5kZWNsYXJlIHZhciBtb25pdG9yOiBNb25pdG9yQmFzZTtcbmRlY2xhcmUgdmFyIEpTRkxPV19TVEFDS19DSEVDSzogYm9vbGVhbjtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBfR2V0VmFsdWUoKTogdm9pZCB7XG4gIGxldCB2cyA9IG1vbml0b3IuY29udGV4dC52YWx1ZVN0YWNrO1xuICAvLyBAdHMtaWdub3JlXG4gIGxldCB2YWw6IFZhbHVlPFZhbHVlVHlwZXM+ID0gdnMucG9wKCk7XG5cbiAgdnMucHVzaChHZXRWYWx1ZSh2YWwpKTtcbn1cblxuLy8gZXhwcmVzc2lvbiBoYW5kbGVyIGZ1bmN0aW9ucyBcblxuZXhwb3J0IHZhciBleHByZXNzaW9udGJsID0ge1xuICAnVGhpc0V4cHJlc3Npb24nOiB0aGlzRXhwcmVzc2lvbixcbiAgJ0FycmF5RXhwcmVzc2lvbic6IGFycmF5RXhwcmVzc2lvbixcbiAgJ09iamVjdEV4cHJlc3Npb24nOiBvYmplY3RFeHByZXNzaW9uLFxuICAnRnVuY3Rpb25FeHByZXNzaW9uJzogZnVuY3Rpb25FeHByZXNzaW9uLFxuICAnU2VxdWVuY2VFeHByZXNzaW9uJzogc2VxdWVuY2VFeHByZXNzaW9uLFxuICAnVW5hcnlFeHByZXNzaW9uJzogdW5hcnlFeHByZXNzaW9uLFxuICAnQmluYXJ5RXhwcmVzc2lvbic6IGJpbmFyeUV4cHJlc3Npb24sXG4gICdVcGRhdGVFeHByZXNzaW9uJzogdXBkYXRlRXhwcmVzc2lvbixcbiAgJ0xvZ2ljYWxFeHByZXNzaW9uJzogbG9naWNhbEV4cHJlc3Npb24sXG4gICdBc3NpZ25tZW50RXhwcmVzc2lvbic6IGFzc2lnbm1lbnRFeHByZXNzaW9uLFxuICAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJzogY29uZGl0aW9uYWxFeHByZXNzaW9uLFxuICAnTmV3RXhwcmVzc2lvbic6IG5ld0V4cHJlc3Npb24sXG4gICdDYWxsRXhwcmVzc2lvbic6IGNhbGxFeHByZXNzaW9uLFxuICAnTWVtYmVyRXhwcmVzc2lvbic6IG1lbWJlckV4cHJlc3Npb24sXG4gICdJZGVudGlmaWVyJzogaWRlbnRpZmllckV4cHJlc3Npb24sXG4gICdMaXRlcmFsJzogbGl0ZXJhbEV4cHJlc3Npb25cbn07XG5cblxuZnVuY3Rpb24gQ2hlY2tDYW5hcnkoXG4gIHRoaXM6IHZvaWQsXG4gIHdsOiBXb3JrTGlzdCxcbiAgdnM6IFZhbHVlU3RhY2ssXG4gIGNhbmFyeTogQ2FuYXJ5XG4pIHtcbiAgbGV0IHJlc3VsdCA9IHZzLnBvcCgpO1xuICBBc3NlcnRWYWxpZENhbmFyeSh2cywgY2FuYXJ5KTtcbiAgdnMucHVzaChyZXN1bHQpO1xufVxuXG4vLyBUaGlzLCAxMS4xLjEgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gXG5cbmZ1bmN0aW9uIHRoaXNFeHByZXNzaW9uKFxuICB0aGlzOiB2b2lkLFxuICBub2RlOiBlc3RyZWUuVGhpc0V4cHJlc3Npb24sXG4gIHdsOiBXb3JrTGlzdCxcbiAgdnM6IFZhbHVlU3RhY2tcbik6IHZvaWQge1xuICBsZXQgYyA9IG1vbml0b3IuY29udGV4dDtcbiAgdnMucHVzaChjLnRoaXNWYWx1ZS5jbG9uZSgpKTtcbn1cblxuLy8gQXJyYXkgSW5pdGlhbGl6ZXIsIDExLjEuNCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIGFycmF5RXhwcmVzc2lvbihcbiAgdGhpczogdm9pZCxcbiAgbm9kZTogZXN0cmVlLkFycmF5RXhwcmVzc2lvbixcbiAgd2w6IFdvcmtMaXN0LFxuICB2czogVmFsdWVTdGFja1xuKTogdm9pZCB7XG4gIGxldCBjYW5hcnk6IENhbmFyeTtcbiAgaWYgKEpTRkxPV19TVEFDS19DSEVDSykge1xuICAgIGNhbmFyeSA9IFB1c2hDYW5hcnkodnMsIGBhcnJheUV4cHJlc3Npb24gOiAke3BwLnByZXR0eShub2RlKX1gKTtcbiAgfVxuXG4gIGxldCBpcCA9IHdsLnRvcCgpO1xuXG4gIGxldCBhcnIgPSBuZXcgVmFsdWUobmV3IEFycmF5T2JqZWN0KCksIGJvdCk7XG4gIGxldCBlcyA9IG5vZGUuZWxlbWVudHM7XG4gIGxldCBsZW4gPSBlcy5sZW5ndGg7XG5cbiAgYXJyLlB1dChjb25zdGFudHMubGVuZ3RoLCBuZXcgVmFsdWUobGVuLCBib3QpKTtcbiAgdnMucHVzaChhcnIpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXNbaV0pIHtcbiAgICAgIGlwLnRoZW4oZXNbaV0pO1xuICAgICAgaXAudGhlbigod2w6IFdvcmtMaXN0LCB2czogVmFsdWVTdGFjaykgPT4gYXJyYXlFeHByZXNzaW9uVXBkYXRlKGFyciwgaSwgd2wsIHZzKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKEpTRkxPV19TVEFDS19DSEVDSykge1xuICAgIGlwLnRoZW4oKHdsOiBXb3JrTGlzdCwgdnM6IFZhbHVlU3RhY2spID0+IENoZWNrQ2FuYXJ5KHdsLCB2cywgY2FuYXJ5KSk7XG4gIH1cbn1cblxuLy8gLS0tXG5cbmZ1bmN0aW9uIGFycmF5RXhwcmVzc2lvblVwZGF0ZShcbiAgdGhpczogdm9pZCxcbiAgYXJyYXk6IFZhbHVlPEFycmF5T2JqZWN0PixcbiAgaW5kZXg6IG51bWJlcixcbiAgd2w6IFdvcmtMaXN0LFxuICB2czogVmFsdWVTdGFja1xuKTogdm9pZCB7XG4gIC8vQHRzLWlnbm9yZSBTVEFDS1xuICBsZXQgaW5pdFZhbHVlID0gR2V0VmFsdWUodnMucG9wKCkpO1xuICBhcnJheS5QdXQobmV3IFZhbHVlKGluZGV4LCBib3QpLCBpbml0VmFsdWUpO1xufVxuXG4vLyBPYmplY3QgSW5pdGlhbGl6ZXIsIDExLjEuNSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gb2JqZWN0RXhwcmVzc2lvbihcbiAgdGhpczogdm9pZCxcbiAgbm9kZTogZXN0cmVlLk9iamVjdEV4cHJlc3Npb24sXG4gIHdsOiBXb3JrTGlzdCxcbiAgdnM6IFZhbHVlU3RhY2tcbik6IHZvaWQge1xuICBsZXQgY2FuYXJ5OiBDYW5hcnk7XG4gIGlmIChKU0ZMT1dfU1RBQ0tfQ0hFQ0spIHtcbiAgICBjYW5hcnkgPSBQdXNoQ2FuYXJ5KHZzLCBgb2JqZWN0RXhwcmVzc2lvbiA6ICR7cHAucHJldHR5KG5vZGUpfWApO1xuICB9XG5cbiAgbGV0IGlwID0gd2wudG9wKCk7XG5cbiAgbGV0IG9iaiA9IG5ldyBWYWx1ZShuZXcgT2JqZWN0T2JqZWN0KCksIGJvdCk7XG4gIHZzLnB1c2gob2JqKTtcblxuICBsZXQgcHMgPSBub2RlLnByb3BlcnRpZXM7XG5cbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaXAudGhlbihwc1tpXS52YWx1ZSk7XG4gICAgaXAudGhlbigod2w6IFdvcmtMaXN0LCB2czogVmFsdWVTdGFjaykgPT4gb2JqZWN0RXhwcmVzc2lvblVwZGF0ZShwcywgb2JqLCBpLCB3bCwgdnMpKTtcbiAgfVxuXG4gIGlmIChKU0ZMT1dfU1RBQ0tfQ0hFQ0spIHtcbiAgICBpcC50aGVuKCh3bDogV29ya0xpc3QsIHZzOiBWYWx1ZVN0YWNrKSA9PiBDaGVja0NhbmFyeSh3bCwgdnMsIGNhbmFyeSkpO1xuICB9XG59XG5cbi8vIC0tLVxuXG5mdW5jdGlvbiBvYmplY3RFeHByZXNzaW9uVXBkYXRlKFxuICB0aGlzOiB2b2lkLFxuICBwcm9wZXJ0aWVzOiBlc3RyZWUuUHJvcGVydHlbXSxcbiAgb2JqZWN0OiBWYWx1ZTxPYmplY3RPYmplY3Q+LFxuICBpbmRleDogbnVtYmVyLFxuICB3bDogV29ya0xpc3QsXG4gIHZzOiBWYWx1ZVN0YWNrXG4pOiB2b2lkIHtcblxuICBsZXQgcHJvcCA9IHByb3BlcnRpZXNbaW5kZXhdO1xuICBsZXQgcHJvcE5hbWU6IFZhbHVlPHN0cmluZyB8IG51bWJlcj47XG5cbiAgc3dpdGNoIChwcm9wLmtleS50eXBlKSB7XG4gICAgY2FzZSAnSWRlbnRpZmllcic6XG4gICAgICBwcm9wTmFtZSA9IG5ldyBWYWx1ZShwcm9wLmtleS5uYW1lLCBib3QpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdMaXRlcmFsJzpcbiAgICAgIC8vIGNhbiBvbmx5IGJlIHN0cmluZyBvciBudW1iZXI7IGNvbnZlcnNpb24gd2lsbCBvY2N1ciBvbmNlIGFzc2lnbmVkIHRvIHRoZSBvYmplY3RcbiAgICAgIC8vIFRPRE86IGZpeFxuICAgICAgLy9AdHMtaWdub3JlIFNZTlRBWFxuICAgICAgcHJvcE5hbWUgPSBuZXcgVmFsdWUocHJvcC5rZXkudmFsdWUsIGJvdCk7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIC8vQHRzLWlnbm9yZSBTVEFDS1xuICBsZXQgcHJvcFZhbHVlID0gR2V0VmFsdWUodnMucG9wKCkpO1xuICBsZXQgcHJvcERlc2M6IEpTRlByb3BlcnR5RGVzY3JpcHRvciA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCBsYWJlbDogYm90IH07XG5cbiAgc3dpdGNoIChwcm9wLmtpbmQpIHtcblxuICAgIGNhc2UgJ2luaXQnOlxuICAgICAgcHJvcERlc2MudmFsdWUgPSBwcm9wVmFsdWUudmFsdWU7XG4gICAgICBwcm9wRGVzYy5sYWJlbCA9IHByb3BWYWx1ZS5sYWJlbDtcbiAgICAgIHByb3BEZXNjLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnZ2V0JzpcbiAgICAgIC8vIFRPRE86IGZpeCBcbiAgICAgIC8vQHRzLWlnbm9yZSBERVNDIEhFTExcbiAgICAgIHByb3BEZXNjLmdldCA9IHByb3BWYWx1ZS52YWx1ZTtcbiAgICAgIHByb3BEZXNjLmxhYmVsID0gcHJvcFZhbHVlLmxhYmVsO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdzZXQnOlxuICAgICAgLy8gVE9ETzogZml4IFxuICAgICAgLy9AdHMtaWdub3JlIERFU0MgSEVMTFxuICAgICAgcHJvcERlc2Muc2V0ID0gcHJvcFZhbHVlLnZhbHVlO1xuICAgICAgcHJvcERlc2MubGFiZWwgPSBwcm9wVmFsdWUubGFiZWw7XG4gICAgICBicmVhaztcblxuICB9XG5cbiAgbGV0IHByZXZpb3VzID0gb2JqZWN0LkdldE93blByb3BlcnR5KHByb3BOYW1lKTtcblxuICBtb25pdG9yLmNvbnRleHQucHVzaFBDKHByZXZpb3VzLmxhYmVsKTtcbiAgaWYgKHByZXZpb3VzLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoKElzRGF0YURlc2NyaXB0b3IocHJldmlvdXMpICYmIElzQWNjZXNzb3JEZXNjcmlwdG9yKHByb3BEZXNjKSkgfHxcbiAgICAgIChJc0FjY2Vzc29yRGVzY3JpcHRvcihwcmV2aW91cykgJiYgSXNEYXRhRGVzY3JpcHRvcihwcm9wRGVzYykpIHx8XG4gICAgICAoSXNBY2Nlc3NvckRlc2NyaXB0b3IocHJldmlvdXMpICYmIElzQWNjZXNzb3JEZXNjcmlwdG9yKHByb3BEZXNjKSAmJlxuICAgICAgICAvL0B0cy1pZ25vcmUgREVTQyBIRUxMXG4gICAgICAgICgocHJldmlvdXMuZ2V0ICYmIHByb3BEZXNjLmdldCkgfHwgKHByZXZpb3VzLnNldCAmJiBwcm9wRGVzYy5zZXQpKVxuICAgICAgKVxuICAgICkge1xuICAgICAgbW9uaXRvci5UaHJvdyhcbiAgICAgICAgXCJTeW50YXhFcnJvclwiLFxuICAgICAgICAnT2JqZWN0IGluaXRpYWxpemVyOiBpbGxlZ2FsIHJlZGVmaW5lIG9mIHByb3BlcnR5JyxcbiAgICAgICAgYm90XG4gICAgICApO1xuICAgIH1cbiAgfVxuICBtb25pdG9yLmNvbnRleHQucG9wUEMoKTtcbiAgbGV0IG9iaiA9IG9iamVjdDtcbiAgLy9AdHMtaWdub3JlIFRZUEVTXG4gIG9iai5EZWZpbmVPd25Qcm9wZXJ0eShwcm9wTmFtZSwgcHJvcERlc2MpO1xufVxuXG4vLyBGdW5jdGlvbiBEZWZpbml0aW9uLCAxMyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIGZ1bmN0aW9uRXhwcmVzc2lvbihcbiAgdGhpczogdm9pZCxcbiAgbm9kZTogZXN0cmVlLkZ1bmN0aW9uRXhwcmVzc2lvbixcbiAgd2w6IFdvcmtMaXN0LFxuICB2czogVmFsdWVTdGFja1xuKTogdm9pZCB7XG4gIGxldCBmdW46IEZ1bmN0aW9uT2JqZWN0O1xuXG4gIGlmIChub2RlLmlkKSB7XG4gICAgbGV0IGZ1bmNFbnYgPSBOZXdEZWNsYXJhdGl2ZUVudmlyb25tZW50KG1vbml0b3IuY29udGV4dC5sZXhpY2FsRW52KTtcbiAgICBsZXQgaWRlbnRpZmllciA9IG5ldyBWYWx1ZShub2RlLmlkLm5hbWUsIGJvdCk7XG4gICAgZnVuY0Vudi5DcmVhdGVJbW11dGFibGVCaW5kaW5nKGlkZW50aWZpZXIpO1xuXG4gICAgZnVuID0gbmV3IEZ1bmN0aW9uT2JqZWN0KG5vZGUucGFyYW1zLCBub2RlLmJvZHksIG5ldyBWYWx1ZShmdW5jRW52LCBib3QpKTtcbiAgICBmdW4uTmFtZSA9IG5vZGUuaWQubmFtZTtcbiAgICBmdW4uU291cmNlID0gbm9kZTtcblxuICAgIGZ1bmNFbnYuSW5pdGlhbGl6ZUltbXV0YWJsZUJpbmRpbmcoaWRlbnRpZmllciwgbmV3IFZhbHVlKGZ1biwgYm90KSk7XG4gIH0gZWxzZSB7XG4gICAgZnVuID0gbmV3IEZ1bmN0aW9uT2JqZWN0KG5vZGUucGFyYW1zLCBub2RlLmJvZHksIG1vbml0b3IuY29udGV4dC5sZXhpY2FsRW52KTtcbiAgICBmdW4uU291cmNlID0gbm9kZTtcbiAgfVxuXG4gIHZzLnB1c2gobmV3IFZhbHVlKGZ1biwgYm90KSk7XG59XG5cbi8vIENvbW1hIE9wZXJhdG9yLCAxMS4xNCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gc2VxdWVuY2VFeHByZXNzaW9uKFxuICB0aGlzOiB2b2lkLFxuICBub2RlOiBlc3RyZWUuU2VxdWVuY2VFeHByZXNzaW9uLFxuICB3bDogV29ya0xpc3QsXG4gIHZzOiBWYWx1ZVN0YWNrXG4pOiB2b2lkIHtcbiAgbGV0IGNhbmFyeTogQ2FuYXJ5O1xuICBpZiAoSlNGTE9XX1NUQUNLX0NIRUNLKSB7XG4gICAgY2FuYXJ5ID0gUHVzaENhbmFyeSh2cywgYHNlcXVlbmNlRXhwcmVzc2lvbiA6ICR7cHAucHJldHR5KG5vZGUpfWApO1xuICB9XG5cbiAgbGV0IGlwID0gd2wudG9wKCk7XG4gIGxldCBlcyA9IG5vZGUuZXhwcmVzc2lvbnM7XG4gIGxldCBsZW4gPSBlcy5sZW5ndGg7XG5cbiAgbGV0IGkgPSAwO1xuICBmb3IgKDsgaSA8IGxlbiAtIDE7IGkrKykge1xuICAgIGlwLnRoZW4oZXNbaV0pO1xuICB9XG5cbiAgaWYgKGkgPCBsZW4pIHtcbiAgICBpcC50aGVuKGVzW2ldKTtcbiAgICBpcC50aGVuKCh3bDogV29ya0xpc3QsIHZzOiBWYWx1ZVN0YWNrKSA9PiBzZXF1ZW5jZUV4cHJlc3Npb25FbmQobGVuLCB3bCwgdnMpKTtcbiAgfVxuXG4gIGlmIChKU0ZMT1dfU1RBQ0tfQ0hFQ0spIHtcbiAgICBpcC50aGVuKCh3bDogV29ya0xpc3QsIHZzOiBWYWx1ZVN0YWNrKSA9PiBDaGVja0NhbmFyeSh3bCwgdnMsIGNhbmFyeSkpO1xuICB9XG59XG5cbi8vIC0tLVxuXG5mdW5jdGlvbiBzZXF1ZW5jZUV4cHJlc3Npb25FbmQoXG4gIHRoaXM6IHZvaWQsXG4gIGxlbmd0aDogbnVtYmVyLFxuICB3bDogV29ya0xpc3QsXG4gIHZzOiBWYWx1ZVN0YWNrXG4pOiB2b2lkIHtcbiAgbGV0IHJlc3VsdCA9IHZzLnBvcCgpO1xuXG4gIC8vIFBvcCBhbGwgYnV0IGxhc3QgYW5kIGV4ZWN1dGUgR2V0VmFsdWUgb24gcmVzdWx0IGZvciBldmVudHVhbCBzaWRlIGVmZmVjdHMuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgLy9AdHMtaWdub3JlIFNUQUNLXG4gICAgR2V0VmFsdWUodnMucG9wKCkpO1xuICB9XG5cbiAgdnMucHVzaChyZXN1bHQpO1xufVxuXG4vLyBVbmFyeSBPcGVyYXRvcnMsIDExLjQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIHVuYXJ5RXhwcmVzc2lvbihcbiAgdGhpczogdm9pZCxcbiAgbm9kZTogZXN0cmVlLlVuYXJ5RXhwcmVzc2lvbixcbiAgd2w6IFdvcmtMaXN0LFxuICB2czogVmFsdWVTdGFja1xuKTogdm9pZCB7XG4gIGxldCBjYW5hcnk6IENhbmFyeTtcbiAgaWYgKEpTRkxPV19TVEFDS19DSEVDSykge1xuICAgIGNhbmFyeSA9IFB1c2hDYW5hcnkodnMsIGB1bmFyeUV4cHJlc3Npb24gOiAke3BwLnByZXR0eShub2RlKX1gKTtcbiAgfVxuXG4gIGxldCBpcCA9IHdsLnRvcCgpO1xuICBpcC50aGVuKG5vZGUuYXJndW1lbnQpO1xuICBpcC50aGVuKHVuYXJ5dGJsW25vZGUub3BlcmF0b3JdKTtcblxuICBpZiAoSlNGTE9XX1NUQUNLX0NIRUNLKSB7XG4gICAgaXAudGhlbigod2w6IFdvcmtMaXN0LCB2czogVmFsdWVTdGFjaykgPT4gQ2hlY2tDYW5hcnkod2wsIHZzLCBjYW5hcnkpKTtcbiAgfVxufVxuXG4vLyBCaW5hcnkgT3BlcmF0b3JzLCAxMS41LTExLjkgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gYmluYXJ5RXhwcmVzc2lvbihcbiAgdGhpczogdm9pZCxcbiAgbm9kZTogZXN0cmVlLkJpbmFyeUV4cHJlc3Npb24sXG4gIHdsOiBXb3JrTGlzdCxcbiAgdnM6IFZhbHVlU3RhY2tcbik6IHZvaWQge1xuICBsZXQgY2FuYXJ5OiBDYW5hcnk7XG4gIGlmIChKU0ZMT1dfU1RBQ0tfQ0hFQ0spIHtcbiAgICBjYW5hcnkgPSBQdXNoQ2FuYXJ5KHZzLCBgYmluYXJ5RXhwcmVzc2lvbiA6ICR7cHAucHJldHR5KG5vZGUpfWApO1xuICB9XG5cbiAgbGV0IGlwID0gd2wudG9wKCk7XG4gIGlwLnRoZW4obm9kZS5sZWZ0KTtcbiAgaXAudGhlbihfR2V0VmFsdWUpO1xuICBpcC50aGVuKG5vZGUucmlnaHQpO1xuICBpcC50aGVuKF9HZXRWYWx1ZSk7XG4gIGlwLnRoZW4oYmluYXJ5dGJsW25vZGUub3BlcmF0b3JdKTtcblxuICBpZiAoSlNGTE9XX1NUQUNLX0NIRUNLKSB7XG4gICAgaXAudGhlbigod2w6IFdvcmtMaXN0LCB2czogVmFsdWVTdGFjaykgPT4gQ2hlY2tDYW5hcnkod2wsIHZzLCBjYW5hcnkpKTtcbiAgfVxufVxuXG4vLyBQcmVmaXgsIGFuZCBQb3N0Zml4IEV4cHJlc3Npb25zLCAxMS4zLCAxMS40LjQsIDExLjQuNSAtLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiB1cGRhdGVFeHByZXNzaW9uKFxuICB0aGlzOiB2b2lkLFxuICBub2RlOiBlc3RyZWUuVXBkYXRlRXhwcmVzc2lvbixcbiAgd2w6IFdvcmtMaXN0LFxuICB2czogVmFsdWVTdGFja1xuKTogdm9pZCB7XG4gIGxldCBjYW5hcnk6IENhbmFyeTtcbiAgaWYgKEpTRkxPV19TVEFDS19DSEVDSykge1xuICAgIGNhbmFyeSA9IFB1c2hDYW5hcnkodnMsIGB1cGRhdGVFeHByZXNzaW9uIDogJHtwcC5wcmV0dHkobm9kZSl9YCk7XG4gIH1cblxuICBsZXQgaXAgPSB3bC50b3AoKTtcbiAgaXAudGhlbihub2RlLmFyZ3VtZW50KTtcbiAgaWYgKG5vZGUucHJlZml4KSB7XG4gICAgaXAudGhlbihwcmVmaXh0Ymxbbm9kZS5vcGVyYXRvcl0pO1xuICB9IGVsc2Uge1xuICAgIGlwLnRoZW4ocG9zdGZpeHRibFtub2RlLm9wZXJhdG9yXSk7XG4gIH1cblxuICBpZiAoSlNGTE9XX1NUQUNLX0NIRUNLKSB7XG4gICAgaXAudGhlbigod2w6IFdvcmtMaXN0LCB2czogVmFsdWVTdGFjaykgPT4gQ2hlY2tDYW5hcnkod2wsIHZzLCBjYW5hcnkpKTtcbiAgfVxufVxuXG4vLyBCaW5hcnkgT3BlcmF0b3JzLCAxMS41LTExLjkgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gbG9naWNhbEV4cHJlc3Npb24oXG4gIHRoaXM6IHZvaWQsXG4gIG5vZGU6IGVzdHJlZS5Mb2dpY2FsRXhwcmVzc2lvbixcbiAgd2w6IFdvcmtMaXN0LFxuICB2czogVmFsdWVTdGFja1xuKTogdm9pZCB7XG4gIGxldCBjYW5hcnk6IENhbmFyeTtcbiAgaWYgKEpTRkxPV19TVEFDS19DSEVDSykge1xuICAgIGNhbmFyeSA9IFB1c2hDYW5hcnkodnMsIGBsb2dpY2FsRXhwcmVzc2lvbiA6ICR7cHAucHJldHR5KG5vZGUpfWApO1xuICB9XG5cbiAgbGV0IGlwID0gd2wudG9wKCk7XG4gIGlwLnRoZW4obm9kZS5sZWZ0KTtcbiAgaXAudGhlbihsb2dpY2FsdGJsW25vZGUub3BlcmF0b3JdKTtcbiAgaXAudGhlbihub2RlLnJpZ2h0KTtcblxuICBpZiAoSlNGTE9XX1NUQUNLX0NIRUNLKSB7XG4gICAgaXAudGhlbigod2w6IFdvcmtMaXN0LCB2czogVmFsdWVTdGFjaykgPT4gQ2hlY2tDYW5hcnkod2wsIHZzLCBjYW5hcnkpKTtcbiAgfVxufVxuXG4vLyBBc3NpZ25tZW50LCAxMS4xMyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBhc3NpZ25tZW50RXhwcmVzc2lvbihcbiAgdGhpczogdm9pZCxcbiAgbm9kZTogZXN0cmVlLkFzc2lnbm1lbnRFeHByZXNzaW9uLFxuICB3bDogV29ya0xpc3QsXG4gIHZzOiBWYWx1ZVN0YWNrXG4pOiB2b2lkIHtcbiAgbGV0IGNhbmFyeTogQ2FuYXJ5O1xuICBpZiAoSlNGTE9XX1NUQUNLX0NIRUNLKSB7XG4gICAgY2FuYXJ5ID0gUHVzaENhbmFyeSh2cywgYGFzc2lnbm1lbnRFeHByZXNzaW9uIDogJHtwcC5wcmV0dHkobm9kZSl9YCk7XG4gIH1cblxuICBsZXQgaXAgPSB3bC50b3AoKTtcbiAgaXAudGhlbihub2RlLmxlZnQpO1xuICBpcC50aGVuKG5vZGUucmlnaHQpO1xuICBpcC50aGVuKGFzc2lnbm1lbnR0Ymxbbm9kZS5vcGVyYXRvcl0pO1xuICBpcC50aGVuKGFzc2lnbm1lbnRFeHByZXNzaW9uRW5kKTtcblxuICBpZiAoSlNGTE9XX1NUQUNLX0NIRUNLKSB7XG4gICAgaXAudGhlbigod2w6IFdvcmtMaXN0LCB2czogVmFsdWVTdGFjaykgPT4gQ2hlY2tDYW5hcnkod2wsIHZzLCBjYW5hcnkpKTtcbiAgfVxufVxuXG4vLyAtLS1cblxuZnVuY3Rpb24gYXNzaWdubWVudEV4cHJlc3Npb25FbmQoXG4gIHRoaXM6IHZvaWQsXG4gIHdsOiBXb3JrTGlzdCxcbiAgdnM6IFZhbHVlU3RhY2tcbik6IHZvaWQge1xuICAvL0B0cy1pZ25vcmVcbiAgbGV0IHJ2YWw6IFZhbHVlPFZhbHVlVHlwZXM+ID0gdnMucG9wKCk7XG4gIC8vQHRzLWlnbm9yZVxuICBsZXQgbHJlZjogUmVmZXJlbmNlID0gdnMucG9wKCk7XG4gIFB1dFZhbHVlKGxyZWYsIHJ2YWwpO1xuXG4gIHZzLnB1c2gocnZhbCk7XG59XG5cbi8vIENvbmRpdGlvbmFsIE9wZXJhdG9yLCAxMS4xMiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gY29uZGl0aW9uYWxFeHByZXNzaW9uKFxuICB0aGlzOiB2b2lkLFxuICBub2RlOiBlc3RyZWUuQ29uZGl0aW9uYWxFeHByZXNzaW9uLFxuICB3bDogV29ya0xpc3QsXG4gIHZzOiBWYWx1ZVN0YWNrXG4pOiB2b2lkIHtcbiAgbGV0IGNhbmFyeTogQ2FuYXJ5O1xuICBpZiAoSlNGTE9XX1NUQUNLX0NIRUNLKSB7XG4gICAgY2FuYXJ5ID0gUHVzaENhbmFyeSh2cywgYGNvbmRpdGlvbmFsRXhwcmVzc2lvbiA6ICR7cHAucHJldHR5KG5vZGUpfWApO1xuICB9XG5cbiAgbGV0IGlwID0gd2wudG9wKCk7XG4gIGlwLnRoZW4obm9kZS50ZXN0KTtcbiAgaXAudGhlbigod2w6IFdvcmtMaXN0LCB2czogVmFsdWVTdGFjaykgPT4gY29uZGl0aW9uYWxFeHByZXNzaW9uQ2hvb3NlKG5vZGUsIHdsLCB2cykpO1xuXG4gIGlmIChKU0ZMT1dfU1RBQ0tfQ0hFQ0spIHtcbiAgICBpcC50aGVuKCh3bDogV29ya0xpc3QsIHZzOiBWYWx1ZVN0YWNrKSA9PiBDaGVja0NhbmFyeSh3bCwgdnMsIGNhbmFyeSkpO1xuICB9XG59XG5cbi8vIC0tLVxuXG5mdW5jdGlvbiBjb25kaXRpb25hbEV4cHJlc3Npb25DaG9vc2UoXG4gIHRoaXM6IHZvaWQsXG4gIG5vZGU6IGVzdHJlZS5Db25kaXRpb25hbEV4cHJlc3Npb24sXG4gIHdsOiBXb3JrTGlzdCxcbiAgdnM6IFZhbHVlU3RhY2tcbik6IHZvaWQge1xuICBsZXQgaXAgPSB3bC50b3AoKTtcbiAgLy9AdHMtaWdub3JlIFNUQUNLXG4gIGxldCBsdmFsID0gR2V0VmFsdWUodnMucG9wKCkpO1xuICBsZXQgbGIgPSBUb0Jvb2xlYW4obHZhbCk7XG5cbiAgbW9uaXRvci5jb250ZXh0LnB1c2hQQyhsYi5sYWJlbCk7XG5cbiAgaWYgKGxiLnZhbHVlKSB7XG4gICAgaXAudGhlbihub2RlLmNvbnNlcXVlbnQpO1xuICB9XG4gIGVsc2Uge1xuICAgIGlwLnRoZW4obm9kZS5hbHRlcm5hdGUpO1xuICB9XG5cbiAgaXAudGhlbigod2w6IFdvcmtMaXN0LCB2czogVmFsdWVTdGFjaykgPT4gY29uZGl0aW9uYWxFeHByZXNzaW9uRW5kKGx2YWwsIHdsLCB2cykpO1xufVxuXG4vLyAtLS1cblxuZnVuY3Rpb24gY29uZGl0aW9uYWxFeHByZXNzaW9uRW5kKFxuICB0aGlzOiB2b2lkLFxuICB0ZXN0OiBWYWx1ZTxWYWx1ZVR5cGVzPixcbiAgd2w6IFdvcmtMaXN0LFxuICB2czogVmFsdWVTdGFja1xuKTogdm9pZCB7XG4gIC8vQHRzLWlnbm9yZSBTVEFDS1xuICBsZXQgdmFsID0gR2V0VmFsdWUodnMucG9wKCkpO1xuXG4gIG1vbml0b3IuY29udGV4dC5wb3BQQygpO1xuICB2cy5wdXNoKG5ldyBWYWx1ZSh2YWwudmFsdWUsIGx1Yih2YWwubGFiZWwsIHRlc3QubGFiZWwpKSk7XG59XG5cbi8vIFRoZSBuZXcgT3BlcmF0b3IsIDExLjIuMiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gbmV3RXhwcmVzc2lvbihcbiAgdGhpczogdm9pZCxcbiAgbm9kZTogZXN0cmVlLk5ld0V4cHJlc3Npb24sXG4gIHdsOiBXb3JrTGlzdCxcbiAgdnM6IFZhbHVlU3RhY2tcbik6IHZvaWQge1xuICBsZXQgY2FuYXJ5OiBDYW5hcnk7XG4gIGlmIChKU0ZMT1dfU1RBQ0tfQ0hFQ0spIHtcbiAgICBjYW5hcnkgPSBQdXNoQ2FuYXJ5KHZzLCBgbmV3RXhwcmVzc2lvbiA6ICR7cHAucHJldHR5KG5vZGUpfWApO1xuICB9XG5cbiAgbGV0IGlwID0gd2wudG9wKCk7XG4gIGlwLnRoZW4obm9kZS5jYWxsZWUpO1xuXG4gIGxldCBhcyA9IG5vZGUuYXJndW1lbnRzO1xuICBsZXQgbGVuID0gYXMubGVuZ3RoO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpcC50aGVuKGFzW2ldKTtcbiAgfVxuXG4gIGlwLnRoZW4oKHdsOiBXb3JrTGlzdCwgdnM6IFZhbHVlU3RhY2spID0+IG5ld0V4cHJlc3Npb25FeGVjdXRlKGxlbiwgd2wsIHZzLCBwcC5wcmV0dHkobm9kZSkpKTtcblxuICBpZiAoSlNGTE9XX1NUQUNLX0NIRUNLKSB7XG4gICAgaXAudGhlbigod2w6IFdvcmtMaXN0LCB2czogVmFsdWVTdGFjaykgPT4gQ2hlY2tDYW5hcnkod2wsIHZzLCBjYW5hcnkpKTtcbiAgfVxufVxuXG4vLyAtLS1cblxuZnVuY3Rpb24gbmV3RXhwcmVzc2lvbkV4ZWN1dGUoXG4gIHRoaXM6IHZvaWQsXG4gIGxlbmd0aDogbnVtYmVyLFxuICB3bDogV29ya0xpc3QsXG4gIHZzOiBWYWx1ZVN0YWNrLFxuICBkYXRhIDogc3RyaW5nXG4pOiB2b2lkIHtcbiAgbGV0IGMgPSBtb25pdG9yLmNvbnRleHQ7XG4gIGxldCBpcCA9IHdsLnRvcCgpO1xuXG4gIGxldCBhcmdMaXN0OiBWYWx1ZTxWYWx1ZVR5cGVzPltdID0gW107XG4gIGZvciAobGV0IGkgPSBsZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIC8vQHRzLWlnbm9yZSBTVEFDS1xuICAgIGFyZ0xpc3RbaV0gPSBHZXRWYWx1ZSh2cy5wb3AoKSk7XG4gIH1cblxuICAvL0B0cy1pZ25vcmUgU1RBQ0tcbiAgbGV0IGNvbnN0cnVjdG9yID0gR2V0VmFsdWUodnMucG9wKCkpO1xuXG4gIGlmIChjb25zdHJ1Y3Rvci52YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgY29uc3RydWN0b3IudmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgaWYgKGZhbHNlKSB7IC8vIFNJTEVOVCBFUlJPUlxuICAgICAgbGV0IHYgPSBuZXcgVmFsdWUodW5kZWZpbmVkLCBjb25zdHJ1Y3Rvci5sYWJlbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1vbml0b3IuVGhyb3coXG4gICAgICBcIlR5cGVFcnJvclwiLFxuICAgICAgXCJpbnZhbGlkICduZXcnIHBhcmFtZXRlcjogbm90IGEgY29uc3RydWN0b3JcIixcbiAgICAgIGNvbnN0cnVjdG9yLmxhYmVsXG4gICAgKTtcblxuICAgIHRocm93ICdUeXBlU2NyaXB0JztcbiAgfVxuXG4gIGlmICghKCdDb25zdHJ1Y3QnIGluIGNvbnN0cnVjdG9yLnZhbHVlKSkge1xuICAgIGlmIChmYWxzZSkgeyAvLyBTSUxFTlQgRVJST1JcbiAgICAgIGxldCB2ID0gbmV3IFZhbHVlKHVuZGVmaW5lZCwgY29uc3RydWN0b3IubGFiZWwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBtb25pdG9yLlRocm93KFxuICAgICAgXCJUeXBlRXJyb3JcIixcbiAgICAgIFwiaW52YWxpZCAnbmV3JyBwYXJhbWV0ZXI6IG5vdCBhIGNvbnN0cnVjdG9yXCIsXG4gICAgICBjb25zdHJ1Y3Rvci5sYWJlbFxuICAgICk7XG5cbiAgICB0aHJvdyAnVHlwZVNjcmlwdCc7XG4gIH1cblxuICBpZiAoY29uc3RydWN0b3IudmFsdWUuQXN5bmNDb25zdHJ1Y3QpIHtcbiAgICBjLnB1c2hQQyhjb25zdHJ1Y3Rvci5sYWJlbCk7XG5cbiAgICBpcCA9IGNvbnN0cnVjdG9yLnZhbHVlLkFzeW5jQ29uc3RydWN0KGFyZ0xpc3QpO1xuXG4gICAgaXAudGhlbigod2w6IFdvcmtMaXN0LCB2czogVmFsdWVTdGFjaykgPT4gY2FsbEV4cHJlc3Npb25FbmQoY29uc3RydWN0b3IubGFiZWwsIHdsLCB2cywgZGF0YSkpO1xuXG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCByZXR2YWwgPSBjb25zdHJ1Y3Rvci5Db25zdHJ1Y3QoYXJnTGlzdCk7XG4gICAgICByZXR2YWwucmFpc2UoY29uc3RydWN0b3IubGFiZWwpO1xuICAgICAgdnMucHVzaChyZXR2YWwpO1xuICAgIH0gY2F0Y2ggKGUpIHtcblxuICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIFZhbHVlKSkge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuXG4gICAgICBsZXQgcmVzdWx0ID0gYy5yZXN1bHQ7XG5cbiAgICAgIC8vIFZlcmZpeSB0aGF0IHRoZSBleGNlcHRpb24gaXMgYWxsb3dlZCBcbiAgICAgIG1vbml0b3IuYXNzZXJ0KGxlKGMuZWZmZWN0aXZlUEMsIGMubGFiZWxzLmV4YyksXG4gICAgICAgIFwiZXhjZXB0aW9uIGluIFwiICsgYy5lZmZlY3RpdmVQQyArIFwiIG5vdCBhbGxvd2VkIHdpdGggZXhjZXB0aW9uIGxhYmVsIFwiICsgYy5sYWJlbHMuZXhjKTtcblxuICAgICAgLy8gRm9yIG9ic2VydmFibGUgZmxvd3NcbiAgICAgIGMubGFiZWxzLmV4YyA9IGx1YihjLmxhYmVscy5leGMsIGMuZWZmZWN0aXZlUEMpO1xuXG4gICAgICByZXN1bHQudHlwZSA9ICd0aHJvdyc7XG4gICAgICByZXN1bHQudmFsdWUgPSBlO1xuICAgIH1cbiAgfVxufVxuXG4vLyBGdW5jdGlvbiBDYWxscywgMTEuMi4zIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIGNhbGxFeHByZXNzaW9uKFxuICB0aGlzOiB2b2lkLFxuICBub2RlOiBlc3RyZWUuQ2FsbEV4cHJlc3Npb24sXG4gIHdsOiBXb3JrTGlzdCxcbiAgdnM6IFZhbHVlU3RhY2tcbik6IHZvaWQge1xuICBsZXQgY2FuYXJ5OiBDYW5hcnk7XG4gIGlmIChKU0ZMT1dfU1RBQ0tfQ0hFQ0spIHtcbiAgICBjYW5hcnkgPSBQdXNoQ2FuYXJ5KHZzLCBgY2FsbEV4cHJlc3Npb24gOiAke3BwLnByZXR0eShub2RlKX1gKTtcbiAgfVxuXG4gIGxldCBpcCA9IHdsLnRvcCgpO1xuXG4gIGxldCBhcyA9IG5vZGUuYXJndW1lbnRzO1xuICBsZXQgbGVuID0gYXMubGVuZ3RoO1xuXG4gIGlwLnRoZW4obm9kZS5jYWxsZWUpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpcC50aGVuKGFzW2ldKTtcbiAgfVxuXG4gIGlwLnRoZW4oKHdsOiBXb3JrTGlzdCwgdnM6IFZhbHVlU3RhY2spID0+IGNhbGxFeHByZXNzaW9uRXhlY3V0ZShsZW4sIG5vZGUsIHdsLCB2cywgcHAucHJldHR5KG5vZGUpKSk7XG5cbiAgaWYgKEpTRkxPV19TVEFDS19DSEVDSykge1xuICAgIGlwLnRoZW4oKHdsOiBXb3JrTGlzdCwgdnM6IFZhbHVlU3RhY2spID0+IENoZWNrQ2FuYXJ5KHdsLCB2cywgY2FuYXJ5KSk7XG4gIH1cbn1cblxuLy8gY2FsbEV4cHJlc3Npb25FeGVjdXRlXG5cbmZ1bmN0aW9uIGNhbGxFeHByZXNzaW9uRXhlY3V0ZShcbiAgdGhpczogdm9pZCxcbiAgbGVuZ3RoOiBudW1iZXIsXG4gIG5vZGU6IGVzdHJlZS5DYWxsRXhwcmVzc2lvbixcbiAgd2w6IFdvcmtMaXN0LFxuICB2czogVmFsdWVTdGFjayxcbiAgZGF0YSA6IHN0cmluZ1xuKTogdm9pZCB7XG4gIGxldCBjID0gbW9uaXRvci5jb250ZXh0O1xuICBsZXQgaXAgPSB3bC50b3AoKTtcblxuICBsZXQgYXJnTGlzdDogVmFsdWU8VmFsdWVUeXBlcz5bXSA9IFtdO1xuICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBsZXQgYXJnID0gdnMucG9wKCk7XG4gICAgLy9AdHMtaWdub3JlIFNUQUNLXG4gICAgYXJnTGlzdFtpXSA9IEdldFZhbHVlKGFyZyk7XG4gIH1cblxuICBsZXQgcmVmID0gdnMucG9wKCk7XG4gIC8vQHRzLWlnbm9yZSBTVEFDS1xuICBsZXQgZnVuYyA9IEdldFZhbHVlKHJlZik7XG5cbiAgaWYgKCFJc0NhbGxhYmxlKGZ1bmMpKSB7XG4gICAgaWYgKGZhbHNlKSB7IC8vIFNJTEVOVCBFUlJPUlNcbiAgICAgIGxldCB2ID0gbmV3IFZhbHVlKHVuZGVmaW5lZCwgZnVuYy5sYWJlbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1vbml0b3IuVGhyb3coXG4gICAgICBcIlR5cGVFcnJvclwiLFxuICAgICAgJ0ludmFsaWQgY2FsbCB0YXJnZXQ7ICcgKyBwcC5wcmV0dHkobm9kZS5jYWxsZWUpICsgJyBldmFsdWF0ZXMgdG8gJyArIGZ1bmMudmFsdWUgKyAnIGluICcgKyBwcC5wcmV0dHkobm9kZSksXG4gICAgICBmdW5jLmxhYmVsXG4gICAgKTtcblxuICAgIHRocm93ICdUeXBlU2NyaXB0JztcbiAgfVxuXG4gIC8vIHVzZWQgdG8gZGVjaWRlIGlmIGV2YWwgaXMgYSBkaXJlY3QgY2FsbCBpbiBmdW5jdGlvbi5lbnRlckV2YWxDb2RlXG4gIC8vQHRzLWlnbm9yZSBUWVBFU1xuICBjLmN1cnJlbnRDYWxsID0geyByZWZlcmVuY2U6IHJlZiwgdGFyZ2V0OiBmdW5jLnZhbHVlLCBzb3VyY2U6IG5vZGUgfTtcblxuICAvLyBmb3IgZXZhbFxuICAvL0B0cy1pZ25vcmUgVFlQRVNcbiAgYy5jYWxsID0geyByZWY6IHJlZiwgZnVuYzogZnVuYyB9O1xuXG4gIGxldCB0aGlzVmFsdWU6IFZhbHVlPFJlZmVyZW5jZVR5cGU+O1xuICBpZiAocmVmIGluc3RhbmNlb2YgUmVmZXJlbmNlKSB7XG4gICAgaWYgKHJlZi5Jc1Byb3BlcnR5UmVmZXJlbmNlKCkpIHtcbiAgICAgIHRoaXNWYWx1ZSA9IHJlZi5iYXNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvL0B0cy1pZ25vcmUgVFlQRVNcbiAgICAgIHRoaXNWYWx1ZSA9IHJlZi5iYXNlLkltcGxpY2l0VGhpc1ZhbHVlKCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vQHRzLWlnbm9yZSBUWVBFU1xuICAgIHRoaXNWYWx1ZSA9IG5ldyBWYWx1ZSh1bmRlZmluZWQsIHJlZi5sYWJlbCk7XG4gIH1cblxuICBpZiAoZnVuYy52YWx1ZS5Bc3luY0NhbGwpIHtcblxuICAgIG1vbml0b3IuY29udGV4dC5wdXNoUEMoZnVuYy5sYWJlbCk7XG5cbiAgICBmdW5jLnZhbHVlLkFzeW5jQ2FsbCh0aGlzVmFsdWUsIGFyZ0xpc3QpO1xuICAgIGlwLnRoZW4oKHdsOiBXb3JrTGlzdCwgdnM6IFZhbHVlU3RhY2spID0+IGNhbGxFeHByZXNzaW9uRW5kKGZ1bmMubGFiZWwsIHdsLCB2cywgZGF0YSkpO1xuXG4gIH0gZWxzZSB7XG5cbiAgICB0cnkge1xuICAgICAgbGV0IHJldHZhbCA9IGZ1bmMuQ2FsbCh0aGlzVmFsdWUsIGFyZ0xpc3QpO1xuICAgICAgcmV0dmFsLnJhaXNlKGZ1bmMubGFiZWwpO1xuICAgICAgdnMucHVzaChyZXR2YWwpO1xuXG4gICAgfSBjYXRjaCAoZSkge1xuXG4gICAgICBpZiAoIShlIGluc3RhbmNlb2YgVmFsdWUpKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG5cbiAgICAgIGxldCByZXN1bHQgPSBjLnJlc3VsdDtcblxuICAgICAgLy8gVmVyZml5IHRoYXQgdGhlIGV4Y2VwdGlvbiBpcyBhbGxvd2VkIFxuICAgICAgbW9uaXRvci5hc3NlcnQobGUoYy5lZmZlY3RpdmVQQywgYy5sYWJlbHMuZXhjKSxcbiAgICAgICAgXCJleGNlcHRpb24gaW4gXCIgKyBjLmVmZmVjdGl2ZVBDICsgXCIgbm90IGFsbG93ZWQgd2l0aCBleGNlcHRpb24gbGFiZWwgXCIgKyBjLmxhYmVscy5leGMpO1xuXG4gICAgICAvLyBGb3Igb2JzZXJ2YWJsZSBmbG93c1xuICAgICAgYy5sYWJlbHMuZXhjID0gbHViKGMubGFiZWxzLmV4YywgYy5lZmZlY3RpdmVQQyk7XG5cbiAgICAgIHJlc3VsdC50eXBlID0gJ3Rocm93JztcbiAgICAgIHJlc3VsdC52YWx1ZSA9IGU7XG4gICAgfVxuICB9XG59XG5cbi8vIGNhbGxFeHByZXNzaW9uRW5kIFxuXG5mdW5jdGlvbiBjYWxsRXhwcmVzc2lvbkVuZChcbiAgdGhpczogdm9pZCxcbiAgbGFiZWw6IExhYmVsLFxuICB3bDogV29ya0xpc3QsXG4gIHZzOiBWYWx1ZVN0YWNrLFxuICBkYXRhIDogc3RyaW5nXG4pOiB2b2lkIHtcbiAgLy8gQHRzLWlnbm9yZVxuICBsZXQgY2FsbFJlc3VsdDogUmVzdWx0ID0gdnMucG9wKCk7XG4gIGxldCBjID0gbW9uaXRvci5jb250ZXh0O1xuICBsZXQgcmVzdWx0ID0gYy5yZXN1bHQ7XG5cbiAgaWYgKGNhbGxSZXN1bHQgPT09IHVuZGVmaW5lZCB8fCBjYWxsUmVzdWx0LnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICBtb25pdG9yLmVycm9yKGRhdGEpO1xuICAgIG1vbml0b3IuZXJyb3IoY2FsbFJlc3VsdCk7XG4gIH1cblxuICBjYWxsUmVzdWx0LnZhbHVlLnJhaXNlKGxhYmVsKTtcblxuICBpZiAoY2FsbFJlc3VsdC50eXBlID09PSAndGhyb3cnKSB7XG4gICAgcmVzdWx0LnR5cGUgPSAndGhyb3cnO1xuICAgIHJlc3VsdC52YWx1ZSA9IGNhbGxSZXN1bHQudmFsdWU7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgYy5wb3BQQygpO1xuICB2cy5wdXNoKGNhbGxSZXN1bHQudmFsdWUpO1xufVxuXG4vLyBQcm9wZXJ0eSBBY2Nlc3NvcnMsIDExLjIuMSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIG1lbWJlckV4cHJlc3Npb24oXG4gIHRoaXMgOiB2b2lkLFxuICBub2RlOiBlc3RyZWUuTWVtYmVyRXhwcmVzc2lvbixcbiAgd2w6IFdvcmtMaXN0LFxuICB2czogVmFsdWVTdGFja1xuKTogdm9pZCB7XG4gIGxldCBjYW5hcnk6IENhbmFyeTtcbiAgaWYgKEpTRkxPV19TVEFDS19DSEVDSykge1xuICAgIGNhbmFyeSA9IFB1c2hDYW5hcnkodnMsIGBtZW1iZXJFeHByZXNzaW9uIDogJHtwcC5wcmV0dHkobm9kZSl9YCk7XG4gIH1cblxuICBsZXQgaXAgPSB3bC50b3AoKTtcblxuICBpcC50aGVuKG5vZGUub2JqZWN0KTtcbiAgaXAudGhlbihfR2V0VmFsdWUpO1xuXG4gIGlmIChub2RlLmNvbXB1dGVkKSB7XG4gICAgaXAudGhlbihub2RlLnByb3BlcnR5KTtcbiAgICBpcC50aGVuKF9HZXRWYWx1ZSk7XG4gIH1cblxuICBpcC50aGVuKCh3bDogV29ya0xpc3QsIHZzOiBWYWx1ZVN0YWNrKSA9PiBtZW1iZXJFeHByZXNzaW9uRXhlY3V0ZShub2RlLCB3bCwgdnMpKTtcblxuICBpZiAoSlNGTE9XX1NUQUNLX0NIRUNLKSB7XG4gICAgaXAudGhlbigod2w6IFdvcmtMaXN0LCB2czogVmFsdWVTdGFjaykgPT4gQ2hlY2tDYW5hcnkod2wsIHZzLCBjYW5hcnkpKTtcbiAgfVxufVxuXG4vLyAtLS1cblxuZnVuY3Rpb24gbWVtYmVyRXhwcmVzc2lvbkV4ZWN1dGUoXG4gIHRoaXM6IHZvaWQsXG4gIG5vZGUgOiBlc3RyZWUuTWVtYmVyRXhwcmVzc2lvbixcbiAgd2w6IFdvcmtMaXN0LFxuICB2czogVmFsdWVTdGFja1xuKTogdm9pZCB7XG5cbiAgbGV0IHByb3BlcnR5TmFtZVZhbHVlO1xuXG4gIGlmIChub2RlLmNvbXB1dGVkKSB7XG4gICAgcHJvcGVydHlOYW1lVmFsdWUgPSB2cy5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICAvL0B0cy1pZ25vcmUgVFlQRVNcbiAgICBwcm9wZXJ0eU5hbWVWYWx1ZSA9IG5ldyBWYWx1ZShub2RlLnByb3BlcnR5Lm5hbWUsIGJvdCk7XG4gIH1cblxuICAvLyBAdHMtaWdub3JlXG4gIGxldCBiYXNlVmFsdWU6IFZhbHVlPFZhbHVlVHlwZXM+ID0gdnMucG9wKCk7XG5cbiAgLypcbiAgaWYgKGJhc2VWYWx1ZS52YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IGJhc2VWYWx1ZS52YWx1ZSA9PT0gbnVsbCkge1xuICAgIG1vbml0b3Iud2FybihwcC5wcmV0dHkobm9kZS5vYmplY3QpICsgJyBldmFsdWF0ZXMgdG8gJyArIFN0cmluZyhiYXNlVmFsdWUudmFsdWUpICsgJyBpbiAnICsgcHAucHJldHR5KG5vZGUpLCBub2RlKTtcbiAgfVxuICAqL1xuICBcblxuICBDaGVja09iamVjdENvZXJjaWJsZShiYXNlVmFsdWUpO1xuICAvL0B0cy1pZ25vcmUgVFlQRVNcbiAgdnMucHVzaChuZXcgUmVmZXJlbmNlKGJhc2VWYWx1ZSwgVG9TdHJpbmcocHJvcGVydHlOYW1lVmFsdWUpKSk7XG59XG5cbi8vIElkZW50aWZpZXIsIDExLjEuMiAtPiAxMC4zLjEgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gaWRlbnRpZmllckV4cHJlc3Npb24oXG4gIG5vZGU6IGVzdHJlZS5JZGVudGlmaWVyLFxuICB3bDogV29ya0xpc3QsXG4gIHZzOiBWYWx1ZVN0YWNrXG4pOiB2b2lkIHtcbiAgdnMucHVzaChHZXRJZGVudGlmaWVyUmVmZXJlbmNlKG1vbml0b3IuY29udGV4dC5sZXhpY2FsRW52LCBub2RlLm5hbWUpKTtcbn1cblxuLy8gTGl0ZXJhbHMsIDExLjEuMyAtPiA3LjggLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBsaXRlcmFsRXhwcmVzc2lvbihcbiAgbm9kZTogZXN0cmVlLkxpdGVyYWwsXG4gIHdsOiBXb3JrTGlzdCxcbiAgdnM6IFZhbHVlU3RhY2tcbik6IHZvaWQge1xuICAvLyBAdHMtaWdub3JlXG4gIGxldCByZXM6IFZhbHVlPFZhbHVlVHlwZXM+ID0gbmV3IFZhbHVlKG5vZGUudmFsdWUsIGJvdCk7XG5cbiAgaWYgKG5vZGUudmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXMudmFsdWUgPSBuZXcgUmVnRXhwT2JqZWN0KG5vZGUudmFsdWUsIGJvdCk7XG4gIH1cblxuICB2cy5wdXNoKHJlcyk7XG59IiwiXG5pbXBvcnQgeyBNb25pdG9yQmFzZSB9IGZyb20gXCIuLi9Nb25pdG9yQmFzZVwiO1xuXG5pbXBvcnQgeyBzd2l0Y2hTdGF0ZW1lbnQgfSBmcm9tIFwiLi9UcmFjaW5nL1N3aXRjaFN0YXRlbWVudFwiO1xuaW1wb3J0IHsgYmxvY2tTdGF0ZW1lbnQgfSBmcm9tIFwiLi9UcmFjaW5nL0Jsb2NrU3RhdGVtZW50XCI7XG5pbXBvcnQgeyBlbXB0eVN0YXRlbWVudCB9IGZyb20gXCIuL1RyYWNpbmcvRW1wdHlTdGF0ZW1lbnRcIjtcbmltcG9ydCB7IGV4cHJlc3Npb25TdGF0ZW1lbnQgfSBmcm9tIFwiLi9UcmFjaW5nL0V4cHJlc3Npb25TdGF0ZW1lbnRcIjtcbmltcG9ydCB7IGlmU3RhdGVtZW50IH0gZnJvbSBcIi4vVHJhY2luZy9JZlN0YXRlbWVudFwiO1xuaW1wb3J0IHsgbGFiZWxlZFN0YXRlbWVudCB9IGZyb20gXCIuL1RyYWNpbmcvTGFiZWxlZFN0YXRlbWVudFwiO1xuaW1wb3J0IHsgYnJlYWtTdGF0ZW1lbnQgfSBmcm9tIFwiLi9UcmFjaW5nL0JyZWFrU3RhdGVtZW50XCI7XG5pbXBvcnQgeyBjb250aW51ZVN0YXRlbWVudCB9IGZyb20gXCIuL1RyYWNpbmcvQ29udGludWVTdGF0ZW1lbnRcIjtcbmltcG9ydCB7IHdpdGhTdGF0ZW1lbnQgfSBmcm9tIFwiLi9UcmFjaW5nL1dpdGhTdGF0ZW1lbnRcIjtcbmltcG9ydCB7IHJldHVyblN0YXRlbWVudCB9IGZyb20gXCIuL1RyYWNpbmcvUmV0dXJuU3RhdGVtZW50XCI7XG5pbXBvcnQgeyB0aHJvd1N0YXRlbWVudCB9IGZyb20gXCIuL1RyYWNpbmcvVGhyb3dTdGF0ZW1lbnRcIjtcbmltcG9ydCB7IHdoaWxlU3RhdGVtZW50LCBkb1doaWxlU3RhdGVtZW50IH0gZnJvbSBcIi4vVHJhY2luZy9XaGlsZVN0YXRlbWVudFwiO1xuaW1wb3J0IHsgZm9yU3RhdGVtZW50IH0gZnJvbSBcIi4vVHJhY2luZy9Gb3JTdGF0ZW1lbnRcIjtcbmltcG9ydCB7IGZvckluU3RhdGVtZW50IH0gZnJvbSBcIi4vVHJhY2luZy9Gb3JJblN0YXRlbWVudFwiO1xuaW1wb3J0IHsgdmFyaWFibGVEZWNsYXJhdGlvbiB9IGZyb20gXCIuL1RyYWNpbmcvVmFyaWFibGVEZWNsYXJhdGlvblwiO1xuaW1wb3J0IHsgZGVidWdnZXJTdGF0ZW1lbnQgfSBmcm9tIFwiLi9UcmFjaW5nL0RlYnVnZ2VyU3RhdGVtZW50XCI7XG5pbXBvcnQgeyB0cnlTdGF0ZW1lbnQgfSBmcm9tIFwiLi9UcmFjaW5nL1RyeUNhdGNoU3RhdGVtZW50XCI7XG5cbmltcG9ydCAqIGFzIGVzdHJlZSBmcm9tIFwiZXN0cmVlXCI7XG5pbXBvcnQgeyBXb3JrTGlzdCwgVmFsdWVTdGFjayB9IGZyb20gXCIuLi9Db250ZXh0XCI7XG5cbmRlY2xhcmUgdmFyIG1vbml0b3I6IE1vbml0b3JCYXNlO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIEV4ZWN1dGVTdGF0ZW1lbnQoc3RhdGVtZW50OiBlc3RyZWUuU3RhdGVtZW50LCB3bDogV29ya0xpc3QsIHZzOiBWYWx1ZVN0YWNrKTogdm9pZCB7XG5cbiAgICBzd2l0Y2ggKHN0YXRlbWVudC50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJCbG9ja1N0YXRlbWVudFwiOlxuICAgICAgICAgICAgYmxvY2tTdGF0ZW1lbnQoc3RhdGVtZW50LCB3bCwgdnMpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcIkJyZWFrU3RhdGVtZW50XCI6XG4gICAgICAgICAgICBicmVha1N0YXRlbWVudChzdGF0ZW1lbnQsIHdsLCB2cyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwiQ2xhc3NEZWNsYXJhdGlvblwiOiB0aHJvdyBcIlRPRE9cIjtcblxuICAgICAgICBjYXNlIFwiQ29udGludWVTdGF0ZW1lbnRcIjpcbiAgICAgICAgICAgIGNvbnRpbnVlU3RhdGVtZW50KHN0YXRlbWVudCwgd2wsIHZzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJEZWJ1Z2dlclN0YXRlbWVudFwiOlxuICAgICAgICAgICAgZGVidWdnZXJTdGF0ZW1lbnQoc3RhdGVtZW50LCB3bCwgdnMpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcIkRvV2hpbGVTdGF0ZW1lbnRcIjpcbiAgICAgICAgICAgIGRvV2hpbGVTdGF0ZW1lbnQoc3RhdGVtZW50LCB3bCwgdnMpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcIkVtcHR5U3RhdGVtZW50XCI6XG4gICAgICAgICAgICBlbXB0eVN0YXRlbWVudChzdGF0ZW1lbnQsIHdsLCB2cyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdFeHByZXNzaW9uU3RhdGVtZW50JzpcbiAgICAgICAgICAgIGV4cHJlc3Npb25TdGF0ZW1lbnQoc3RhdGVtZW50LCB3bCwgdnMpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcIkZvckluU3RhdGVtZW50XCI6XG4gICAgICAgICAgICBmb3JJblN0YXRlbWVudChzdGF0ZW1lbnQsIHdsLCB2cyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwiRm9yT2ZTdGF0ZW1lbnRcIjogdGhyb3cgXCJUT0RPXCI7XG5cbiAgICAgICAgY2FzZSBcIkZvclN0YXRlbWVudFwiOlxuICAgICAgICAgICAgZm9yU3RhdGVtZW50KHN0YXRlbWVudCwgd2wsIHZzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCI6XG4gICAgICAgICAgICAvLyBoYW5kbGVkIHZpYSBmdW5jdGlvbiBob2lzdGluZ1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcIklmU3RhdGVtZW50XCI6XG4gICAgICAgICAgICBpZlN0YXRlbWVudChzdGF0ZW1lbnQsIHdsLCB2cyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwiTGFiZWxlZFN0YXRlbWVudFwiOlxuICAgICAgICAgICAgbGFiZWxlZFN0YXRlbWVudChzdGF0ZW1lbnQsIHdsLCB2cyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwiUmV0dXJuU3RhdGVtZW50XCI6XG4gICAgICAgICAgICByZXR1cm5TdGF0ZW1lbnQoc3RhdGVtZW50LCB3bCwgdnMpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcIlN3aXRjaFN0YXRlbWVudFwiOlxuICAgICAgICAgICAgc3dpdGNoU3RhdGVtZW50KHN0YXRlbWVudCwgd2wsIHZzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJUaHJvd1N0YXRlbWVudFwiOlxuICAgICAgICAgICAgdGhyb3dTdGF0ZW1lbnQoc3RhdGVtZW50LCB3bCwgdnMpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcIlRyeVN0YXRlbWVudFwiOlxuICAgICAgICAgICAgdHJ5U3RhdGVtZW50KHN0YXRlbWVudCwgd2wsIHZzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCI6XG4gICAgICAgICAgICB2YXJpYWJsZURlY2xhcmF0aW9uKHN0YXRlbWVudCwgd2wsIHZzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJXaGlsZVN0YXRlbWVudFwiOlxuICAgICAgICAgICAgd2hpbGVTdGF0ZW1lbnQoc3RhdGVtZW50LCB3bCwgdnMpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcIldpdGhTdGF0ZW1lbnRcIjpcbiAgICAgICAgICAgIHdpdGhTdGF0ZW1lbnQoc3RhdGVtZW50LCB3bCwgdnMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgbW9uaXRvci5mYXRhbChzdGF0ZW1lbnQudHlwZSArICcgbm90IGltcGxlbWVudGVkJyk7XG59XG5cblxuLy8gc3RhdGVtZW50IGhhbmRsZXIgZnVuY3Rpb25zXG5cbmV4cG9ydCB2YXIgc3RhdGVtZW50dGJsID0ge1xuICAgICdQcm9ncmFtJzogYmxvY2tTdGF0ZW1lbnQsXG4gICAgJ0Jsb2NrU3RhdGVtZW50JzogYmxvY2tTdGF0ZW1lbnQsXG4gICAgJ0VtcHR5U3RhdGVtZW50JzogZW1wdHlTdGF0ZW1lbnQsXG4gICAgJ0V4cHJlc3Npb25TdGF0ZW1lbnQnOiBleHByZXNzaW9uU3RhdGVtZW50LFxuICAgICdJZlN0YXRlbWVudCc6IGlmU3RhdGVtZW50LFxuICAgICdTd2l0Y2hTdGF0ZW1lbnQnOiBzd2l0Y2hTdGF0ZW1lbnQsXG4gICAgJ0xhYmVsZWRTdGF0ZW1lbnQnOiBsYWJlbGVkU3RhdGVtZW50LFxuICAgICdCcmVha1N0YXRlbWVudCc6IGJyZWFrU3RhdGVtZW50LFxuICAgICdDb250aW51ZVN0YXRlbWVudCc6IGNvbnRpbnVlU3RhdGVtZW50LFxuICAgICdXaXRoU3RhdGVtZW50Jzogd2l0aFN0YXRlbWVudCxcbiAgICAnUmV0dXJuU3RhdGVtZW50JzogcmV0dXJuU3RhdGVtZW50LFxuICAgICdUaHJvd1N0YXRlbWVudCc6IHRocm93U3RhdGVtZW50LFxuICAgICdUcnlTdGF0ZW1lbnQnOiB0cnlTdGF0ZW1lbnQsXG4gICAgJ1doaWxlU3RhdGVtZW50Jzogd2hpbGVTdGF0ZW1lbnQsXG4gICAgJ0RvV2hpbGVTdGF0ZW1lbnQnOiBkb1doaWxlU3RhdGVtZW50LFxuICAgICdGb3JTdGF0ZW1lbnQnOiBmb3JTdGF0ZW1lbnQsXG4gICAgJ0ZvckluU3RhdGVtZW50JzogZm9ySW5TdGF0ZW1lbnQsXG5cbiAgICAnVmFyaWFibGVEZWNsYXJhdGlvbic6IHZhcmlhYmxlRGVjbGFyYXRpb24sXG4gICAgJ0Z1bmN0aW9uRGVjbGFyYXRpb24nOiBlbXB0eVN0YXRlbWVudCxcbiAgICAnRGVidWdnZXJTdGF0ZW1lbnQnOiBkZWJ1Z2dlclN0YXRlbWVudFxufTtcblxubGV0IGVtcHR5TGFiZWwgPSAnZGVmYXVsdCc7IC8vIGRlZmF1bHQgaXMgYSByZXNlcnZlZCB3b3JkIHNvIG5vIGFjdHVhbCBsYWJlbCBjYW4gYmUgbmFtZWQgZGVmYXVsdCBcblxuXG5cbiIsImltcG9ydCB7IFJlc3VsdFR5cGUgfSBmcm9tIFwiLi4vUmVzdWx0XCI7XG5pbXBvcnQgeyBXb3JrTGlzdCwgVmFsdWVTdGFjayB9IGZyb20gXCIuLi9Db250ZXh0XCI7XG5pbXBvcnQgeyBDYW5hcnksIFB1c2hDYW5hcnksIEFzc2VydFZhbGlkQ2FuYXJ5IH0gZnJvbSBcIi4vRGVidWdcIjtcbmltcG9ydCB7IE1vbml0b3JCYXNlIH0gZnJvbSBcIi4uL01vbml0b3JCYXNlXCI7XG5cblxuZGVjbGFyZSB2YXIgbW9uaXRvcjogTW9uaXRvckJhc2U7XG5kZWNsYXJlIHZhciBKU0ZMT1dfU1RBQ0tfQ0hFQ0s6IGJvb2xlYW47XG5cbmV4cG9ydCB0eXBlIFJ1bkZvciA9IHsgW2tleSBpbiBSZXN1bHRUeXBlXT86IGJvb2xlYW4gfVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgVGFzayB7XG5cbiAgICBydW5mb3I6IFJ1bkZvcjtcblxuICAgIHN0YXRpYyBydW5mb3JfYWxsID0geyAndGhyb3cnOiB0cnVlLCAnY29udGludWUnOiB0cnVlLCAnYnJlYWsnOiB0cnVlLCAncmV0dXJuJyA6IHRydWUgfTtcbiAgICBzdGF0aWMgcnVuZm9yX3Rocm93ID0geyAndGhyb3cnOiB0cnVlIH07XG4gICAgc3RhdGljIHJ1bmZvcl9jb250aW51ZSA9IHsgJ2NvbnRpbnVlJzogdHJ1ZSB9O1xuICAgIHN0YXRpYyBydW5mb3JfYnJlYWsgPSB7ICdicmVhayc6IHRydWUgfTtcbiAgICBzdGF0aWMgcnVuZm9yX2NvbnRpbnVlX2JyZWFrID0geyAnYnJlYWsnOiB0cnVlLCAnY29udGludWUnOiB0cnVlIH07XG5cbiAgICBjb25zdHJ1Y3RvcihydW5mb3I/OiBSdW5Gb3IpIHtcbiAgICAgICAgdGhpcy5ydW5mb3IgPSBydW5mb3IgfHwge307XG4gICAgfVxuXG4gICAgUnVuRm9yKHg6IFJlc3VsdFR5cGUpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHggaW4gdGhpcy5ydW5mb3I7XG4gICAgfVxuXG4gICAgYWJzdHJhY3QgRXhlY3V0ZSh3bDogV29ya0xpc3QsIHZzOiBWYWx1ZVN0YWNrKTogdm9pZDtcblxufVxuXG4vLyAtLS1cblxuZnVuY3Rpb24gQ2hlY2tDYW5hcnkoXG4gICAgdGhpczogdm9pZCxcbiAgICB3bDogV29ya0xpc3QsXG4gICAgdnM6IFZhbHVlU3RhY2ssXG4gICAgY2FuYXJ5OiBDYW5hcnlcbikge1xuICAgIEFzc2VydFZhbGlkQ2FuYXJ5KHZzLCBjYW5hcnkpO1xufSIsImltcG9ydCB7IFdvcmtMaXN0LCBWYWx1ZVN0YWNrIH0gZnJvbSBcIi4uLy4uL0NvbnRleHRcIjtcblxuaW1wb3J0ICogYXMgZXN0cmVlIGZyb20gJ2VzdHJlZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBibG9ja1N0YXRlbWVudChcbiAgICBub2RlOiBlc3RyZWUuQmxvY2tTdGF0ZW1lbnQsXG4gICAgd2w6IFdvcmtMaXN0LFxuICAgIHZzOiBWYWx1ZVN0YWNrXG4pOiB2b2lkIHtcbiAgICB3bC5wcmVwZW5kKG5vZGUuYm9keSk7XG59IiwiaW1wb3J0IHsgTW9uaXRvckJhc2UgfSBmcm9tIFwiLi4vLi4vTW9uaXRvckJhc2VcIjtcbmltcG9ydCB7IFdvcmtMaXN0LCBWYWx1ZVN0YWNrIH0gZnJvbSBcIi4uLy4uL0NvbnRleHRcIjtcbmltcG9ydCB7IGx1YiwgbGUgfSBmcm9tIFwiLi4vLi4vTGFiZWxcIjtcblxuaW1wb3J0ICogYXMgZXN0cmVlIGZyb20gJ2VzdHJlZSc7XG5cbmRlY2xhcmUgdmFyIG1vbml0b3I6IE1vbml0b3JCYXNlO1xuXG5sZXQgZW1wdHlMYWJlbCA9ICdkZWZhdWx0JzsgLy8gZGVmYXVsdCBpcyBhIHJlc2VydmVkIHdvcmQgc28gbm8gYWN0dWFsIGxhYmVsIGNhbiBiZSBuYW1lZCBkZWZhdWx0IFxuXG4vLyAxMi44IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIGJyZWFrU3RhdGVtZW50KFxuICAgIG5vZGU6IGVzdHJlZS5CcmVha1N0YXRlbWVudCxcbiAgICB3bDogV29ya0xpc3QsXG4gICAgdnM6IFZhbHVlU3RhY2tcbik6IHZvaWQge1xuICAgIGxldCBjID0gbW9uaXRvci5jb250ZXh0O1xuICAgIGxldCByZXN1bHQgPSBtb25pdG9yLmNvbnRleHQucmVzdWx0O1xuXG4gICAgbGV0IG5hbWUgPSBub2RlLmxhYmVsID8gbm9kZS5sYWJlbC5uYW1lIDogZW1wdHlMYWJlbDtcbiAgICBsZXQgbGJsY29udGV4dCA9IGMubGFiZWxzLmxhYmVsbWFwW25hbWVdLmxhYmVsO1xuXG4gICAgbGV0IGRpc3BsYXlOYW1lID0gbm9kZS5sYWJlbCA/ICcoJyArIG5hbWUgKyAnKScgOiAnJztcbiAgICBtb25pdG9yLmFzc2VydChsZShjLmVmZmVjdGl2ZVBDLCBsYmxjb250ZXh0KSxcbiAgICAgICAgJ3dyaXRlIGNvbnRleHQgJyArIGMuZWZmZWN0aXZlUEMgKyAnIG5vdCBiZWxvdyAnICtcbiAgICAgICAgJ2xhYmVsIGNvbnRleHQgJyArIGxibGNvbnRleHQgKyAnICcgKyBkaXNwbGF5TmFtZVxuICAgICk7XG5cbiAgICAvLyBGb3Igb2JzZXJ2YWJsZSBmbG93c1xuICAgIGMubGFiZWxzLmxhYmVsbWFwW25hbWVdLmxhYmVsID0gbHViKGxibGNvbnRleHQsIGMuZWZmZWN0aXZlUEMpO1xuXG4gICAgcmVzdWx0LnR5cGUgPSAnYnJlYWsnO1xuICAgIHJlc3VsdC50YXJnZXQgPSBuYW1lO1xufSIsImltcG9ydCB7IE1vbml0b3JCYXNlIH0gZnJvbSBcIi4uLy4uL01vbml0b3JCYXNlXCI7XG5pbXBvcnQgeyBXb3JrTGlzdCwgVmFsdWVTdGFjayB9IGZyb20gXCIuLi8uLi9Db250ZXh0XCI7XG5pbXBvcnQgeyBsdWIsIGxlIH0gZnJvbSBcIi4uLy4uL0xhYmVsXCI7XG5cbmltcG9ydCAqIGFzIGVzdHJlZSBmcm9tICdlc3RyZWUnO1xuXG5kZWNsYXJlIHZhciBtb25pdG9yOiBNb25pdG9yQmFzZTtcblxubGV0IGVtcHR5TGFiZWwgPSAnZGVmYXVsdCc7IC8vIGRlZmF1bHQgaXMgYSByZXNlcnZlZCB3b3JkIHNvIG5vIGFjdHVhbCBsYWJlbCBjYW4gYmUgbmFtZWQgZGVmYXVsdCBcblxuLy8gMTIuNyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBmdW5jdGlvbiBjb250aW51ZVN0YXRlbWVudChcbiAgICBub2RlOiBlc3RyZWUuQ29udGludWVTdGF0ZW1lbnQsXG4gICAgd2w6IFdvcmtMaXN0LFxuICAgIHZzOiBWYWx1ZVN0YWNrXG4pOiB2b2lkIHtcbiAgICBsZXQgYyA9IG1vbml0b3IuY29udGV4dDtcbiAgICBsZXQgcmVzdWx0ID0gbW9uaXRvci5jb250ZXh0LnJlc3VsdDtcblxuICAgIGxldCBuYW1lID0gbm9kZS5sYWJlbCA/IG5vZGUubGFiZWwubmFtZSA6IGVtcHR5TGFiZWw7XG4gICAgbGV0IGxibGNvbnRleHQgPSBjLmxhYmVscy5sYWJlbG1hcFtuYW1lXS5sYWJlbDtcblxuICAgIGxldCBkaXNwbGF5TmFtZSA9IG5vZGUubGFiZWwgPyAnKCcgKyBuYW1lICsgJyknIDogJyc7XG4gICAgbW9uaXRvci5hc3NlcnQobGUoYy5lZmZlY3RpdmVQQywgbGJsY29udGV4dCksXG4gICAgICAgICd3cml0ZSBjb250ZXh0ICcgKyBjLmVmZmVjdGl2ZVBDICsgJyBub3QgYmVsb3cgJyArXG4gICAgICAgICdsYWJlbCBjb250ZXh0ICcgKyBsYmxjb250ZXh0ICsgZGlzcGxheU5hbWVcbiAgICApO1xuXG4gICAgLy8gRm9yIG9ic2VydmFibGUgZmxvd3NcbiAgICBjLmxhYmVscy5sYWJlbG1hcFtuYW1lXS5sYWJlbCA9IGx1YihsYmxjb250ZXh0LCBjLmVmZmVjdGl2ZVBDKTtcblxuICAgIHJlc3VsdC50eXBlID0gJ2NvbnRpbnVlJztcbiAgICByZXN1bHQudGFyZ2V0ID0gbmFtZTtcbn0iLCJpbXBvcnQgeyBNb25pdG9yQmFzZSB9IGZyb20gXCIuLi8uLi9Nb25pdG9yQmFzZVwiO1xuaW1wb3J0IHsgV29ya0xpc3QsIFZhbHVlU3RhY2sgfSBmcm9tIFwiLi4vLi4vQ29udGV4dFwiO1xuXG5pbXBvcnQgKiBhcyBlc3RyZWUgZnJvbSAnZXN0cmVlJztcblxuZGVjbGFyZSB2YXIgbW9uaXRvcjogTW9uaXRvckJhc2U7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlYnVnZ2VyU3RhdGVtZW50KFxuICAgIG5vZGU6IGVzdHJlZS5EZWJ1Z2dlclN0YXRlbWVudCxcbiAgICB3bDogV29ya0xpc3QsXG4gICAgdnM6IFZhbHVlU3RhY2tcbik6IHZvaWQge1xuICAgIG1vbml0b3IuZGVidWcuYWN0aXZlID0gdHJ1ZTtcbn0iLCJpbXBvcnQgeyBXb3JrTGlzdCwgVmFsdWVTdGFjayB9IGZyb20gXCIuLi8uLi9Db250ZXh0XCI7XG5cbmltcG9ydCAqIGFzIGVzdHJlZSBmcm9tICdlc3RyZWUnO1xuXG5leHBvcnQgZnVuY3Rpb24gZW1wdHlTdGF0ZW1lbnQoXG4gICAgbm9kZTogZXN0cmVlLkVtcHR5U3RhdGVtZW50LFxuICAgIHdsOiBXb3JrTGlzdCxcbiAgICB2czogVmFsdWVTdGFja1xuKTogdm9pZCB7XG59IiwiaW1wb3J0IHsgTW9uaXRvckJhc2UgfSBmcm9tIFwiLi4vLi4vTW9uaXRvckJhc2VcIjtcbmltcG9ydCB7IFdvcmtMaXN0LCBWYWx1ZVN0YWNrIH0gZnJvbSBcIi4uLy4uL0NvbnRleHRcIjtcbmltcG9ydCB7IEdldFZhbHVlIH0gZnJvbSBcIi4uLy4uL0dldFZhbHVlXCI7XG5pbXBvcnQgeyBUYXNrIH0gZnJvbSBcIi4uL1Rhc2tcIjtcblxuaW1wb3J0ICogYXMgZXN0cmVlIGZyb20gJ2VzdHJlZSc7XG5cbmRlY2xhcmUgdmFyIG1vbml0b3I6IE1vbml0b3JCYXNlO1xuZXhwb3J0IGZ1bmN0aW9uIGV4cHJlc3Npb25TdGF0ZW1lbnQoXG4gICAgdGhpczogdm9pZCxcbiAgICBub2RlOiBlc3RyZWUuRXhwcmVzc2lvblN0YXRlbWVudCxcbiAgICB3bDogV29ya0xpc3QsXG4gICAgdnM6IFZhbHVlU3RhY2tcbik6IHZvaWQge1xuICAgIGxldCBpcCA9IHdsLnRvcCgpO1xuXG4gICAgaXAudGhlbihub2RlLmV4cHJlc3Npb24pO1xuICAgIGlwLnRoZW4oRXhwcmVzc2lvblN0YXRlbWVudEVuZC5JbnN0YW5jZSk7XG59XG5cbmNsYXNzIEV4cHJlc3Npb25TdGF0ZW1lbnRFbmQgZXh0ZW5kcyBUYXNrIHtcblxuICAgIHN0YXRpYyBJbnN0YW5jZSA9IG5ldyBFeHByZXNzaW9uU3RhdGVtZW50RW5kKCk7IFxuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxuXG4gICAgRXhlY3V0ZSh3bDogV29ya0xpc3QsIHZzOiBWYWx1ZVN0YWNrKTogdm9pZCB7XG4gICAgICAgIGxldCBjID0gbW9uaXRvci5jb250ZXh0O1xuXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgbGV0IHZhbDogVmFsdWUgPCBWYWx1ZVR5cGVzID4gPSB2cy5wb3AoKTtcbiAgICAgICAgYy5yZXN1bHQudmFsdWUgPSBHZXRWYWx1ZSh2YWwpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBNb25pdG9yQmFzZSB9IGZyb20gXCIuLi8uLi9Nb25pdG9yQmFzZVwiO1xuaW1wb3J0IHsgV29ya0xpc3QsIFZhbHVlU3RhY2sgfSBmcm9tIFwiLi4vLi4vQ29udGV4dFwiO1xuaW1wb3J0IHsgVGFzayB9IGZyb20gXCIuLi9UYXNrXCI7XG5pbXBvcnQgeyBMYWJlbCB9IGZyb20gXCIuLi8uLi9MYWJlbFwiO1xuaW1wb3J0IHsgR2V0VmFsdWUgfSBmcm9tIFwiLi4vLi4vR2V0VmFsdWVcIjtcbmltcG9ydCB7IFRvT2JqZWN0IH0gZnJvbSBcIi4uLy4uL0NvbnZlcnNpb24vVG9PYmplY3RcIjtcbmltcG9ydCB7IFB1dFZhbHVlIH0gZnJvbSBcIi4uLy4uL1B1dFZhbHVlXCI7XG5pbXBvcnQgeyBTdGFja01hcmtlciB9IGZyb20gXCIuLi8uLi9TdGFja1wiO1xuXG5pbXBvcnQgKiBhcyBlc3RyZWUgZnJvbSAnZXN0cmVlJztcbmltcG9ydCB7IFZhbHVlIH0gZnJvbSBcIi4uLy4uL1ZhbHVlXCI7XG5pbXBvcnQgeyBFY21hT2JqZWN0IH0gZnJvbSBcIi4uLy4uL09iamVjdHMvRWNtYU9iamVjdFwiO1xuXG5kZWNsYXJlIHZhciBtb25pdG9yOiBNb25pdG9yQmFzZTtcblxubGV0IGVtcHR5TGFiZWwgPSAnZGVmYXVsdCc7IC8vIGRlZmF1bHQgaXMgYSByZXNlcnZlZCB3b3JkIHNvIG5vIGFjdHVhbCBsYWJlbCBjYW4gYmUgbmFtZWQgZGVmYXVsdCBcblxuaW50ZXJmYWNlIExhYmVsZWRGb3JJblN0YXRlbWVudCBleHRlbmRzIGVzdHJlZS5Gb3JJblN0YXRlbWVudCB7XG4gICAgbGFiZWxzZXQ/OiBTZXQ8c3RyaW5nPjtcbn1cblxubGV0IE15U2V0ID0gU2V0O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvckluU3RhdGVtZW50KFxuICAgIG5vZGU6IExhYmVsZWRGb3JJblN0YXRlbWVudCxcbiAgICB3bDogV29ya0xpc3QsXG4gICAgdnM6IFZhbHVlU3RhY2tcbik6IHZvaWQge1xuICAgIGxldCBpcCA9IHdsLnRvcCgpO1xuXG4gICAgbGV0IGxlZnQ6IGVzdHJlZS5QYXR0ZXJuO1xuICAgIGlmIChub2RlLmxlZnQudHlwZSA9PT0gJ1ZhcmlhYmxlRGVjbGFyYXRpb24nKSB7XG4gICAgICAgIGlwLnRoZW4obm9kZS5sZWZ0KTtcblxuICAgICAgICAvLyB0aGUgc3RhbmRhcmQgb25seSBhbGxvd3MgZm9yIG9uZSBkZWNsYXJhdGlvbiwgZ2V0IHRoZSBuYW1lXG4gICAgICAgIGxlZnQgPSBub2RlLmxlZnQuZGVjbGFyYXRpb25zWzBdLmlkO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxlZnQgPSBub2RlLmxlZnQ7XG4gICAgfVxuXG4gICAgaXAudGhlbihub2RlLnJpZ2h0KTtcbiAgICBpcC50aGVuKG5ldyBGb3JJblN0YXRlbWVudFNldHVwKG5vZGUsIGxlZnQpKTtcbn1cblxuLy8gLS0tXG5cbmNsYXNzIEZvckluU3RhdGVtZW50U2V0dXAgZXh0ZW5kcyBUYXNrIHtcbiAgICBub2RlOiBMYWJlbGVkRm9ySW5TdGF0ZW1lbnQ7XG4gICAgbGVmdDogZXN0cmVlLlBhdHRlcm47XG5cbiAgICBjb25zdHJ1Y3Rvcihub2RlOiBMYWJlbGVkRm9ySW5TdGF0ZW1lbnQsIGxlZnQ6IGVzdHJlZS5QYXR0ZXJuKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgfVxuXG4gICAgRXhlY3V0ZSh3bDogV29ya0xpc3QsIHZzOiBWYWx1ZVN0YWNrKTogdm9pZCB7XG4gICAgICAgIGxldCBjID0gbW9uaXRvci5jb250ZXh0O1xuICAgICAgICBsZXQgaXAgPSB3bC50b3AoKTtcbiAgICAgICAgbGV0IGxtYXAgPSBjLmxhYmVscy5sYWJlbG1hcDtcblxuICAgICAgICBsZXQgbm9kZSA9IHRoaXMubm9kZTtcblxuICAgICAgICBpZiAoIW5vZGUubGFiZWxzZXQpIHtcbiAgICAgICAgICAgIG5vZGUubGFiZWxzZXQgPSBuZXcgTXlTZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLmxhYmVsc2V0LmFkZChlbXB0eUxhYmVsKTtcblxuICAgICAgICBsZXQgb3V0ZXJFbXB0eUxhYmVsRGF0YSA9IGxtYXBbZW1wdHlMYWJlbF07XG4gICAgICAgIGxtYXBbZW1wdHlMYWJlbF0gPSB7XG4gICAgICAgICAgICBsYWJlbDogYy5lZmZlY3RpdmVQQyxcbiAgICAgICAgICAgIHBjbWFya2VyOiBjLnBjU3RhY2subWFya2VyKClcbiAgICAgICAgfTtcblxuICAgICAgICBsZXQgY29udGV4dExhYmVsID0gbG1hcFtlbXB0eUxhYmVsXS5sYWJlbDtcbiAgICAgICAgYy5wdXNoUEMoY29udGV4dExhYmVsKTtcblxuICAgICAgICAvL0B0cy1pZ25vcmUgU1RBQ0tcbiAgICAgICAgbGV0IHZhbCA9IEdldFZhbHVlKHZzLnBvcCgpKTtcbiAgICAgICAgaWYgKHZhbC52YWx1ZSA9PT0gbnVsbCB8fCB2YWwudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG9iaiA9IFRvT2JqZWN0KHZhbCk7XG4gICAgICAgIGxldCBtYXhQcm9wZXJ0eSA9IG9iai52YWx1ZS5nZXRFbnVtZXJhYmxlUHJvcGVydHlOYW1lcyhvYmoubGFiZWwpLmxlbmd0aDtcblxuICAgICAgICAvLyBtb25pdG9yLmNvbnRleHQucHVzaFBDKG9iai5sYWJlbCk7XG5cbiAgICAgICAgaXAudGhlbihuZXcgRm9ySW5FeGVjdXRlKG5vZGUsIHRoaXMubGVmdCwgb2JqLCBtYXhQcm9wZXJ0eSwgb3V0ZXJFbXB0eUxhYmVsRGF0YSkpO1xuICAgIH1cbn1cblxuLy8gLS0tXG5cbmNsYXNzIEZvckluRXhlY3V0ZSBleHRlbmRzIFRhc2sge1xuICAgIG5vZGU6IExhYmVsZWRGb3JJblN0YXRlbWVudDtcbiAgICBsZWZ0OiBlc3RyZWUuUGF0dGVybjtcbiAgICBvYmo6IFZhbHVlPEVjbWFPYmplY3Q+O1xuICAgIG5leHRQcm9wZXJ0eTogbnVtYmVyO1xuICAgIG1heFByb3BlcnR5OiBudW1iZXI7XG4gICAgb3V0ZXJFbXB0eUxhYmVsRGF0YTogeyBsYWJlbDogTGFiZWwsIHBjbWFya2VyOiBTdGFja01hcmtlciB9O1xuXG4gICAgdXBkYXRlOiBGb3JJblVwZGF0ZTtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBub2RlOiBMYWJlbGVkRm9ySW5TdGF0ZW1lbnQsXG4gICAgICAgIGxlZnQ6IGVzdHJlZS5QYXR0ZXJuLFxuICAgICAgICBvYmo6IFZhbHVlPEVjbWFPYmplY3Q+LFxuICAgICAgICBtYXhQcm9wZXJ0eTogbnVtYmVyLFxuICAgICAgICBvdXRlckVtcHR5TGFiZWxEYXRhOiB7IGxhYmVsOiBMYWJlbCwgcGNtYXJrZXI6IFN0YWNrTWFya2VyIH1cbiAgICApIHtcbiAgICAgICAgc3VwZXIoVGFzay5ydW5mb3JfY29udGludWVfYnJlYWspO1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICB0aGlzLm9iaiA9IG9iajtcbiAgICAgICAgdGhpcy5tYXhQcm9wZXJ0eSA9IG1heFByb3BlcnR5O1xuICAgICAgICB0aGlzLm91dGVyRW1wdHlMYWJlbERhdGEgPSBvdXRlckVtcHR5TGFiZWxEYXRhO1xuXG4gICAgICAgIHRoaXMubmV4dFByb3BlcnR5ID0gMDtcbiAgICAgICAgdGhpcy51cGRhdGUgPSBuZXcgRm9ySW5VcGRhdGUobm9kZSwgdGhpcyk7XG4gICAgfVxuXG4gICAgRXhlY3V0ZSh3bDogV29ya0xpc3QsIHZzOiBWYWx1ZVN0YWNrKTogdm9pZCB7XG4gICAgICAgIGxldCBpcCA9IHdsLnRvcCgpO1xuICAgICAgICBsZXQgYyA9IG1vbml0b3IuY29udGV4dDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGMucmVzdWx0O1xuXG4gICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gJ2JyZWFrJyAmJiB0aGlzLm5vZGUubGFiZWxzZXQhLmhhcyhyZXN1bHQudGFyZ2V0KSkge1xuICAgICAgICAgICAgcmVzdWx0LnR5cGUgPSAnbm9ybWFsJztcbiAgICAgICAgICAgIHJlc3VsdC50YXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgYy5sYWJlbHMubGFiZWxtYXBbZW1wdHlMYWJlbF0gPSB0aGlzLm91dGVyRW1wdHlMYWJlbERhdGE7XG4gICAgICAgICAgICBjLnBvcFBDKCk7IC8vIGNvbnRleHRMYWJlbFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdC50eXBlICE9PSAnY29udGludWUnIHx8ICF0aGlzLm5vZGUubGFiZWxzZXQhLmhhcyhyZXN1bHQudGFyZ2V0KSkge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC50eXBlICE9PSAnbm9ybWFsJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnRpbnVlIGdldHMgdXMgaGVyZVxuICAgICAgICByZXN1bHQudHlwZSA9ICdub3JtYWwnO1xuICAgICAgICByZXN1bHQudGFyZ2V0ID0gbnVsbDtcblxuICAgICAgICBsZXQgcHJvcGVydGllcyA9IHRoaXMub2JqLnZhbHVlLmdldEVudW1lcmFibGVQcm9wZXJ0eU5hbWVzKHRoaXMub2JqLmxhYmVsKTtcblxuICAgICAgICBpZiAodGhpcy5uZXh0UHJvcGVydHkgPj0gcHJvcGVydGllcy5sZW5ndGggfHwgdGhpcy5uZXh0UHJvcGVydHkgPj0gdGhpcy5tYXhQcm9wZXJ0eSkge1xuICAgICAgICAgICAgYy5sYWJlbHMubGFiZWxtYXBbZW1wdHlMYWJlbF0gPSB0aGlzLm91dGVyRW1wdHlMYWJlbERhdGE7XG4gICAgICAgICAgICBjLnBvcFBDKCk7IC8vIGNvbnRleHRMYWJlbFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHByb3BOYW1lID0gcHJvcGVydGllc1t0aGlzLm5leHRQcm9wZXJ0eV07XG4gICAgICAgIHRoaXMubmV4dFByb3BlcnR5Kys7XG5cbiAgICAgICAgdnMucHVzaChwcm9wTmFtZSk7XG4gICAgICAgIGlwLnRoZW4odGhpcy5sZWZ0KTtcbiAgICAgICAgaXAudGhlbih0aGlzLnVwZGF0ZSk7XG4gICAgfVxufVxuXG4vLyAtLS1cblxuY2xhc3MgRm9ySW5VcGRhdGUgZXh0ZW5kcyBUYXNrIHtcbiAgICBub2RlOiBMYWJlbGVkRm9ySW5TdGF0ZW1lbnQ7XG4gICAgZXhlY3V0ZTogRm9ySW5FeGVjdXRlO1xuXG4gICAgY29uc3RydWN0b3Iobm9kZTogTGFiZWxlZEZvckluU3RhdGVtZW50LCBleGVjdXRlOiBGb3JJbkV4ZWN1dGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5leGVjdXRlID0gZXhlY3V0ZTtcbiAgICB9XG5cbiAgICBFeGVjdXRlKHdsOiBXb3JrTGlzdCwgdnM6IFZhbHVlU3RhY2spOiB2b2lkIHtcbiAgICAgICAgbGV0IGlwID0gd2wudG9wKCk7XG5cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBsZXQgbGhzOiBSZWZlcmVuY2UgPSB2cy5wb3AoKTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBsZXQgcHJvcE5hbWU6IFZhbHVlPFZhbHVlVHlwZXM+ID0gdnMucG9wKCk7XG5cbiAgICAgICAgUHV0VmFsdWUobGhzLCBwcm9wTmFtZSk7XG5cbiAgICAgICAgbW9uaXRvci5jb250ZXh0LnB1c2hQQyhwcm9wTmFtZS5sYWJlbCk7XG5cbiAgICAgICAgaXAudGhlbih0aGlzLm5vZGUuYm9keSk7XG4gICAgICAgIGlwLnRoZW4oRm9ySW5TZWN1cml0eUNvbnRleHRFbmQuSW5zdGFuY2UpO1xuICAgICAgICBpcC50aGVuKHRoaXMuZXhlY3V0ZSk7XG4gICAgfVxufVxuXG4vLyAtLS1cblxuY2xhc3MgRm9ySW5TZWN1cml0eUNvbnRleHRFbmQgZXh0ZW5kcyBUYXNrIHtcbiAgICBzdGF0aWMgSW5zdGFuY2UgPSBuZXcgRm9ySW5TZWN1cml0eUNvbnRleHRFbmQoKTtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cblxuICAgIEV4ZWN1dGUod2w6IFdvcmtMaXN0LCB2czogVmFsdWVTdGFjayk6IHZvaWQge1xuICAgICAgICBtb25pdG9yLmNvbnRleHQucG9wUEMoKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgTW9uaXRvckJhc2UgfSBmcm9tIFwiLi4vLi4vTW9uaXRvckJhc2VcIjtcbmltcG9ydCB7IFdvcmtMaXN0LCBWYWx1ZVN0YWNrIH0gZnJvbSBcIi4uLy4uL0NvbnRleHRcIjtcbmltcG9ydCB7IFRhc2sgfSBmcm9tIFwiLi4vVGFza1wiO1xuaW1wb3J0IHsgTGFiZWwsIGx1YiB9IGZyb20gXCIuLi8uLi9MYWJlbFwiO1xuaW1wb3J0IHsgR2V0VmFsdWUgfSBmcm9tIFwiLi4vLi4vR2V0VmFsdWVcIjtcbmltcG9ydCB7IFRvQm9vbGVhbiB9IGZyb20gXCIuLi8uLi9Db252ZXJzaW9uL1RvQm9vbGVhblwiO1xuXG5pbXBvcnQgKiBhcyBlc3RyZWUgZnJvbSAnZXN0cmVlJztcbmltcG9ydCB7IFN0YWNrTWFya2VyIH0gZnJvbSBcIi4uLy4uL1N0YWNrXCI7XG5cbmRlY2xhcmUgdmFyIG1vbml0b3I6IE1vbml0b3JCYXNlO1xuXG5sZXQgZW1wdHlMYWJlbCA9ICdkZWZhdWx0JzsgLy8gZGVmYXVsdCBpcyBhIHJlc2VydmVkIHdvcmQgc28gbm8gYWN0dWFsIGxhYmVsIGNhbiBiZSBuYW1lZCBkZWZhdWx0IFxuXG5pbnRlcmZhY2UgTGFiZWxlZEZvclN0YXRlbWVudCBleHRlbmRzIGVzdHJlZS5Gb3JTdGF0ZW1lbnQge1xuICAgIGxhYmVsc2V0PzogU2V0PHN0cmluZz47XG59XG5cblxuY2xhc3MgUmVzZXRWYWx1ZVN0YWNrIGV4dGVuZHMgVGFzayB7XG5cbiAgICB0YXJnZXRTaXplIDogbnVtYmVyXG5cbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXRTaXplOiBudW1iZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG5cbiAgICBFeGVjdXRlKHdsOiBXb3JrTGlzdCwgdnM6IFZhbHVlU3RhY2spOiB2b2lkIHtcbiAgICAgICAgd2hpbGUodnMuc2l6ZSgpID4gdGhpcy50YXJnZXRTaXplKSB7XG4gICAgICAgICAgICB2cy5wb3AoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxubGV0IE15U2V0ID0gU2V0O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvclN0YXRlbWVudChcbiAgICBub2RlOiBMYWJlbGVkRm9yU3RhdGVtZW50LFxuICAgIHdsOiBXb3JrTGlzdCxcbiAgICB2czogVmFsdWVTdGFja1xuKTogdm9pZCB7XG4gICAgbGV0IGMgPSBtb25pdG9yLmNvbnRleHQ7XG4gICAgbGV0IGlwID0gd2wudG9wKCk7XG5cbiAgICBsZXQgbG1hcCA9IGMubGFiZWxzLmxhYmVsbWFwO1xuXG4gICAgaWYgKG5vZGUuaW5pdCkge1xuICAgICAgICBpcC50aGVuKG5vZGUuaW5pdCk7XG4gICAgICAgIGlwLnRoZW4obmV3IFJlc2V0VmFsdWVTdGFjayh2cy5zaXplKCkpKTtcbiAgICB9XG5cbiAgICBpZiAoIW5vZGUubGFiZWxzZXQpIHtcbiAgICAgICAgbm9kZS5sYWJlbHNldCA9IG5ldyBNeVNldChbXSk7XG4gICAgfVxuICAgIG5vZGUubGFiZWxzZXQuYWRkKGVtcHR5TGFiZWwpO1xuXG4gICAgbGV0IG91dGVyRW1wdHlMYWJlbERhdGEgPSBsbWFwW2VtcHR5TGFiZWxdO1xuICAgIGxtYXBbZW1wdHlMYWJlbF0gPSB7XG4gICAgICAgIGxhYmVsOiBjLmVmZmVjdGl2ZVBDLFxuICAgICAgICBwY21hcmtlcjogYy5wY1N0YWNrLm1hcmtlcigpXG4gICAgfTtcblxuICAgIGxldCBjb250ZXh0TGFiZWwgPSBsbWFwW2VtcHR5TGFiZWxdLmxhYmVsO1xuICAgIGMucHVzaFBDKGNvbnRleHRMYWJlbCk7XG5cbiAgICBpcC50aGVuKG5ldyBGb3JTdGF0ZW1lbnRNYWluKG5vZGUpKTtcbiAgICBpcC50aGVuKG5ldyBGb3JTdGF0ZW1lbnRFbmQob3V0ZXJFbXB0eUxhYmVsRGF0YSkpO1xufVxuXG4vLyAtLS1cblxuY2xhc3MgRm9yU3RhdGVtZW50TWFpbiBleHRlbmRzIFRhc2sge1xuXG4gICAgbm9kZTogTGFiZWxlZEZvclN0YXRlbWVudDtcbiAgICBjaG9vc2U6IEZvclN0YXRlbWVudENob29zZTtcbiAgICBleGVjdXRlOiBGb3JTdGF0ZW1lbnRFeGVjdXRlO1xuICAgIHVwZGF0ZTogRm9yU3RhdGVtZW50VXBkYXRlO1xuXG4gICAgY29uc3RydWN0b3Iobm9kZTogTGFiZWxlZEZvclN0YXRlbWVudCkge1xuICAgICAgICBzdXBlcihUYXNrLnJ1bmZvcl9jb250aW51ZV9icmVhayk7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMuZXhlY3V0ZSA9IG5ldyBGb3JTdGF0ZW1lbnRFeGVjdXRlKG5vZGUsIHRoaXMpO1xuICAgICAgICB0aGlzLmNob29zZSA9IG5ldyBGb3JTdGF0ZW1lbnRDaG9vc2Uobm9kZSwgdGhpcyk7XG4gICAgICAgIHRoaXMudXBkYXRlID0gbmV3IEZvclN0YXRlbWVudFVwZGF0ZShub2RlKTtcbiAgICB9XG5cbiAgICBFeGVjdXRlKHdsOiBXb3JrTGlzdCwgdnM6IFZhbHVlU3RhY2spOiB2b2lkIHtcbiAgICAgICAgbGV0IGMgPSBtb25pdG9yLmNvbnRleHQ7XG4gICAgICAgIGxldCBpcCA9IHdsLnRvcCgpO1xuXG5cbiAgICAgICAgbGV0IHJlc3VsdCA9IGMucmVzdWx0O1xuXG4gICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gJ2JyZWFrJyAmJiB0aGlzLm5vZGUubGFiZWxzZXQhLmhhcyhyZXN1bHQudGFyZ2V0KSkge1xuICAgICAgICAgICAgcmVzdWx0LnR5cGUgPSAnbm9ybWFsJztcbiAgICAgICAgICAgIHJlc3VsdC50YXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdC50eXBlICE9PSAnY29udGludWUnIHx8ICF0aGlzLm5vZGUubGFiZWxzZXQhLmhhcyhyZXN1bHQudGFyZ2V0KSkge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC50eXBlICE9PSAnbm9ybWFsJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC50eXBlID0gJ25vcm1hbCc7XG4gICAgICAgIHJlc3VsdC50YXJnZXQgPSBudWxsO1xuXG4gICAgICAgIGlmICh0aGlzLm5vZGUudGVzdCkge1xuICAgICAgICAgICAgaXAudGhlbih0aGlzLm5vZGUudGVzdCk7XG4gICAgICAgICAgICBpcC50aGVuKHRoaXMuY2hvb3NlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlwLnRoZW4odGhpcy5leGVjdXRlKTtcbiAgICAgICAgfVxuXG4gICAgfVxufVxuXG4vLyAtLS1cbmNsYXNzIEZvclN0YXRlbWVudENob29zZSBleHRlbmRzIFRhc2sge1xuICAgIG5vZGU6IExhYmVsZWRGb3JTdGF0ZW1lbnQ7XG4gICAgbWFpbjogRm9yU3RhdGVtZW50TWFpbjtcblxuICAgIGNvbnN0cnVjdG9yKG5vZGU6IExhYmVsZWRGb3JTdGF0ZW1lbnQsIG1haW46IEZvclN0YXRlbWVudE1haW4pIHtcbiAgICAgICAgc3VwZXIoVGFzay5ydW5mb3JfY29udGludWUpO1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLm1haW4gPSBtYWluO1xuICAgIH1cblxuICAgIEV4ZWN1dGUod2w6IFdvcmtMaXN0LCB2czogVmFsdWVTdGFjayk6IHZvaWQge1xuICAgICAgICBsZXQgaXAgPSB3bC50b3AoKTtcbiAgICAgICAgbGV0IGMgPSBtb25pdG9yLmNvbnRleHQ7XG4gICAgICAgIGxldCByZXN1bHQgPSBjLnJlc3VsdDtcblxuICAgICAgICAvL0B0cy1pZ25vcmUgU1RBQ0tcbiAgICAgICAgbGV0IGNvbmQgPSBHZXRWYWx1ZSh2cy5wb3AoKSk7XG4gICAgICAgIGxldCBjb25kYiA9IFRvQm9vbGVhbihjb25kKTtcblxuICAgICAgICBjLmxhYmVscy5wYyA9IGx1YihjLmxhYmVscy5wYywgY29uZGIubGFiZWwpO1xuICAgICAgICBpZiAoIWNvbmRiLnZhbHVlKSB7XG4gICAgICAgICAgICByZXN1bHQudHlwZSA9ICdub3JtYWwnO1xuICAgICAgICAgICAgcmVzdWx0LnRhcmdldCA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaXAudGhlbih0aGlzLm1haW4uZXhlY3V0ZSk7XG4gICAgfVxufVxuXG5jbGFzcyBGb3JTdGF0ZW1lbnRFeGVjdXRlIGV4dGVuZHMgVGFzayB7XG4gICAgbm9kZTogTGFiZWxlZEZvclN0YXRlbWVudDtcbiAgICBtYWluOiBGb3JTdGF0ZW1lbnRNYWluO1xuXG4gICAgY29uc3RydWN0b3Iobm9kZTogTGFiZWxlZEZvclN0YXRlbWVudCwgbWFpbjogRm9yU3RhdGVtZW50TWFpbikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLm1haW4gPSBtYWluO1xuICAgIH1cblxuICAgIEV4ZWN1dGUod2w6IFdvcmtMaXN0LCB2czogVmFsdWVTdGFjayk6IHZvaWQge1xuICAgICAgICBsZXQgaXAgPSB3bC50b3AoKTtcblxuICAgICAgICBpcC50aGVuKHRoaXMubm9kZS5ib2R5KTtcbiAgICAgICAgaXAudGhlbih0aGlzLm1haW4udXBkYXRlKTtcbiAgICAgICAgaXAudGhlbih0aGlzLm1haW4pO1xuICAgIH1cbn1cblxuY2xhc3MgRm9yU3RhdGVtZW50VXBkYXRlIGV4dGVuZHMgVGFzayB7XG4gICAgbm9kZTogTGFiZWxlZEZvclN0YXRlbWVudDtcblxuICAgIGNvbnN0cnVjdG9yKG5vZGU6IExhYmVsZWRGb3JTdGF0ZW1lbnQpIHtcbiAgICAgICAgc3VwZXIoVGFzay5ydW5mb3JfY29udGludWUpO1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgIH1cblxuICAgIEV4ZWN1dGUod2w6IFdvcmtMaXN0LCB2czogVmFsdWVTdGFjayk6IHZvaWQge1xuICAgICAgICBsZXQgaXAgPSB3bC50b3AoKTtcblxuICAgICAgICBsZXQgYyA9IG1vbml0b3IuY29udGV4dDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGMucmVzdWx0O1xuXG4gICAgICAgIGlmIChyZXN1bHQudHlwZSAhPT0gJ2NvbnRpbnVlJyB8fCAhdGhpcy5ub2RlLmxhYmVsc2V0IS5oYXMocmVzdWx0LnRhcmdldCkpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQudHlwZSAhPT0gJ25vcm1hbCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQudHlwZSA9ICdub3JtYWwnO1xuICAgICAgICByZXN1bHQudGFyZ2V0ID0gbnVsbDtcblxuICAgICAgICBpZiAodGhpcy5ub2RlLnVwZGF0ZSkge1xuICAgICAgICAgICAgaXAudGhlbih0aGlzLm5vZGUudXBkYXRlKTtcbiAgICAgICAgICAgIGlwLnRoZW4obmV3IFJlc2V0VmFsdWVTdGFjayh2cy5zaXplKCkpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG4vLyBmb3JTdGF0ZW1lbnRlRW5kXG5jbGFzcyBGb3JTdGF0ZW1lbnRFbmQgZXh0ZW5kcyBUYXNrIHtcbiAgICBvdXRlckVtcHR5TGFiZWxEYXRhOiB7IGxhYmVsOiBMYWJlbCwgcGNtYXJrZXI6IFN0YWNrTWFya2VyIH07XG5cbiAgICBjb25zdHJ1Y3RvcihvdXRlckVtcHR5TGFiZWxEYXRhOiB7IGxhYmVsOiBMYWJlbCwgcGNtYXJrZXI6IFN0YWNrTWFya2VyIH0pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5vdXRlckVtcHR5TGFiZWxEYXRhID0gb3V0ZXJFbXB0eUxhYmVsRGF0YTtcbiAgICB9XG5cbiAgICBFeGVjdXRlKHdsOiBXb3JrTGlzdCwgdnM6IFZhbHVlU3RhY2spOiB2b2lkIHtcbiAgICAgICAgbGV0IGMgPSBtb25pdG9yLmNvbnRleHQ7XG4gICAgICAgIGMubGFiZWxzLmxhYmVsbWFwW2VtcHR5TGFiZWxdID0gdGhpcy5vdXRlckVtcHR5TGFiZWxEYXRhO1xuICAgICAgICBjLnBvcFBDKCk7XG4gICAgfVxufSIsImltcG9ydCB7IE1vbml0b3JCYXNlIH0gZnJvbSBcIi4uLy4uL01vbml0b3JCYXNlXCI7XG5pbXBvcnQgeyBXb3JrTGlzdCwgVmFsdWVTdGFjayB9IGZyb20gXCIuLi8uLi9Db250ZXh0XCI7XG5pbXBvcnQgeyBUYXNrIH0gZnJvbSBcIi4uL1Rhc2tcIjtcbmltcG9ydCB7IExhYmVsIH0gZnJvbSBcIi4uLy4uL0xhYmVsXCI7XG5pbXBvcnQgeyBHZXRWYWx1ZSB9IGZyb20gXCIuLi8uLi9HZXRWYWx1ZVwiO1xuaW1wb3J0IHsgVG9Cb29sZWFuIH0gZnJvbSBcIi4uLy4uL0NvbnZlcnNpb24vVG9Cb29sZWFuXCI7XG5cbmltcG9ydCAqIGFzIGVzdHJlZSBmcm9tICdlc3RyZWUnO1xuXG5kZWNsYXJlIHZhciBtb25pdG9yOiBNb25pdG9yQmFzZTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBmdW5jdGlvbiBpZlN0YXRlbWVudChcbiAgICB0aGlzOiB2b2lkLFxuICAgIG5vZGU6IGVzdHJlZS5JZlN0YXRlbWVudCxcbiAgICB3bDogV29ya0xpc3QsXG4gICAgdnM6IFZhbHVlU3RhY2tcbik6IHZvaWQge1xuICAgIGxldCBpcCA9IHdsLnRvcCgpO1xuXG4gICAgaXAudGhlbihub2RlLnRlc3QpO1xuICAgIGlwLnRoZW4obmV3IElmU3RhdGVtZW50Q2hvb3NlKG5vZGUpKTtcbn1cblxuLy8gLS0tXG5cbmNsYXNzIElmU3RhdGVtZW50Q2hvb3NlIGV4dGVuZHMgVGFzayB7XG4gICAgbm9kZTogZXN0cmVlLklmU3RhdGVtZW50O1xuXG4gICAgY29uc3RydWN0b3Iobm9kZTogZXN0cmVlLklmU3RhdGVtZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgfVxuXG4gICAgRXhlY3V0ZSh3bDogV29ya0xpc3QsIHZzOiBWYWx1ZVN0YWNrKTogdm9pZCB7XG5cbiAgICAgICAgbGV0IGlwID0gd2wudG9wKCk7XG5cbiAgICAgICAgLy9AdHMtaWdub3JlIFNUQUNLXG4gICAgICAgIGxldCBjb25kID0gR2V0VmFsdWUodnMucG9wKCkpO1xuICAgICAgICBjb25kID0gVG9Cb29sZWFuKGNvbmQpO1xuXG4gICAgICAgIG1vbml0b3IuY29udGV4dC5wdXNoUEMoY29uZC5sYWJlbCk7XG5cbiAgICAgICAgaWYgKGNvbmQudmFsdWUpIHtcbiAgICAgICAgICAgIGlwLnRoZW4odGhpcy5ub2RlLmNvbnNlcXVlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ub2RlLmFsdGVybmF0ZSAmJiBpcC50aGVuKHRoaXMubm9kZS5hbHRlcm5hdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaXAudGhlbihuZXcgSWZTdGF0ZW1lbnRFbmQoY29uZC5sYWJlbCkpO1xuICAgIH1cbn1cblxuLy8gLS0tXG5cbmNsYXNzIElmU3RhdGVtZW50RW5kIGV4dGVuZHMgVGFzayB7XG4gICAgbGFiZWwgOiBMYWJlbDtcbiAgICBjb25zdHJ1Y3RvcihsYWJlbCA6IExhYmVsKSB7XG4gICAgICAgIHN1cGVyKFRhc2sucnVuZm9yX2NvbnRpbnVlX2JyZWFrKTtcbiAgICAgICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgIH1cblxuICAgIEV4ZWN1dGUod2w6IFdvcmtMaXN0LCB2czogVmFsdWVTdGFjayk6IHZvaWQge1xuICAgICAgICBsZXQgYyA9IG1vbml0b3IuY29udGV4dDtcbiAgICAgICAgYy5wb3BQQygpO1xuICAgICAgICBpZiAoYy5yZXN1bHQudmFsdWUpIHtcbiAgICAgICAgICAgIGMucmVzdWx0LnZhbHVlLnJhaXNlKHRoaXMubGFiZWwpO1xuICAgICAgICB9XG4gICAgfVxufSIsImltcG9ydCB7IE1vbml0b3JCYXNlIH0gZnJvbSBcIi4uLy4uL01vbml0b3JCYXNlXCI7XG5pbXBvcnQgeyBXb3JrTGlzdCwgVmFsdWVTdGFjayB9IGZyb20gXCIuLi8uLi9Db250ZXh0XCI7XG5pbXBvcnQgeyBUYXNrIH0gZnJvbSBcIi4uL1Rhc2tcIjtcbmltcG9ydCB7IExhYmVsLCBib3QsIGx1YiB9IGZyb20gXCIuLi8uLi9MYWJlbFwiO1xuaW1wb3J0IHsgU3RhY2tNYXJrZXIgfSBmcm9tIFwiLi4vLi4vU3RhY2tcIjtcblxuaW1wb3J0ICogYXMgZXN0cmVlIGZyb20gJ2VzdHJlZSc7XG5cbmRlY2xhcmUgdmFyIG1vbml0b3I6IE1vbml0b3JCYXNlO1xubGV0IE15U2V0ID0gU2V0O1xuXG4vLyAxMi4xMiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIGxhYmVsZWRTdGF0ZW1lbnQoXG4gICAgbm9kZTogZXN0cmVlLkxhYmVsZWRTdGF0ZW1lbnQsXG4gICAgd2w6IFdvcmtMaXN0LFxuICAgIHZzOiBWYWx1ZVN0YWNrXG4pOiB2b2lkIHtcbiAgICBsZXQgaXAgPSB3bC50b3AoKTtcbiAgICBsZXQgYyA9IG1vbml0b3IuY29udGV4dDtcblxuICAgIGxldCBwY21hcmtlciA9IGMucGNTdGFjay5tYXJrZXIoKTtcbiAgICBsZXQgdnNtYXJrZXIgPSBjLnZhbHVlU3RhY2subWFya2VyKCk7XG5cbiAgICAvL0B0cy1pZ25vcmUgTEFCRUxTRVRcbiAgICBpZiAoIW5vZGUuYm9keS5sYWJlbHNldCkge1xuICAgICAgICAvL0B0cy1pZ25vcmUgTEFCRUxTRVRcbiAgICAgICAgbm9kZS5ib2R5LmxhYmVsc2V0ID0gbmV3IE15U2V0KFtub2RlLmxhYmVsLm5hbWVdKTtcblxuICAgICAgICAvL0B0cy1pZ25vcmUgTEFCRUxTRVRcbiAgICAgICAgaWYgKG5vZGUubGFiZWxzZXQpIHtcbiAgICAgICAgICAgIC8vQHRzLWlnbm9yZSBMQUJFTFNFVFxuICAgICAgICAgICAgbm9kZS5ib2R5LmxhYmVsc2V0LnVuaW9uKG5vZGUubGFiZWxzZXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGV0IG5hbWUgPSBub2RlLmxhYmVsLm5hbWU7XG4gICAgbGV0IG91dGVybGFiZWwgPSBzZXR1cFN0YXRlbWVudExhYmVsKG5hbWUpO1xuXG4gICAgbGV0IGxhYmVsZGF0YSA9IGMubGFiZWxzLmxhYmVsbWFwW25hbWVdO1xuICAgIGxhYmVsZGF0YS5wY21hcmtlciA9IGMucGNTdGFjay5tYXJrZXIoKTtcblxuICAgIGMucHVzaFBDKGxhYmVsZGF0YS5sYWJlbCk7XG5cbiAgICBpcC50aGVuKG5vZGUuYm9keSk7XG4gICAgaXAudGhlbihuZXcgTGFiZWxlZFN0YXRlbWVudEVuZChuYW1lLCBsYWJlbGRhdGEubGFiZWwsIHBjbWFya2VyLCB2c21hcmtlcikpO1xufVxuXG4vLyBsYWJlbGVkU3RhdGVtZW50RW5kXG5cbmNsYXNzIExhYmVsZWRTdGF0ZW1lbnRFbmQgZXh0ZW5kcyBUYXNrIHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgb3V0ZXJsYWJlbDogTGFiZWw7XG4gICAgcGNtYXJrZXI6IFN0YWNrTWFya2VyO1xuICAgIHZzbWFya2VyOiBTdGFja01hcmtlcjtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBuYW1lOiBzdHJpbmcsXG4gICAgICAgIG91dGVybGFiZWw6IExhYmVsLFxuICAgICAgICBwY21hcmtlcjogU3RhY2tNYXJrZXIsXG4gICAgICAgIHZzbWFya2VyOiBTdGFja01hcmtlcixcbiAgICApIHtcbiAgICAgICAgc3VwZXIoVGFzay5ydW5mb3JfY29udGludWVfYnJlYWspO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLm91dGVybGFiZWwgPSBvdXRlcmxhYmVsO1xuICAgICAgICB0aGlzLnBjbWFya2VyID0gcGNtYXJrZXI7XG4gICAgICAgIHRoaXMudnNtYXJrZXIgPSB2c21hcmtlcjtcbiAgICB9XG5cblxuICAgIEV4ZWN1dGUod2w6IFdvcmtMaXN0LCB2czogVmFsdWVTdGFjayk6IHZvaWQge1xuICAgICAgICBsZXQgYyA9IG1vbml0b3IuY29udGV4dDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGMucmVzdWx0O1xuXG4gICAgICAgIC8vIHJlc2V0IHRoZSBvdXRlciBsYWJlbCAtIG5vIG5lZWQgdG8gcmVzZXQgcGNtYXJrZXIgc2luY2VcbiAgICAgICAgLy8gc3RhdGVtZW50IGxhYmVscyB3aXRoIHRoZSBzYW1lIG5hbWUgY2Fubm90IGJlIG5lc3RlZFxuICAgICAgICBjLmxhYmVscy5sYWJlbG1hcFt0aGlzLm5hbWVdLmxhYmVsID0gdGhpcy5vdXRlcmxhYmVsO1xuXG4gICAgICAgIGMucGNTdGFjay5yZXNldCh0aGlzLnBjbWFya2VyKTtcbiAgICAgICAgYy52YWx1ZVN0YWNrLnJlc2V0KHRoaXMudnNtYXJrZXIpO1xuXG4gICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gJ2JyZWFrJyAmJiByZXN1bHQudGFyZ2V0ID09PSB0aGlzLm5hbWUpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGMucmVzdWx0O1xuICAgICAgICAgICAgcmVzdWx0LnR5cGUgPSAnbm9ybWFsJztcbiAgICAgICAgICAgIHJlc3VsdC50YXJnZXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzZXR1cFN0YXRlbWVudExhYmVsKG5hbWU6IHN0cmluZyk6IExhYmVsIHtcbiAgICBsZXQgYyA9IG1vbml0b3IuY29udGV4dDtcbiAgICBsZXQgbG1hcCA9IGMubGFiZWxzLmxhYmVsbWFwO1xuICAgIGlmICghbG1hcFtuYW1lXSkge1xuICAgICAgICBsbWFwW25hbWVdID0geyBsYWJlbDogYm90LCBwY21hcmtlcjogdW5kZWZpbmVkIH07XG4gICAgfVxuXG4gICAgbGV0IGxhYmVsZGF0YSA9IGxtYXBbbmFtZV07XG4gICAgbGV0IG91dGVybGFiZWwgPSBsYWJlbGRhdGEubGFiZWw7XG5cbiAgICAvLyByYWlzZSB0byBlZmZlY3RpdmUgcGNcbiAgICBsYWJlbGRhdGEubGFiZWwgPSBsdWIobGFiZWxkYXRhLmxhYmVsLCBjLmVmZmVjdGl2ZVBDKTtcblxuICAgIHJldHVybiBvdXRlcmxhYmVsO1xufVxuIiwiaW1wb3J0IHsgTW9uaXRvckJhc2UgfSBmcm9tIFwiLi4vLi4vTW9uaXRvckJhc2VcIjtcbmltcG9ydCB7IFdvcmtMaXN0LCBWYWx1ZVN0YWNrIH0gZnJvbSBcIi4uLy4uL0NvbnRleHRcIjtcbmltcG9ydCB7IFRhc2sgfSBmcm9tIFwiLi4vVGFza1wiO1xuaW1wb3J0IHsgR2V0VmFsdWUgfSBmcm9tIFwiLi4vLi4vR2V0VmFsdWVcIjtcbmltcG9ydCB7IFZhbHVlIH0gZnJvbSBcIi4uLy4uL1ZhbHVlXCI7XG5pbXBvcnQgeyBsZSwgbHViLCBib3QgfSBmcm9tIFwiLi4vLi4vTGFiZWxcIjtcblxuaW1wb3J0ICogYXMgZXN0cmVlIGZyb20gJ2VzdHJlZSc7XG5pbXBvcnQgeyBwcmV0dHkgfSBmcm9tIFwiLi4vLi4vUFBcIjtcblxuZGVjbGFyZSB2YXIgbW9uaXRvcjogTW9uaXRvckJhc2U7XG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gXG5cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5TdGF0ZW1lbnQoXG4gICAgdGhpczogdm9pZCxcbiAgICBub2RlOiBlc3RyZWUuUmV0dXJuU3RhdGVtZW50LFxuICAgIHdsOiBXb3JrTGlzdCxcbiAgICB2czogVmFsdWVTdGFja1xuKTogdm9pZCB7XG4gICAgbGV0IGMgPSBtb25pdG9yLmNvbnRleHQ7XG4gICAgbGV0IGlwID0gd2wudG9wKCk7XG5cbiAgICBtb25pdG9yLmFzc2VydChsZShjLmVmZmVjdGl2ZVBDLCBjLmxhYmVscy5yZXQpLFxuICAgICAgICAnd3JpdGUgY29udGV4dCAnICsgYy5lZmZlY3RpdmVQQyArICcgbm90IGJlbG93ICcgK1xuICAgICAgICAncmV0dXJuIGNvbnRleHQgJyArIGMubGFiZWxzLnJldFxuICAgICk7XG5cbiAgICAvLyBUaGlzIGlzIGZvciB0aGUgbmV3IG1vZGUgb2Ygb3BlcmF0aW9uLCBmb3Igb2JzZXJ2YWJsZSBmbG93c1xuICAgIGMubGFiZWxzLnJldCA9IGx1YihjLmxhYmVscy5yZXQsIGMuZWZmZWN0aXZlUEMpO1xuXG4gICAgaWYgKG5vZGUuYXJndW1lbnQpIHtcbiAgICAgICAgaXAudGhlbihub2RlLmFyZ3VtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjLnZhbHVlU3RhY2sucHVzaChuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpKTtcbiAgICB9XG4gICAgaXAudGhlbihSZXR1cm5TdGF0ZW1lbnRFbmQuSW5zdGFuY2UpO1xuXG59XG5cbi8vIHJldHVyblN0YXRlbWVudEVuZFxuXG5jbGFzcyBSZXR1cm5TdGF0ZW1lbnRFbmQgZXh0ZW5kcyBUYXNrIHtcblxuICAgIHN0YXRpYyBJbnN0YW5jZSA9IG5ldyBSZXR1cm5TdGF0ZW1lbnRFbmQoKTtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cblxuICAgIEV4ZWN1dGUod2w6IFdvcmtMaXN0LCB2czogVmFsdWVTdGFjayk6IHZvaWQge1xuICAgICAgICBsZXQgcmVzdWx0ID0gbW9uaXRvci5jb250ZXh0LnJlc3VsdDtcblxuICAgICAgICByZXN1bHQudHlwZSA9ICdyZXR1cm4nO1xuICAgICAgICAvL0B0cy1pZ25vcmUgU1RBQ0tcbiAgICAgICAgcmVzdWx0LnZhbHVlID0gR2V0VmFsdWUodnMucG9wKCkpO1xuICAgICAgICByZXN1bHQudGFyZ2V0ID0gbnVsbDtcbiAgICB9XG59IiwiaW1wb3J0IHsgTW9uaXRvckJhc2UgfSBmcm9tIFwiLi4vLi4vTW9uaXRvckJhc2VcIjtcbmltcG9ydCB7IFdvcmtMaXN0LCBWYWx1ZVN0YWNrIH0gZnJvbSBcIi4uLy4uL0NvbnRleHRcIjtcbmltcG9ydCB7IFRhc2sgfSBmcm9tIFwiLi4vVGFza1wiO1xuaW1wb3J0IHsgbHViLCBMYWJlbCB9IGZyb20gXCIuLi8uLi9MYWJlbFwiO1xuaW1wb3J0IHsgYmluYXJ5U3RyaWN0RXFzIH0gZnJvbSBcIi4uL0JpbmFyeU9wZXJhdG9yc1wiO1xuaW1wb3J0IHsgU3RhY2tNYXJrZXIsIFN0YWNrIH0gZnJvbSBcIi4uLy4uL1N0YWNrXCI7XG5pbXBvcnQgeyBHZXRWYWx1ZSB9IGZyb20gXCIuLi8uLi9HZXRWYWx1ZVwiO1xuXG5pbXBvcnQgKiBhcyBlc3RyZWUgZnJvbSAnZXN0cmVlJztcblxuZGVjbGFyZSB2YXIgbW9uaXRvcjogTW9uaXRvckJhc2U7XG5cbmZ1bmN0aW9uIF9HZXRWYWx1ZSgpOiB2b2lkIHtcbiAgICBsZXQgdnMgPSBtb25pdG9yLmNvbnRleHQudmFsdWVTdGFjaztcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgbGV0IHZhbDogVmFsdWU8VmFsdWVUeXBlcz4gPSB2cy5wb3AoKTtcblxuICAgIHZzLnB1c2goR2V0VmFsdWUodmFsKSk7XG59XG5cbmxldCBlbXB0eUxhYmVsID0gJ2RlZmF1bHQnOyAvLyBkZWZhdWx0IGlzIGEgcmVzZXJ2ZWQgd29yZCBzbyBubyBhY3R1YWwgbGFiZWwgY2FuIGJlIG5hbWVkIGRlZmF1bHQgXG5sZXQgTXlTZXQgPSBTZXQ7XG5cbi8vIDEyLjExIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudHlwZSBTd2l0Y2hTdGF0ZSA9IHsgZGVmYXVsdENhc2VJbmRleDogbnVtYmVyIHwgbnVsbCwgbmV4dENhc2U6IG51bWJlciB9O1xuXG5pbnRlcmZhY2UgTGFiZWxlZFN3aXRjaFN0YXRlbWVudCBleHRlbmRzIGVzdHJlZS5Td2l0Y2hTdGF0ZW1lbnQge1xuICAgIGxhYmVsc2V0PyA6IFNldDxzdHJpbmc+O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3dpdGNoU3RhdGVtZW50KFxuICAgIHRoaXM6IHZvaWQsXG4gICAgbm9kZTogTGFiZWxlZFN3aXRjaFN0YXRlbWVudCxcbiAgICB3bDogV29ya0xpc3QsXG4gICAgdnM6IFZhbHVlU3RhY2tcbik6IHZvaWQge1xuICBcbiAgICBsZXQgYyA9IG1vbml0b3IuY29udGV4dDtcbiAgICBsZXQgbG1hcCA9IG1vbml0b3IuY29udGV4dC5sYWJlbHMubGFiZWxtYXA7XG5cbiAgICBpZiAoIW5vZGUubGFiZWxzZXQpIHtcbiAgICAgICAgbm9kZS5sYWJlbHNldCA9IG5ldyBNeVNldChbXSk7XG4gICAgfVxuICAgIG5vZGUubGFiZWxzZXQuYWRkKGVtcHR5TGFiZWwpO1xuXG4gICAgbGV0IG91dGVyRW1wdHlMYWJlbERhdGEgPSBsbWFwW2VtcHR5TGFiZWxdO1xuICAgIGxtYXBbZW1wdHlMYWJlbF0gPSB7XG4gICAgICAgIGxhYmVsOiBjLmVmZmVjdGl2ZVBDLFxuICAgICAgICBwY21hcmtlcjogYy5wY1N0YWNrLm1hcmtlcigpXG4gICAgfTtcblxuICAgIGxldCBjb250ZXh0TGFiZWwgPSBsbWFwW2VtcHR5TGFiZWxdLmxhYmVsO1xuICAgIGMucHVzaFBDKGNvbnRleHRMYWJlbCk7XG5cbiAgICBsZXQgc3dpdGNoU3RhdGU6IFN3aXRjaFN0YXRlID0ge1xuICAgICAgICBkZWZhdWx0Q2FzZUluZGV4OiBudWxsLFxuICAgICAgICBuZXh0Q2FzZTogMFxuICAgIH07XG5cbiAgICBpZiAobm9kZS5jYXNlcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2FzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChub2RlLmNhc2VzW2ldLnRlc3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2hTdGF0ZS5kZWZhdWx0Q2FzZUluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxldCBpcCA9IHdsLnRvcCgpO1xuXG4gICAgLy8gU3RvcmUgdGhlIGRpc2NyaW1pbmFudCB2YWx1ZSBvbiB0aGUgdmFsdWUgc3RhY2suXG4gICAgLy8gSXQgaXMgbGF0ZXIgcG9wcGVkIGJ5IHN3aXRjaFN0YXRlbWVudEVuZC5cbiAgICBpcC50aGVuKG5vZGUuZGlzY3JpbWluYW50KTtcbiAgICBpcC50aGVuKF9HZXRWYWx1ZSk7XG5cbiAgICAvLyBTZXQgdXAgc3RhdGVtZW50IGxhYmVsc1xuICAgIGlwLnRoZW4obmV3IFN3aXRjaFN0YXRlbWVudFVwZ3JhZGVMYWJlbHMobm9kZSkpO1xuXG4gICAgLy8gS2ljayBvZmYgdGhlIGZpcnN0IGNhc2VcbiAgICBpcC50aGVuKG5ldyBTd2l0Y2hTdGF0ZW1lbnRDYXNlKG5vZGUsIHN3aXRjaFN0YXRlKSk7XG5cbiAgICAvLyBDbGVhbiB1cCBhbmQgaGFuZGxlIGJyZWFrc1xuICAgIGlwLnRoZW4obmV3IFN3aXRjaFN0YXRlbWVudEVuZChub2RlLCBvdXRlckVtcHR5TGFiZWxEYXRhKSk7XG59XG5cbi8vIC0tLVxuXG5jbGFzcyBTd2l0Y2hTdGF0ZW1lbnRVcGdyYWRlTGFiZWxzIGV4dGVuZHMgVGFzayB7XG4gICAgbm9kZTogTGFiZWxlZFN3aXRjaFN0YXRlbWVudDtcblxuICAgIGNvbnN0cnVjdG9yKG5vZGU6IExhYmVsZWRTd2l0Y2hTdGF0ZW1lbnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB9XG5cbiAgICBFeGVjdXRlKHdsOiBXb3JrTGlzdCwgdnM6IFZhbHVlU3RhY2spOiB2b2lkIHtcbiAgICAgICAgbGV0IGMgPSBtb25pdG9yLmNvbnRleHQ7XG4gICAgICAgIC8vQHRzLWlnbm9yZSBTVEFDS1xuICAgICAgICBsZXQgZGlzY3JpbWluYW50TGFiZWwgPSB2cy5wZWVrKCkubGFiZWw7XG4gICAgICAgIGxldCBsYmxtYXAgPSBjLmxhYmVscy5sYWJlbG1hcDtcbiAgICBcbiAgICAgICAgYy5sYWJlbHMucGMgPSBsdWIoYy5sYWJlbHMucGMsIGRpc2NyaW1pbmFudExhYmVsKTtcbiAgICBcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiB0aGlzLm5vZGUubGFiZWxzZXQpIHtcbiAgICAgICAgICAgIGxibG1hcFtuYW1lXS5sYWJlbCA9IGx1YihsYmxtYXBbbmFtZV0ubGFiZWwsIGRpc2NyaW1pbmFudExhYmVsKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gLS0tXG5cbmNsYXNzIFN3aXRjaFN0YXRlbWVudENhc2UgZXh0ZW5kcyBUYXNrIHtcblxuICAgIG5vZGU6IExhYmVsZWRTd2l0Y2hTdGF0ZW1lbnQ7XG4gICAgc3dpdGNoU3RhdGU6IFN3aXRjaFN0YXRlO1xuXG4gICAgY29uc3RydWN0b3Iobm9kZTogTGFiZWxlZFN3aXRjaFN0YXRlbWVudCwgc3dpdGNoU3RhdGU6IFN3aXRjaFN0YXRlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMuc3dpdGNoU3RhdGUgPSBzd2l0Y2hTdGF0ZTtcbiAgICB9XG5cbiAgICBFeGVjdXRlKHdsOiBXb3JrTGlzdCwgdnM6IFZhbHVlU3RhY2spOiB2b2lkIHtcblxuICAgICAgICBsZXQgaXAgPSB3bC50b3AoKTtcbiAgICAgICAgbGV0IGlkeCA9IHRoaXMuc3dpdGNoU3RhdGUubmV4dENhc2U7XG5cbiAgICAgICAgaWYgKHRoaXMubm9kZS5jYXNlcyA9PT0gdW5kZWZpbmVkIHx8IGlkeCA+PSB0aGlzLm5vZGUuY2FzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBObyBtb3JlIGNhc2VzIHRvIHRyeSwgc2NoZWR1bGUgdGhlIGRlZmF1bHQgXG4gICAgICAgICAgICAvLyBjYXNlIGlmIHRoZXJlIGlzIG9uZVxuICAgICAgICAgICAgaWYgKHRoaXMuc3dpdGNoU3RhdGUuZGVmYXVsdENhc2VJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnN3aXRjaFN0YXRlLmRlZmF1bHRDYXNlSW5kZXg7IGkgPCB0aGlzLm5vZGUuY2FzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLm5vZGUuY2FzZXNbaV0uY29uc2VxdWVudC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXAudGhlbih0aGlzLm5vZGUuY2FzZXNbaV0uY29uc2VxdWVudFtqXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaWR4ID09PSB0aGlzLnN3aXRjaFN0YXRlLmRlZmF1bHRDYXNlSW5kZXgpIHtcbiAgICAgICAgICAgIC8vIFNraXAgdGhlIGRlZmF1bHQgY2FzZSBkdXJpbmcgbWF0Y2hpbmdcbiAgICAgICAgICAgIHRoaXMuc3dpdGNoU3RhdGUubmV4dENhc2UgKz0gMTtcbiAgICAgICAgICAgIGlwLnRoZW4obmV3IFN3aXRjaFN0YXRlbWVudENhc2UodGhpcy5ub2RlLCB0aGlzLnN3aXRjaFN0YXRlKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2cy5kdXAoKTsgLy8gRHVwbGljYXRlIHRoZSBkaXNjcmltaW5hbnQgdmFsdWVcblxuICAgICAgICAvLyBQdXNoIHRoZSB0ZXN0IHZhbHVlXG4gICAgICAgIGlwLnRoZW4odGhpcy5ub2RlLmNhc2VzW2lkeF0udGVzdCk7XG4gICAgICAgIGlwLnRoZW4oX0dldFZhbHVlKTtcblxuICAgICAgICAvLyBUZXN0IGZvciBlcXVhbGl0eSBhbmQgZGVjaWRlIHdoYXQgdG8gZG8gbmV4dFxuICAgICAgICBpcC50aGVuKG5ldyBTd2l0Y2hTdGF0ZW1lbnRUZXN0KHRoaXMubm9kZSwgdGhpcy5zd2l0Y2hTdGF0ZSkpO1xuICAgIH1cbn1cblxuLy8gLS0tXG5cbmNsYXNzIFN3aXRjaFN0YXRlbWVudFRlc3QgZXh0ZW5kcyBUYXNrIHtcbiAgICBub2RlOiBMYWJlbGVkU3dpdGNoU3RhdGVtZW50O1xuICAgIHN3aXRjaFN0YXRlOiBTd2l0Y2hTdGF0ZTtcblxuICAgIGNvbnN0cnVjdG9yKG5vZGU6IExhYmVsZWRTd2l0Y2hTdGF0ZW1lbnQsIHN3aXRjaFN0YXRlOiBTd2l0Y2hTdGF0ZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLnN3aXRjaFN0YXRlID0gc3dpdGNoU3RhdGU7XG4gICAgfVxuXG4gICAgRXhlY3V0ZSh3bDogV29ya0xpc3QsIHZzOiBWYWx1ZVN0YWNrKTogdm9pZCB7XG5cbiAgICAgICAgbGV0IGlwID0gd2wudG9wKCk7XG5cbiAgICAgICAgYmluYXJ5U3RyaWN0RXFzKCc9PT0nLCB3bCwgdnMpO1xuXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgbGV0IGJyZXN1bHQ6IFZhbHVlPFZhbHVlVHlwZXM+ID0gdnMucG9wKCk7XG5cbiAgICAgICAgbW9uaXRvci5jb250ZXh0LmxhYmVscy5wYyA9IGx1Yihtb25pdG9yLmNvbnRleHQubGFiZWxzLnBjLCBicmVzdWx0LmxhYmVsKTtcblxuICAgICAgICBpZiAoYnJlc3VsdC52YWx1ZSkge1xuICAgICAgICAgICAgLy8gRm91bmQgYSBtYXRjaCwgc2NoZWR1bGUgYWxsIHN0YXRlbWVudHMgZnJvbSBoZXJlIGRvd25cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnN3aXRjaFN0YXRlLm5leHRDYXNlOyBpIDwgdGhpcy5ub2RlLmNhc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLm5vZGUuY2FzZXNbaV0uY29uc2VxdWVudC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpcC50aGVuKHRoaXMubm9kZS5jYXNlc1tpXS5jb25zZXF1ZW50W2pdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN3aXRjaFN0YXRlLm5leHRDYXNlICs9IDE7XG4gICAgICAgICAgICBpcC50aGVuKG5ldyBTd2l0Y2hTdGF0ZW1lbnRDYXNlKHRoaXMubm9kZSwgdGhpcy5zd2l0Y2hTdGF0ZSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyAtLS1cblxuY2xhc3MgU3dpdGNoU3RhdGVtZW50RW5kIGV4dGVuZHMgVGFzayB7XG5cbiAgICBub2RlOiBMYWJlbGVkU3dpdGNoU3RhdGVtZW50O1xuICAgIG91dGVyRW1wdHlMYWJlbERhdGEgOiB7IGxhYmVsIDogTGFiZWwsIHBjbWFya2VyIDogU3RhY2tNYXJrZXIgfTtcblxuICAgIGNvbnN0cnVjdG9yKG5vZGU6IExhYmVsZWRTd2l0Y2hTdGF0ZW1lbnQsIG91dGVyRW1wdHlMYWJlbERhdGEgOiB7IGxhYmVsIDogTGFiZWwsIHBjbWFya2VyIDogU3RhY2tNYXJrZXIgfSkge1xuICAgICAgICBzdXBlcihUYXNrLnJ1bmZvcl9icmVhayk7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMub3V0ZXJFbXB0eUxhYmVsRGF0YSA9IG91dGVyRW1wdHlMYWJlbERhdGE7XG4gICAgfVxuXG4gICAgRXhlY3V0ZSh3bDogV29ya0xpc3QsIHZzOiBWYWx1ZVN0YWNrKTogdm9pZCB7XG4gICAgICAgIGxldCBjID0gbW9uaXRvci5jb250ZXh0O1xuXG4gICAgICAgIHZzLnBvcCgpOyAvLyBwb3AgdGhlIGRpc2NyaW1pbmFudCB2YWx1ZVxuICAgICAgICBjLnBvcFBDKCk7IC8vIHBvcCB0aGUgbGFiZWxDb250ZXh0XG5cbiAgICAgICAgaWYgKGMucmVzdWx0LnR5cGUgPT09ICdicmVhaycgJiYgdGhpcy5ub2RlLmxhYmVsc2V0IS5oYXMoYy5yZXN1bHQudGFyZ2V0KSkge1xuICAgICAgICAgICAgYy5yZXN1bHQudHlwZSA9ICdub3JtYWwnO1xuICAgICAgICAgICAgYy5yZXN1bHQudGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgIGMubGFiZWxzLmxhYmVsbWFwWydlbXB0eSddID0gdGhpcy5vdXRlckVtcHR5TGFiZWxEYXRhO1xuICAgICAgICB9XG4gICAgfVxufSIsImltcG9ydCB7IE1vbml0b3JCYXNlIH0gZnJvbSBcIi4uLy4uL01vbml0b3JCYXNlXCI7XG5pbXBvcnQgeyBXb3JrTGlzdCwgVmFsdWVTdGFjayB9IGZyb20gXCIuLi8uLi9Db250ZXh0XCI7XG5pbXBvcnQgeyBUYXNrIH0gZnJvbSBcIi4uL1Rhc2tcIjtcbmltcG9ydCB7IEdldFZhbHVlIH0gZnJvbSBcIi4uLy4uL0dldFZhbHVlXCI7XG5pbXBvcnQgeyBsZSwgbHViIH0gZnJvbSBcIi4uLy4uL0xhYmVsXCI7XG5pbXBvcnQgeyBSZWZlcmVuY2UgfSBmcm9tIFwiLi4vLi4vUmVmZXJlbmNlXCI7XG5cbmltcG9ydCAqIGFzIGVzdHJlZSBmcm9tICdlc3RyZWUnO1xuXG5kZWNsYXJlIHZhciBtb25pdG9yOiBNb25pdG9yQmFzZTtcblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFxuXG5leHBvcnQgZnVuY3Rpb24gdGhyb3dTdGF0ZW1lbnQoXG4gICAgdGhpczogdm9pZCxcbiAgICBub2RlOiBlc3RyZWUuVGhyb3dTdGF0ZW1lbnQsXG4gICAgd2w6IFdvcmtMaXN0LFxuICAgIHZzOiBWYWx1ZVN0YWNrXG4pOiB2b2lkIHtcbiAgICBsZXQgaXAgPSB3bC50b3AoKTtcblxuICAgIGlwLnRoZW4obm9kZS5hcmd1bWVudCk7XG4gICAgaXAudGhlbihUaHJvd1N0YXRlbWVudEVuZC5JbnN0YW5jZSk7XG59XG5cbi8vIC0tLVxuXG5jbGFzcyBUaHJvd1N0YXRlbWVudEVuZCBleHRlbmRzIFRhc2sge1xuXG4gICAgc3RhdGljIEluc3RhbmNlID0gbmV3IFRocm93U3RhdGVtZW50RW5kKCk7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG5cbiAgICBFeGVjdXRlKHdsOiBXb3JrTGlzdCwgdnM6IFZhbHVlU3RhY2spOiB2b2lkIHtcbiAgICAgICAgbGV0IGMgPSBtb25pdG9yLmNvbnRleHQ7XG4gICAgICAgIGxldCByZXN1bHQgPSBjLnJlc3VsdDtcbiAgICAgICAgLy9AdHMtaWdub3JlXG4gICAgICAgIGxldCBleHByUmVmIDogUmVmZXJlbmNlPSB2cy5wb3AoKTtcblxuICAgICAgICAvLyBWZXJmaXkgdGhhdCB0aGUgZXhjZXB0aW9uIGlzIGFsbG93ZWQgXG4gICAgICAgIG1vbml0b3IuYXNzZXJ0KGxlKGMuZWZmZWN0aXZlUEMsIGMubGFiZWxzLmV4YyksXG4gICAgICAgICAgICBcImV4Y2VwdGlvbiBpbiBcIiArIGMuZWZmZWN0aXZlUEMgKyBcIiBub3QgYWxsb3dlZCB3aXRoIGV4Y2VwdGlvbiBsYWJlbCBcIiArIGMubGFiZWxzLmV4Yyk7XG5cbiAgICAgICAgLy8gRm9yIG9ic2VydmFibGUgZmxvd3NcbiAgICAgICAgYy5sYWJlbHMuZXhjID0gbHViKGMubGFiZWxzLmV4YywgYy5lZmZlY3RpdmVQQyk7XG5cbiAgICAgICAgcmVzdWx0LnR5cGUgPSAndGhyb3cnO1xuICAgICAgICByZXN1bHQudmFsdWUgPSBHZXRWYWx1ZShleHByUmVmKTtcbiAgICAgICAgbW9uaXRvci5vZmZlbmRpbmdUcmFjZSA9IG1vbml0b3Iuc3RhY2tUcmFjZSgpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBNb25pdG9yQmFzZSB9IGZyb20gXCIuLi8uLi9Nb25pdG9yQmFzZVwiO1xuaW1wb3J0IHsgV29ya0xpc3QsIFZhbHVlU3RhY2sgfSBmcm9tIFwiLi4vLi4vQ29udGV4dFwiO1xuaW1wb3J0IHsgVGFzayB9IGZyb20gXCIuLi9UYXNrXCI7XG5pbXBvcnQgeyBMYWJlbCwgbHViLCBib3QgfSBmcm9tIFwiLi4vLi4vTGFiZWxcIjtcblxuaW1wb3J0IHsgU3RhY2tNYXJrZXIgfSBmcm9tIFwiLi4vLi4vU3RhY2tcIjtcblxuaW1wb3J0ICogYXMgZXN0cmVlIGZyb20gJ2VzdHJlZSc7XG5pbXBvcnQgeyBWYWx1ZSB9IGZyb20gXCIuLi8uLi9WYWx1ZVwiO1xuaW1wb3J0IHsgTmV3RGVjbGFyYXRpdmVFbnZpcm9ubWVudCB9IGZyb20gXCIuLi8uLi9EZWNsYXJhdGl2ZUVudmlyb25tZW50UmVjb3JkXCI7XG5pbXBvcnQgeyBSZXN1bHQgfSBmcm9tIFwiLi4vLi4vUmVzdWx0XCI7XG5pbXBvcnQgeyBMZXhpY2FsRW52aXJvbm1lbnQgfSBmcm9tIFwiLi4vLi4vTGV4aWNhbEVudmlyb25tZW50XCI7XG5cbmRlY2xhcmUgdmFyIG1vbml0b3I6IE1vbml0b3JCYXNlO1xuXG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBcblxuZXhwb3J0IGZ1bmN0aW9uIHRyeVN0YXRlbWVudChcbiAgICBub2RlOiBlc3RyZWUuVHJ5U3RhdGVtZW50LFxuICAgIHdsOiBXb3JrTGlzdCxcbiAgICB2czogVmFsdWVTdGFja1xuKTogdm9pZCB7XG4gICAgbGV0IGlwID0gd2wudG9wKCk7XG4gICAgbGV0IGMgPSBtb25pdG9yLmNvbnRleHQ7XG5cbiAgICBpcC50aGVuKG5vZGUuYmxvY2spO1xuICAgIC8vIEV4cHJlc3Npb24gZXZhbHVhdGlvbiBtaWdodCBjYXVzZSBleGNlcHRpb25zOyBpZiBzbyB0aGUgc3RhdGUgb2ZcbiAgICAvLyB0aGUgY29udGV4dCBtaWdodCBuZWVkIHNvbWUgY2xlYW5pbmcgdXAuXG4gICAgLy8gVGhlIHJlc3VsdCBzdGFjayBhbmQgdGhlIHdvcmtsaXN0IGFyZSBub3QgYWZmZWN0ZWQgYnkgZXhwcmVzc2lvbiBzbyB0aGVpclxuICAgIC8vIHN0YXRlcyBhcmUgZmluZS5cbiAgICAvLyBUaGUgcmV0IGxhYmVsIGNhbm5vdCBiZSBhZmZlY3RlZCBieSBleGNlcHRpb25zLlxuXG4gICAgLy8gVGhlIHN0YWNrcyBuZWVkcyB0byBiZSByZXNldC4gXG4gICAgbGV0IHBjbWFya2VyID0gYy5wY1N0YWNrLm1hcmtlcigpO1xuICAgIGxldCB2c21hcmtlciA9IGMudmFsdWVTdGFjay5tYXJrZXIoKTtcblxuICAgIGxldCBleGMgPSBjLmxhYmVscy5leGM7XG5cbiAgICAvLyBlc3ByaW1hIHNlZW1zIHRvIGdlbmVyYXRlIGEgbGlzdCBvZiBoYW5kbGVycyAtLS0gc3RhbmRhcmQgb25seSBzdXBwb3J0cyBvbmVcbiAgICAvL0B0cy1pZ25vcmUgU1lOVEFYXG4gICAgaXAudGhlbihuZXcgVHJ5U3RhdGVtZW50Q2F0Y2gobm9kZS5oYW5kbGVyc1swXSwgcGNtYXJrZXIsIHZzbWFya2VyLCBleGMpKTtcblxuICAgIC8vIFRoZSBmaW5hbGl6ZXIgXG4gICAgbGV0IGxleGljYWxFbnYgPSBjLmxleGljYWxFbnY7XG4gICAgaXAudGhlbihuZXcgVHJ5U3RhdGVtZW50RmluYWxseShub2RlLmZpbmFsaXplciwgcGNtYXJrZXIsIHZzbWFya2VyLCBsZXhpY2FsRW52KSk7XG59XG5cbi8vIC0tLVxuXG5jbGFzcyBUcnlTdGF0ZW1lbnRDYXRjaCBleHRlbmRzIFRhc2sge1xuICAgIGhhbmRsZXI6IGVzdHJlZS5DYXRjaENsYXVzZTtcbiAgICBwY21hcmtlcjogU3RhY2tNYXJrZXI7XG4gICAgdnNtYXJrZXI6IFN0YWNrTWFya2VyO1xuICAgIGV4YzogTGFiZWw7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgaGFuZGxlcjogZXN0cmVlLkNhdGNoQ2xhdXNlLFxuICAgICAgICBwY21hcmtlcjogU3RhY2tNYXJrZXIsXG4gICAgICAgIHZzbWFya2VyOiBTdGFja01hcmtlcixcbiAgICAgICAgZXhjOiBMYWJlbFxuICAgICkge1xuICAgICAgICBzdXBlcihUYXNrLnJ1bmZvcl90aHJvdyk7XG4gICAgICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XG4gICAgICAgIHRoaXMucGNtYXJrZXIgPSBwY21hcmtlcjtcbiAgICAgICAgdGhpcy52c21hcmtlciA9IHZzbWFya2VyO1xuICAgICAgICB0aGlzLmV4YyA9IGV4YztcbiAgICB9XG5cbiAgICBFeGVjdXRlKHdsOiBXb3JrTGlzdCwgdnM6IFZhbHVlU3RhY2spOiB2b2lkIHtcbiAgICAgICAgbGV0IGMgPSBtb25pdG9yLmNvbnRleHQ7XG4gICAgICAgIGxldCByZXN1bHQgPSBjLnJlc3VsdDtcblxuICAgICAgICAvLyBXZSBhcmUgaW4gY2hhcmdlIG9mIHJlc2V0dGluZyB0aGUgZXhjIGxhYmVsLCB0aGUgZmluYWxseSBkb2VzIHRoZSByZXN0IFxuICAgICAgICAvLyBvZiB0aGUgY2xlYW5pbmcuXG5cbiAgICAgICAgLy8gVGhlIHBjIG9mIHRoZSBjYXRjaCBibG9jayBpcyBwYyArIGV4YyBvZiBib2R5XG4gICAgICAgIGxldCBoYW5kbGVyUEMgPSBsdWIoYy5sYWJlbHMucGMsIGMubGFiZWxzLmV4Yyk7XG5cbiAgICAgICAgLy8gVGhlIGV4YyBvZiB0aGUgY2F0Y2ggYmxvY2sgaXMgdGhlIGV4YyBvZiBfY2F0Y2gsIHRoYXQgcmVzZXRzIHRoZSBleGNcbiAgICAgICAgYy5sYWJlbHMuZXhjID0gdGhpcy5leGM7XG5cbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gaGFuZGxlciBvciBubyBleGNlcHRpb24gd2FzIHRocm93biwgdGhlcmUncyBub3RoaW5nIG1vcmUgdG8gZG9cbiAgICAgICAgaWYgKCF0aGlzLmhhbmRsZXIgfHwgcmVzdWx0LnR5cGUgIT09ICd0aHJvdycpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGMucGNTdGFjay5yZXNldCh0aGlzLnBjbWFya2VyKTtcbiAgICAgICAgYy52YWx1ZVN0YWNrLnJlc2V0KHRoaXMudnNtYXJrZXIpO1xuXG4gICAgICAgIGMucGNTdGFjay5wdXNoKGhhbmRsZXJQQyk7XG5cbiAgICAgICAgbGV0IGNhdGNoRW52ID0gTmV3RGVjbGFyYXRpdmVFbnZpcm9ubWVudChjLmxleGljYWxFbnYpO1xuXG4gICAgICAgIC8vIEVDTUEtMjYyIGFsbG93cyBvbmx5IGlkZW5maWZpZXJzLCBidXQgdGhlIHBhcnNlciBhbGxvd3MgcGF0dGVybnM7XG4gICAgICAgIGlmICh0aGlzLmhhbmRsZXIucGFyYW0udHlwZSAhPT0gJ0lkZW50aWZpZXInKSB7XG4gICAgICAgICAgICBtb25pdG9yLmZhdGFsKCdQYXR0ZXJuIGluIGNhdGNoIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vQHRzLWlnbm9yZSBTWU5UQVhcbiAgICAgICAgbGV0IGlkZW50aWZpZXIgPSBuZXcgVmFsdWUodGhpcy5oYW5kbGVyLnBhcmFtLm5hbWUsIGJvdCk7XG4gICAgICAgIGNhdGNoRW52LkNyZWF0ZU11dGFibGVCaW5kaW5nKGlkZW50aWZpZXIpO1xuICAgICAgICBjYXRjaEVudi5TZXRNdXRhYmxlQmluZGluZyhpZGVudGlmaWVyLCByZXN1bHQudmFsdWUpO1xuXG4gICAgICAgIGMubGV4aWNhbEVudiA9IG5ldyBWYWx1ZShjYXRjaEVudiwgYy5lZmZlY3RpdmVQQyk7XG5cbiAgICAgICAgcmVzdWx0LnR5cGUgPSAnbm9ybWFsJztcbiAgICAgICAgcmVzdWx0LnZhbHVlID0gbnVsbDtcblxuICAgICAgICB3bC5wdXNoKHRoaXMuaGFuZGxlci5ib2R5KTtcbiAgICB9XG59XG5cblxuLy8gLS0tXG5cbmNsYXNzIFRyeVN0YXRlbWVudEZpbmFsbHkgZXh0ZW5kcyBUYXNrIHtcbiAgICBib2R5OiBlc3RyZWUuQmxvY2tTdGF0ZW1lbnQgfCBudWxsIHwgdW5kZWZpbmVkO1xuICAgIHBjbWFya2VyOiBTdGFja01hcmtlcjtcbiAgICB2c21hcmtlcjogU3RhY2tNYXJrZXI7XG4gICAgbGV4aWNhbEVudjogVmFsdWU8TGV4aWNhbEVudmlyb25tZW50PjtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBib2R5OiBlc3RyZWUuQmxvY2tTdGF0ZW1lbnQgfCBudWxsIHwgdW5kZWZpbmVkLFxuICAgICAgICBwY21hcmtlcjogU3RhY2tNYXJrZXIsXG4gICAgICAgIHZzbWFya2VyOiBTdGFja01hcmtlcixcbiAgICAgICAgbGV4aWNhbEVudjogVmFsdWU8TGV4aWNhbEVudmlyb25tZW50PlxuICAgICkge1xuICAgICAgICBzdXBlcihUYXNrLnJ1bmZvcl9hbGwpO1xuICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICB0aGlzLnBjbWFya2VyID0gcGNtYXJrZXI7XG4gICAgICAgIHRoaXMudnNtYXJrZXIgPSB2c21hcmtlcjtcbiAgICAgICAgdGhpcy5sZXhpY2FsRW52ID0gbGV4aWNhbEVudjtcbiAgICB9XG5cbiAgICBFeGVjdXRlKHdsOiBXb3JrTGlzdCwgdnM6IFZhbHVlU3RhY2spOiB2b2lkIHtcbiAgICAgICAgbGV0IGMgPSBtb25pdG9yLmNvbnRleHQ7XG5cbiAgICAgICAgLy8gVGhlIHBjIG9mIHRoZSBmaW5hbGx5IGlzIHRoZSBwYyBvZiB0aGUgdHJ5LlxuICAgICAgICAvLyBUaGUgZXhjIG9mIHRoZSBmaW5hbGx5IGlzIHRoZSBleGMgb2YgdGhlIF9jYXRjaCwgd2hpY2ggaXMgZWl0aGVyXG4gICAgICAgIC8vIHRoZSBleGMgb2YgdGhlZWUgdHJ5LCB1bmxlc3MgaXQgd2FzIHJhaXNlZCBieSBhIGhhbmRsZXIsIGluIHdoaWNoXG4gICAgICAgIC8vIGNhc2UgaXQgZXNjYXBlcyB0aGUgdHJ5LCBhbmQgc2hvdWxkIGFmZmVjdCB0aGUgZmluYWxseSB0b28uXG5cbiAgICAgICAgLy8gV2UgYXJlIGluIGNoYXJnZSBvZiByZXNldHRpbmcgdGhlIHBjU3RhY2ssIGFuZCB0aGUgbGV4aWNhbEVudiBcbiAgICAgICAgYy5wY1N0YWNrLnJlc2V0KHRoaXMucGNtYXJrZXIpO1xuICAgICAgICBjLnZhbHVlU3RhY2sucmVzZXQodGhpcy52c21hcmtlcik7XG4gICAgICAgIGMubGV4aWNhbEVudiA9IHRoaXMubGV4aWNhbEVudjtcblxuXG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIGZpbmFsbHkgYmxvY2ssIHdlJ3JlIGRvbmVcbiAgICAgICAgaWYgKCF0aGlzLmJvZHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFsbG9jYXRlIGEgbmV3IHJlc3VsdCAtLS0gX2ZpbmFsbHkgZW52IGNob3NlcyBiZXR3ZWVuIHRoZSByZXN1bHRcbiAgICAgICAgLy8gb2YgdGhlIGJvZHkvaGFuZGxlciwgYW5kIHRoZSByZXN1bHQgb2YgdGhlIGZpbmFsbHlcbiAgICAgICAgbGV0IHJlc3VsdCA9IGMucmVzdWx0O1xuICAgICAgICBjLnJlc3VsdCA9IG5ldyBSZXN1bHQoKTtcblxuICAgICAgICBsZXQgaXAgPSBjLndvcmtMaXN0LnRvcCgpO1xuXG4gICAgICAgIGlwLnRoZW4odGhpcy5ib2R5KTtcbiAgICAgICAgaXAudGhlbihuZXcgVHJ5U3RhdGVtZW50RmluYWxseUVuZChyZXN1bHQpKTtcbiAgICB9XG59XG5cbi8vIC0tLVxuXG5jbGFzcyBUcnlTdGF0ZW1lbnRGaW5hbGx5RW5kIGV4dGVuZHMgVGFzayB7XG4gICAgcmVzdWx0OiBSZXN1bHQ7XG5cbiAgICBjb25zdHJ1Y3RvcihyZXN1bHQ6IFJlc3VsdCkge1xuICAgICAgICBzdXBlcihUYXNrLnJ1bmZvcl9hbGwpOyAvLyBUT0RPOyByZWFsbHkgYWxsP1xuICAgICAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICB9XG5cbiAgICBFeGVjdXRlKHdsOiBXb3JrTGlzdCwgdnM6IFZhbHVlU3RhY2spOiB2b2lkIHtcbiAgICAgICAgbGV0IGMgPSBtb25pdG9yLmNvbnRleHQ7XG5cbiAgICAgICAgaWYgKGMucmVzdWx0LnR5cGUgPT09ICdub3JtYWwnKSB7XG4gICAgICAgICAgICBjLnJlc3VsdCA9IHRoaXMucmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cbiIsImltcG9ydCB7IE1vbml0b3JCYXNlIH0gZnJvbSBcIi4uLy4uL01vbml0b3JCYXNlXCI7XG5pbXBvcnQgeyBXb3JrTGlzdCwgVmFsdWVTdGFjayB9IGZyb20gXCIuLi8uLi9Db250ZXh0XCI7XG5pbXBvcnQgeyBHZXRWYWx1ZSB9IGZyb20gXCIuLi8uLi9HZXRWYWx1ZVwiO1xuaW1wb3J0IHsgUHV0VmFsdWUgfSBmcm9tIFwiLi4vLi4vUHV0VmFsdWVcIjtcbmltcG9ydCB7IEdldElkZW50aWZpZXJSZWZlcmVuY2UgfSBmcm9tIFwiLi4vLi4vR2V0SWRlbnRpZmllclJlZmVyZW5jZVwiO1xuaW1wb3J0IHsgUmVmZXJlbmNlIH0gZnJvbSBcIi4uLy4uL1JlZmVyZW5jZVwiO1xuXG5pbXBvcnQgKiBhcyBlc3RyZWUgZnJvbSAnZXN0cmVlJztcbmltcG9ydCB7IFRhc2sgfSBmcm9tIFwiLi4vVGFza1wiO1xuXG5kZWNsYXJlIHZhciBtb25pdG9yOiBNb25pdG9yQmFzZTtcblxuZXhwb3J0IGZ1bmN0aW9uIHZhcmlhYmxlRGVjbGFyYXRpb24oXG4gICAgdGhpczogdm9pZCxcbiAgICBub2RlOiBlc3RyZWUuVmFyaWFibGVEZWNsYXJhdGlvbixcbiAgICB3bDogV29ya0xpc3QsXG4gICAgdnM6IFZhbHVlU3RhY2tcbik6IHZvaWQge1xuICAgIGxldCBpcCA9IHdsLnRvcCgpO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG5vZGUuZGVjbGFyYXRpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGxldCB2ZCA9IG5vZGUuZGVjbGFyYXRpb25zW2ldO1xuICAgICAgICBpZiAodmQuaW5pdCkge1xuXG4gICAgICAgICAgICBpZiAodmQuaWQudHlwZSAhPT0gJ0lkZW50aWZpZXInKSB7XG4gICAgICAgICAgICAgICAgbW9uaXRvci5mYXRhbCh2ZC5pZC50eXBlICsgJyBub3Qgc3VwcG9ydGVkIGluIHZhcmlhYmxlIGRlY2xhcmF0aW9ucycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL0B0cy1pZ25vcmUgU1lOVEFYXG4gICAgICAgICAgICBsZXQgbGhzID0gR2V0SWRlbnRpZmllclJlZmVyZW5jZShtb25pdG9yLmNvbnRleHQubGV4aWNhbEVudiwgdmQuaWQubmFtZSk7XG4gICAgICAgICAgICBpcC50aGVuKHZkLmluaXQpO1xuICAgICAgICAgICAgaXAudGhlbihuZXcgVmFyaWFibGVEZWNsYXJhdGlvblVwZGF0ZShsaHMpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gLS0tXG5cbmNsYXNzIFZhcmlhYmxlRGVjbGFyYXRpb25VcGRhdGUgZXh0ZW5kcyBUYXNrIHtcbiAgICBsaHM6IFJlZmVyZW5jZTtcblxuICAgIGNvbnN0cnVjdG9yKGxoczogUmVmZXJlbmNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubGhzID0gbGhzO1xuICAgIH1cblxuICAgIEV4ZWN1dGUod2w6IFdvcmtMaXN0LCB2czogVmFsdWVTdGFjayk6IHZvaWQge1xuICAgICAgICAvL0B0cy1pZ25vcmUgU1RBQ0tcbiAgICAgICAgbGV0IHJocyA9IEdldFZhbHVlKHZzLnBvcCgpKTtcbiAgICAgICAgUHV0VmFsdWUodGhpcy5saHMsIHJocyk7XG4gICAgfVxufSIsImltcG9ydCB7IE1vbml0b3JCYXNlIH0gZnJvbSBcIi4uLy4uL01vbml0b3JCYXNlXCI7XG5pbXBvcnQgeyBXb3JrTGlzdCwgVmFsdWVTdGFjayB9IGZyb20gXCIuLi8uLi9Db250ZXh0XCI7XG5pbXBvcnQgeyBUYXNrIH0gZnJvbSBcIi4uL1Rhc2tcIjtcbmltcG9ydCB7IExhYmVsLCBsdWIgfSBmcm9tIFwiLi4vLi4vTGFiZWxcIjtcbmltcG9ydCB7IEdldFZhbHVlIH0gZnJvbSBcIi4uLy4uL0dldFZhbHVlXCI7XG5pbXBvcnQgeyBUb0Jvb2xlYW4gfSBmcm9tIFwiLi4vLi4vQ29udmVyc2lvbi9Ub0Jvb2xlYW5cIjtcblxuaW1wb3J0ICogYXMgZXN0cmVlIGZyb20gJ2VzdHJlZSc7XG5pbXBvcnQgeyBTdGFja01hcmtlciB9IGZyb20gXCIuLi8uLi9TdGFja1wiO1xuXG5kZWNsYXJlIHZhciBtb25pdG9yOiBNb25pdG9yQmFzZTtcblxubGV0IGVtcHR5TGFiZWwgPSAnZGVmYXVsdCc7IC8vIGRlZmF1bHQgaXMgYSByZXNlcnZlZCB3b3JkIHNvIG5vIGFjdHVhbCBsYWJlbCBjYW4gYmUgbmFtZWQgZGVmYXVsdCBcblxuaW50ZXJmYWNlIExhYmVsZWRXaGlsZVN0YXRlbWVudCBleHRlbmRzIGVzdHJlZS5XaGlsZVN0YXRlbWVudCB7XG4gICAgbGFiZWxzZXQ/OiBTZXQ8c3RyaW5nPjtcbn1cblxuaW50ZXJmYWNlIExhYmVsZWREb1doaWxlU3RhdGVtZW50IGV4dGVuZHMgZXN0cmVlLkRvV2hpbGVTdGF0ZW1lbnQge1xuICAgIGxhYmVsc2V0PzogU2V0PHN0cmluZz47XG59XG5sZXQgTXlTZXQgPSBTZXQ7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZnVuY3Rpb24gd2hpbGVTdGF0ZW1lbnQoXG4gICAgbm9kZTogTGFiZWxlZFdoaWxlU3RhdGVtZW50LFxuICAgIHdsOiBXb3JrTGlzdCxcbiAgICB2czogVmFsdWVTdGFja1xuKTogdm9pZCB7XG4gICAgbGV0IGMgPSBtb25pdG9yLmNvbnRleHQ7XG4gICAgbGV0IGlwID0gd2wudG9wKCk7XG5cbiAgICBsZXQgbG1hcCA9IGMubGFiZWxzLmxhYmVsbWFwO1xuXG4gICAgaWYgKCFub2RlLmxhYmVsc2V0KSB7XG4gICAgICAgIG5vZGUubGFiZWxzZXQgPSBuZXcgTXlTZXQoW10pO1xuICAgIH1cbiAgICBub2RlLmxhYmVsc2V0LmFkZChlbXB0eUxhYmVsKTtcblxuICAgIGxldCBvdXRlckVtcHR5TGFiZWxEYXRhID0gbG1hcFtlbXB0eUxhYmVsXTtcbiAgICBsbWFwW2VtcHR5TGFiZWxdID0ge1xuICAgICAgICBsYWJlbDogYy5lZmZlY3RpdmVQQyxcbiAgICAgICAgcGNtYXJrZXI6IGMucGNTdGFjay5tYXJrZXIoKVxuICAgIH07XG5cbiAgICBsZXQgY29udGV4dExhYmVsID0gbG1hcFtlbXB0eUxhYmVsXS5sYWJlbDtcbiAgICBjLnB1c2hQQyhjb250ZXh0TGFiZWwpO1xuXG4gICAgaXAudGhlbihuZXcgV2hpbGVTdGF0ZW1lbnRTaGFyZWQobm9kZSwgb3V0ZXJFbXB0eUxhYmVsRGF0YSkpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIGRvV2hpbGVTdGF0ZW1lbnQoXG4gICAgbm9kZTogTGFiZWxlZERvV2hpbGVTdGF0ZW1lbnQsXG4gICAgd2w6IFdvcmtMaXN0LFxuICAgIHZzOiBWYWx1ZVN0YWNrXG4pOiB2b2lkIHtcbiAgICBsZXQgYyA9IG1vbml0b3IuY29udGV4dDtcbiAgICBsZXQgaXAgPSB3bC50b3AoKTtcblxuICAgIGxldCBsbWFwID0gYy5sYWJlbHMubGFiZWxtYXA7XG5cbiAgICBpZiAoIW5vZGUubGFiZWxzZXQpIHtcbiAgICAgICAgbm9kZS5sYWJlbHNldCA9IG5ldyBNeVNldChbXSk7XG4gICAgfVxuICAgIG5vZGUubGFiZWxzZXQuYWRkKGVtcHR5TGFiZWwpO1xuXG4gICAgbGV0IG91dGVyRW1wdHlMYWJlbERhdGEgPSBsbWFwW2VtcHR5TGFiZWxdO1xuICAgIGxtYXBbZW1wdHlMYWJlbF0gPSB7XG4gICAgICAgIGxhYmVsOiBjLmVmZmVjdGl2ZVBDLFxuICAgICAgICBwY21hcmtlcjogYy5wY1N0YWNrLm1hcmtlcigpXG4gICAgfTtcblxuICAgIC8vIHVzZWQgZm9yIGJvdGggc3RhdGVtZW50IGxhYmVsIHNlY3VyaXR5IGxhYmVscyBhbmQgY29udHJvbCBzZWN1cml0eSBsYWJlbFxuICAgIGxldCBjb250ZXh0TGFiZWwgPSBsbWFwW2VtcHR5TGFiZWxdLmxhYmVsO1xuICAgIGMucHVzaFBDKGNvbnRleHRMYWJlbCk7XG5cbiAgICBpcC50aGVuKG5vZGUuYm9keSk7XG4gICAgaXAudGhlbihuZXcgV2hpbGVTdGF0ZW1lbnRTaGFyZWQobm9kZSwgb3V0ZXJFbXB0eUxhYmVsRGF0YSkpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY2xhc3MgV2hpbGVTdGF0ZW1lbnRTaGFyZWQgZXh0ZW5kcyBUYXNrIHtcbiAgICBub2RlOiBMYWJlbGVkV2hpbGVTdGF0ZW1lbnQgfCBMYWJlbGVkRG9XaGlsZVN0YXRlbWVudDtcbiAgICBvdXRlckVtcHR5TGFiZWxEYXRhOiB7IGxhYmVsOiBMYWJlbCwgcGNtYXJrZXI6IFN0YWNrTWFya2VyIH07XG5cbiAgICBjaG9zZXIgOiBXaGlsZVN0YXRlbWVudFNoYXJlZENob29zZTtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBub2RlOiBMYWJlbGVkV2hpbGVTdGF0ZW1lbnQgfCBMYWJlbGVkRG9XaGlsZVN0YXRlbWVudCxcbiAgICAgICAgb3V0ZXJFbXB0eUxhYmVsRGF0YTogeyBsYWJlbDogTGFiZWwsIHBjbWFya2VyOiBTdGFja01hcmtlciB9XG4gICAgKSB7XG4gICAgICAgIHN1cGVyKFRhc2sucnVuZm9yX2NvbnRpbnVlX2JyZWFrKTtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5vdXRlckVtcHR5TGFiZWxEYXRhID0gb3V0ZXJFbXB0eUxhYmVsRGF0YTtcblxuICAgICAgICB0aGlzLmNob3NlciA9IG5ldyBXaGlsZVN0YXRlbWVudFNoYXJlZENob29zZSh0aGlzKTtcbiAgICB9XG5cbiAgICBFeGVjdXRlKHdsOiBXb3JrTGlzdCwgdnM6IFZhbHVlU3RhY2spOiB2b2lkIHtcblxuICAgICAgICBsZXQgaXAgPSB3bC50b3AoKTtcblxuICAgICAgICBsZXQgYyA9IG1vbml0b3IuY29udGV4dDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGMucmVzdWx0O1xuXG4gICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gJ2JyZWFrJyAmJiB0aGlzLm5vZGUubGFiZWxzZXQhLmhhcyhyZXN1bHQudGFyZ2V0KSkge1xuICAgICAgICAgICAgcmVzdWx0LnR5cGUgPSAnbm9ybWFsJztcbiAgICAgICAgICAgIHJlc3VsdC50YXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgYy5sYWJlbHMubGFiZWxtYXBbZW1wdHlMYWJlbF0gPSB0aGlzLm91dGVyRW1wdHlMYWJlbERhdGE7XG4gICAgICAgICAgICBjLnBvcFBDKCk7IC8vIGNvbnRleHRMYWJlbFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdC50eXBlICE9PSAnY29udGludWUnIHx8ICF0aGlzLm5vZGUubGFiZWxzZXQhLmhhcyhyZXN1bHQudGFyZ2V0KSkge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC50eXBlICE9PSAnbm9ybWFsJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnRpbnVlIGdldHMgdXMgaGVyZVxuICAgICAgICByZXN1bHQudHlwZSA9ICdub3JtYWwnO1xuICAgICAgICByZXN1bHQudGFyZ2V0ID0gbnVsbDtcblxuICAgICAgICBpcC50aGVuKHRoaXMubm9kZS50ZXN0KTtcbiAgICAgICAgaXAudGhlbih0aGlzLmNob3Nlcik7XG5cbiAgICB9XG59XG5cbi8vIC0tLVxuXG5jbGFzcyBXaGlsZVN0YXRlbWVudFNoYXJlZENob29zZSBleHRlbmRzIFRhc2sge1xuICAgIGNvbnRyb2xsZXIgOiBXaGlsZVN0YXRlbWVudFNoYXJlZDtcblxuICAgIGNvbnN0cnVjdG9yKGNvbnRyb2xsZXIgOiBXaGlsZVN0YXRlbWVudFNoYXJlZCkge1xuICAgICAgICBzdXBlcihUYXNrLnJ1bmZvcl9jb250aW51ZSk7XG4gICAgICAgIHRoaXMuY29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgfVxuXG4gICAgRXhlY3V0ZSh3bDogV29ya0xpc3QsIHZzOiBWYWx1ZVN0YWNrKTogdm9pZCB7XG5cbiAgICAgICAgbGV0IGMgPSBtb25pdG9yLmNvbnRleHQ7XG5cbiAgICAgICAgLy9AdHMtaWdub3JlIFNUQUNLXG4gICAgICAgIGxldCBjb25kID0gR2V0VmFsdWUodnMucG9wKCkpO1xuICAgICAgICBsZXQgY29uZGIgPSBUb0Jvb2xlYW4oY29uZCk7XG5cbiAgICAgICAgYy5sYWJlbHMucGMgPSBsdWIoYy5sYWJlbHMucGMsIGNvbmRiLmxhYmVsKTtcbiAgICAgICAgaWYgKGNvbmRiLnZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgaXAgPSB3bC50b3AoKTtcblxuICAgICAgICAgICAgaXAudGhlbih0aGlzLmNvbnRyb2xsZXIubm9kZS5ib2R5KTtcbiAgICAgICAgICAgIGlwLnRoZW4odGhpcy5jb250cm9sbGVyKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYy5sYWJlbHMubGFiZWxtYXBbZW1wdHlMYWJlbF0gPSB0aGlzLmNvbnRyb2xsZXIub3V0ZXJFbXB0eUxhYmVsRGF0YTtcbiAgICAgICAgICAgIGMucG9wUEMoKTsgLy8gY29udGV4dExhYmVsXG4gICAgICAgIH1cbiAgICB9XG59IiwiaW1wb3J0IHsgTW9uaXRvckJhc2UgfSBmcm9tIFwiLi4vLi4vTW9uaXRvckJhc2VcIjtcbmltcG9ydCB7IFdvcmtMaXN0LCBWYWx1ZVN0YWNrIH0gZnJvbSBcIi4uLy4uL0NvbnRleHRcIjtcbmltcG9ydCB7IFRhc2sgfSBmcm9tIFwiLi4vVGFza1wiO1xuaW1wb3J0IHsgR2V0VmFsdWUgfSBmcm9tIFwiLi4vLi4vR2V0VmFsdWVcIjtcbmltcG9ydCB7IFRvT2JqZWN0IH0gZnJvbSBcIi4uLy4uL0NvbnZlcnNpb24vVG9PYmplY3RcIjtcbmltcG9ydCB7IE5ld09iamVjdEVudmlyb25tZW50IH0gZnJvbSBcIi4uLy4uL09iamVjdEVudmlyb25tZW50UmVjb3JkXCI7XG5pbXBvcnQgeyBWYWx1ZSB9IGZyb20gXCIuLi8uLi9WYWx1ZVwiO1xuaW1wb3J0IHsgTGV4aWNhbEVudmlyb25tZW50IH0gZnJvbSBcIi4uLy4uL0xleGljYWxFbnZpcm9ubWVudFwiO1xuXG5pbXBvcnQgKiBhcyBlc3RyZWUgZnJvbSAnZXN0cmVlJztcblxuZGVjbGFyZSB2YXIgbW9uaXRvcjogTW9uaXRvckJhc2U7XG4vLyAxMi4xMCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIHdpdGhTdGF0ZW1lbnQoXG4gICAgbm9kZTogZXN0cmVlLldpdGhTdGF0ZW1lbnQsXG4gICAgd2w6IFdvcmtMaXN0LFxuICAgIHZzOiBWYWx1ZVN0YWNrXG4pOiB2b2lkIHtcbiAgICBsZXQgaXAgPSB3bC50b3AoKTtcblxuICAgIGlwLnRoZW4obm9kZS5vYmplY3QpO1xuICAgIGlwLnRoZW4obmV3IFdpdGhTdGF0ZW1lbnRCb2R5KG5vZGUpKTtcbn1cblxuLy8gLS0tXG5cbmNsYXNzIFdpdGhTdGF0ZW1lbnRCb2R5IGV4dGVuZHMgVGFzayB7XG4gICAgbm9kZTogZXN0cmVlLldpdGhTdGF0ZW1lbnQ7XG5cbiAgICBjb25zdHJ1Y3Rvcihub2RlOiBlc3RyZWUuV2l0aFN0YXRlbWVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgIH1cblxuICAgIEV4ZWN1dGUod2w6IFdvcmtMaXN0LCB2czogVmFsdWVTdGFjayk6IHZvaWQge1xuICAgICAgICBsZXQgaXAgPSB3bC50b3AoKTtcbiAgICAgICAgbGV0IGMgPSBtb25pdG9yLmNvbnRleHQ7XG5cbiAgICAgICAgLy9AdHMtaWdub3JlIFNUQUNLXG4gICAgICAgIGxldCB2YWwgPSBHZXRWYWx1ZSh2cy5wb3AoKSk7XG4gICAgICAgIGxldCBvYmogPSBUb09iamVjdCh2YWwpO1xuXG4gICAgICAgIGxldCBvbGRFbnYgPSBjLmxleGljYWxFbnY7XG4gICAgICAgIGxldCBuZXdFbnYgPSBOZXdPYmplY3RFbnZpcm9ubWVudChvYmosIG9sZEVudik7XG4gICAgICAgIG5ld0Vudi5wcm92aWRlVGhpcygpO1xuXG4gICAgICAgIGMubGV4aWNhbEVudiA9IG5ldyBWYWx1ZShuZXdFbnYsIG9iai5sYWJlbCk7XG5cbiAgICAgICAgaXAudGhlbih0aGlzLm5vZGUuYm9keSk7XG4gICAgICAgIGlwLnRoZW4obmV3IFdpdGhTdGF0ZW1lbnRFbmQob2xkRW52KSk7XG4gICAgfVxufVxuXG4vLyB3aXRoU3RhdGVtZW50RW5kXG5cbmNsYXNzIFdpdGhTdGF0ZW1lbnRFbmQgZXh0ZW5kcyBUYXNrIHtcbiAgICBsZXhpY2FsRW52OiBWYWx1ZTxMZXhpY2FsRW52aXJvbm1lbnQ+O1xuXG4gICAgY29uc3RydWN0b3IobGV4aWNhbEVudjogVmFsdWU8TGV4aWNhbEVudmlyb25tZW50Pikge1xuICAgICAgICBzdXBlcihUYXNrLnJ1bmZvcl9jb250aW51ZV9icmVhayk7XG4gICAgICAgIHRoaXMubGV4aWNhbEVudiA9IGxleGljYWxFbnY7XG4gICAgfVxuXG4gICAgRXhlY3V0ZSh3bDogV29ya0xpc3QsIHZzOiBWYWx1ZVN0YWNrKTogdm9pZCB7XG4gICAgICAgIG1vbml0b3IuY29udGV4dC5sZXhpY2FsRW52ID0gdGhpcy5sZXhpY2FsRW52O1xuICAgIH1cbn0iLCJpbXBvcnQgeyBXb3JrTGlzdCwgVmFsdWVTdGFjayB9IGZyb20gXCIuLi9Db250ZXh0XCI7XG5pbXBvcnQgeyBWYWx1ZSB9IGZyb20gXCIuLi9WYWx1ZVwiO1xuaW1wb3J0IHsgVmFsdWVUeXBlcyB9IGZyb20gXCIuLi9JbnRlcmZhY2VzXCI7XG5pbXBvcnQgeyBSZWZlcmVuY2UgfSBmcm9tIFwiLi4vUmVmZXJlbmNlXCI7XG5pbXBvcnQgeyBUb051bWJlciB9IGZyb20gXCIuLi9Db252ZXJzaW9uL1RvTnVtYmVyXCI7XG5pbXBvcnQgeyBHZXRWYWx1ZSB9IGZyb20gXCIuLi9HZXRWYWx1ZVwiO1xuaW1wb3J0IHsgVG9Cb29sZWFuIH0gZnJvbSBcIi4uL0NvbnZlcnNpb24vVG9Cb29sZWFuXCI7XG5pbXBvcnQgeyBUb0ludDMyIH0gZnJvbSBcIi4uL0NvbnZlcnNpb24vVG9JbnQzMlwiO1xuaW1wb3J0IHsgYm90IH0gZnJvbSBcIi4uL0xhYmVsXCI7XG5pbXBvcnQgeyBUb09iamVjdCB9IGZyb20gXCIuLi9Db252ZXJzaW9uL1RvT2JqZWN0XCI7XG5pbXBvcnQgeyBQdXRWYWx1ZSB9IGZyb20gXCIuLi9QdXRWYWx1ZVwiO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBVbmFyeSBvcGVyYXRvcnNcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVW5hcnkgLSwgMTEuNC43XG5cbmZ1bmN0aW9uIHVuYXJ5TWludXMod2w6IFdvcmtMaXN0LCB2czogVmFsdWVTdGFjayk6IHZvaWQge1xuICAgIGxldCByZWYgPSB2cy5wb3AoKTtcbiAgICAvL0B0cy1pZ25vcmUgU1RBQ0tcbiAgICBsZXQgbiA9IFRvTnVtYmVyKEdldFZhbHVlKHJlZikpO1xuICAgIG4udmFsdWUgPSAtbi52YWx1ZTtcbiAgICB2cy5wdXNoKG4pO1xuICB9XG4gIFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFVuYXJ5ICssIDExLjQuNlxuICBcbiAgZnVuY3Rpb24gdW5hcnlQbHVzKHdsOiBXb3JrTGlzdCwgdnM6IFZhbHVlU3RhY2spOiB2b2lkIHtcbiAgICBsZXQgcmVmID0gdnMucG9wKCk7XG4gICAgLy9AdHMtaWdub3JlIFNUQUNLXG4gICAgbGV0IG4gPSBUb051bWJlcihHZXRWYWx1ZShyZWYpKTtcbiAgICB2cy5wdXNoKG4pO1xuICB9XG4gIFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIExvZ2ljYWwgTk9ULCAxMS40LjlcbiAgXG4gIGZ1bmN0aW9uIHVuYXJ5TG9naWNhbE5vdCh3bDogV29ya0xpc3QsIHZzOiBWYWx1ZVN0YWNrKTogdm9pZCB7XG4gICAgbGV0IHJlZiA9IHZzLnBvcCgpO1xuICAgIC8vQHRzLWlnbm9yZSBTVEFDS1xuICAgIGxldCBiID0gVG9Cb29sZWFuKEdldFZhbHVlKHJlZikpO1xuICAgIGIudmFsdWUgPSAhYi52YWx1ZTtcbiAgICB2cy5wdXNoKGIpO1xuICB9XG4gIFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIEJpdHdpc2UgTk9ULCAxMS40LjhcbiAgXG4gIGZ1bmN0aW9uIHVuYXJ5Qml0d2lzZU5vdCh3bDogV29ya0xpc3QsIHZzOiBWYWx1ZVN0YWNrKTogdm9pZCB7XG4gICAgbGV0IHJlZiA9IHZzLnBvcCgpO1xuICAgIC8vQHRzLWlnbm9yZSBTVEFDS1xuICAgIGxldCBuID0gVG9JbnQzMihHZXRWYWx1ZShyZWYpKTtcbiAgICBuLnZhbHVlID0gfm4udmFsdWU7XG4gICAgdnMucHVzaChuKTtcbiAgfVxuICBcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBUaGUgdHlwZW9mIE9wZXJhdG9yLCAxMS40LjNcbiAgXG4gIGZ1bmN0aW9uIHVuYXJ5VHlwZW9mKHdsOiBXb3JrTGlzdCwgdnM6IFZhbHVlU3RhY2spOiB2b2lkIHtcbiAgICBsZXQgcmVmID0gdnMucG9wKCk7XG4gIFxuICAgIGlmIChyZWYgaW5zdGFuY2VvZiBSZWZlcmVuY2UgJiYgcmVmLklzVW5yZXNvbHZhYmxlUmVmZXJlbmNlKCkpIHtcbiAgICAgIHZzLnB1c2gobmV3IFZhbHVlKCd1bmRlZmluZWQnLCByZWYuYmFzZS5sYWJlbCkpO1xuICAgIH0gZWxzZSB7XG4gIFxuICAgICAgbGV0IHZhbDogVmFsdWU8VmFsdWVUeXBlcz47XG4gIFxuICAgICAgaWYgKHJlZiBpbnN0YW5jZW9mIFJlZmVyZW5jZSkge1xuICAgICAgICB2YWwgPSBHZXRWYWx1ZShyZWYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy9AdHMtaWdub3JlIFRZUEVTXG4gICAgICAgIHZhbCA9IHJlZjtcbiAgICAgIH1cbiAgXG4gICAgICBpZiAodmFsLnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHZzLnB1c2gobmV3IFZhbHVlKCdvYmplY3QnLCB2YWwubGFiZWwpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICBcbiAgICAgIGlmICh0eXBlb2YgdmFsLnZhbHVlID09PSAnb2JqZWN0Jykge1xuICBcbiAgICAgICAgLy8gVE9ETzogdXNlIHR5cGUgcHJlZGljYXRlXG4gICAgICAgIGlmICgnQ2FsbCcgaW4gdmFsLnZhbHVlKSB7XG4gICAgICAgICAgdnMucHVzaChuZXcgVmFsdWUoJ2Z1bmN0aW9uJywgdmFsLmxhYmVsKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdnMucHVzaChuZXcgVmFsdWUoJ29iamVjdCcsIHZhbC5sYWJlbCkpO1xuICAgICAgICB9XG4gIFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdnMucHVzaChuZXcgVmFsdWUodHlwZW9mIHZhbC52YWx1ZSwgdmFsLmxhYmVsKSk7XG4gICAgICB9XG4gICAgfVxuICBcbiAgfVxuICBcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBUaGUgdm9pZCBPcGVyYXRvciwgMTEuNC4yXG4gIFxuICBmdW5jdGlvbiB1bmFyeVZvaWQod2w6IFdvcmtMaXN0LCB2czogVmFsdWVTdGFjayk6IHZvaWQge1xuICAgIGxldCByZWYgPSB2cy5wb3AoKTtcbiAgICAvL0B0cy1pZ25vcmUgU1RBQ0tcbiAgICBsZXQgX2lnbm9yZSA9IEdldFZhbHVlKHJlZik7XG4gICAgdnMucHVzaChuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpKTtcbiAgfVxuICBcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBUaGUgZGVsZXRlIE9wZXJhdG9yLCAxMS40LjFcbiAgXG4gIGZ1bmN0aW9uIHVuYXJ5RGVsZXRlKHdsOiBXb3JrTGlzdCwgdnM6IFZhbHVlU3RhY2spOiB2b2lkIHtcbiAgICBsZXQgcmVmID0gdnMucG9wKCk7XG4gIFxuICAgIGlmIChyZWYgaW5zdGFuY2VvZiBSZWZlcmVuY2UpIHtcbiAgXG4gICAgICBpZiAocmVmLklzVW5yZXNvbHZhYmxlUmVmZXJlbmNlKCkpIHtcbiAgICAgICAgdnMucHVzaChuZXcgVmFsdWUodHJ1ZSwgcmVmLmJhc2UubGFiZWwpKTtcbiAgICAgIH0gZWxzZSB7XG4gIFxuICAgICAgICBpZiAocmVmLklzUHJvcGVydHlSZWZlcmVuY2UoKSkge1xuICAgICAgICAgIGxldCBvYmplY3QgPSBUb09iamVjdChyZWYuYmFzZSk7XG4gICAgICAgICAgdnMucHVzaChvYmplY3QuRGVsZXRlKHJlZi5wcm9wZXJ0eU5hbWUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2cy5wdXNoKHJlZi5iYXNlLkRlbGV0ZUJpbmRpbmcocmVmLnByb3BlcnR5TmFtZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gIFxuICAgIH0gZWxzZSB7XG4gICAgICAvL0B0cy1pZ25vcmUgVFlQRVNcbiAgICAgIHZzLnB1c2gobmV3IFZhbHVlKHRydWUsIHJlZi5sYWJlbCkpO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBcbiAgZXhwb3J0IHZhciB1bmFyeXRibCA9IHtcbiAgICAnLSc6IHVuYXJ5TWludXMsXG4gICAgJysnOiB1bmFyeVBsdXMsXG4gICAgJyEnOiB1bmFyeUxvZ2ljYWxOb3QsXG4gICAgJ34nOiB1bmFyeUJpdHdpc2VOb3QsXG4gICAgJ3R5cGVvZic6IHVuYXJ5VHlwZW9mLFxuICAgICd2b2lkJzogdW5hcnlWb2lkLFxuICAgICdkZWxldGUnOiB1bmFyeURlbGV0ZVxuICB9O1xuXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gXG4vLyBQcmVmaXgsIGFuZCBQb3N0Zml4IEV4cHJlc3Npb25zLCAxMS4zLCAxMS40LjQsIDExLjQuNVxuXG5mdW5jdGlvbiBwcmVmaXhPcHMoXG4gICAgb3A6IFwiKytcIiB8IFwiLS1cIixcbiAgICB3bDogV29ya0xpc3QsXG4gICAgdnM6IFZhbHVlU3RhY2tcbiAgKTogdm9pZCB7XG4gICAgLy9AdHMtaWdub3JlXG4gICAgbGV0IHJlZjogUmVmZXJlbmNlID0gdnMucG9wKCk7XG4gICAgbGV0IG9sZFZhbHVlID0gVG9OdW1iZXIoR2V0VmFsdWUocmVmKSk7XG4gICAgbGV0IHZhbCA9IG9wID09PSAnKysnID8gb2xkVmFsdWUudmFsdWUgKyAxIDogb2xkVmFsdWUudmFsdWUgLSAxO1xuICAgIGxldCBuZXdWYWx1ZSA9IG5ldyBWYWx1ZSh2YWwsIG9sZFZhbHVlLmxhYmVsKTtcbiAgICBQdXRWYWx1ZShyZWYsIG5ld1ZhbHVlKTtcbiAgXG4gICAgdnMucHVzaChuZXdWYWx1ZSk7XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIHBvc3RmaXhPcHMoXG4gICAgb3A6IFwiKytcIiB8IFwiLS1cIixcbiAgICB3bDogV29ya0xpc3QsXG4gICAgdnM6IFZhbHVlU3RhY2tcbiAgKTogdm9pZCB7XG4gICAgLy9AdHMtaWdub3JlXG4gICAgbGV0IHJlZjogUmVmZXJlbmNlID0gdnMucG9wKCk7XG4gICAgbGV0IG9sZFZhbHVlID0gVG9OdW1iZXIoR2V0VmFsdWUocmVmKSk7XG4gICAgbGV0IHZhbCA9IG9wID09PSAnKysnID8gb2xkVmFsdWUudmFsdWUgKyAxIDogb2xkVmFsdWUudmFsdWUgLSAxO1xuICAgIGxldCBuZXdWYWx1ZSA9IG5ldyBWYWx1ZSh2YWwsIG9sZFZhbHVlLmxhYmVsKTtcbiAgICBQdXRWYWx1ZShyZWYsIG5ld1ZhbHVlKTtcbiAgXG4gICAgdnMucHVzaChvbGRWYWx1ZSk7XG4gIH1cbiAgXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgXG4gIGV4cG9ydCB2YXIgcHJlZml4dGJsID0ge1xuICAgICcrKyc6IHByZWZpeE9wcy5iaW5kKG51bGwsICcrKycpLFxuICAgICctLSc6IHByZWZpeE9wcy5iaW5kKG51bGwsICctLScpXG4gIH07XG4gIFxuICBleHBvcnQgdmFyIHBvc3RmaXh0YmwgPSB7XG4gICAgJysrJzogcG9zdGZpeE9wcy5iaW5kKG51bGwsICcrKycpLFxuICAgICctLSc6IHBvc3RmaXhPcHMuYmluZChudWxsLCAnLS0nKVxuICB9OyIsIi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnR5cGUgSlNGbG93RXJyb3JUeXBlID0gJ1NlY3VyaXR5RXJyb3InIHwgJ0ZhdGFsRXJyb3InO1xuXG4vLyBKU0Zsb3dFcnJvciBhcmUgZXJyb3JzIHRoYXQgY2Fubm90IGJlIGNhdWdodCwgYW5kIGNhdXNlcyB0ZXJtaW5hdGlvbiBvZiB0aGUgZXhlY3V0aW9uXG5cbmV4cG9ydCBpbnRlcmZhY2UgSlNGbG93RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIHR5cGU6IEpTRmxvd0Vycm9yVHlwZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzSlNGbG93RXJyb3IoZTogYW55KTogZSBpcyBKU0Zsb3dFcnJvciB7XG4gIHJldHVybiBlICE9PSB1bmRlZmluZWQgJiYgZSAhPT0gbnVsbCAmJiBlLnR5cGUgIT09IHVuZGVmaW5lZDtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGNsYXNzIFNlY3VyaXR5RXJyb3IgZXh0ZW5kcyBFcnJvciBpbXBsZW1lbnRzIEpTRmxvd0Vycm9yIHtcbiAgdHlwZTogSlNGbG93RXJyb3JUeXBlO1xuXG4gIGNvbnN0cnVjdG9yKG1zZzogc3RyaW5nKSB7XG4gICAgc3VwZXIobXNnKTtcbiAgICB0aGlzLnR5cGUgPSAnU2VjdXJpdHlFcnJvcic7XG4gIH1cbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGNsYXNzIEZhdGFsRXJyb3IgZXh0ZW5kcyBFcnJvciBpbXBsZW1lbnRzIEpTRmxvd0Vycm9yIHtcbiAgdHlwZTogSlNGbG93RXJyb3JUeXBlO1xuXG4gIGNvbnN0cnVjdG9yKG1zZzogc3RyaW5nKSB7XG4gICAgc3VwZXIobXNnKTtcbiAgICB0aGlzLnR5cGUgPSAnRmF0YWxFcnJvcic7XG4gIH1cbn0iLCJpbXBvcnQgeyBib3QgfSBmcm9tIFwiLi9MYWJlbFwiO1xuaW1wb3J0IHsgUmVmZXJlbmNlIH0gZnJvbSBcIi4vUmVmZXJlbmNlXCI7XG5pbXBvcnQgeyBWYWx1ZSB9IGZyb20gXCIuL1ZhbHVlXCI7XG5pbXBvcnQgeyBNb25pdG9yQmFzZSB9IGZyb20gXCIuL01vbml0b3JCYXNlXCI7XG5pbXBvcnQgeyBMZXhpY2FsRW52aXJvbm1lbnQgfSBmcm9tIFwiLi9MZXhpY2FsRW52aXJvbm1lbnRcIjtcblxuZGVjbGFyZSB2YXIgbW9uaXRvcjogTW9uaXRvckJhc2U7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gR2V0SWRlbnRpZmllclJlZmVyZW5jZSwgMTAuMi4yLjFcblxuZXhwb3J0IGZ1bmN0aW9uIEdldElkZW50aWZpZXJSZWZlcmVuY2UocCA6IFZhbHVlPExleGljYWxFbnZpcm9ubWVudD4sIHggOiBzdHJpbmcpIDogUmVmZXJlbmNlIHtcblxuICAgIGlmICghcCkge1xuICAgICAgbW9uaXRvci5mYXRhbCgnR2V0SWRlbnRpZmllclJlZmVyZW5jZTogcCB1bmRlZmluZWQgb3IgbnVsbCBmb3IgJyArIHgpO1xuICAgIH1cbiAgXG4gICAgaWYgKHAudmFsdWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5ldyBSZWZlcmVuY2UobmV3IFZhbHVlKHVuZGVmaW5lZCwgcC5sYWJlbCksXG4gICAgICAgIG5ldyBWYWx1ZSh4LCBib3QpKTtcbiAgICB9XG4gIFxuICAgIHZhciBlcnAgPSBuZXcgVmFsdWUocC52YWx1ZS5FbnZpcm9ubWVudFJlY29yZCwgcC5sYWJlbCk7XG4gIFxuICAgIHZhciBiID0gZXJwLkhhc0JpbmRpbmcobmV3IFZhbHVlKHgsIGJvdCkpO1xuICAgIGlmIChiLnZhbHVlKSB7XG4gICAgICBlcnAubGFiZWwgPSBiLmxhYmVsO1xuICAgICAgcmV0dXJuIG5ldyBSZWZlcmVuY2UoZXJwLCBuZXcgVmFsdWUoeCwgYm90KSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHJlcyA9IEdldElkZW50aWZpZXJSZWZlcmVuY2UocC52YWx1ZS5PdXRlckxleGljYWxFbnZpcm9ubWVudCwgeCk7XG4gICAgICByZXMuYmFzZS5yYWlzZShiLmxhYmVsKTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICB9XG4gICIsImltcG9ydCB7IFJlZmVyZW5jZSB9IGZyb20gXCIuL1JlZmVyZW5jZVwiO1xuaW1wb3J0IHsgVmFsdWUgfSBmcm9tIFwiLi9WYWx1ZVwiO1xuaW1wb3J0IHsgVG9PYmplY3QgfSBmcm9tICcuL0NvbnZlcnNpb24vVG9PYmplY3QnO1xuaW1wb3J0IHsgbHViIH0gZnJvbSAnLi9MYWJlbCc7XG5pbXBvcnQgeyBJc0RhdGFEZXNjcmlwdG9yIH0gZnJvbSAnLi9Qcm9wZXJ0eURlc2NyaXB0b3InO1xuaW1wb3J0IHsgVmFsdWVUeXBlcyB9IGZyb20gXCIuL0ludGVyZmFjZXNcIjtcbmltcG9ydCB7IE1vbml0b3JCYXNlIH0gZnJvbSBcIi4vTW9uaXRvckJhc2VcIjtcblxuZGVjbGFyZSB2YXIgbW9uaXRvcjogTW9uaXRvckJhc2U7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gR2V0VmFsdWUsIDguNy4xXG5cblxuZXhwb3J0IGZ1bmN0aW9uIEdldFZhbHVlKHY6IFZhbHVlPFZhbHVlVHlwZXM+IHwgUmVmZXJlbmNlICkgOiBWYWx1ZTxWYWx1ZVR5cGVzPjtcbmV4cG9ydCBmdW5jdGlvbiBHZXRWYWx1ZSh2PyA6IFZhbHVlPFZhbHVlVHlwZXM+IHwgUmVmZXJlbmNlICkgOiBWYWx1ZTxWYWx1ZVR5cGVzPiB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKCF2IHx8ICEodiBpbnN0YW5jZW9mIFJlZmVyZW5jZSkpIHtcbiAgICAgIC8vQHRzLWlnbm9yZSBUWVBFU1xuICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICBcbiAgICBpZiAodi5iYXNlLmxhYmVsID09PSB1bmRlZmluZWQpXG4gICAgICBtb25pdG9yLmZhdGFsKCdHZXRWYWx1ZSwgYmFzZS5sYWJlbCB1bmRlZmluZWQnKTtcbiAgXG4gICAgaWYgKHYuSXNVbnJlc29sdmFibGVSZWZlcmVuY2UoKSkge1xuICAgICAgbW9uaXRvci5UaHJvdyhcbiAgICAgICAgXCJSZWZlcmVuY2VFcnJvclwiLFxuICAgICAgICB2LnByb3BlcnR5TmFtZS52YWx1ZSArICcgbm90IGRlZmluZWQnLFxuICAgICAgICB2LmJhc2UubGFiZWxcbiAgICAgICk7XG4gICAgfVxuICBcbiAgICBsZXQgcCA9IHYuYmFzZTtcbiAgICBsZXQgcyA9IHYucHJvcGVydHlOYW1lO1xuICBcbiAgICBpZiAodi5Jc1Byb3BlcnR5UmVmZXJlbmNlKCkpIHtcbiAgICAgIGlmICghdi5IYXNQcmltaXRpdmVCYXNlKCkpIHtcbiAgICAgICAgcmV0dXJuIHAuR2V0KHMpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGxldCBvID0gVG9PYmplY3QocCk7XG4gICAgICAgIGxldCBsZGVzYyA9IG8uR2V0UHJvcGVydHkocyk7XG4gIFxuICAgICAgICBpZiAobGRlc2MudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vQHRzLWlnbm9yZSBUWVBFU1xuICAgICAgICAgIHJldHVybiBsZGVzYztcbiAgICAgICAgfVxuICBcbiAgICAgICAgbGV0IGxibCA9IGx1YihsZGVzYy5sYWJlbCwgbGRlc2MudmFsdWUubGFiZWwpO1xuICAgICAgICBsZXQgZGVzYyA9IGxkZXNjLnZhbHVlO1xuICBcbiAgICAgICAgaWYgKElzRGF0YURlc2NyaXB0b3IoZGVzYykpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFZhbHVlKGRlc2MudmFsdWUsIGxibCk7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIGxldCBnZXQgPSBkZXNjLmdldDtcbiAgICAgICAgaWYgKGdldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbmV3IFZhbHVlKHVuZGVmaW5lZCwgbGJsKTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgLy8gVE9ETzogdGhpcyBtdXN0IGJlIHdyb25nISBwYXJ0IG9mIG9sZCBoYW5kbGluZyBvZiBnZXR0ZXIvc2V0dGVycz9cbiAgICAgICAgbW9uaXRvci5jb250ZXh0LnB1c2hQQyhsYmwpO1xuICAgICAgICAvL0B0cy1pZ25vcmUgVFlQRVNcbiAgICAgICAgbGV0IHJlcyA9IGdldC5DYWxsKGdldCwgdi5iYXNlKTtcbiAgICAgICAgbW9uaXRvci5jb250ZXh0LnBvcFBDKCk7XG4gIFxuICAgICAgICByZXMucmFpc2UobGJsKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICB9XG4gIFxuICAgIHJldHVybiBwLkdldEJpbmRpbmdWYWx1ZShzKTtcbiAgfVxuICAiLCJpbXBvcnQgeyBsdWIsIGJvdCB9IGZyb20gJy4vTGFiZWwnO1xuaW1wb3J0IHsgVmFsdWUgfSBmcm9tIFwiLi9WYWx1ZVwiO1xuaW1wb3J0ICogYXMgY29uc3RhbnRzIGZyb20gJy4vQ29uc3RhbnRzJztcblxuaW1wb3J0IHsgTW9uaXRvckJhc2UgfSBmcm9tICcuL01vbml0b3JCYXNlJztcbmltcG9ydCB7IFZhbHVlVHlwZXMsIElFY21hT2JqZWN0LCBJc0lFY21hT2JqZWN0IH0gZnJvbSAnLi9JbnRlcmZhY2VzJztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmRlY2xhcmUgdmFyIG1vbml0b3I6IE1vbml0b3JCYXNlO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIEhhc0luc3RhbmNlKHRoaXM6IElFY21hT2JqZWN0LCBYOiBWYWx1ZTxWYWx1ZVR5cGVzPikge1xuICBsZXQgRiA9IHRoaXM7XG4gIGxldCBsID0gWC5sYWJlbDtcblxuICBpZiAoSXNJRWNtYU9iamVjdChYKSkge1xuICAgIC8vIG5lZWRlZCB0byBtYWtlIHR5cGVjaGVja2luZyB3b3JrLCBvdGhlcndpc2UgViBnZXRzIHR5cGUgVmFsdWU8VmFsdWVUeXBlcz4gaW4gd2hpbGUgYmVsb3dcbiAgICBsZXQgViA9IFg7XG5cbiAgICBsZXQgTyA9IEYuR2V0KGNvbnN0YW50cy5wcm90b3R5cGUpO1xuICAgIGlmICghSXNJRWNtYU9iamVjdChPKSkge1xuICAgICAgbW9uaXRvci5UaHJvdyhcbiAgICAgICAgXCJUeXBlRXJyb3JcIixcbiAgICAgICAgJ0hhc0luc3RhbmNlJyxcbiAgICAgICAgYm90XG4gICAgICApO1xuICAgICAgdGhyb3cgXCJUeXBlU2NyaXB0XCI7XG4gICAgfVxuXG4gICAgd2hpbGUgKFYudmFsdWUgIT09IG51bGwpIHtcbiAgICAgIFYgPSBWLnZhbHVlLlByb3RvdHlwZTtcbiAgICAgIGwgPSBsdWIobCwgVi5sYWJlbCk7XG4gICAgICBpZiAoTy52YWx1ZSA9PT0gVi52YWx1ZSkgcmV0dXJuIG5ldyBWYWx1ZSh0cnVlLCBsKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFZhbHVlKGZhbHNlLCBsKTtcbn1cbiIsIlxuaW1wb3J0IHsgRnVuY3Rpb25Qcm90b3R5cGUgfSBmcm9tICcuL1Byb3RvdHlwZXMvRnVuY3Rpb25Qcm90b3R5cGUnO1xuaW1wb3J0IHsgRnVuY3Rpb25Db25zdHJ1Y3RvciB9IGZyb20gJy4vQ29uc3RydWN0b3JzL0Z1bmN0aW9uQ29uc3RydWN0b3InO1xuaW1wb3J0IHsgT2JqZWN0Q29uc3RydWN0b3IgfSBmcm9tICcuL0NvbnN0cnVjdG9ycy9PYmplY3RDb25zdHJ1Y3Rvcic7XG5pbXBvcnQgeyBPYmplY3RQcm90b3R5cGUgfSBmcm9tICcuL1Byb3RvdHlwZXMvT2JqZWN0UHJvdG90eXBlJztcblxuaW1wb3J0IHsgRXJyb3JQcm90b3R5cGUgfSBmcm9tICcuL1Byb3RvdHlwZXMvRXJyb3JQcm90b3R5cGUnO1xuaW1wb3J0IHsgRXJyb3JDb25zdHJ1Y3RvciB9IGZyb20gJy4vQ29uc3RydWN0b3JzL0Vycm9yQ29uc3RydWN0b3InO1xuXG5pbXBvcnQgeyBFdmFsRXJyb3JQcm90b3R5cGUgfSBmcm9tICcuL1Byb3RvdHlwZXMvRXZhbEVycm9yUHJvdG90eXBlJztcbmltcG9ydCB7IEV2YWxFcnJvckNvbnN0cnVjdG9yIH0gZnJvbSAnLi9Db25zdHJ1Y3RvcnMvRXZhbEVycm9yQ29uc3RydWN0b3InO1xuXG5pbXBvcnQgeyBSYW5nZUVycm9yUHJvdG90eXBlIH0gZnJvbSAnLi9Qcm90b3R5cGVzL1JhbmdlRXJyb3JQcm90b3R5cGUnO1xuaW1wb3J0IHsgUmFuZ2VFcnJvckNvbnN0cnVjdG9yIH0gZnJvbSAnLi9Db25zdHJ1Y3RvcnMvUmFuZ2VFcnJvckNvbnN0cnVjdG9yJztcblxuaW1wb3J0IHsgUmVmZXJlbmNlRXJyb3JQcm90b3R5cGUgfSBmcm9tICcuL1Byb3RvdHlwZXMvUmVmZXJlbmNlRXJyb3JQcm90b3R5cGUnO1xuaW1wb3J0IHsgUmVmZXJlbmNlRXJyb3JDb25zdHJ1Y3RvciB9IGZyb20gJy4vQ29uc3RydWN0b3JzL1JlZmVyZW5jZUVycm9yQ29uc3RydWN0b3InO1xuXG5pbXBvcnQgeyBTeW50YXhFcnJvclByb3RvdHlwZSB9IGZyb20gJy4vUHJvdG90eXBlcy9TeW50YXhFcnJvclByb3RvdHlwZSc7XG5pbXBvcnQgeyBTeW50YXhFcnJvckNvbnN0cnVjdG9yIH0gZnJvbSAnLi9Db25zdHJ1Y3RvcnMvU3ludGF4RXJyb3JDb25zdHJ1Y3Rvcic7XG5cbmltcG9ydCB7IFR5cGVFcnJvclByb3RvdHlwZSB9IGZyb20gJy4vUHJvdG90eXBlcy9UeXBlRXJyb3JQcm90b3R5cGUnO1xuaW1wb3J0IHsgVHlwZUVycm9yQ29uc3RydWN0b3IgfSBmcm9tICcuL0NvbnN0cnVjdG9ycy9UeXBlRXJyb3JDb25zdHJ1Y3Rvcic7XG5cbmltcG9ydCB7IFVSSUVycm9yUHJvdG90eXBlIH0gZnJvbSAnLi9Qcm90b3R5cGVzL1VSSUVycm9yUHJvdG90eXBlJztcbmltcG9ydCB7IFVSSUVycm9yQ29uc3RydWN0b3IgfSBmcm9tICcuL0NvbnN0cnVjdG9ycy9VUklFcnJvckNvbnN0cnVjdG9yJztcblxuaW1wb3J0IHsgQm9vbGVhbkNvbnN0cnVjdG9yIH0gZnJvbSAnLi9Db25zdHJ1Y3RvcnMvQm9vbGVhbkNvbnN0cnVjdG9yJztcbmltcG9ydCB7IEJvb2xlYW5Qcm90b3R5cGUgfSBmcm9tICcuL1Byb3RvdHlwZXMvQm9vbGVhblByb3RvdHlwZSc7XG5pbXBvcnQgeyBBcnJheVByb3RvdHlwZSB9IGZyb20gJy4vUHJvdG90eXBlcy9BcnJheVByb3RvdHlwZSc7XG5pbXBvcnQgeyBBcnJheUNvbnN0cnVjdG9yIH0gZnJvbSAnLi9Db25zdHJ1Y3RvcnMvQXJyYXlDb25zdHJ1Y3Rvcic7XG5cbmltcG9ydCB7IE51bWJlclByb3RvdHlwZSB9IGZyb20gJy4vUHJvdG90eXBlcy9OdW1iZXJQcm90b3R5cGUnO1xuaW1wb3J0IHsgTnVtYmVyQ29uc3RydWN0b3IgfSBmcm9tICcuL0NvbnN0cnVjdG9ycy9OdW1iZXJDb25zdHJ1Y3Rvcic7XG5cbmltcG9ydCB7IFN0cmluZ1Byb3RvdHlwZSB9IGZyb20gJy4vUHJvdG90eXBlcy9TdHJpbmdQcm90b3R5cGUnO1xuaW1wb3J0IHsgU3RyaW5nQ29uc3RydWN0b3IgfSBmcm9tICcuL0NvbnN0cnVjdG9ycy9TdHJpbmdDb25zdHJ1Y3Rvcic7XG5cbmltcG9ydCB7IFJlZ0V4cFByb3RvdHlwZSB9IGZyb20gJy4vUHJvdG90eXBlcy9SZWdFeHBQcm90b3R5cGUnO1xuaW1wb3J0IHsgUmVnRXhwQ29uc3RydWN0b3IgfSBmcm9tICcuL0NvbnN0cnVjdG9ycy9SZWdFeHBDb25zdHJ1Y3Rvcic7XG5cbmltcG9ydCB7IERhdGVQcm90b3R5cGUgfSBmcm9tICcuL1Byb3RvdHlwZXMvRGF0ZVByb3RvdHlwZSc7XG5pbXBvcnQgeyBEYXRlQ29uc3RydWN0b3IgfSBmcm9tICcuL0NvbnN0cnVjdG9ycy9EYXRlQ29uc3RydWN0b3InO1xuXG5pbXBvcnQgeyBNYXRoT2JqZWN0IH0gZnJvbSAnLi9PYmplY3RzL01hdGhPYmplY3QnO1xuaW1wb3J0IHsgSlNPTk9iamVjdCB9IGZyb20gJy4vT2JqZWN0cy9KU09OT2JqZWN0JztcblxuXG5leHBvcnQgY2xhc3MgSW5zdGFuY2VzIHtcblxuICAgIEZ1bmN0aW9uQ29uc3RydWN0b3IgOiBGdW5jdGlvbkNvbnN0cnVjdG9yO1xuICAgIEZ1bmN0aW9uUHJvdG90eXBlIDogRnVuY3Rpb25Qcm90b3R5cGU7XG4gIFxuICAgIE9iamVjdENvbnN0cnVjdG9yIDogT2JqZWN0Q29uc3RydWN0b3I7XG4gICAgT2JqZWN0UHJvdG90eXBlIDogT2JqZWN0UHJvdG90eXBlO1xuICBcbiAgICBFcnJvckNvbnN0cnVjdG9yIDogRXJyb3JDb25zdHJ1Y3RvcjtcbiAgICBFcnJvclByb3RvdHlwZSA6IEVycm9yUHJvdG90eXBlO1xuICBcbiAgICBFdmFsRXJyb3JDb25zdHJ1Y3RvciA6IEV2YWxFcnJvckNvbnN0cnVjdG9yO1xuICAgIEV2YWxFcnJvclByb3RvdHlwZSA6IEV2YWxFcnJvclByb3RvdHlwZTtcbiAgXG4gICAgUmFuZ2VFcnJvckNvbnN0cnVjdG9yIDogUmFuZ2VFcnJvckNvbnN0cnVjdG9yO1xuICAgIFJhbmdlRXJyb3JQcm90b3R5cGUgOiBSYW5nZUVycm9yUHJvdG90eXBlO1xuICBcbiAgICBSZWZlcmVuY2VFcnJvckNvbnN0cnVjdG9yIDogUmVmZXJlbmNlRXJyb3JDb25zdHJ1Y3RvcjtcbiAgICBSZWZlcmVuY2VFcnJvclByb3RvdHlwZSA6IFJlZmVyZW5jZUVycm9yUHJvdG90eXBlO1xuICBcbiAgICBTeW50YXhFcnJvckNvbnN0cnVjdG9yIDogU3ludGF4RXJyb3JDb25zdHJ1Y3RvcjtcbiAgICBTeW50YXhFcnJvclByb3RvdHlwZSA6IFN5bnRheEVycm9yUHJvdG90eXBlO1xuICBcbiAgICBUeXBlRXJyb3JDb25zdHJ1Y3RvciA6IFR5cGVFcnJvckNvbnN0cnVjdG9yO1xuICAgIFR5cGVFcnJvclByb3RvdHlwZSA6IFR5cGVFcnJvclByb3RvdHlwZTtcbiAgXG4gICAgVVJJRXJyb3JDb25zdHJ1Y3RvciA6IFVSSUVycm9yQ29uc3RydWN0b3I7XG4gICAgVVJJRXJyb3JQcm90b3R5cGUgOiBVUklFcnJvclByb3RvdHlwZTtcbiAgXG4gICAgQm9vbGVhbkNvbnN0cnVjdG9yIDogQm9vbGVhbkNvbnN0cnVjdG9yO1xuICAgIEJvb2xlYW5Qcm90b3R5cGUgOiBCb29sZWFuUHJvdG90eXBlO1xuICBcbiAgICBBcnJheUNvbnN0cnVjdG9yIDogQXJyYXlDb25zdHJ1Y3RvcjtcbiAgICBBcnJheVByb3RvdHlwZSA6IEFycmF5UHJvdG90eXBlO1xuXG4gICAgTnVtYmVyQ29uc3RydWN0b3IgOiBOdW1iZXJDb25zdHJ1Y3RvcjtcbiAgICBOdW1iZXJQcm90b3R5cGUgOiBOdW1iZXJQcm90b3R5cGU7XG4gIFxuICAgIFN0cmluZ0NvbnN0cnVjdG9yIDogU3RyaW5nQ29uc3RydWN0b3I7XG4gICAgU3RyaW5nUHJvdG90eXBlIDogU3RyaW5nUHJvdG90eXBlO1xuICBcbiAgICBSZWdFeHBDb25zdHJ1Y3RvciA6IFJlZ0V4cENvbnN0cnVjdG9yO1xuICAgIFJlZ0V4cFByb3RvdHlwZSA6IFJlZ0V4cFByb3RvdHlwZTtcblxuICAgIERhdGVDb25zdHJ1Y3RvciA6IERhdGVDb25zdHJ1Y3RvcjtcbiAgICBEYXRlUHJvdG90eXBlIDogRGF0ZVByb3RvdHlwZTtcblxuICAgIE1hdGhPYmplY3QgOiBNYXRoT2JqZWN0O1xuICAgIEpTT05PYmplY3QgOiBKU09OT2JqZWN0O1xuICBcbiAgICBjb25zdHJ1Y3RvcihnbG9iYWwpIHtcbiAgICAgIC8vIHByZS1hbGxvY2F0ZXMgaW5zdGFuY2VzLCB3aXRob3V0IHNldHRpbmcgdGhlbSB1cCBkdWUgdG8gY2lyY3VsYXJpdHlcbiAgICAgIHRoaXMuRnVuY3Rpb25Db25zdHJ1Y3RvciA9IG5ldyBGdW5jdGlvbkNvbnN0cnVjdG9yKGdsb2JhbC5GdW5jdGlvbik7XG4gICAgICB0aGlzLkZ1bmN0aW9uUHJvdG90eXBlID0gbmV3IEZ1bmN0aW9uUHJvdG90eXBlKGdsb2JhbC5GdW5jdGlvbi5wcm90b3R5cGUpO1xuICBcbiAgICAgIHRoaXMuT2JqZWN0Q29uc3RydWN0b3IgPSBuZXcgT2JqZWN0Q29uc3RydWN0b3IoZ2xvYmFsLk9iamVjdCk7XG4gICAgICB0aGlzLk9iamVjdFByb3RvdHlwZSA9IG5ldyBPYmplY3RQcm90b3R5cGUoZ2xvYmFsLk9iamVjdC5wcm90b3R5cGUpO1xuICBcbiAgICAgIHRoaXMuRXJyb3JDb25zdHJ1Y3RvciA9IG5ldyBFcnJvckNvbnN0cnVjdG9yKGdsb2JhbC5FcnJvcik7XG4gICAgICB0aGlzLkVycm9yUHJvdG90eXBlICA9IG5ldyBFcnJvclByb3RvdHlwZShnbG9iYWwuRXJyb3IucHJvdG90eXBlKTtcbiAgXG4gICAgICB0aGlzLkV2YWxFcnJvckNvbnN0cnVjdG9yID0gbmV3IEV2YWxFcnJvckNvbnN0cnVjdG9yKGdsb2JhbC5FdmFsRXJyb3IpO1xuICAgICAgdGhpcy5FdmFsRXJyb3JQcm90b3R5cGUgID0gbmV3IEV2YWxFcnJvclByb3RvdHlwZShnbG9iYWwuRXZhbEVycm9yLnByb3RvdHlwZSk7XG4gIFxuICAgICAgdGhpcy5SYW5nZUVycm9yQ29uc3RydWN0b3IgPSBuZXcgUmFuZ2VFcnJvckNvbnN0cnVjdG9yKGdsb2JhbC5SYW5nZUVycm9yKTtcbiAgICAgIHRoaXMuUmFuZ2VFcnJvclByb3RvdHlwZSAgPSBuZXcgUmFuZ2VFcnJvclByb3RvdHlwZShnbG9iYWwuUmFuZ2VFcnJvci5wcm90b3R5cGUpO1xuICBcbiAgICAgIHRoaXMuUmVmZXJlbmNlRXJyb3JDb25zdHJ1Y3RvciA9IG5ldyBSZWZlcmVuY2VFcnJvckNvbnN0cnVjdG9yKGdsb2JhbC5SZWZlcmVuY2VFcnJvcik7XG4gICAgICB0aGlzLlJlZmVyZW5jZUVycm9yUHJvdG90eXBlICA9IG5ldyBSZWZlcmVuY2VFcnJvclByb3RvdHlwZShnbG9iYWwuUmVmZXJlbmNlRXJyb3IucHJvdG90eXBlKTtcbiAgXG4gICAgICB0aGlzLlN5bnRheEVycm9yQ29uc3RydWN0b3IgPSBuZXcgU3ludGF4RXJyb3JDb25zdHJ1Y3RvcihnbG9iYWwuU3ludGF4RXJyb3IpO1xuICAgICAgdGhpcy5TeW50YXhFcnJvclByb3RvdHlwZSAgPSBuZXcgU3ludGF4RXJyb3JQcm90b3R5cGUoZ2xvYmFsLlN5bnRheEVycm9yLnByb3RvdHlwZSk7XG4gIFxuICAgICAgdGhpcy5UeXBlRXJyb3JDb25zdHJ1Y3RvciA9IG5ldyBUeXBlRXJyb3JDb25zdHJ1Y3RvcihnbG9iYWwuVHlwZUVycm9yKTtcbiAgICAgIHRoaXMuVHlwZUVycm9yUHJvdG90eXBlICA9IG5ldyBUeXBlRXJyb3JQcm90b3R5cGUoZ2xvYmFsLlR5cGVFcnJvci5wcm90b3R5cGUpO1xuICAgICAgXG4gICAgICB0aGlzLlVSSUVycm9yQ29uc3RydWN0b3IgPSBuZXcgVVJJRXJyb3JDb25zdHJ1Y3RvcihnbG9iYWwuVVJJRXJyb3IpO1xuICAgICAgdGhpcy5VUklFcnJvclByb3RvdHlwZSAgPSBuZXcgVVJJRXJyb3JQcm90b3R5cGUoZ2xvYmFsLlVSSUVycm9yLnByb3RvdHlwZSk7XG4gIFxuICAgICAgdGhpcy5Cb29sZWFuQ29uc3RydWN0b3IgPSBuZXcgQm9vbGVhbkNvbnN0cnVjdG9yKGdsb2JhbC5Cb29sZWFuKTtcbiAgICAgIHRoaXMuQm9vbGVhblByb3RvdHlwZSA9IG5ldyBCb29sZWFuUHJvdG90eXBlKGdsb2JhbC5Cb29sZWFuLnByb3RvdHlwZSk7XG4gICAgICBcbiAgICAgIHRoaXMuQXJyYXlDb25zdHJ1Y3RvciA9IG5ldyBBcnJheUNvbnN0cnVjdG9yKGdsb2JhbC5BcnJheSk7XG4gICAgICB0aGlzLkFycmF5UHJvdG90eXBlID0gbmV3IEFycmF5UHJvdG90eXBlKGdsb2JhbC5BcnJheS5wcm90b3R5cGUpO1xuICBcbiAgICAgIHRoaXMuTnVtYmVyQ29uc3RydWN0b3IgPSBuZXcgTnVtYmVyQ29uc3RydWN0b3IoZ2xvYmFsLk51bWJlcik7XG4gICAgICB0aGlzLk51bWJlclByb3RvdHlwZSA9IG5ldyBOdW1iZXJQcm90b3R5cGUoZ2xvYmFsLk51bWJlci5wcm90b3R5cGUpO1xuXG4gICAgICB0aGlzLlN0cmluZ0NvbnN0cnVjdG9yID0gbmV3IFN0cmluZ0NvbnN0cnVjdG9yKGdsb2JhbC5TdHJpbmcpO1xuICAgICAgdGhpcy5TdHJpbmdQcm90b3R5cGUgPSBuZXcgU3RyaW5nUHJvdG90eXBlKGdsb2JhbC5TdHJpbmcucHJvdG90eXBlKTtcblxuICAgICAgdGhpcy5SZWdFeHBDb25zdHJ1Y3RvciA9IG5ldyBSZWdFeHBDb25zdHJ1Y3RvcihnbG9iYWwuUmVnRXhwKTtcbiAgICAgIHRoaXMuUmVnRXhwUHJvdG90eXBlID0gbmV3IFJlZ0V4cFByb3RvdHlwZShnbG9iYWwuUmVnRXhwLnByb3RvdHlwZSk7XG5cbiAgICAgIHRoaXMuRGF0ZUNvbnN0cnVjdG9yID0gbmV3IERhdGVDb25zdHJ1Y3RvcihnbG9iYWwuRGF0ZSk7XG4gICAgICB0aGlzLkRhdGVQcm90b3R5cGUgPSBuZXcgRGF0ZVByb3RvdHlwZShnbG9iYWwuRGF0ZS5wcm90b3R5cGUpO1xuXG4gICAgICB0aGlzLk1hdGhPYmplY3QgPSBuZXcgTWF0aE9iamVjdChnbG9iYWwuTWF0aCk7XG4gICAgICB0aGlzLkpTT05PYmplY3QgPSBuZXcgSlNPTk9iamVjdChnbG9iYWwuSlNPTik7XG4gICAgfVxuICBcbiAgICBTZXR1cCgpIHtcbiAgICB0aGlzLkZ1bmN0aW9uQ29uc3RydWN0b3IuU2V0dXAoKTtcbiAgICB0aGlzLkZ1bmN0aW9uUHJvdG90eXBlLlNldHVwKCk7IFxuICBcbiAgICB0aGlzLk9iamVjdENvbnN0cnVjdG9yLlNldHVwKCk7XG4gICAgdGhpcy5PYmplY3RQcm90b3R5cGUuU2V0dXAoKTtcblxuICAgIHRoaXMuRXJyb3JDb25zdHJ1Y3Rvci5TZXR1cCgpO1xuICAgIHRoaXMuRXJyb3JQcm90b3R5cGUuU2V0dXAoKTtcblxuICAgIHRoaXMuRXZhbEVycm9yQ29uc3RydWN0b3IuU2V0dXAoKTtcbiAgICB0aGlzLkV2YWxFcnJvclByb3RvdHlwZS5TZXR1cCgpO1xuXG4gICAgdGhpcy5SYW5nZUVycm9yQ29uc3RydWN0b3IuU2V0dXAoKTtcbiAgICB0aGlzLlJhbmdlRXJyb3JQcm90b3R5cGUuU2V0dXAoKTtcblxuICAgIHRoaXMuUmVmZXJlbmNlRXJyb3JDb25zdHJ1Y3Rvci5TZXR1cCgpO1xuICAgIHRoaXMuUmVmZXJlbmNlRXJyb3JQcm90b3R5cGUuU2V0dXAoKTtcblxuICAgIHRoaXMuU3ludGF4RXJyb3JDb25zdHJ1Y3Rvci5TZXR1cCgpO1xuICAgIHRoaXMuU3ludGF4RXJyb3JQcm90b3R5cGUuU2V0dXAoKTtcblxuICAgIHRoaXMuVHlwZUVycm9yQ29uc3RydWN0b3IuU2V0dXAoKTtcbiAgICB0aGlzLlR5cGVFcnJvclByb3RvdHlwZS5TZXR1cCgpO1xuXG4gICAgdGhpcy5VUklFcnJvckNvbnN0cnVjdG9yLlNldHVwKCk7XG4gICAgdGhpcy5VUklFcnJvclByb3RvdHlwZS5TZXR1cCgpO1xuICBcbiAgICB0aGlzLkJvb2xlYW5Db25zdHJ1Y3Rvci5TZXR1cCgpO1xuICAgIHRoaXMuQm9vbGVhblByb3RvdHlwZS5TZXR1cCgpO1xuICBcbiAgICB0aGlzLkFycmF5Q29uc3RydWN0b3IuU2V0dXAoKTtcbiAgICB0aGlzLkFycmF5UHJvdG90eXBlLlNldHVwKCk7XG4gIFxuICAgIHRoaXMuTnVtYmVyQ29uc3RydWN0b3IuU2V0dXAoKTtcbiAgICB0aGlzLk51bWJlclByb3RvdHlwZS5TZXR1cCgpO1xuICBcbiAgICB0aGlzLlN0cmluZ0NvbnN0cnVjdG9yLlNldHVwKCk7XG4gICAgdGhpcy5TdHJpbmdQcm90b3R5cGUuU2V0dXAoKTtcblxuICAgIHRoaXMuUmVnRXhwQ29uc3RydWN0b3IuU2V0dXAoKTtcbiAgICB0aGlzLlJlZ0V4cFByb3RvdHlwZS5TZXR1cCgpO1xuXG4gICAgdGhpcy5EYXRlQ29uc3RydWN0b3IuU2V0dXAoKTtcbiAgICB0aGlzLkRhdGVQcm90b3R5cGUuU2V0dXAoKTtcblxuICAgIHRoaXMuTWF0aE9iamVjdC5TZXR1cCgpO1xuICAgIHRoaXMuSlNPTk9iamVjdC5TZXR1cCgpO1xuICAgIH1cbiAgfSIsImltcG9ydCB7IExhYmVsIH0gZnJvbSBcIi4vTGFiZWxcIjtcbmltcG9ydCB7IFZhbHVlIH0gZnJvbSBcIi4vVmFsdWVcIjtcbmltcG9ydCB7IFByb3BlcnR5TGFiZWwgfSBmcm9tIFwiLi9Qcm9wZXJ0eUxhYmVsXCI7XG5cbmltcG9ydCAqIGFzIGVzdHJlZSBmcm9tICdlc3RyZWUnO1xuaW1wb3J0IHsgTGV4aWNhbEVudmlyb25tZW50IH0gZnJvbSBcIi4vTGV4aWNhbEVudmlyb25tZW50XCI7XG5pbXBvcnQgeyBMYWJlbGVkUHJvcGVydHlEZXNjcmlwdG9yLCBKU0ZQcm9wZXJ0eURlc2NyaXB0b3IgfSBmcm9tIFwiLi9Qcm9wZXJ0eURlc2NyaXB0b3JcIjtcbmltcG9ydCB7IFdvcmtMaXN0UHRyIH0gZnJvbSBcIi4vQ29udGV4dFwiO1xuXG4vLyAtLS1cblxuZXhwb3J0IHR5cGUgVGhyb3dUeXBlID0gXCJFcnJvclwiIHwgXCJFdmFsRXJyb3JcIiB8IFwiUmFuZ2VFcnJvclwiIHwgXCJSZWZlcmVuY2VFcnJvclwiIHwgXCJTeW50YXhFcnJvclwiIHwgXCJUeXBlRXJyb3JcIiB8IFwiVVJJRXJyb3JcIlxuXG5leHBvcnQgdHlwZSBQcmltaXRpdmVWYWx1ZVR5cGVzID0gdW5kZWZpbmVkIHwgbnVsbCB8IG51bWJlciB8IGJvb2xlYW4gfCBzdHJpbmdcbmV4cG9ydCB0eXBlIFZhbHVlVHlwZXMgPSBQcmltaXRpdmVWYWx1ZVR5cGVzIHwgSUVjbWFPYmplY3QgfCBJRWNtYUZ1bmN0aW9uIHwgTGFiZWxlZFByb3BlcnR5RGVzY3JpcHRvcjtcblxuZXhwb3J0IGludGVyZmFjZSBJRWNtYU9iamVjdCB7XG5cbiAgQ2xhc3M/OiBzdHJpbmc7XG4gIFByb3RvdHlwZTogVmFsdWU8SUVjbWFPYmplY3QgfCBudWxsPjtcbiAgRXh0ZW5zaWJsZTogYm9vbGVhbjtcblxuICAvLyBlbmNvZGluZ1xuICBwcm9wZXJ0aWVzOiB7IFtzOiBzdHJpbmddOiBhbnkgfTtcblxuICAvLyBzZWN1cml0eVxuICBsYWJlbHM6IHsgW3M6IHN0cmluZ106IFByb3BlcnR5TGFiZWwgfTtcbiAgc3RydWN0OiBMYWJlbDtcblxuICAvLyBzdGFuZGFyZCBtYW5kYXRlZCBpbm5lciBwcm9wZXJ0aWVzXG4gIEdldE93blByb3BlcnR5KHM6IFZhbHVlPHN0cmluZyB8IG51bWJlcj4pOiBWYWx1ZTxMYWJlbGVkUHJvcGVydHlEZXNjcmlwdG9yIHwgdW5kZWZpbmVkPjtcbiAgR2V0UHJvcGVydHkoczogVmFsdWU8c3RyaW5nIHwgbnVtYmVyPik6IFZhbHVlPExhYmVsZWRQcm9wZXJ0eURlc2NyaXB0b3IgfCB1bmRlZmluZWQ+O1xuICBHZXQoczogVmFsdWU8c3RyaW5nIHwgbnVtYmVyPik6IFZhbHVlPFZhbHVlVHlwZXM+O1xuICBDYW5QdXQocDogVmFsdWU8c3RyaW5nIHwgbnVtYmVyPik6IFZhbHVlPGJvb2xlYW4+O1xuICBQdXQoczogVmFsdWU8c3RyaW5nIHwgbnVtYmVyPiwgdjogVmFsdWU8VmFsdWVUeXBlcz4sIFRocm93PzogYm9vbGVhbik6IHZvaWQ7XG4gIEhhc1Byb3BlcnR5KHM6IFZhbHVlPHN0cmluZyB8IG51bWJlcj4pOiBWYWx1ZTxib29sZWFuPjtcbiAgRGVsZXRlKHM6IFZhbHVlPHN0cmluZyB8IG51bWJlcj4sIFRocm93PzogYm9vbGVhbik6IFZhbHVlPGJvb2xlYW4+O1xuICBEZWZhdWx0VmFsdWUoaGludD86IFwic3RyaW5nXCIgfCBcIm51bWJlclwiKTogVmFsdWU8UHJpbWl0aXZlVmFsdWVUeXBlcz47XG4gIERlZmluZU93blByb3BlcnR5KHM6IFZhbHVlPHN0cmluZyB8IG51bWJlcj4sIGRlc2M6IEpTRlByb3BlcnR5RGVzY3JpcHRvciwgVGhyb3c/OiBCb29sZWFuKTogVmFsdWU8Ym9vbGVhbj47XG5cbiAgLy8gb3RoZXIgaW50ZXJuYWwgcHJvcGVydGllc1xuICBnZXRPd25Qcm9wZXJ0eU5hbWVzKGxhYmVsOiBMYWJlbCk6IFZhbHVlPHN0cmluZz5bXTtcbiAgZ2V0T3duRW51bWVyYWJsZVByb3BlcnR5TmFtZXMobGFiZWw6IExhYmVsKTogVmFsdWU8c3RyaW5nPltdO1xuICBnZXRFbnVtZXJhYmxlUHJvcGVydHlOYW1lcyhpbml0aWFsTGFiZWw6IExhYmVsKTogVmFsdWU8c3RyaW5nPltdO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBJc0lFY21hT2JqZWN0KHg6IFZhbHVlPFZhbHVlVHlwZXM+KTogeCBpcyBWYWx1ZTxJRWNtYU9iamVjdD4ge1xuICByZXR1cm4gdHlwZW9mIHgudmFsdWUgPT09ICdvYmplY3QnICYmIHgudmFsdWUgIT09IG51bGwgJiYgXCJDbGFzc1wiIGluIHgudmFsdWU7XG59XG5cbi8vIE5PVEU6IENhbGwgbWF5IGdldCB2YWx1ZXMsIHNlZSwgZS5nLiwgMTUuMy40LjNcbmV4cG9ydCBpbnRlcmZhY2UgSUVjbWFGdW5jdGlvbiBleHRlbmRzIElFY21hT2JqZWN0IHtcblxuICBTY29wZT86IFZhbHVlPExleGljYWxFbnZpcm9ubWVudD47XG4gIEZvcm1hbFBhcmFtZXRlcnM/OiBBcnJheTxlc3RyZWUuUGF0dGVybj47XG4gIENvZGU/OiBlc3RyZWUuU3RhdGVtZW50IHwgZXN0cmVlLkV4cHJlc3Npb247XG5cbiAgSGFzSW5zdGFuY2UoVjogVmFsdWU8VmFsdWVUeXBlcz4pOiBWYWx1ZTxib29sZWFuPjtcbiAgQ2FsbCh0aGlzQXJnOiBWYWx1ZTxWYWx1ZVR5cGVzPiwgYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPFZhbHVlVHlwZXM+XG4gIENvbnN0cnVjdChhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8SUVjbWFPYmplY3Q+XG4gIEFzeW5jQ2FsbD8odGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBXb3JrTGlzdFB0clxuICBBc3luY0NhbGxFbmQ/KCk6IFZhbHVlPFZhbHVlVHlwZXM+XG4gIEFzeW5jQ29uc3RydWN0PyhhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogV29ya0xpc3RQdHJcbiAgQXN5bmNDb25zdHJ1Y3RFbmQ/KCk6IFZhbHVlPElFY21hT2JqZWN0IHwgdW5kZWZpbmVkPlxufVxuXG5leHBvcnQgaW50ZXJmYWNlIElFbnZpcm9ubWVudFJlY29yZCB7XG4gIEhhc0JpbmRpbmcocDogVmFsdWU8c3RyaW5nPik6IFZhbHVlPGJvb2xlYW4+O1xuICBDcmVhdGVNdXRhYmxlQmluZGluZyhwOiBWYWx1ZTxzdHJpbmc+LCBkPzogYm9vbGVhbik6IHZvaWQ7XG4gIEdldEJpbmRpbmdWYWx1ZShwOiBWYWx1ZTxzdHJpbmc+LCBzPyA6IGJvb2xlYW4pOiBWYWx1ZTxWYWx1ZVR5cGVzPjtcbiAgU2V0TXV0YWJsZUJpbmRpbmcocDogVmFsdWU8c3RyaW5nPiwgdjogVmFsdWU8VmFsdWVUeXBlcz4sIHM/OiBib29sZWFuKTogdm9pZDtcbiAgRGVsZXRlQmluZGluZyhwOiBWYWx1ZTxzdHJpbmc+KTogVmFsdWU8Ym9vbGVhbj47XG4gIEltcGxpY2l0VGhpc1ZhbHVlKCk6IFZhbHVlPElFY21hT2JqZWN0IHwgdW5kZWZpbmVkPjtcbn1cbiIsImltcG9ydCB7IE1vbml0b3JCYXNlIH0gZnJvbSBcIi4vTW9uaXRvckJhc2VcIjtcbmltcG9ydCB7IElzQ3Jhd2xlciB9IGZyb20gXCIuL1RvcGxldmVsL2NyYXdsZXIvQ3Jhd2xlclV0aWxcIjtcblxuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy4gKi9cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gXG5cbi8vICNDUkFXTEVSXG5cbmxldCBpbmNsdWRlID0ge1xuICAnZ2xvYmFsLkF1ZGlvQ29udGV4dC5kZXN0aW5hdGlvbi5jaGFubmVsQ291bnQnOiB0cnVlLFxuICAnZ2xvYmFsLkF1ZGlvQ29udGV4dC5kZXN0aW5hdGlvbi5jaGFubmVsQ291bnRNb2RlJzogdHJ1ZSxcbiAgJ2dsb2JhbC5BdWRpb0NvbnRleHQuZGVzdGluYXRpb24uY2hhbm5lbEludGVycHJldGF0aW9uJzogdHJ1ZSxcbiAgJ2dsb2JhbC5BdWRpb0NvbnRleHQuZGVzdGluYXRpb24ubWF4Q2hhbm5lbENvdW50JzogdHJ1ZSxcbiAgJ2dsb2JhbC5BdWRpb0NvbnRleHQuZGVzdGluYXRpb24ubnVtYmVyT2ZJbnB1dHMnOiB0cnVlLFxuICAnZ2xvYmFsLkF1ZGlvQ29udGV4dC5kZXN0aW5hdGlvbi5udW1iZXJPZk91dHB1dHMnOiB0cnVlLFxuICAnZ2xvYmFsLkF1ZGlvQ29udGV4dC5zYW1wbGVSYXRlJzogdHJ1ZSxcbiAgJ2dsb2JhbC5IVE1MRm9ybUVsZW1lbnQuYWRkQmVoYXZpb3InOiB0cnVlLFxuICAnZ2xvYmFsLkhUTUxGb3JtRWxlbWVudC5jbGllbnRIZWlnaHQnOiB0cnVlLFxuICAnZ2xvYmFsLkhUTUxGb3JtRWxlbWVudC5jbGllbnRXaWR0aCc6IHRydWUsXG4gICdnbG9iYWwuSFRNTEZvcm1FbGVtZW50Lm9mZnNldEhlaWdodCc6IHRydWUsXG4gICdnbG9iYWwuSFRNTEZvcm1FbGVtZW50Lm9mZnNldFdpZHRoJzogdHJ1ZSxcbiAgJ2dsb2JhbC5JbnQ4QXJyYXkucmVkdWNlJzogdHJ1ZSxcbiAgJ2dsb2JhbC5JbnQ4QXJyYXkuc2xpY2UucmVkdWNlJzogdHJ1ZSxcbiAgJ2dsb2JhbC5JbnRsLkRhdGVUaW1lRm9ybWF0LnJlc29sdmVkT3B0aW9ucy50aW1lWm9uZSc6IHRydWUsXG4gICdnbG9iYWwuT2ZmbGluZUF1ZGlvQ29udGV4dC5vbmNvbXBsZXRlWzBdWzBdLnJlbmRlcmVkQnVmZmVyLmdldENoYW5uZWxEYXRhLnJlZHVjZSc6IHRydWUsXG4gICdnbG9iYWwuT2ZmbGluZUF1ZGlvQ29udGV4dC5vbmNvbXBsZXRlWzBdWzBdLnJlbmRlcmVkQnVmZmVyLmdldENoYW5uZWxEYXRhLnNsaWNlJzogdHJ1ZSxcbiAgJ2dsb2JhbC5QbHVnaW4uZGVzY3JpcHRpb24nOiB0cnVlLFxuICAnZ2xvYmFsLlBsdWdpbi5sZW5ndGgnOiB0cnVlLFxuICAnZ2xvYmFsLlBsdWdpbi5uYW1lJzogdHJ1ZSxcbiAgJ2dsb2JhbC5QbHVnaW5BcnJheS5sZW5ndGgnOiB0cnVlLFxuICAnZ2xvYmFsLlJUQ1BlZXJDb25uZWN0aW9uLm9uaWNlY2FuZGlkYXRlWzBdWzBdLmNhbmRpZGF0ZS5jYW5kaWRhdGUnOiB0cnVlLFxuICAnZ2xvYmFsLldlYkdMUmVuZGVyaW5nQ29udGV4dCc6IHRydWUsXG4gICdnbG9iYWwuWE1MSHR0cFJlcXVlc3QucmVhZHlTdGF0ZSc6IHRydWUsXG4gICdnbG9iYWwuWE1MSHR0cFJlcXVlc3QucmVzcG9uc2VUZXh0JzogdHJ1ZSxcbiAgJ2dsb2JhbC5YTUxIdHRwUmVxdWVzdC5zdGF0dXMnOiB0cnVlLFxuICAnZ2xvYmFsLmFkZEJlaGF2aW9yJzogdHJ1ZSxcbiAgJ2dsb2JhbC5kZXZpY2VQaXhlbFJhdGlvJzogdHJ1ZSxcbiAgJ2dsb2JhbC5kb05vdFRyYWNrJzogdHJ1ZSxcbiAgJ2dsb2JhbC5kb2N1bWVudC5hcHBlbmRDaGlsZCc6IHRydWUsXG4gICdnbG9iYWwuZG9jdW1lbnQuYm9keS5hZGRCZWhhdmlvcic6IHRydWUsXG4gICdnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudC5jbGllbnRIZWlnaHQnOiB0cnVlLFxuICAnZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQuY2xpZW50V2lkdGgnOiB0cnVlLFxuICAnZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQuZ2V0Q29udGV4dC5jYW52YXMnOiB0cnVlLFxuICAnZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQuZ2V0Q29udGV4dC5nZXRDb250ZXh0QXR0cmlidXRlcy5hbnRpYWxpYXMnOiB0cnVlLFxuICAnZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQuZ2V0Q29udGV4dC5nZXRFeHRlbnNpb24nOiB0cnVlLFxuICAnZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQuZ2V0Q29udGV4dC5nZXRQYXJhbWV0ZXInOiB0cnVlLFxuICAnZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQuZ2V0Q29udGV4dC5nZXRQYXJhbWV0ZXIuMCc6IHRydWUsXG4gICdnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudC5nZXRDb250ZXh0LmdldFBhcmFtZXRlci4xJzogdHJ1ZSxcbiAgJ2dsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50LmdldENvbnRleHQuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0LnByZWNpc2lvbic6IHRydWUsXG4gICdnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudC5nZXRDb250ZXh0LmdldFNoYWRlclByZWNpc2lvbkZvcm1hdC5yYW5nZU1heCc6IHRydWUsXG4gICdnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudC5nZXRDb250ZXh0LmdldFNoYWRlclByZWNpc2lvbkZvcm1hdC5yYW5nZU1pbic6IHRydWUsXG4gICdnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudC5nZXRDb250ZXh0LmdldFN1cHBvcnRlZEV4dGVuc2lvbnMnOiB0cnVlLFxuICAnZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQuZ2V0Q29udGV4dC5nZXRTdXBwb3J0ZWRFeHRlbnNpb25zLjAnOiB0cnVlLFxuICAnZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQuZ2V0Q29udGV4dC5nZXRTdXBwb3J0ZWRFeHRlbnNpb25zLjEnOiB0cnVlLFxuICAnZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQuZ2V0Q29udGV4dC5nZXRTdXBwb3J0ZWRFeHRlbnNpb25zLjEwJzogdHJ1ZSxcbiAgJ2dsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50LmdldENvbnRleHQuZ2V0U3VwcG9ydGVkRXh0ZW5zaW9ucy4xMSc6IHRydWUsXG4gICdnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudC5nZXRDb250ZXh0LmdldFN1cHBvcnRlZEV4dGVuc2lvbnMuMTInOiB0cnVlLFxuICAnZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQuZ2V0Q29udGV4dC5nZXRTdXBwb3J0ZWRFeHRlbnNpb25zLjEzJzogdHJ1ZSxcbiAgJ2dsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50LmdldENvbnRleHQuZ2V0U3VwcG9ydGVkRXh0ZW5zaW9ucy4xNCc6IHRydWUsXG4gICdnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudC5nZXRDb250ZXh0LmdldFN1cHBvcnRlZEV4dGVuc2lvbnMuMTUnOiB0cnVlLFxuICAnZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQuZ2V0Q29udGV4dC5nZXRTdXBwb3J0ZWRFeHRlbnNpb25zLjE2JzogdHJ1ZSxcbiAgJ2dsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50LmdldENvbnRleHQuZ2V0U3VwcG9ydGVkRXh0ZW5zaW9ucy4xNyc6IHRydWUsXG4gICdnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudC5nZXRDb250ZXh0LmdldFN1cHBvcnRlZEV4dGVuc2lvbnMuMTgnOiB0cnVlLFxuICAnZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQuZ2V0Q29udGV4dC5nZXRTdXBwb3J0ZWRFeHRlbnNpb25zLjE5JzogdHJ1ZSxcbiAgJ2dsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50LmdldENvbnRleHQuZ2V0U3VwcG9ydGVkRXh0ZW5zaW9ucy4yJzogdHJ1ZSxcbiAgJ2dsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50LmdldENvbnRleHQuZ2V0U3VwcG9ydGVkRXh0ZW5zaW9ucy4yMCc6IHRydWUsXG4gICdnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudC5nZXRDb250ZXh0LmdldFN1cHBvcnRlZEV4dGVuc2lvbnMuMjEnOiB0cnVlLFxuICAnZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQuZ2V0Q29udGV4dC5nZXRTdXBwb3J0ZWRFeHRlbnNpb25zLjIyJzogdHJ1ZSxcbiAgJ2dsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50LmdldENvbnRleHQuZ2V0U3VwcG9ydGVkRXh0ZW5zaW9ucy4yMyc6IHRydWUsXG4gICdnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudC5nZXRDb250ZXh0LmdldFN1cHBvcnRlZEV4dGVuc2lvbnMuMjQnOiB0cnVlLFxuICAnZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQuZ2V0Q29udGV4dC5nZXRTdXBwb3J0ZWRFeHRlbnNpb25zLjI1JzogdHJ1ZSxcbiAgJ2dsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50LmdldENvbnRleHQuZ2V0U3VwcG9ydGVkRXh0ZW5zaW9ucy4zJzogdHJ1ZSxcbiAgJ2dsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50LmdldENvbnRleHQuZ2V0U3VwcG9ydGVkRXh0ZW5zaW9ucy40JzogdHJ1ZSxcbiAgJ2dsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50LmdldENvbnRleHQuZ2V0U3VwcG9ydGVkRXh0ZW5zaW9ucy41JzogdHJ1ZSxcbiAgJ2dsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50LmdldENvbnRleHQuZ2V0U3VwcG9ydGVkRXh0ZW5zaW9ucy42JzogdHJ1ZSxcbiAgJ2dsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50LmdldENvbnRleHQuZ2V0U3VwcG9ydGVkRXh0ZW5zaW9ucy43JzogdHJ1ZSxcbiAgJ2dsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50LmdldENvbnRleHQuZ2V0U3VwcG9ydGVkRXh0ZW5zaW9ucy44JzogdHJ1ZSxcbiAgJ2dsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50LmdldENvbnRleHQuZ2V0U3VwcG9ydGVkRXh0ZW5zaW9ucy45JzogdHJ1ZSxcbiAgJ2dsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50LmdldENvbnRleHQuZ2V0U3VwcG9ydGVkRXh0ZW5zaW9ucy5qb2luJzogdHJ1ZSxcbiAgJ2dsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50LmdldENvbnRleHQuZ2V0U3VwcG9ydGVkRXh0ZW5zaW9ucy5sZW5ndGgnOiB0cnVlLFxuICAnZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQuZ2V0Q29udGV4dC5pc1BvaW50SW5QYXRoJzogdHJ1ZSxcbiAgJ2dsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50Lm9mZnNldEhlaWdodCc6IHRydWUsXG4gICdnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudC5vZmZzZXRXaWR0aCc6IHRydWUsXG4gICdnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudC50b0RhdGFVUkwnOiB0cnVlLFxuICAnZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUV2ZW50JzogdHJ1ZSxcbiAgJ2dsb2JhbC5kb2N1bWVudC5nZXRFbGVtZW50QnlJZCc6IHRydWUsXG4gICdnbG9iYWwuZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSc6IHRydWUsXG4gICdnbG9iYWwuZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZS4wJzogdHJ1ZSxcbiAgJ2dsb2JhbC5kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSc6IHRydWUsXG4gICdnbG9iYWwuZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUuMC5hcHBlbmRDaGlsZCc6IHRydWUsXG4gICdnbG9iYWwuZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUuMC5vZmZzZXRIZWlnaHQnOiB0cnVlLFxuICAnZ2xvYmFsLmRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lLjAub2Zmc2V0V2lkdGgnOiB0cnVlLFxuICAnZ2xvYmFsLmRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lLmFwcGVuZENoaWxkJzogdHJ1ZSxcbiAgJ2dsb2JhbC5kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZS5vZmZzZXRIZWlnaHQnOiB0cnVlLFxuICAnZ2xvYmFsLmRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lLm9mZnNldFdpZHRoJzogdHJ1ZSxcbiAgJ2dsb2JhbC5pbmRleGVkREInOiB0cnVlLFxuICAnZ2xvYmFsLmxvY2FsU3RvcmFnZSc6IHRydWUsXG4gICdnbG9iYWwubmF2aWdhdG9yLmNvb2tpZUVuYWJsZWQnOiB0cnVlLFxuICAnZ2xvYmFsLm5hdmlnYXRvci5jcHVDbGFzcyc6IHRydWUsXG4gICdnbG9iYWwubmF2aWdhdG9yLmRldmljZU1lbW9yeSc6IHRydWUsXG4gICdnbG9iYWwubmF2aWdhdG9yLmRvTm90VHJhY2snOiB0cnVlLFxuICAnZ2xvYmFsLm5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5JzogdHJ1ZSxcbiAgJ2dsb2JhbC5uYXZpZ2F0b3IubGFuZ3VhZ2UnOiB0cnVlLFxuICAnZ2xvYmFsLm5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyc6IHRydWUsXG4gICdnbG9iYWwubmF2aWdhdG9yLm1lZGlhRGV2aWNlcyc6IHRydWUsXG4gICdnbG9iYWwubmF2aWdhdG9yLm1zRG9Ob3RUcmFjayc6IHRydWUsXG4gICdnbG9iYWwubmF2aWdhdG9yLnBsYXRmb3JtJzogdHJ1ZSxcbiAgJ2dsb2JhbC5uYXZpZ2F0b3IucGx1Z2lucyc6IHRydWUsXG4gICdnbG9iYWwubmF2aWdhdG9yLnBsdWdpbnMuMC4wLnN1ZmZpeGVzJzogdHJ1ZSxcbiAgJ2dsb2JhbC5uYXZpZ2F0b3IucGx1Z2lucy4wLjAudHlwZSc6IHRydWUsXG4gICdnbG9iYWwubmF2aWdhdG9yLnBsdWdpbnMuMC5kZXNjcmlwdGlvbic6IHRydWUsXG4gICdnbG9iYWwubmF2aWdhdG9yLnBsdWdpbnMuMC5mb3JFYWNoJzogdHJ1ZSxcbiAgJ2dsb2JhbC5uYXZpZ2F0b3IucGx1Z2lucy4wLmxlbmd0aCc6IHRydWUsXG4gICdnbG9iYWwubmF2aWdhdG9yLnBsdWdpbnMuMC5uYW1lJzogdHJ1ZSxcbiAgJ2dsb2JhbC5uYXZpZ2F0b3IucGx1Z2lucy4xLjAuc3VmZml4ZXMnOiB0cnVlLFxuICAnZ2xvYmFsLm5hdmlnYXRvci5wbHVnaW5zLjEuMC50eXBlJzogdHJ1ZSxcbiAgJ2dsb2JhbC5uYXZpZ2F0b3IucGx1Z2lucy4xLmRlc2NyaXB0aW9uJzogdHJ1ZSxcbiAgJ2dsb2JhbC5uYXZpZ2F0b3IucGx1Z2lucy4xLmZvckVhY2gnOiB0cnVlLFxuICAnZ2xvYmFsLm5hdmlnYXRvci5wbHVnaW5zLjEubGVuZ3RoJzogdHJ1ZSxcbiAgJ2dsb2JhbC5uYXZpZ2F0b3IucGx1Z2lucy4xLm5hbWUnOiB0cnVlLFxuICAnZ2xvYmFsLm5hdmlnYXRvci5wbHVnaW5zLjIuMC5zdWZmaXhlcyc6IHRydWUsXG4gICdnbG9iYWwubmF2aWdhdG9yLnBsdWdpbnMuMi4wLnR5cGUnOiB0cnVlLFxuICAnZ2xvYmFsLm5hdmlnYXRvci5wbHVnaW5zLjIuMS5zdWZmaXhlcyc6IHRydWUsXG4gICdnbG9iYWwubmF2aWdhdG9yLnBsdWdpbnMuMi4xLnR5cGUnOiB0cnVlLFxuICAnZ2xvYmFsLm5hdmlnYXRvci5wbHVnaW5zLjIuZGVzY3JpcHRpb24nOiB0cnVlLFxuICAnZ2xvYmFsLm5hdmlnYXRvci5wbHVnaW5zLjIuZm9yRWFjaCc6IHRydWUsXG4gICdnbG9iYWwubmF2aWdhdG9yLnBsdWdpbnMuMi5sZW5ndGgnOiB0cnVlLFxuICAnZ2xvYmFsLm5hdmlnYXRvci5wbHVnaW5zLjIubmFtZSc6IHRydWUsXG4gICdnbG9iYWwubmF2aWdhdG9yLnBsdWdpbnMuZGVzY3JpcHRpb24nOiB0cnVlLFxuICAnZ2xvYmFsLm5hdmlnYXRvci5wbHVnaW5zLmZvckVhY2gnOiB0cnVlLFxuICAnZ2xvYmFsLm5hdmlnYXRvci5wbHVnaW5zLmxlbmd0aCc6IHRydWUsXG4gICdnbG9iYWwubmF2aWdhdG9yLnBsdWdpbnMubmFtZSc6IHRydWUsXG4gICdnbG9iYWwubmF2aWdhdG9yLnBsdWdpbnMuc3VmZml4ZXMnOiB0cnVlLFxuICAnZ2xvYmFsLm5hdmlnYXRvci5wbHVnaW5zLnR5cGUnOiB0cnVlLFxuICAnZ2xvYmFsLm5hdmlnYXRvci5zeXN0ZW1MYW5ndWFnZSc6IHRydWUsXG4gICdnbG9iYWwubmF2aWdhdG9yLnVzZXJBZ2VudCc6IHRydWUsXG4gICdnbG9iYWwubmF2aWdhdG9yLndlYmRyaXZlcic6IHRydWUsXG4gICdnbG9iYWwub250b3VjaHN0YXJ0JzogdHJ1ZSxcbiAgJ2dsb2JhbC5vcGVuRGF0YWJhc2UnOiB0cnVlLFxuICAnZ2xvYmFsLnNjcmVlbi5hdmFpbEhlaWdodCc6IHRydWUsXG4gICdnbG9iYWwuc2NyZWVuLmF2YWlsV2lkdGgnOiB0cnVlLFxuICAnZ2xvYmFsLnNjcmVlbi5jb2xvckRlcHRoJzogdHJ1ZSxcbiAgJ2dsb2JhbC5zY3JlZW4uZGV2aWNlWERQSSc6IHRydWUsXG4gICdnbG9iYWwuc2NyZWVuLmRldmljZVlEUEknOiB0cnVlLFxuICAnZ2xvYmFsLnNjcmVlbi5oZWlnaHQnOiB0cnVlLFxuICAnZ2xvYmFsLnNjcmVlbi53aWR0aCc6IHRydWUsXG4gICdnbG9iYWwuc2Vzc2lvblN0b3JhZ2UnOiB0cnVlLFxuICAnZ2xvYmFsLnN3Zm9iamVjdCc6IHRydWVcbn1cblxuLy8gXG5cbmVudW0gVG9wIHsgVG9wIH07XG5cbmxldCBNeVNldCA9IFNldDtcblxuZGVjbGFyZSB2YXIgbW9uaXRvcjogTW9uaXRvckJhc2U7XG5cbmV4cG9ydCBjbGFzcyBMYWJlbCB7XG5cbiAgcHJpbmNpcGFsczogU2V0PHN0cmluZz4gfCBUb3A7XG5cbiAgY29uc3RydWN0b3IocD86IFRvcCB8IHN0cmluZyB8IHN0cmluZ1tdLCAuLi5yZXN0OiBzdHJpbmdbXSkge1xuXG4gICAgaWYgKHAgPT09IFRvcC5Ub3ApIHtcbiAgICAgIHRoaXMucHJpbmNpcGFscyA9IFRvcC5Ub3A7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5wcmluY2lwYWxzID0gbmV3IE15U2V0KHJlc3QpO1xuXG4gICAgaWYgKHR5cGVvZiBwID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAvLyAjQ1JBV0xFUiAtIGlmIG5vdCBpbiB0aGUgaW50ZXJlc3RpbmcgbGFiZWwgc2V0LCBiZWNvbWUgYm90XG4gICAgICBpZiAoIWluY2x1ZGVbcF0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5wcmluY2lwYWxzLmFkZChwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHAgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBmb3IgKGxldCB4IG9mIHApIHtcbiAgICAgICAgLy8gI0NSQVdMRVIgLSBpZiBub3QgaW4gdGhlIGludGVyZXN0aW5nIGxhYmVsIHNldCBkb24ndCBhZGRcbiAgICAgICAgaWYgKGluY2x1ZGVbeF0pIHtcbiAgICAgICAgICB0aGlzLnByaW5jaXBhbHMuYWRkKHgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gXG5cbiAgc3RhdGljIGZyb21TdHJpbmcobDogc3RyaW5nKTogTGFiZWwge1xuICAgIHJldHVybiBuZXcgTGFiZWwobC5zcGxpdCgnLCcpKTtcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFxuXG4gIHN0YXRpYyBmcm9tVVJMKGw6IHN0cmluZyk6IExhYmVsIHtcbiAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKCdodHRwOi8vW14vXSovJyk7XG4gICAgdmFyIHJlcyA9IHJlLmV4ZWMobCk7XG4gICAgaWYgKHJlcyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5ldyBMYWJlbChsLnNwbGl0KCcsJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IExhYmVsKFtyZXNbMF1dKTtcbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBcblxuICBlcXVhbHMobDogTGFiZWwpOiBib29sZWFuIHtcblxuICAgIGxldCBBID0gdGhpcy5wcmluY2lwYWxzO1xuICAgIGxldCBCID0gbC5wcmluY2lwYWxzO1xuXG4gICAgaWYgKEEgPT09IFRvcC5Ub3AgfHwgQiA9PT0gVG9wLlRvcCkge1xuICAgICAgcmV0dXJuIEEgPT09IEI7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgcCBvZiBBKSB7XG4gICAgICBpZiAoIUIuaGFzKHApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGxldCBwIG9mIEIpIHtcbiAgICAgIGlmICghQS5oYXMocCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gXG5cbiAgbGUobDogTGFiZWwpOiBib29sZWFuIHtcblxuICAgIGxldCBBID0gdGhpcy5wcmluY2lwYWxzO1xuICAgIGxldCBCID0gbC5wcmluY2lwYWxzO1xuXG4gICAgaWYgKEIgPT09IFRvcC5Ub3ApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChBID09PSBUb3AuVG9wKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgcCBvZiBBKSB7XG4gICAgICBpZiAoIUIuaGFzKHApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFxuXG4gIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgbGV0IHN0ciA9ICdUJztcbiAgICBpZiAodGhpcy5wcmluY2lwYWxzICE9PSBUb3AuVG9wKSB7XG4gICAgICBzdHIgPSBBcnJheS5mcm9tKHRoaXMucHJpbmNpcGFscykuam9pbignLCAnKTtcbiAgICB9XG4gICAgcmV0dXJuIFwiPFwiICsgc3RyICsgXCI+XCI7XG4gIH1cblxuICAvLyAtLS1cblxuICBUb0FycmF5KCkgOiBBcnJheTxzdHJpbmc+IHtcbiAgICBpZiAodGhpcy5wcmluY2lwYWxzID09PSBUb3AuVG9wKSB7XG4gICAgICByZXR1cm4gW1wiVFwiXTtcbiAgICB9XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5wcmluY2lwYWxzKS5zb3J0KCk7XG4gIH1cbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gXG5cbmV4cG9ydCB2YXIgdG9wID0gbmV3IExhYmVsKFRvcC5Ub3ApO1xuZXhwb3J0IHZhciBib3QgPSBuZXcgTGFiZWwoKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gXG5cbmV4cG9ydCBmdW5jdGlvbiBsZShsMSA6IExhYmVsLCBsMiA6IExhYmVsKSB7XG4gIHJldHVybiAobDEubGUobDIpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlKGwxIDogTGFiZWwsIGwyIDogTGFiZWwpIHtcbiAgcmV0dXJuICFsMS5sZShsMikgfHwgbDEuZXF1YWxzKGwyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGx1YiguLi5hcmdzIDogTGFiZWxbXSkge1xuICBpZihhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBib3Q7XG4gIH1cblxuICBsZXQgY29tYmluZWRQcmluY2lwYWxzOiBTZXQ8c3RyaW5nPiA9IG5ldyBNeVNldCgpO1xuICBmb3IobGV0IGwgb2YgYXJncykge1xuICAgIGlmKGwucHJpbmNpcGFscyA9PT0gVG9wLlRvcCkge1xuICAgICAgcmV0dXJuIHRvcDtcbiAgICB9XG5cbiAgICBmb3IobGV0IHAgb2YgbC5wcmluY2lwYWxzKSB7XG4gICAgICBjb21iaW5lZFByaW5jaXBhbHMuYWRkKHApO1xuICAgIH1cbiAgfVxuXG4gIGxldCByZXQgPSBuZXcgTGFiZWwoKTtcbiAgcmV0LnByaW5jaXBhbHMgPSBjb21iaW5lZFByaW5jaXBhbHM7XG5cbiAgLy8gI0NSQVdMRVJcbiAgaWYgKElzQ3Jhd2xlcihtb25pdG9yKSkge1xuICAgIG1vbml0b3IuQ3Jhd2xlckRhdGEuQWRkR2VuZXJhdGVkKHJldCk7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2xiKC4uLmFyZ3MgOiBMYWJlbFtdKSB7XG4gIGlmKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGJvdDtcbiAgfVxuXG4gIGxldCBpbnRlcnNlY3RlZFByaW5jaXBhbHM6IFNldDxzdHJpbmc+ID0gbmV3IE15U2V0KCk7XG4gIGxldCBhbGxJc1RvcCA9IHRydWU7XG4gIGZvcihsZXQgbCBvZiBhcmdzKSB7XG4gICAgaWYobC5wcmluY2lwYWxzICE9PSBUb3AuVG9wKSB7XG4gICAgICBpbnRlcnNlY3RlZFByaW5jaXBhbHMgPSBsLnByaW5jaXBhbHM7XG4gICAgICBhbGxJc1RvcCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYoYWxsSXNUb3ApIHtcbiAgICAvLyBBbGwgaXMgVG9wIVxuICAgIHJldHVybiB0b3A7XG4gIH1cblxuICBmb3IobGV0IGwgb2YgYXJncykge1xuICAgIGlmKGwucHJpbmNpcGFscyA9PT0gVG9wLlRvcCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgZm9yKGxldCBwIG9mIGludGVyc2VjdGVkUHJpbmNpcGFscykge1xuICAgICAgaWYoIWwucHJpbmNpcGFscy5oYXMocCkpIHtcbiAgICAgICAgaW50ZXJzZWN0ZWRQcmluY2lwYWxzLmRlbGV0ZShwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBsZXQgcmV0ID0gbmV3IExhYmVsKCk7XG4gIHJldC5wcmluY2lwYWxzID0gaW50ZXJzZWN0ZWRQcmluY2lwYWxzO1xuICByZXR1cm4gcmV0O1xufVxuIiwiaW1wb3J0IHsgSUVudmlyb25tZW50UmVjb3JkLCBWYWx1ZVR5cGVzLCBJRWNtYU9iamVjdCB9IGZyb20gXCIuL0ludGVyZmFjZXNcIjtcbmltcG9ydCB7IE9iamVjdEVudmlyb25tZW50UmVjb3JkIH0gZnJvbSBcIi4vT2JqZWN0RW52aXJvbm1lbnRSZWNvcmRcIjtcbmltcG9ydCB7IERlY2xhcmF0aXZlRW52aXJvbm1lbnRSZWNvcmQgfSBmcm9tIFwiLi9EZWNsYXJhdGl2ZUVudmlyb25tZW50UmVjb3JkXCI7XG5pbXBvcnQgeyBWYWx1ZSB9IGZyb20gXCIuL1ZhbHVlXCI7XG5pbXBvcnQgeyBNb25pdG9yQmFzZSB9IGZyb20gXCIuL01vbml0b3JCYXNlXCI7XG5cbmRlY2xhcmUgdmFyIG1vbml0b3I6IE1vbml0b3JCYXNlO1xuXG4vLyAtLS1cblxuZXhwb3J0IGNsYXNzIExleGljYWxFbnZpcm9ubWVudCBpbXBsZW1lbnRzIElFbnZpcm9ubWVudFJlY29yZCB7XG5cbiAgRW52aXJvbm1lbnRSZWNvcmQ6IE9iamVjdEVudmlyb25tZW50UmVjb3JkIHwgRGVjbGFyYXRpdmVFbnZpcm9ubWVudFJlY29yZDtcbiAgT3V0ZXJMZXhpY2FsRW52aXJvbm1lbnQ6IFZhbHVlPExleGljYWxFbnZpcm9ubWVudD47XG5cbiAgY29uc3RydWN0b3IoZXI6IE9iamVjdEVudmlyb25tZW50UmVjb3JkIHwgRGVjbGFyYXRpdmVFbnZpcm9ubWVudFJlY29yZCwgbGU6IFZhbHVlPExleGljYWxFbnZpcm9ubWVudD4pIHtcbiAgICB0aGlzLkVudmlyb25tZW50UmVjb3JkID0gZXI7XG4gICAgdGhpcy5PdXRlckxleGljYWxFbnZpcm9ubWVudCA9IGxlO1xuICB9XG5cbiAgcHJvdmlkZVRoaXMoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuRW52aXJvbm1lbnRSZWNvcmQgaW5zdGFuY2VvZiBPYmplY3RFbnZpcm9ubWVudFJlY29yZCkge1xuICAgICAgdGhpcy5FbnZpcm9ubWVudFJlY29yZC5wcm92aWRlVGhpcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgSGFzQmluZGluZyhzOiBWYWx1ZTxzdHJpbmc+KTogVmFsdWU8Ym9vbGVhbj4ge1xuICAgIHJldHVybiB0aGlzLkVudmlyb25tZW50UmVjb3JkLkhhc0JpbmRpbmcocyk7XG4gIH1cblxuICBDcmVhdGVNdXRhYmxlQmluZGluZyhwOiBWYWx1ZTxzdHJpbmc+LCBkPzogYm9vbGVhbik6IHZvaWQge1xuICAgIHJldHVybiB0aGlzLkVudmlyb25tZW50UmVjb3JkLkNyZWF0ZU11dGFibGVCaW5kaW5nKHAsIGQpO1xuICB9XG5cbiAgU2V0TXV0YWJsZUJpbmRpbmcocDogVmFsdWU8c3RyaW5nPiwgdjogVmFsdWU8VmFsdWVUeXBlcz4sIHM/OiBib29sZWFuKTogdm9pZCB7XG4gICAgcmV0dXJuIHRoaXMuRW52aXJvbm1lbnRSZWNvcmQuU2V0TXV0YWJsZUJpbmRpbmcocCwgdiwgcyk7XG4gIH1cblxuICBHZXRCaW5kaW5nVmFsdWUocDogVmFsdWU8c3RyaW5nPiwgcz86IGJvb2xlYW4pOiBWYWx1ZTxWYWx1ZVR5cGVzPiB7XG4gICAgcmV0dXJuIHRoaXMuRW52aXJvbm1lbnRSZWNvcmQuR2V0QmluZGluZ1ZhbHVlKHAsIHMpO1xuICB9XG5cbiAgRGVsZXRlQmluZGluZyhwOiBWYWx1ZTxzdHJpbmc+KTogVmFsdWU8Ym9vbGVhbj4ge1xuICAgIHJldHVybiB0aGlzLkVudmlyb25tZW50UmVjb3JkLkRlbGV0ZUJpbmRpbmcocCk7XG4gIH1cblxuICBJbXBsaWNpdFRoaXNWYWx1ZSgpOiBWYWx1ZTxJRWNtYU9iamVjdCB8IHVuZGVmaW5lZD4ge1xuICAgIHJldHVybiB0aGlzLkVudmlyb25tZW50UmVjb3JkLkltcGxpY2l0VGhpc1ZhbHVlKCk7XG4gIH1cblxuICAvLyBUT0RPOiBmaXhcbiAgLy8gT25seSBtZWFuaW5nZnVsIGlmIHRoZSB1bmRlcmx5aW5nIGVudmlyb25tZW50IHJlY29yZCBpcyBcbiAgLy8gIGEgZGVjbGFyYXRpdmUgZW52aXJvbm1lbnQgcmVjb3JkXG4gIENyZWF0ZUltbXV0YWJsZUJpbmRpbmcocDogVmFsdWU8c3RyaW5nPiwgcz86IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAvL0B0cy1pZ25vcmUgVFlQRVNcbiAgICB0aGlzLkVudmlyb25tZW50UmVjb3JkLkNyZWF0ZUltbXV0YWJsZUJpbmRpbmcocCk7XG4gIH1cblxuICBJbml0aWFsaXplSW1tdXRhYmxlQmluZGluZyhwIDogVmFsdWU8c3RyaW5nPiwgdiA6IFZhbHVlPFZhbHVlVHlwZXM+KSA6IHZvaWQgIHtcbiAgICAvL0B0cy1pZ25vcmUgVFlQRVNcbiAgICB0aGlzLkVudmlyb25tZW50UmVjb3JkLkluaXRpYWxpemVJbW11dGFibGVCaW5kaW5nKHAsIHYpO1xuICB9XG5cbn0iLCJpbXBvcnQgeyBWYWx1ZSB9IGZyb20gXCIuLi8uLi9WYWx1ZVwiO1xuaW1wb3J0IHsgYm90IH0gZnJvbSBcIi4uLy4uL0xhYmVsXCI7XG5pbXBvcnQgeyBSZXF1aXJlIH0gZnJvbSBcIi4uL1JlcXVpcmVcIjtcbmltcG9ydCB7IE1vZHVsZSB9IGZyb20gXCIuLi9Nb2R1bGVcIjtcbmltcG9ydCB7IE1vbml0b3JCYXNlIH0gZnJvbSBcIi4uLy4uL01vbml0b3JCYXNlXCI7XG5pbXBvcnQgeyBWYWx1ZVR5cGVzIH0gZnJvbSBcIi4uLy4uL0ludGVyZmFjZXNcIjtcbmltcG9ydCB7IHJlYWRGaWxlU3luYyB9IGZyb20gXCJmc1wiO1xuaW1wb3J0IHsgYmFzZW5hbWUsIGRpcm5hbWUgfSBmcm9tIFwicGF0aFwiO1xuaW1wb3J0IHsgQ29tbW9uSlNSZXF1aXJlIH0gZnJvbSBcIi4vUmVxdWlyZVwiO1xuXG5cbmRlY2xhcmUgdmFyIG1vbml0b3I6IE1vbml0b3JCYXNlO1xuXG4vLy0tLVxuXG5leHBvcnQgY2xhc3MgQ29tbW9uSlNNb2R1bGUgZXh0ZW5kcyBNb2R1bGUge1xuXG4gICAgcmVxdWlyZTogUmVxdWlyZTtcblxuICAgIGNvbnN0cnVjdG9yKGZpbGVuYW1lPzogVmFsdWU8c3RyaW5nPiwgcGFyZW50PzogTW9kdWxlKSB7XG4gICAgICAgIHN1cGVyKGZpbGVuYW1lLCBwYXJlbnQpO1xuXG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLnJlcXVpcmUgPSBuZXcgQ29tbW9uSlNSZXF1aXJlKHRoaXMpO1xuICAgICAgICB0aGlzLlB1dChuZXcgVmFsdWUoJ3JlcXVpcmUnLCBib3QpLCBuZXcgVmFsdWUodGhpcy5yZXF1aXJlLCBib3QpLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgc3RhdGljIExvYWRNb2R1bGUocGF0aDogVmFsdWU8c3RyaW5nPiwgcGFyZW50PzogTW9kdWxlKTogVmFsdWU8VmFsdWVUeXBlcz4ge1xuICAgICAgICBsZXQgc2NyaXB0ID0gcmVhZEZpbGVTeW5jKHBhdGgudmFsdWUpLnRvU3RyaW5nKCk7XG4gICAgICAgIGxldCBtb2R1bGVGdW5jdGlvbiA9IG1vbml0b3IuaW5zdGFuY2VzLkZ1bmN0aW9uQ29uc3RydWN0b3IuQ29uc3RydWN0KFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIG5ldyBWYWx1ZSgncmVxdWlyZScsIGJvdCksXG4gICAgICAgICAgICAgICAgbmV3IFZhbHVlKCdtb2R1bGUnLCBib3QpLFxuICAgICAgICAgICAgICAgIG5ldyBWYWx1ZSgnZXhwb3J0cycsIGJvdCksXG4gICAgICAgICAgICAgICAgbmV3IFZhbHVlKCdfX2ZpbGVuYW1lJywgYm90KSxcbiAgICAgICAgICAgICAgICBuZXcgVmFsdWUoJ19fZGlybmFtZScsIGJvdCksXG4gICAgICAgICAgICAgICAgbmV3IFZhbHVlKHNjcmlwdCwgcGF0aC5sYWJlbClcbiAgICAgICAgICAgIF1cbiAgICAgICAgKTtcblxuICAgICAgICBsZXQgbW9kdWxlID0gbmV3IENvbW1vbkpTTW9kdWxlKHBhdGgsIHBhcmVudCk7XG4gICAgICAgIGxldCBleHBvcnRzT2JqZWN0ID0gbW9kdWxlLkdldChuZXcgVmFsdWUoJ2V4cG9ydHMnLCBib3QpKTtcbiAgICAgICAgUmVxdWlyZS5jYWNoZS5zZXQocGF0aC52YWx1ZSwgZXhwb3J0c09iamVjdCk7XG5cbiAgICAgICAgbW9kdWxlRnVuY3Rpb24uQ2FsbChcbiAgICAgICAgICAgIG5ldyBWYWx1ZSh1bmRlZmluZWQsIGJvdCksXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgbmV3IFZhbHVlKG1vZHVsZS5yZXF1aXJlLCBib3QpLFxuICAgICAgICAgICAgICAgIG5ldyBWYWx1ZShtb2R1bGUsIGJvdCksXG4gICAgICAgICAgICAgICAgZXhwb3J0c09iamVjdCxcbiAgICAgICAgICAgICAgICBuZXcgVmFsdWUoYmFzZW5hbWUocGF0aC52YWx1ZSksIHBhdGgubGFiZWwpLFxuICAgICAgICAgICAgICAgIG5ldyBWYWx1ZShkaXJuYW1lKHBhdGgudmFsdWUpLCBwYXRoLmxhYmVsKVxuICAgICAgICAgICAgXVxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBtb2R1bGUuR2V0KG5ldyBWYWx1ZSgnZXhwb3J0cycsIGJvdCkpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBub3JtYWxpemUsIGpvaW4sIHJlc29sdmUgfSBmcm9tIFwicGF0aFwiO1xuaW1wb3J0IHsgZXhpc3RzU3luYyB9IGZyb20gXCJmc1wiO1xuaW1wb3J0IHsgUmVxdWlyZSB9IGZyb20gXCIuLi9SZXF1aXJlXCI7XG5pbXBvcnQgeyBNb2R1bGUgfSBmcm9tIFwiLi4vTW9kdWxlXCI7XG5pbXBvcnQgeyBWYWx1ZSB9IGZyb20gXCIuLi8uLi9WYWx1ZVwiO1xuaW1wb3J0IHsgVmFsdWVUeXBlcyB9IGZyb20gXCIuLi8uLi9JbnRlcmZhY2VzXCI7XG5pbXBvcnQgeyBsdWIgfSBmcm9tIFwiLi4vLi4vTGFiZWxcIjtcbmltcG9ydCB7IENvbW1vbkpTTW9kdWxlIH0gZnJvbSBcIi4vTW9kdWxlXCI7XG5cblxuZXhwb3J0IGNsYXNzIENvbW1vbkpTUmVxdWlyZSBleHRlbmRzIFJlcXVpcmUge1xuXG4gICAgY29uc3RydWN0b3IobW9kdWxlOiBNb2R1bGUpIHtcbiAgICAgICAgc3VwZXIobW9kdWxlKTtcbiAgICB9XG5cbiAgICBUcnlMb2FkKGxhYmVsZWRJRDogVmFsdWU8c3RyaW5nPik6IFZhbHVlPFZhbHVlVHlwZXM+IHwgdW5kZWZpbmVkIHtcbiAgICAgICAgbGV0IGlkID0gbGFiZWxlZElELnZhbHVlO1xuXG4gICAgICAgIGZvciAobGV0IHBhcmVudFBhdGggb2YgdGhpcy5tb2R1bGUucGF0aHMpIHtcbiAgICAgICAgICAgIGlmIChpZC5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRQYXRoID0gJy8nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaWQuc3RhcnRzV2l0aCgnLi8nKSB8fCBpZC5zdGFydHNXaXRoKCcvJykgfHwgaWQuc3RhcnRzV2l0aCgnLi4vJykpIHtcbiAgICAgICAgICAgICAgICBsZXQgbW9kdWxlUGF0aCA9IHJlc29sdmUoam9pbihwYXJlbnRQYXRoLCBpZCkpO1xuICAgICAgICAgICAgICAgIGlmIChleGlzdHNTeW5jKG1vZHVsZVBhdGgpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKFJlcXVpcmUuY2FjaGUuZ2V0KG1vZHVsZVBhdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbW9kdWxlID0gUmVxdWlyZS5jYWNoZS5nZXQobW9kdWxlUGF0aCkgYXMgVmFsdWU8TW9kdWxlPjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZS5yYWlzZShsdWIodGhpcy5sYWJlbCwgbGFiZWxlZElELmxhYmVsKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9kdWxlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIENvbW1vbkpTTW9kdWxlLkxvYWRNb2R1bGUobmV3IFZhbHVlKG1vZHVsZVBhdGgsIGxhYmVsZWRJRC5sYWJlbCksIHRoaXMubW9kdWxlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb2R1bGVQYXRoID0gcmVzb2x2ZShqb2luKHBhcmVudFBhdGgsIGlkICsgJy5qcycpKTtcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RzU3luYyhtb2R1bGVQYXRoKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChSZXF1aXJlLmNhY2hlLmdldChtb2R1bGVQYXRoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1vZHVsZSA9IFJlcXVpcmUuY2FjaGUuZ2V0KG1vZHVsZVBhdGgpIGFzIFZhbHVlPE1vZHVsZT47XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGUucmFpc2UobHViKHRoaXMubGFiZWwsIGxhYmVsZWRJRC5sYWJlbCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vZHVsZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBDb21tb25KU01vZHVsZS5Mb2FkTW9kdWxlKG5ldyBWYWx1ZShtb2R1bGVQYXRoLCBsYWJlbGVkSUQubGFiZWwpLCB0aGlzLm1vZHVsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59IiwiaW1wb3J0IHsgVmFsdWUgfSBmcm9tIFwiLi4vVmFsdWVcIjtcbmltcG9ydCB7IE1vbml0b3JCYXNlIH0gZnJvbSBcIi4uL01vbml0b3JCYXNlXCI7XG5pbXBvcnQgeyBPYmplY3RPYmplY3QgfSBmcm9tIFwiLi4vT2JqZWN0cy9PYmplY3RPYmplY3RcIjtcbmltcG9ydCB7IGRpcm5hbWUgfSBmcm9tIFwicGF0aFwiO1xuaW1wb3J0IHsgRWNtYU9iamVjdCB9IGZyb20gXCIuLi9PYmplY3RzL0VjbWFPYmplY3RcIjtcbmltcG9ydCB7IGJvdCwgTGFiZWwsIGx1YiB9IGZyb20gXCIuLi9MYWJlbFwiO1xuaW1wb3J0IHsgY3dkIH0gZnJvbSBcInByb2Nlc3NcIjtcbmltcG9ydCB7IFJlcXVpcmUgfSBmcm9tIFwiLi9SZXF1aXJlXCI7XG5pbXBvcnQgeyBWYWx1ZVR5cGVzIH0gZnJvbSBcIi4uL0ludGVyZmFjZXNcIjtcblxuZGVjbGFyZSB2YXIgbW9uaXRvcjogTW9uaXRvckJhc2U7XG5cbi8vIC0tLVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgTW9kdWxlIGV4dGVuZHMgRWNtYU9iamVjdCB7XG5cbiAgICBsYWJlbDogTGFiZWw7XG4gICAgZmlsZW5hbWU/OiBzdHJpbmc7XG4gICAgcGF0aHM6IHN0cmluZ1tdO1xuXG4gICAgcGFyZW50OiBNb2R1bGUgfCB1bmRlZmluZWQ7XG5cbiAgICBhYnN0cmFjdCByZXF1aXJlOiBSZXF1aXJlO1xuXG4gICAgY29uc3RydWN0b3IoZmlsZW5hbWU/OiBWYWx1ZTxzdHJpbmc+LCBwYXJlbnQ/OiBNb2R1bGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5DbGFzcyA9ICdNb2R1bGUnO1xuXG4gICAgICAgIGlmIChmaWxlbmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmxhYmVsID0gbHViKGZpbGVuYW1lLmxhYmVsLCBtb25pdG9yLmNvbnRleHQuZWZmZWN0aXZlUEMpO1xuICAgICAgICAgICAgdGhpcy5maWxlbmFtZSA9IGZpbGVuYW1lLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5wYXRocyA9IHRoaXMuY29tcHV0ZVBhdGhzKGRpcm5hbWUodGhpcy5maWxlbmFtZSkpO1xuICAgICAgICAgICAgdGhpcy5QdXQobmV3IFZhbHVlKCdmaWxlbmFtZScsIGJvdCksIGZpbGVuYW1lLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLlB1dChuZXcgVmFsdWUoJ2lkJywgYm90KSwgZmlsZW5hbWUsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGFiZWwgPSBtb25pdG9yLmNvbnRleHQuZWZmZWN0aXZlUEM7XG4gICAgICAgICAgICB0aGlzLnBhdGhzID0gdGhpcy5jb21wdXRlUGF0aHMoY3dkKCkpO1xuICAgICAgICAgICAgdGhpcy5QdXQobmV3IFZhbHVlKCdmaWxlbmFtZScsIGJvdCksIG5ldyBWYWx1ZSh1bmRlZmluZWQsIGJvdCksIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuUHV0KG5ldyBWYWx1ZSgnaWQnLCBib3QpLCBuZXcgVmFsdWUoXCI8cmVwbD5cIiwgYm90KSwgZmFsc2UpO1xuXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZXhwb3J0c09iamVjdCA9IG5ldyBPYmplY3RPYmplY3QoKTtcbiAgICAgICAgdGhpcy5QdXQobmV3IFZhbHVlKCdleHBvcnRzJywgYm90KSwgbmV3IFZhbHVlKGV4cG9ydHNPYmplY3QsIGJvdCksIGZhbHNlKTtcbiAgICB9XG5cbiAgICBjb21wdXRlUGF0aHMoZGlybmFtZTogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgICAgICByZXR1cm4gW2Rpcm5hbWVdO1xuICAgIH1cblxufVxuIiwiaW1wb3J0IHsgVmFsdWUgfSBmcm9tIFwiLi4vVmFsdWVcIjtcbmltcG9ydCB7IFZhbHVlVHlwZXMgfSBmcm9tIFwiLi4vSW50ZXJmYWNlc1wiO1xuaW1wb3J0IHsgRWNtYU9iamVjdCB9IGZyb20gXCIuLi9PYmplY3RzL0VjbWFPYmplY3RcIjtcbmltcG9ydCB7IExhYmVsLCBsdWIgfSBmcm9tIFwiLi4vTGFiZWxcIjtcbmltcG9ydCB7IE1vZHVsZSB9IGZyb20gXCIuL01vZHVsZVwiO1xuaW1wb3J0IHsgTW9uaXRvckJhc2UgfSBmcm9tIFwiLi4vTW9uaXRvckJhc2VcIjtcblxuZGVjbGFyZSB2YXIgbW9uaXRvcjogTW9uaXRvckJhc2U7XG5cbi8vIC0tLVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgUmVxdWlyZSBleHRlbmRzIEVjbWFPYmplY3Qge1xuXG4gICAgbGFiZWw6IExhYmVsO1xuXG4gICAgbW9kdWxlOiBNb2R1bGU7XG4gICAgbWFpbj86IE1vZHVsZTtcbiAgICBzdGF0aWMgY2FjaGU6IE1hcDxzdHJpbmcsIFZhbHVlPFZhbHVlVHlwZXM+PiA9IG5ldyBNYXAoKTtcblxuICAgIGNvbnN0cnVjdG9yKG1vZHVsZTogTW9kdWxlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuQ2xhc3MgPSAnUmVxdWlyZSc7XG4gICAgICAgIHRoaXMubW9kdWxlID0gbW9kdWxlO1xuXG4gICAgICAgIC8vIHRoaXMgaXMgdGhlIHRvcG1vc3QgcmVxdWlyZVxuICAgICAgICBpZiAobW9kdWxlLnBhcmVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmxhYmVsID0gbW9uaXRvci5jb250ZXh0LmVmZmVjdGl2ZVBDO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tYWluID0gbW9kdWxlLnBhcmVudC5yZXF1aXJlLm1haW47XG4gICAgICAgICAgICB0aGlzLmxhYmVsID0gbHViKG1vZHVsZS5sYWJlbCwgbW9uaXRvci5jb250ZXh0LmVmZmVjdGl2ZVBDKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIC0tLVxuXG4gICAgQ2FsbCh0aGlzQXJnOiBWYWx1ZTxWYWx1ZVR5cGVzPiwgYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPFZhbHVlVHlwZXM+IHtcbiAgICAgICAgbGV0IGxhYmVsZWRJRCA9IGFyZ3NbMF07XG4gICAgICAgIGlmICh0eXBlb2YgbGFiZWxlZElELnZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbW9uaXRvci5UaHJvdyhcbiAgICAgICAgICAgICAgICBcIlR5cGVFcnJvclwiLFxuICAgICAgICAgICAgICAgICdyZXF1aXJlIGV4cGVjdHMgYSBzdHJpbmcnLFxuICAgICAgICAgICAgICAgIHRoaXNBcmcubGFiZWxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aHJvdyAnVHlwZVNjcmlwdCc7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbW9kdWxlID0gdGhpcy5UcnlMb2FkKGxhYmVsZWRJRCBhcyBWYWx1ZTxzdHJpbmc+KTtcblxuICAgICAgICBpZiAobW9kdWxlID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgbW9uaXRvci5UaHJvdyhcbiAgICAgICAgICAgICAgICBcIkVycm9yXCIsXG4gICAgICAgICAgICAgICAgYCR7bGFiZWxlZElELnZhbHVlfSBub3QgZm91bmRgLFxuICAgICAgICAgICAgICAgIHRoaXNBcmcubGFiZWxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aHJvdyAnVHlwZVNjcmlwdCc7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtb2R1bGU7XG4gICAgfVxuXG4gICAgQ29uc3RydWN0KGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxWYWx1ZVR5cGVzPiB7XG4gICAgICAgIG1vbml0b3IuZmF0YWwoJ0Nhbm5vdCB1c2UgcmVxdWlyZSBhcyBhIGNvbnN0cnVjdG9yJyk7XG4gICAgICAgIHRocm93ICdUeXBlU2NyaXB0JztcbiAgICB9XG5cbiAgICAvLyAtLS1cbiAgICBhYnN0cmFjdCBUcnlMb2FkKGxhYmVsZWRJRDogVmFsdWU8c3RyaW5nPik6IFZhbHVlPFZhbHVlVHlwZXM+IHwgdW5kZWZpbmVkO1xufSIsIi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uICovXG5cbmltcG9ydCB7IExhYmVsLCBsZSwgYm90IH0gZnJvbSAnLi9MYWJlbCc7XG5pbXBvcnQgeyBWYWx1ZSB9IGZyb20gXCIuL1ZhbHVlXCI7XG5pbXBvcnQgeyBDb250ZXh0IH0gZnJvbSAnLi9Db250ZXh0JztcbmltcG9ydCB7IE9wdGlvbnMgfSBmcm9tICcuL09wdGlvbnMnO1xuaW1wb3J0IHsgU3RhY2sgfSBmcm9tICcuL1N0YWNrJztcblxuaW1wb3J0IHsgSW5zdGFuY2VzIH0gZnJvbSAnLi9JbnN0YW5jZXMnO1xuaW1wb3J0IHsgRXJyb3JPYmplY3QgfSBmcm9tICcuL09iamVjdHMvRXJyb3JPYmplY3QnO1xuaW1wb3J0IHsgRXZhbEVycm9yT2JqZWN0IH0gZnJvbSAnLi9PYmplY3RzL0V2YWxFcnJvck9iamVjdCc7XG5pbXBvcnQgeyBSYW5nZUVycm9yT2JqZWN0IH0gZnJvbSAnLi9PYmplY3RzL1JhbmdlRXJyb3JPYmplY3QnO1xuaW1wb3J0IHsgUmVmZXJlbmNlRXJyb3JPYmplY3QgfSBmcm9tICcuL09iamVjdHMvUmVmZXJlbmNlRXJyb3JPYmplY3QnO1xuaW1wb3J0IHsgU3ludGF4RXJyb3JPYmplY3QgfSBmcm9tICcuL09iamVjdHMvU3ludGF4RXJyb3JPYmplY3QnO1xuaW1wb3J0IHsgVHlwZUVycm9yT2JqZWN0IH0gZnJvbSAnLi9PYmplY3RzL1R5cGVFcnJvck9iamVjdCc7XG5pbXBvcnQgeyBVUklFcnJvck9iamVjdCB9IGZyb20gJy4vT2JqZWN0cy9VUklFcnJvck9iamVjdCc7XG5pbXBvcnQgeyBHbG9iYWxPYmplY3QgfSBmcm9tICcuL09iamVjdHMvR2xvYmFsT2JqZWN0JztcbmltcG9ydCB7IFRocm93VHlwZSwgVmFsdWVUeXBlcyB9IGZyb20gJy4vSW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBMZXhpY2FsRW52aXJvbm1lbnQgfSBmcm9tICcuL0xleGljYWxFbnZpcm9ubWVudCc7XG5cbmltcG9ydCAqIGFzIGVzdHJlZSBmcm9tICdlc3RyZWUnO1xuaW1wb3J0IHsgU3RhY2tUcmFjZSB9IGZyb20gJy4vU3RhY2tUcmFjZSc7XG5pbXBvcnQgeyBydW5uaW5nLCBleGVjdXRlR2xvYmFsQ29kZSwgcmVzdW1lIH0gZnJvbSAnLi9FbmdpbmUvRXhlY3V0ZSc7XG5pbXBvcnQgeyBGYXRhbEVycm9yLCBTZWN1cml0eUVycm9yLCBpc0pTRmxvd0Vycm9yIH0gZnJvbSAnLi9FcnJvcic7XG5cbmltcG9ydCAqIGFzIGJlYXV0aWZ5IGZyb20gXCJqcy1iZWF1dGlmeVwiO1xuXG5kZWNsYXJlIHZhciBtb25pdG9yOiBNb25pdG9yQmFzZTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGNsYXNzIEV4ZWN1dGlvbkluZm8ge1xuXG4gIHN0ZXBzIDogbnVtYmVyO1xuICB0aW1lIDogbnVtYmVyO1xuICBkZWx0YSA9IDEwMDAwMDtcblxuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5zdGVwcyA9IDA7XG4gICAgdGhpcy50aW1lID0gRGF0ZS5ub3coKTtcbiAgfVxuXG4gIHN0ZXAoKSB7XG4gICAgdGhpcy5zdGVwcysrO1xuICAgIGlmICh0aGlzLnN0ZXBzICUgdGhpcy5kZWx0YSA9PT0gMCkge1xuICAgICAgdGhpcy5yZXBvcnQoKTtcbiAgICB9XG4gIH1cblxuICByZXBvcnQoKSA6IHZvaWQge1xuICAgIGlmICghbW9uaXRvci5vcHRpb25zLmdldCgnbW9uaXRvci5wcm9ncmVzcycpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBsZXQgZWxhcHNlZCA9IChjdXJyZW50VGltZSAtIHRoaXMudGltZSkvMTAwMDtcbiAgICBtb25pdG9yLmluZm8oYEV4ZWN1dGVkIGEgdG90YWwgb2YgJHt0aGlzLnN0ZXBzfSBzdGVwcyBpbiAke2VsYXBzZWR9IHNlY29uZHMgYXQgYW4gYXZlcmFnZSByYXRlIG9mICR7TWF0aC5mbG9vcih0aGlzLnN0ZXBzL2VsYXBzZWQpfSBzdGVwcy9zZWNvbmRgKTtcbiAgfVxuICBcbn1cblxuLy9cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIE1vbml0b3JCYXNlIHtcblxuICBvcHRpb25zOiBPcHRpb25zO1xuICBkZWJ1ZzogeyBhY3RpdmU6IGJvb2xlYW4gfVxuICBjb250ZXh0U3RhY2s6IFN0YWNrPENvbnRleHQ+ID0gbmV3IFN0YWNrKCk7XG4gIGV4ZWN1dGlvbkluZm8gOiBFeGVjdXRpb25JbmZvO1xuXG4gIGNvZGU/OiBzdHJpbmc7IC8vIHNldCBieSBleGVjdXRlR2xvYmFsQ29kZVxuICBhc3Q/OiBlc3RyZWUuUHJvZ3JhbTsgLy8gc2V0IGJ5IGV4ZWN1dGVHbG9iYWxDb2RlXG4gIG9mZmVuZGluZ1RyYWNlPyA6IFN0YWNrVHJhY2U7IC8vIHNldCBieXQgdGhyb3dTdGF0ZW1lbnRFbmRcblxuICBhYnN0cmFjdCBpbnN0YW5jZXM6IEluc3RhbmNlcztcbiAgYWJzdHJhY3QgR2xvYmFsT2JqZWN0OiBHbG9iYWxPYmplY3Q7XG4gIGFic3RyYWN0IEdsb2JhbEVudmlyb25tZW50OiBMZXhpY2FsRW52aXJvbm1lbnQ7XG5cbiAgcHJpbnQ6ICguLi5yZXN0OiBhbnlbXSkgPT4gdm9pZDtcbiAgbG9nOiAoLi4ucmVzdDogYW55W10pID0+IHZvaWQ7XG4gIGluZm86ICguLi5yZXN0OiBhbnlbXSkgPT4gdm9pZDtcbiAgd2FybjogKC4uLnJlc3Q6IGFueVtdKSA9PiB2b2lkO1xuICBlcnJvcjogKC4uLnJlc3Q6IGFueVtdKSA9PiB2b2lkO1xuXG4gIC8vIC0tLVxuICAvLyBjb25zdHJ1Y3RvclxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIGdsb2JhbDogYW55LFxuICAgIHByaW50OiAoLi4ucmVzdDogYW55W10pID0+IHZvaWQsXG4gICAgbG9nOiAoLi4ucmVzdDogYW55W10pID0+IHZvaWQsXG4gICAgaW5mbzogKC4uLnJlc3Q6IGFueVtdKSA9PiB2b2lkLFxuICAgIHdhcm46ICguLi5yZXN0OiBhbnlbXSkgPT4gdm9pZCxcbiAgICBlcnJvcjogKC4uLnJlc3Q6IGFueVtdKSA9PiB2b2lkXG4gICkge1xuICAgIGdsb2JhbC5tb25pdG9yID0gdGhpcztcbiAgICBnbG9iYWwuSlNGTE9XX1NUQUNLX0NIRUNLID0gdHJ1ZTtcblxuICAgIHRoaXMucHJpbnQgPSBwcmludCA/IHByaW50IDogY29uc29sZS5sb2c7XG4gICAgdGhpcy5sb2cgPSBsb2cgPyBsb2cgOiBjb25zb2xlLmxvZztcbiAgICB0aGlzLndhcm4gPSB3YXJuID8gd2FybiA6IGNvbnNvbGUud2FybjtcbiAgICB0aGlzLmluZm8gPSBpbmZvID8gaW5mbyA6IGNvbnNvbGUuaW5mbztcbiAgICB0aGlzLmVycm9yID0gZXJyb3IgPyBlcnJvciA6IGNvbnNvbGUuZXJyb3I7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBuZXcgT3B0aW9ucygpO1xuXG4gICAgLypcbiAgICAqIHRhaW50TW9kZSBkaXNhYmxlcyB0aGUgY29udGV4dCBjb21wdXRhdGlvbiBieSBvdmVycmlkaW5nIGV4YywgcmV0LCBwYywgYW5kIGVmZmVjdGl2ZVBDIFxuICAgICogZm9yY2luZyB0aGVtIHRvIHJldHVybiBib3RcbiAgICAqL1xuICAgIHRoaXMub3B0aW9ucy5kZWNsYXJlKCdtb25pdG9yLnRhaW50TW9kZScsICdib29sZWFuJywgZmFsc2UsICd0YWludCBtb2RlJyk7XG4gICAgLypcbiAgICAqIHRlc3RNb2RlIHN1cHJlc3NlcyBsYWJlbCBwcmludGluZyBpbiBvdXRwdXQgYW5kIHNlY3VyaXR5IGVycm9yc1xuICAgICogdG8gbWFrZSBqc2Zsb3cgY29tcGF0aWJsZSB3aXRoIHRoZSB0ZXN0IGhhcm5lc3Mgc2V0IGJ5IHRoZSBzcGlkZXJmbG93IGFuZCBub2RlZmxvdyBjb21tYW5kc1xuICAgICovXG4gICAgdGhpcy5vcHRpb25zLmRlY2xhcmUoJ21vbml0b3IudGVzdE1vZGUnLCAnYm9vbGVhbicsIGZhbHNlLCAndGVzdCBtb2RlJyk7XG4gICAgLyogb2JzZXJ2YWJsZU1vZGUgc3VwcmVzc2VzIHN0b3Atb24tc2VjdXJpdHktZXJyb3IgYWxsb3dpbmcgZXhlY3V0aW9uIHRvIGNvbnRpbnVlIHdpdGhcbiAgICAqIGEgcHJpbnRlZCB3YXJuaW5nIG1lc3NhZ2UuXG4gICAgKi9cbiAgICB0aGlzLm9wdGlvbnMuZGVjbGFyZSgnbW9uaXRvci5vYnNlcnZhYmxlTW9kZScsICdib29sZWFuJywgZmFsc2UsICdvYnNlcnZhYmxlIG1vZGUnKTtcbiAgICAvKiBwcm9ncmVzcyBjYXVzZXMganNmbG93IHRvIHJlZ3VsYXJseSByZXBvcnQgaXRzIGV4ZWN1dGlvbiBwcm9ncmVzcy5cbiAgICAqL1xuICAgIHRoaXMub3B0aW9ucy5kZWNsYXJlKCdtb25pdG9yLnByb2dyZXNzJywgJ2Jvb2xlYW4nLCBmYWxzZSwgJ3Byb2dyZXNzIG1vZGUnKTtcbiAgICAvKiBjcmF3bGVyIHR1cm5zIG9uIGNyYXdsZXIgc3BlY2lmaWMgZ2F0aGVyaW5nIGNvZGUgdGhhdCBkb2N1bWVudHMgZGlmZmVyZW50IGFzcGVjdHMgb2YgdGhlIGV4ZWN1dGlvbi5cbiAgICAqL1xuICAgIHRoaXMub3B0aW9ucy5kZWNsYXJlKCdtb25pdG9yLmNyYXdsZXInLCAnYm9vbGVhbicsIGZhbHNlLCAnY3Jhd2xlcicpO1xuXG5cbiAgICB0aGlzLmRlYnVnID0geyBhY3RpdmU6IGZhbHNlIH07XG5cbiAgICAvL0B0cy1pZ25vcmVcbiAgICBsZXQgY29udGV4dCA9IG5ldyBDb250ZXh0KG51bGwsIG51bGwsIG51bGwpO1xuICAgIHRoaXMuY29udGV4dFN0YWNrLnB1c2goY29udGV4dCk7XG5cbiAgICB0aGlzLmV4ZWN1dGlvbkluZm8gPSBuZXcgRXhlY3V0aW9uSW5mbygpO1xuICB9XG5cbiAgLy8gLS0tXG5cbiAgZ2V0IGNvbnRleHQoKTogQ29udGV4dCB7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dFN0YWNrLnBlZWsoKTtcbiAgfVxuXG4gIC8vIC0tLVxuXG4gIHJ1bm5pbmcoKSB7XG4gICAgcmV0dXJuIHJ1bm5pbmcoKTtcbiAgfTtcblxuICAvLyAtLS1cblxuICAvLyAtLS1cbiAgLy8gdGhyb3dzOlxuICAvLyAgVmFsdWU8VmFsdWVUeXBlPiBvclxuICAvLyAgSlNGbG93RXJyb3IsIHdoZW4gc2VjdXJpdHkgZXJyb3Igb3IgZmF0YWwgZXJyb3JcblxuICBFeGVjdXRlKGNvZGU6IHN0cmluZywgb3JpZ2luOiBzdHJpbmcpIDogVmFsdWU8VmFsdWVUeXBlcz4ge1xuICAgIHZhciByZXN1bHQgPSBleGVjdXRlR2xvYmFsQ29kZShjb2RlLCBvcmlnaW4pO1xuXG4gICAgaWYgKHJlc3VsdC50eXBlID09PSAndGhyb3cnKSB7XG4gICAgICB0aHJvdyByZXN1bHQudmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgfVxuXG4gIC8vIC0tLVxuICAvLyB0aHJvd3M6XG4gIC8vICBWYWx1ZTxWYWx1ZVR5cGU+IG9yXG4gIC8vICBKU0Zsb3dFcnJvciwgd2hlbiBzZWN1cml0eSBlcnJvciBvciBmYXRhbCBlcnJvclxuXG4gIGFic3RyYWN0IEV4ZWN1dGVNb2R1bGUocGF0aCA6IHN0cmluZykgOiB2b2lkO1xuXG4gIC8vIC0tLVxuICAvLyBjb2RlIHRyYW5zZm9ybWF0aW9uIHN1cHBvcnRcblxuICB0cmFuc2Zvcm0oY29kZSA6IHN0cmluZykgOiBzdHJpbmcge1xuICAgIHJldHVybiBjb2RlO1xuICB9XG5cbiAgLy8gLS0tXG5cbiAgYmVhdXRpZnkoY29kZSA6IHN0cmluZykgOiBzdHJpbmcge1xuICAgIHJldHVybiBiZWF1dGlmeS5qcyhjb2RlKTtcbiAgfVxuICBcbiAgLy8gLS0tXG5cblxuICAvLyAtLS1cblxuICByZXN1bWUoKSB7XG4gICAgdGhpcy5kZWJ1Zy5hY3RpdmUgPSBmYWxzZTtcbiAgICByZXR1cm4gcmVzdW1lKCk7XG4gIH1cblxuICAvLyAtLS1cblxuICBzdGVwKCkge1xuICAgIHJldHVybiByZXN1bWUoKTtcbiAgfVxuXG4gIC8vIC0tLVxuXG4gIHByaW50V29ya0xpc3QoKSB7XG4gICAgdGhpcy5sb2coJ2NvbnRleHQgb3duZXI6ICcgKyB0aGlzLmNvbnRleHQub3duZXIpO1xuICAgIHRoaXMubG9nKFN0cmluZyh0aGlzLmNvbnRleHQud29ya0xpc3QpKTtcbiAgfVxuXG4gIC8vIC0tLVxuXG4gIC8vIFRPRE86IGZpeCBwcm9wZXIgcHJpbnRpbmdcbiAgZmF0YWwobXNnIDogc3RyaW5nLCAuLi5hcmdzKTogbmV2ZXIge1xuICAgIHZhciBleGMgPSBuZXcgRmF0YWxFcnJvcihtc2cgKyBhcmdzLm1hcCh4ID0+IEpTT04uc3RyaW5naWZ5KHgpKS5qb2luKCcgJykpO1xuICAgIHRocm93IGV4YztcbiAgfVxuXG4gIC8vIC0tLVxuXG4gIHN0b3AobXNnKSB7XG4gICAgdmFyIGV4YyA9IG5ldyBFcnJvcihtc2cpO1xuICAgIC8vQHRzLWlnbm9yZSBUWVBFU1xuICAgIGV4Yy50eXBlID0gJ1N0b3AnO1xuICAgIHRocm93IGV4YztcbiAgfVxuXG4gIC8vIC0tLVxuXG4gIFRocm93KGVycm9yOiBUaHJvd1R5cGUsIG1zZzogc3RyaW5nLCBsYmw6IExhYmVsKTogbmV2ZXIge1xuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICBsZSh0aGlzLmNvbnRleHQuZWZmZWN0aXZlUEMsIHRoaXMuY29udGV4dC5sYWJlbHMuZXhjKSxcbiAgICAgICd0aHJvdzogZWZmZWN0aXZlIHBjICcgKyB0aGlzLmNvbnRleHQuZWZmZWN0aXZlUEMgK1xuICAgICAgJyBub3QgYmVsb3cgZXhjZXB0aW9uIGxhYmVsICcgKyB0aGlzLmNvbnRleHQubGFiZWxzLmV4Y1xuICAgICk7XG5cbiAgICBsZXQgbXNnVmFsdWUgPSBuZXcgVmFsdWUobXNnLCBsYmwpO1xuICAgIHRoaXMub2ZmZW5kaW5nVHJhY2UgPSB0aGlzLnN0YWNrVHJhY2UoKTtcblxuICAgIHN3aXRjaCAoZXJyb3IpIHtcbiAgICAgIGNhc2UgXCJFcnJvclwiOiB0aHJvdyBuZXcgVmFsdWUobmV3IEVycm9yT2JqZWN0KG1zZ1ZhbHVlKSwgYm90KTtcbiAgICAgIGNhc2UgXCJFdmFsRXJyb3JcIjogdGhyb3cgbmV3IFZhbHVlKG5ldyBFdmFsRXJyb3JPYmplY3QobXNnVmFsdWUpLCBib3QpO1xuICAgICAgY2FzZSBcIlJhbmdlRXJyb3JcIjogdGhyb3cgbmV3IFZhbHVlKG5ldyBSYW5nZUVycm9yT2JqZWN0KG1zZ1ZhbHVlKSwgYm90KTtcbiAgICAgIGNhc2UgXCJSZWZlcmVuY2VFcnJvclwiOiB0aHJvdyBuZXcgVmFsdWUobmV3IFJlZmVyZW5jZUVycm9yT2JqZWN0KG1zZ1ZhbHVlKSwgYm90KTtcbiAgICAgIGNhc2UgXCJTeW50YXhFcnJvclwiOiB0aHJvdyBuZXcgVmFsdWUobmV3IFN5bnRheEVycm9yT2JqZWN0KG1zZ1ZhbHVlKSwgYm90KTtcbiAgICAgIGNhc2UgXCJUeXBlRXJyb3JcIjogdGhyb3cgbmV3IFZhbHVlKG5ldyBUeXBlRXJyb3JPYmplY3QobXNnVmFsdWUpLCBib3QpO1xuICAgICAgY2FzZSBcIlVSSUVycm9yXCI6IHRocm93IG5ldyBWYWx1ZShuZXcgVVJJRXJyb3JPYmplY3QobXNnVmFsdWUpLCBib3QpO1xuICAgIH1cblxuICAgIHRoaXMuZmF0YWwoXCJUaHJvdzogRG9uJ3Qga25vdyBob3cgdG8gZGVhbCB3aXRoIFwiICsgZXJyb3IpO1xuICB9XG5cbiAgLy8gLS0tXG5cbiAgc3RhY2tUcmFjZSgpIHtcbiAgICByZXR1cm4gbmV3IFN0YWNrVHJhY2UodGhpcy5jb250ZXh0U3RhY2sudG9BcnJheSgpKTtcbiAgfVxuXG4gIC8vIC0tLVxuXG4gIHNlY3VyaXR5RXJyb3IobWVzc2FnZTogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5nZXQoJ21vbml0b3IudGVzdE1vZGUnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmdldCgnbW9uaXRvci50YWludE1vZGUnKSB8fCB0aGlzLm9wdGlvbnMuZ2V0KCdtb25pdG9yLm9ic2VydmFibGVNb2RlJykpIHtcbiAgICAgIHRoaXMud2FybihcIltKU0Zsb3cgTk9STUFMXSBTZWN1cml0eSB2aW9sYXRpb246XCIsIG1lc3NhZ2UpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBleGMgPSBuZXcgU2VjdXJpdHlFcnJvcihtZXNzYWdlKTtcbiAgICAgIHRocm93IGV4YztcbiAgICB9XG4gIH1cblxuICAvLyAtLS1cblxuICBhc3NlcnQoYiA6IGJvb2xlYW4sIG1zZyA6IHN0cmluZykge1xuICAgIGlmICghYikgdGhpcy5zZWN1cml0eUVycm9yKG1zZyk7XG4gIH1cblxuICAvLyBsaWZ0cyBleGNlcHRpb25zIHRoYXQgXG4gIC8vIDEuIGFyZSBub3QgSlNGbG93IGludGVybmFsIGV4Y2VwdGlvbnMgXG4gIC8vIDIuIGhhdmUgYSBhIEpTRmxvdyBtb2RlbGVkIGNvdW50ZXJwYXJ0XG4gIC8vIG90aGVyd2lzZSByZXR1cm5zXG5cbiAgdHJ5UmV0aHJvdyhlICwgVGhyb3c/IDogYm9vbGVhbikge1xuXG4gICAgaWYgKCh0eXBlb2YgZSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIGUgIT09ICdmdW5jdGlvbicpIHx8IGUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoaXNKU0Zsb3dFcnJvcihlKSkge1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG5cbiAgICBpZiAoZSBpbnN0YW5jZW9mIFZhbHVlKSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cblxuICAgIGxldCBpc05hdGl2ZSA9IGUubmFtZSA9PSBcIkVycm9yXCIgfHxcbiAgICAgIGUubmFtZSA9PT0gXCJFdmFsRXJyb3JcIiB8fFxuICAgICAgZS5uYW1lID09PSBcIlJhbmdlRXJyb3JcIiB8fFxuICAgICAgZS5uYW1lID09PSBcIlJlZmVyZW5jZUVycm9yXCIgfHxcbiAgICAgIGUubmFtZSA9PT0gXCJTeW50YXhFcnJvclwiIHx8XG4gICAgICBlLm5hbWUgPT09IFwiVHlwZUVycm9yXCIgfHxcbiAgICAgIGUubmFtZSA9PT0gXCJVUklFcnJvclwiO1xuXG4gICAgaWYgKFRocm93ICYmIGlzTmF0aXZlKSB7XG4gICAgICB0aGlzLlRocm93KGUubmFtZSwgZS5zdGFjaywgYm90KTtcbiAgICB9XG5cbiAgfVxufVxuXG4iLCJpbXBvcnQgeyBMYWJlbCwgYm90IH0gZnJvbSBcIi4vTGFiZWxcIjtcbmltcG9ydCB7IFZhbHVlIH0gZnJvbSBcIi4vVmFsdWVcIjtcbmltcG9ydCB7IEVjbWFPYmplY3QgfSBmcm9tICcuL09iamVjdHMvRWNtYU9iamVjdCc7XG5pbXBvcnQgeyBWYWx1ZVR5cGVzLCBJRWNtYU9iamVjdCB9IGZyb20gXCIuL0ludGVyZmFjZXNcIjtcbmltcG9ydCB7IExleGljYWxFbnZpcm9ubWVudCB9IGZyb20gXCIuL0xleGljYWxFbnZpcm9ubWVudFwiO1xuaW1wb3J0IHsgTW9uaXRvckJhc2UgfSBmcm9tIFwiLi9Nb25pdG9yQmFzZVwiO1xuXG5kZWNsYXJlIHZhciBtb25pdG9yOiBNb25pdG9yQmFzZTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAxMC4yLjIuM1xuXG5leHBvcnQgZnVuY3Rpb24gTmV3T2JqZWN0RW52aXJvbm1lbnQobyA6IFZhbHVlPEVjbWFPYmplY3Q+LCBlIDogVmFsdWU8TGV4aWNhbEVudmlyb25tZW50Pikge1xuICAgIHZhciBlbnZSZWMgPSBuZXcgT2JqZWN0RW52aXJvbm1lbnRSZWNvcmQobyk7XG4gICAgdmFyIGVudiA9IG5ldyBMZXhpY2FsRW52aXJvbm1lbnQoZW52UmVjLCBlKTtcbiAgICByZXR1cm4gZW52O1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEVudmlyb25tZW50IHJlY29yZHMsIDEwLjIuMS4yXG5cbmV4cG9ydCBjbGFzcyBPYmplY3RFbnZpcm9ubWVudFJlY29yZCBleHRlbmRzIEVjbWFPYmplY3Qge1xuXG4gICAgYmluZGluZ09iamVjdDogVmFsdWU8RWNtYU9iamVjdD47XG4gICAgcHJvdmlkZVRoaXM6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIGNvbnN0cnVjdG9yKHA6IFZhbHVlPEVjbWFPYmplY3Q+KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGlmIChwLnZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBtb25pdG9yLmZhdGFsKCdPYmplY3RFbnZpcm9ubWVudFJlY29yZCwgdW5kZWZpbmVkIGJpbmRpbmcgb2JqZWN0Jyk7XG5cbiAgICAgICAgdGhpcy5iaW5kaW5nT2JqZWN0ID0gcDsgLy8gVmFsdWVcbiAgICB9XG5cbiAgICAvLyAtLS1cblxuICAgIHJhaXNlKGw6IExhYmVsKTogdm9pZCB7XG4gICAgICAgIHRoaXMuYmluZGluZ09iamVjdC5yYWlzZShsKTtcbiAgICB9XG5cbiAgICAvLyAtLS1cblxuICAgIC8vIEhhc0JpbmRpbmcsIDEwLjIuMS4yLjFcbiAgICBIYXNCaW5kaW5nKHA6IFZhbHVlPHN0cmluZz4pOiBWYWx1ZTxib29sZWFuPiB7XG4gICAgICAgIHJldHVybiB0aGlzLmJpbmRpbmdPYmplY3QuSGFzUHJvcGVydHkocCk7XG4gICAgfVxuXG4gICAgLy8gLS0tXG5cbiAgICAvLyBDcmVhdGVNdXRhYmxlQmluZGluZywgMTAuMi4xLjIuMlxuICAgIENyZWF0ZU11dGFibGVCaW5kaW5nKHA6IFZhbHVlPHN0cmluZz4sIGQ/OiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHZhciBkZXNjID0ge1xuICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGxhYmVsOiBtb25pdG9yLmNvbnRleHQuZWZmZWN0aXZlUEMsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6ICEhZFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuYmluZGluZ09iamVjdC5EZWZpbmVPd25Qcm9wZXJ0eShwLCBkZXNjLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvLyAtLS1cblxuICAgIC8vIEdldEJpbmRpbmdWYWx1ZSwgMTAuMi4xLjIuNFxuICAgIEdldEJpbmRpbmdWYWx1ZShwOiBWYWx1ZTxzdHJpbmc+LCBzKTogVmFsdWU8VmFsdWVUeXBlcz4ge1xuICAgICAgICByZXR1cm4gdGhpcy5iaW5kaW5nT2JqZWN0LkdldChwKTtcbiAgICB9XG5cbiAgICAvLyBTZXRNdXRhYmxlQmluZGluZywgMTAuMi4xLjIuM1xuICAgIFNldE11dGFibGVCaW5kaW5nKHA6IFZhbHVlPHN0cmluZz4sIHY6IFZhbHVlPFZhbHVlVHlwZXM+LCBzPzogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICB0aGlzLmJpbmRpbmdPYmplY3QuUHV0KHAsIHYsIHMpO1xuICAgIH1cblxuICAgIC8vIERlbGV0ZUJpbmRpbmcsIDEwLjIuMS4yLjVcbiAgICBEZWxldGVCaW5kaW5nKHA6IFZhbHVlPHN0cmluZz4pOiBWYWx1ZTxib29sZWFuPiB7XG4gICAgICAgIHJldHVybiB0aGlzLmJpbmRpbmdPYmplY3QuRGVsZXRlKHApO1xuICAgIH1cblxuICAgIC8vIEltcGxpY2l0VGhpc1ZhbHVlLCAxMC4yLjEuMi42XG4gICAgSW1wbGljaXRUaGlzVmFsdWUoKTogVmFsdWU8SUVjbWFPYmplY3QgfCB1bmRlZmluZWQ+IHtcbiAgICAgICAgaWYgKHRoaXMucHJvdmlkZVRoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJpbmRpbmdPYmplY3QuY2xvbmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgICAgICB9XG4gICAgfVxufSIsImltcG9ydCB7IE1vbml0b3JCYXNlIH0gZnJvbSBcIi4uL01vbml0b3JCYXNlXCI7XG5pbXBvcnQgeyBFY21hT2JqZWN0IH0gZnJvbSBcIi4vRWNtYU9iamVjdFwiO1xuaW1wb3J0IHsgVmFsdWUgfSBmcm9tIFwiLi4vVmFsdWVcIjtcbmltcG9ydCB7IGJvdCB9IGZyb20gXCIuLi9MYWJlbFwiO1xuXG5kZWNsYXJlIHZhciBtb25pdG9yOiBNb25pdG9yQmFzZTtcblxuXG5leHBvcnQgY2xhc3MgQXJndW1lbnRzT2JqZWN0IGV4dGVuZHMgRWNtYU9iamVjdCB7XG4gICAgY29uc3RydWN0b3IoRiwgYXJncykge1xuICAgICAgc3VwZXIoKTtcbiAgXG4gICAgICB0aGlzLlByb3RvdHlwZSA9IG5ldyBWYWx1ZShtb25pdG9yLmluc3RhbmNlcy5PYmplY3RQcm90b3R5cGUsIGJvdCk7XG4gICAgICB0aGlzLkNsYXNzID0gJ0FyZ3VtZW50cyc7XG4gICAgICB0aGlzLkV4dGVuc2libGUgPSB0cnVlO1xuICBcbiAgICAgIHZhciBmb3JtYWxQYXJhbXMgPSBGLkZvcm1hbFBhcmFtZXRlcnM7XG4gICAgICB2YXIgYXJncyA9IGFyZ3MgfHwgW107XG4gIFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuUHV0KG5ldyBWYWx1ZShpLCBib3QpLCBhcmdzW2ldLCBmYWxzZSk7XG4gICAgICB9XG4gIFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb3JtYWxQYXJhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGlkID0gZm9ybWFsUGFyYW1zW2ldO1xuICBcbiAgICAgICAgaWYgKGlkLnR5cGUgIT09ICdJZGVudGlmaWVyJykge1xuICAgICAgICAgIG1vbml0b3IuZmF0YWwoaWQudHlwZSArICcgaXMgbm90IHN1cHBvcnRlZCBpbiBBcmd1bWVudHNPYmplY3QnKTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgaWYgKGFyZ3NbaV0pIHtcbiAgICAgICAgICB0aGlzLlB1dChuZXcgVmFsdWUoaWQubmFtZSwgYm90KSwgYXJnc1tpXSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gIFxuICAgICAgdGhpcy5QdXQobmV3IFZhbHVlKCdsZW5ndGgnLCBib3QpLCBuZXcgVmFsdWUoYXJncy5sZW5ndGgsIGJvdCksIGZhbHNlKTtcbiAgICAgIHRoaXMuUHV0KG5ldyBWYWx1ZSgnY2FsbGVlJywgYm90KSwgbmV3IFZhbHVlKEYsIGJvdCksIGZhbHNlKTtcbiAgICB9XG4gIFxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBDcmVhdGUgQXJndW1lbnRzIE9iamVjdCwgMTAuNlxuXG5leHBvcnQgZnVuY3Rpb24gQ3JlYXRlQXJndW1lbnRzT2JqZWN0KGVudiwgRiwgYXJncykge1xuICAgIHJldHVybiBuZXcgVmFsdWUoXG4gICAgICBuZXcgQXJndW1lbnRzT2JqZWN0KEYsIGFyZ3MpLFxuICAgICAgYm90XG4gICAgKTtcbiAgXG4gIH0iLCJpbXBvcnQgeyBWYWx1ZSB9IGZyb20gXCIuLi9WYWx1ZVwiO1xuaW1wb3J0IHsgTW9uaXRvckJhc2UgfSBmcm9tICcuLi9Nb25pdG9yQmFzZSc7XG5cbmltcG9ydCB7IEVjbWFPYmplY3QgfSBmcm9tICcuLi9PYmplY3RzL0VjbWFPYmplY3QnO1xuaW1wb3J0IHsgYm90LCBsZSwgbHViLCBMYWJlbCB9IGZyb20gJy4uL0xhYmVsJztcbmltcG9ydCB7IFZhbHVlVHlwZXMgfSBmcm9tIFwiLi4vSW50ZXJmYWNlc1wiO1xuaW1wb3J0IHsgSlNGUHJvcGVydHlEZXNjcmlwdG9yIH0gZnJvbSBcIi4uL1Byb3BlcnR5RGVzY3JpcHRvclwiO1xuaW1wb3J0IHsgdGhyb3dTdGF0ZW1lbnQgfSBmcm9tIFwiLi4vRW5naW5lL1RyYWNpbmcvVGhyb3dTdGF0ZW1lbnRcIjtcbmltcG9ydCB7IHRocmVhZElkIH0gZnJvbSBcIndvcmtlcl90aHJlYWRzXCI7XG5pbXBvcnQgeyBUb1VJbnQzMiB9IGZyb20gXCIuLi9Db252ZXJzaW9uL1RvVUludDMyXCI7XG5pbXBvcnQgeyBUb051bWJlciB9IGZyb20gXCIuLi9Db252ZXJzaW9uL1RvTnVtYmVyXCI7XG5pbXBvcnQgeyBUb1N0cmluZyB9IGZyb20gXCIuLi9Db252ZXJzaW9uL1RvU3RyaW5nXCI7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5kZWNsYXJlIHZhciBtb25pdG9yOiBNb25pdG9yQmFzZTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAxNS40LjIuMSwgYW5kIDE1LjQuMi4yXG5cbmV4cG9ydCBjbGFzcyBBcnJheU9iamVjdCBleHRlbmRzIEVjbWFPYmplY3Qge1xuXG4gICAgcHJvcGVydGllczogVmFsdWVUeXBlc1tdO1xuXG4gICAgY29uc3RydWN0b3Ioc3RydWN0PzogTGFiZWwpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5DbGFzcyA9ICdBcnJheSc7XG5cbiAgICAgICAgdGhpcy5Qcm90b3R5cGUgPSBuZXcgVmFsdWUobW9uaXRvci5pbnN0YW5jZXMuQXJyYXlQcm90b3R5cGUsIGJvdCk7XG4gICAgICAgIHRoaXMuRXh0ZW5zaWJsZSA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0gW107XG4gICAgICAgIHRoaXMubGFiZWxzID0ge307XG5cbiAgICAgICAgc3RydWN0ID0gc3RydWN0IHx8IGJvdDtcbiAgICAgICAgdGhpcy5sYWJlbHMubGVuZ3RoID0ge1xuICAgICAgICAgICAgdmFsdWU6IHN0cnVjdCxcbiAgICAgICAgICAgIGV4aXN0ZW5jZTogYm90XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5zdHJ1Y3QgPSBzdHJ1Y3Q7XG4gICAgfVxuXG4gICAgLy8gLS0tXG5cbiAgICBzdGF0aWMgZnJvbVZhbHVlQXJyYXkodmFsdWVzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdLCBzdHJ1Y3Q6IExhYmVsKTogQXJyYXlPYmplY3Qge1xuICAgICAgICBsZXQgYXJyYXkgPSBuZXcgQXJyYXlPYmplY3Qoc3RydWN0KTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdmFsdWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAgICAgICBhcnJheS5wcm9wZXJ0aWVzW2ldID0gdmFsdWUudmFsdWU7XG4gICAgICAgICAgICBhcnJheS5sYWJlbHNbaV0gPSB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLmxhYmVsLFxuICAgICAgICAgICAgICAgIGV4aXN0ZW5jZTogYm90XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8vIC0tLVxuXG4gICAgc3RhdGljIGZyb21Qcm9wZXJ0eUFycmF5KHZhbHVlczogVmFsdWU8VmFsdWVUeXBlcz5bXSwgc3RydWN0OiBMYWJlbCk6IEFycmF5T2JqZWN0IHtcbiAgICAgICAgbGV0IGFycmF5ID0gbmV3IEFycmF5T2JqZWN0KHN0cnVjdCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHZhbHVlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgYXJyYXkucHJvcGVydGllc1tpXSA9IHZhbHVlLnZhbHVlO1xuICAgICAgICAgICAgYXJyYXkubGFiZWxzW2ldID0ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZS5sYWJlbCxcbiAgICAgICAgICAgICAgICBleGlzdGVuY2U6IHZhbHVlLmxhYmVsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8vIC0tLVxuXG4gICAgc3RhdGljIGZyb21BcnJheSh2YWx1ZXM6IFZhbHVlVHlwZXNbXSwgbGFiZWw6IExhYmVsLCBleGlzdGVuY2U6IExhYmVsKTogQXJyYXlPYmplY3Qge1xuICAgICAgICBsZXQgYXJyYXkgPSBuZXcgQXJyYXlPYmplY3QoZXhpc3RlbmNlKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdmFsdWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBhcnJheS5wcm9wZXJ0aWVzW2ldID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgYXJyYXkubGFiZWxzW2ldID0ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBsYWJlbCxcbiAgICAgICAgICAgICAgICBleGlzdGVuY2U6IGV4aXN0ZW5jZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLy8gLS0tXG5cbiAgICB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgLy8gLS0tXG5cbiAgICB0b0xhYmVsZWRTdHJpbmcoKTogc3RyaW5nIHtcbiAgICAgICAgbGV0IHN0cnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcCBpbiB0aGlzLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHN0cnMucHVzaCh0aGlzLnByb3BlcnRpZXNbcF0gKyAnXycgKyB0aGlzLmxhYmVsc1twXS52YWx1ZS50b1N0cmluZygpICsgJygnICsgdGhpcy5sYWJlbHNbcF0uZXhpc3RlbmNlLnRvU3RyaW5nKCkgKyAnKScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICdbICcgKyBzdHJzLmpvaW4oJywgJykgKyAnIHwgJyArIHRoaXMuc3RydWN0LnRvU3RyaW5nKCkgKyAnLCBsZW5ndGggOiAnICsgdGhpcy5sYWJlbHMubGVuZ3RoLnZhbHVlLnRvU3RyaW5nKCkgKyAnKCcgKyB0aGlzLmxhYmVscy5sZW5ndGguZXhpc3RlbmNlLnRvU3RyaW5nKCkgKyAnKScgKyAnIF0nO1xuICAgIH1cblxuXG5cbiAgICAvLyAtLS1cbiAgICAvLyAxNS40LjUuMVxuICAgIERlZmluZU93blByb3BlcnR5KHM6IFZhbHVlPHN0cmluZyB8IG51bWJlcj4sIGRlc2M6IEpTRlByb3BlcnR5RGVzY3JpcHRvciwgVGhyb3c/OiBib29sZWFuKTogVmFsdWU8Ym9vbGVhbj4ge1xuICAgICAgICBsZXQgYyA9IG1vbml0b3IuY29udGV4dDtcblxuICAgICAgICAvKiBJbnN0ZWFkIG9mIGxlbmd0aENvbnRleHQgPSBsdWIoYy5lZmZlY3RpdmVQQywgcy5sYWJlbCksIHB1c2ggcy5sYWJlbCB0b1xuICAgICAgICAgICBwYy1zdGFjaywgYW5kIHVzZSBwYyAodG8gbWFrZSB0YWludE1vZGUgZWFzaWVyKSAqL1xuICAgICAgICBjLnB1c2hQQyhzLmxhYmVsKTtcbiAgICAgICAgaWYgKCFsZShjLmVmZmVjdGl2ZVBDLCB0aGlzLmxhYmVscy5sZW5ndGgudmFsdWUpKSB7XG4gICAgICAgICAgICBtb25pdG9yLnNlY3VyaXR5RXJyb3IoXG4gICAgICAgICAgICAgICAgYEFycmF5LnByb3RvdHlwZS5EZWZpbmVPd25Qcm9wZXJ0eTogd3JpdGUgY29udGV4dCAke2MuZWZmZWN0aXZlUEN9IG5vdCBiZWxvdyBsZW5ndGggbGFiZWwgJHt0aGlzLmxhYmVscy5sZW5ndGgudmFsdWV9YFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gRm9yIG9ic2VydmFibGUgZmxvd3NcbiAgICAgICAgICAgIHRoaXMubGFiZWxzLmxlbmd0aC52YWx1ZSA9IGx1Yih0aGlzLmxhYmVscy5sZW5ndGgudmFsdWUsIGMuZWZmZWN0aXZlUEMpO1xuICAgICAgICB9XG5cbiAgICAgICAgYy5wb3BQQygpO1xuXG4gICAgICAgIGxldCBvbGRMZW5EZXNjID0gdGhpcy5HZXRPd25Qcm9wZXJ0eShuZXcgVmFsdWUoJ2xlbmd0aCcsIGJvdCkpO1xuICAgICAgICBsZXQgb2xkTGVuID0gbmV3IFZhbHVlKG9sZExlbkRlc2MudmFsdWUudmFsdWUsIG9sZExlbkRlc2MubGFiZWwpO1xuICAgICAgICBpZiAocy52YWx1ZSA9PT0gJ2xlbmd0aCcpIHtcbiAgICAgICAgICAgIGlmIChkZXNjLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VwZXIuRGVmaW5lT3duUHJvcGVydHkuY2FsbCh0aGlzLCBzLCBkZXNjLCBUaHJvdyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBuZXdMZW4gPSBUb1VJbnQzMihuZXcgVmFsdWUoZGVzYy52YWx1ZSwgZGVzYy5sYWJlbCkpO1xuICAgICAgICAgICAgaWYgKG5ld0xlbi52YWx1ZSAhPT0gVG9OdW1iZXIobmV3IFZhbHVlKGRlc2MudmFsdWUsIGRlc2MubGFiZWwpKS52YWx1ZSkge1xuICAgICAgICAgICAgICAgIG1vbml0b3IuVGhyb3coXG4gICAgICAgICAgICAgICAgICAgICdSYW5nZUVycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgJ0ludmFsaWQgbGVuZ3RoIGluIEFycmF5LkRlZmluZU93blByb3BlcnR5JyxcbiAgICAgICAgICAgICAgICAgICAgYm90XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobmV3TGVuLnZhbHVlID49IG9sZExlbi52YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdXBlci5EZWZpbmVPd25Qcm9wZXJ0eS5jYWxsKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBzLFxuICAgICAgICAgICAgICAgICAgICB7IHZhbHVlOiBuZXdMZW4udmFsdWUsIGxhYmVsOiBsdWIobmV3TGVuLmxhYmVsLCBkZXNjLmxhYmVsKSB9LFxuICAgICAgICAgICAgICAgICAgICBUaHJvd1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvbGRMZW5EZXNjLnZhbHVlLndyaXRhYmxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGlmIChUaHJvdykge1xuICAgICAgICAgICAgICAgICAgICBtb25pdG9yLlRocm93KFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1R5cGVFcnJvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnTm9uLXdyaXRhYmxlIGRlc2NyaXB0b3IgaW4gQXJyYXkuRGVmaW5lT3duUHJvcGVydHknLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm90XG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZhbHVlKGZhbHNlLCBib3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVzYy52YWx1ZSA9IG5ld0xlbi52YWx1ZTtcbiAgICAgICAgICAgIGRlc2MubGFiZWwgPSBsdWIoZGVzYy5sYWJlbCwgbmV3TGVuLmxhYmVsKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN1cGVyLkRlZmluZU93blByb3BlcnR5LmNhbGwodGhpcywgcywgZGVzYywgVGhyb3cpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBWYWx1ZSB9IGZyb20gXCIuLi9WYWx1ZVwiO1xuaW1wb3J0IHsgRWNtYU9iamVjdCB9IGZyb20gJy4uL09iamVjdHMvRWNtYU9iamVjdCc7XG5pbXBvcnQgeyBib3QsIExhYmVsIH0gZnJvbSAnLi4vTGFiZWwnO1xuaW1wb3J0IHsgTW9uaXRvckJhc2UgfSBmcm9tICcuLi9Nb25pdG9yQmFzZSc7XG5pbXBvcnQgeyBWYWx1ZVR5cGVzIH0gZnJvbSBcIi4uL0ludGVyZmFjZXNcIjtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmRlY2xhcmUgdmFyIG1vbml0b3I6IE1vbml0b3JCYXNlO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEJvb2xlYW4gT2JqZWN0LCAxNS42LjVcblxuZXhwb3J0IGNsYXNzIEJvb2xlYW5PYmplY3QgZXh0ZW5kcyBFY21hT2JqZWN0IHtcblxuICAgIFByaW1pdGl2ZVZhbHVlIDogQm9vbGVhbjtcbiAgICBQcmltaXRpdmVMYWJlbCA6IExhYmVsO1xuXG4gICAgY29uc3RydWN0b3IodmFsIDogVmFsdWVUeXBlcywgbGJsIDogTGFiZWwpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5DbGFzcyA9ICdCb29sZWFuJztcbiAgICAgICAgdGhpcy5QcmltaXRpdmVWYWx1ZSA9IG5ldyBCb29sZWFuKHZhbCk7XG4gICAgICAgIHRoaXMuUHJpbWl0aXZlTGFiZWwgPSBsYmw7XG4gICAgICAgIHRoaXMuRXh0ZW5zaWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMuUHJvdG90eXBlID0gbmV3IFZhbHVlKG1vbml0b3IuaW5zdGFuY2VzLkJvb2xlYW5Qcm90b3R5cGUsIGJvdCk7XG4gICAgfVxufVxuXG4vLyAtLS1cblxuZXhwb3J0IGZ1bmN0aW9uIElzQm9vbGVhbk9iamVjdCh4IDogVmFsdWU8YW55PikgOiB4IGlzIFZhbHVlPEJvb2xlYW5PYmplY3Q+IHtcbiAgICByZXR1cm4gdHlwZW9mIHgudmFsdWUgPT09ICdvYmplY3QnICYmIHgudmFsdWUgIT09IG51bGwgJiYgeC52YWx1ZS5DbGFzcyA9PT0gJ0Jvb2xlYW4nO1xufSIsIlxuaW1wb3J0IHsgVmFsdWUgfSBmcm9tIFwiLi4vVmFsdWVcIjtcbmltcG9ydCB7IFZhbHVlVHlwZXMgfSBmcm9tICcuLi9JbnRlcmZhY2VzJztcbmltcG9ydCB7IEJ1aWx0aW5NZXRob2RPYmplY3QgfSBmcm9tICcuL0J1aWx0aW5NZXRob2RPYmplY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGNsYXNzIEJ1aWx0aW5GdW5jdGlvbk9iamVjdCBleHRlbmRzIEJ1aWx0aW5NZXRob2RPYmplY3Qge1xuXG4gIGNvbnN0cnVjdG9yKGY6ICh0aGlzOiBCdWlsdGluRnVuY3Rpb25PYmplY3QsIHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKSA9PiBWYWx1ZTxWYWx1ZVR5cGVzPiwgbjogbnVtYmVyLCBob3N0OiBGdW5jdGlvbiB8IHN0cmluZykge1xuICAgIHN1cGVyKHVuZGVmaW5lZCwgZiwgbiwgaG9zdCk7XG4gIH1cblxufSIsImltcG9ydCB7IGJvdCB9IGZyb20gJy4uL0xhYmVsJztcbmltcG9ydCB7IFZhbHVlIH0gZnJvbSBcIi4uL1ZhbHVlXCI7XG5pbXBvcnQgeyBEZWZpbmVGRkYgfSBmcm9tICcuLi9EZWZpbmUnO1xuaW1wb3J0IHsgRWNtYU9iamVjdCB9IGZyb20gJy4vRWNtYU9iamVjdCc7XG5pbXBvcnQgKiBhcyBjb25zdGFudHMgZnJvbSAnLi4vQ29uc3RhbnRzJztcbmltcG9ydCB7IE1vbml0b3JCYXNlIH0gZnJvbSAnLi4vTW9uaXRvckJhc2UnO1xuaW1wb3J0IHsgVmFsdWVUeXBlcywgSUVjbWFPYmplY3QgfSBmcm9tICcuLi9JbnRlcmZhY2VzJztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmRlY2xhcmUgdmFyIG1vbml0b3I6IE1vbml0b3JCYXNlO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmV4cG9ydCBjbGFzcyBCdWlsdGluTWV0aG9kT2JqZWN0IGV4dGVuZHMgRWNtYU9iamVjdCB7XG5cbiAgaG9zdDogRnVuY3Rpb24gfCBzdHJpbmc7XG4gIGFjdHVhbEZ1bmN0aW9uOiAodGhpczogRWNtYU9iamVjdCwgdGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pID0+IFZhbHVlPFZhbHVlVHlwZXM+O1xuICBzZWxmOiBFY21hT2JqZWN0O1xuXG4gIGNvbnN0cnVjdG9yKHNlbGY6IEVjbWFPYmplY3QgfCB1bmRlZmluZWQsIGY6ICh0aGlzOiBFY21hT2JqZWN0LCB0aGlzQXJnOiBWYWx1ZTxWYWx1ZVR5cGVzPiwgYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSkgPT4gVmFsdWU8VmFsdWVUeXBlcz4sIG46IG51bWJlciwgaG9zdDogRnVuY3Rpb24gfCBzdHJpbmcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgdGhpcy5hY3R1YWxGdW5jdGlvbiA9IGY7XG4gICAgdGhpcy5zZWxmID0gc2VsZiB8fCB0aGlzO1xuXG4gICAgdGhpcy5DbGFzcyA9ICdGdW5jdGlvbic7XG5cbiAgICB0aGlzLlByb3RvdHlwZSA9IG5ldyBWYWx1ZShtb25pdG9yLmluc3RhbmNlcy5GdW5jdGlvblByb3RvdHlwZSwgYm90KTtcbiAgICB0aGlzLkV4dGVuc2libGUgPSB0cnVlO1xuXG4gICAgRGVmaW5lRkZGKHRoaXMsIGNvbnN0YW50cy5sZW5ndGgsIG4pO1xuICB9XG5cbiAgQ2FsbCh0aGlzQXJnOiBWYWx1ZTxWYWx1ZVR5cGVzPiwgYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPFZhbHVlVHlwZXM+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXMuYWN0dWFsRnVuY3Rpb24uY2FsbCh0aGlzLnNlbGYsIHRoaXNBcmcsIGFyZ3MpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIG1vbml0b3IudHJ5UmV0aHJvdyhlLCB0cnVlKTtcbiAgICAgIG1vbml0b3IuZmF0YWwoYEJ1aWx0aW5NZXRob2RPYmplY3QuQ2FsbCwgdW5hYmxlIHRvIGxpZnQgJHtlfSAoZXJyb3IgaXMgb2YgdHlwZSAke3R5cGVvZiBlfSBcXG5vcmlnaW5hdGluZyBmcm9tICR7dGhpcy5hY3R1YWxGdW5jdGlvbn0gXFxucmVwcmVzZW50aW5nIGhvc3QgJHt0aGlzLmhvc3R9KSBcXG5jYWxsZWQgd2l0aCB0aGlzOiAke3RoaXNBcmcudmFsdWV9IFxcbmFuZCBhcmdzOiAke2FyZ3N9YCk7XG4gICAgICB0aHJvdyAnVHlwZVNjcmlwdCc7XG4gICAgfVxuICB9XG5cbiAgQ29uc3RydWN0KGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxJRWNtYU9iamVjdD4ge1xuICAgIG1vbml0b3IuVGhyb3coXG4gICAgICBcIlR5cGVFcnJvclwiLFxuICAgICAgJ2Nhbm5vdCBiZSB1c2VkIGFzIGEgY29uc3RydWN0b3InLFxuICAgICAgYm90XG4gICAgKTtcbiAgICB0aHJvdyAnVHlwZVNjcmlwdCc7XG4gIH1cblxuICB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgIGlmICh0aGlzLmhvc3QpIHtcbiAgICAgIHJldHVybiB0aGlzLmhvc3QudG9TdHJpbmcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuYWN0dWFsRnVuY3Rpb24udG9TdHJpbmcoKTtcbiAgICB9XG4gIH1cblxufSIsImltcG9ydCB7IFZhbHVlIH0gZnJvbSBcIi4uL1ZhbHVlXCI7XG5pbXBvcnQgeyBNb25pdG9yQmFzZSB9IGZyb20gJy4uL01vbml0b3JCYXNlJztcblxuaW1wb3J0IHsgRWNtYU9iamVjdCB9IGZyb20gJy4uL09iamVjdHMvRWNtYU9iamVjdCc7XG5pbXBvcnQgeyBib3QsIExhYmVsIH0gZnJvbSAnLi4vTGFiZWwnO1xuXG5kZWNsYXJlIHZhciBtb25pdG9yOiBNb25pdG9yQmFzZTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBEYXRlIE9iamVjdCwgMTUuOS41XG5cbmV4cG9ydCBjbGFzcyBEYXRlT2JqZWN0IGV4dGVuZHMgRWNtYU9iamVjdCB7XG5cbiAgICBQcmltaXRpdmVWYWx1ZTogRGF0ZTtcbiAgICBQcmltaXRpdmVMYWJlbDogTGFiZWw7XG5cbiAgICBjb25zdHJ1Y3RvcihkYXRlIDogRGF0ZSwgbGFiZWwgOiBMYWJlbCkge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMuQ2xhc3MgPSAnRGF0ZSc7XG4gICAgICAgIHRoaXMuUHJpbWl0aXZlVmFsdWUgPSBkYXRlO1xuICAgICAgICB0aGlzLlByaW1pdGl2ZUxhYmVsID0gbGFiZWw7XG4gICAgICAgIHRoaXMuRXh0ZW5zaWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMuUHJvdG90eXBlID0gbmV3IFZhbHVlKG1vbml0b3IuaW5zdGFuY2VzLkRhdGVQcm90b3R5cGUsIGJvdCk7XG4gICAgfVxuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBJc0RhdGVPYmplY3QoeCA6IFZhbHVlPGFueT4pIDogeCBpcyBWYWx1ZTxEYXRlT2JqZWN0PiB7XG4gICAgcmV0dXJuIHR5cGVvZiB4LnZhbHVlID09PSAnb2JqZWN0JyAmJiB4LnZhbHVlICE9PSBudWxsICYmIHgudmFsdWUuQ2xhc3MgPT09ICdEYXRlJztcbn0iLCJpbXBvcnQgeyBJRWNtYU9iamVjdCwgVmFsdWVUeXBlcywgUHJpbWl0aXZlVmFsdWVUeXBlcyB9IGZyb20gXCIuLi9JbnRlcmZhY2VzXCI7XG5pbXBvcnQgeyBMYWJlbGVkUHJvcGVydHlEZXNjcmlwdG9yLCBKU0ZQcm9wZXJ0eURlc2NyaXB0b3IgfSBmcm9tIFwiLi4vUHJvcGVydHlEZXNjcmlwdG9yXCI7XG5pbXBvcnQgeyBWYWx1ZSB9IGZyb20gXCIuLi9WYWx1ZVwiO1xuaW1wb3J0IHsgYm90LCBMYWJlbCwgbHViLCBsZSB9IGZyb20gXCIuLi9MYWJlbFwiO1xuaW1wb3J0IHsgUHJvcGVydHlMYWJlbCB9IGZyb20gXCIuLi9Qcm9wZXJ0eUxhYmVsXCI7XG5pbXBvcnQgeyBJc0FjY2Vzc29yRGVzY3JpcHRvciwgSXNEYXRhRGVzY3JpcHRvciB9IGZyb20gXCIuLi9Qcm9wZXJ0eURlc2NyaXB0b3JcIjtcbmltcG9ydCAqIGFzIGNvbnN0YW50cyBmcm9tICcuLi9Db25zdGFudHMnO1xuaW1wb3J0IHsgSXNDYWxsYWJsZSB9IGZyb20gXCIuLi9VdGlsaXR5L0lzQ2FsbGFibGVcIjtcbmltcG9ydCB7IE1vbml0b3JCYXNlIH0gZnJvbSBcIi4uL01vbml0b3JCYXNlXCI7XG5cbmRlY2xhcmUgdmFyIG1vbml0b3I6IE1vbml0b3JCYXNlO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEVjbWEgT2JqZWN0cywgOC42LjJcblxuZXhwb3J0IGNsYXNzIEVjbWFPYmplY3QgaW1wbGVtZW50cyBJRWNtYU9iamVjdCB7XG5cbiAgQ2xhc3M/OiBzdHJpbmc7XG5cbiAgX3Byb3RvdHlwZSA6IFZhbHVlPElFY21hT2JqZWN0IHwgbnVsbD4gPSBuZXcgVmFsdWUobnVsbCwgYm90KTtcblxuICBnZXQgUHJvdG90eXBlKCk6IFZhbHVlPElFY21hT2JqZWN0IHwgbnVsbD4ge1xuICAgICByZXR1cm4gdGhpcy5fcHJvdG90eXBlO1xuICB9XG5cbiAgc2V0IFByb3RvdHlwZShwIDogVmFsdWU8SUVjbWFPYmplY3QgfCBudWxsPikge1xuICAgIHRoaXMuX3Byb3RvdHlwZSA9IHA7XG4gIH1cblxuICBFeHRlbnNpYmxlOiBib29sZWFuID0gdHJ1ZTtcblxuICBwcm9wZXJ0aWVzOiB7IFtrZXk6IHN0cmluZ106IFZhbHVlVHlwZXMgfSB8IFZhbHVlVHlwZXNbXSA9IHt9O1xuXG4gIGxhYmVsczogeyBba2V5OiBzdHJpbmddOiBQcm9wZXJ0eUxhYmVsIH0gPSB7fTtcbiAgc3RydWN0OiBMYWJlbDtcblxuICBjb25zdHJ1Y3RvcigpIHtcblxuICAgIHRoaXMucHJvcGVydGllcyA9IHt9O1xuICAgIHRoaXMubGFiZWxzID0ge307XG5cbiAgICB0aGlzLnN0cnVjdCA9IG1vbml0b3IuY29udGV4dC5lZmZlY3RpdmVQQztcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbWFwJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU29tZXRoaW5nIHRvdWNoZWQgRWNtYS5tYXAnKTtcbiAgICAgIH0sXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcblxuICB9XG5cbiAgLy8gLS0tXG5cbiAgdG9TdHJpbmcoKSA6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuQ2xhc3MgPyB0aGlzLkNsYXNzIDogJ0VjbWFPYmplY3QnO1xuICB9XG5cbiAgLy8gLS0tIHVzZWQgYnkgbHByaW50XG5cbiAgdG9MYWJlbGVkU3RyaW5nKCkgOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH1cblxuICAvLyAtLS1cblxuICBnZXRPd25Qcm9wZXJ0eU5hbWVzKGxhYmVsOiBMYWJlbCk6IFZhbHVlPHN0cmluZz5bXSB7XG4gICAgbGV0IG5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5wcm9wZXJ0aWVzKTtcbiAgICBsZXQgcmVzdWx0OiBWYWx1ZTxzdHJpbmc+W10gPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBuYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgbGV0IG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgIHJlc3VsdFtpXSA9IG5ldyBWYWx1ZShuYW1lLCBsdWIobGFiZWwsIHRoaXMubGFiZWxzW25hbWVdLmV4aXN0ZW5jZSkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyAtLS1cblxuICBnZXRPd25FbnVtZXJhYmxlUHJvcGVydHlOYW1lcyhsYWJlbDogTGFiZWwpOiBWYWx1ZTxzdHJpbmc+W10ge1xuICAgIGxldCBuYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMucHJvcGVydGllcyk7XG4gICAgbGV0IGVudW1lcmFibGU6IFZhbHVlPHN0cmluZz5bXSA9IFtdO1xuICAgIGxldCBqID0gMDtcblxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBuYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgbGV0IG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgIC8vIGZyb20gZ2V0T3duUHJvcGVydHlOYW1lczsgZ3VhcmFudGVlZCB0byBiZSBmb3VuZFxuICAgICAgbGV0IGRlc2MgPSA8UHJvcGVydHlEZXNjcmlwdG9yPk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGhpcy5wcm9wZXJ0aWVzLCBuYW1lKTtcbiAgICAgIGlmIChkZXNjLmVudW1lcmFibGUpIHtcbiAgICAgICAgZW51bWVyYWJsZVtqKytdID0gbmV3IFZhbHVlKG5hbWUsIGx1YihsYWJlbCwgdGhpcy5sYWJlbHNbbmFtZV0uZXhpc3RlbmNlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbnVtZXJhYmxlO1xuICB9XG5cbiAgLy8gLS0tXG5cbiAgZ2V0RW51bWVyYWJsZVByb3BlcnR5TmFtZXMoaW5pdGlhbExhYmVsOiBMYWJlbCk6IFZhbHVlPHN0cmluZz5bXSB7XG5cbiAgICBsZXQgZGVmaW5lZCA9IHt9O1xuICAgIGxldCByZXN1bHQ6IFZhbHVlPHN0cmluZz5bXSA9IFtdO1xuXG4gICAgbGV0IGogPSAwO1xuXG4gICAgbGV0IGN1cnJlbnQ6IEVjbWFPYmplY3QgfCBudWxsID0gdGhpcztcbiAgICBsZXQgbGJsID0gaW5pdGlhbExhYmVsIHx8IGJvdDtcblxuICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICBsZXQgZW51bWVyYWJsZSA9IGN1cnJlbnQuZ2V0T3duRW51bWVyYWJsZVByb3BlcnR5TmFtZXMobGJsKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGVudW1lcmFibGUubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbGV0IG5hbWUgPSBlbnVtZXJhYmxlW2ldO1xuICAgICAgICBpZiAoIWRlZmluZWQuaGFzT3duUHJvcGVydHkobmFtZS52YWx1ZSkpIHtcbiAgICAgICAgICBkZWZpbmVkW25hbWUudmFsdWVdID0gdHJ1ZTtcbiAgICAgICAgICByZXN1bHRbaisrXSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGV0IG5leHQgPSBjdXJyZW50LlByb3RvdHlwZTtcbiAgICAgIC8vQHRzLWlnbm9yZSBUWVBFU1xuICAgICAgY3VycmVudCA9IG5leHQudmFsdWU7XG4gICAgICBsYmwgPSBsdWIobGJsLCBuZXh0LmxhYmVsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gR2V0T3duUHJvcGVydHksIDguMTIuMSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIEdldE93blByb3BlcnR5KHM6IFZhbHVlPHN0cmluZyB8IG51bWJlcj4pOiBWYWx1ZTxMYWJlbGVkUHJvcGVydHlEZXNjcmlwdG9yIHwgdW5kZWZpbmVkPiB7XG4gICAgbGV0IHByb3BOYW1lID0gcy52YWx1ZTtcbiAgICBsZXQgcHJvcE5hbWVMYWJlbCA9IHMubGFiZWw7XG5cbiAgICBsZXQganNkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0aGlzLnByb3BlcnRpZXMsIHByb3BOYW1lKTtcblxuICAgIGlmIChqc2Rlc2MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG5ldyBWYWx1ZSh1bmRlZmluZWQsIGx1Yih0aGlzLnN0cnVjdCwgcHJvcE5hbWVMYWJlbCkpO1xuICAgIH1cbiAgICBsZXQgcHJvcExhYmVsID0gdGhpcy5sYWJlbHNbcHJvcE5hbWVdO1xuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGpzZGVzYy5sYWJlbCA9IHByb3BMYWJlbC52YWx1ZTtcblxuICAgIGxldCByZXN1bHQgPSBuZXcgVmFsdWUoPExhYmVsZWRQcm9wZXJ0eURlc2NyaXB0b3I+anNkZXNjLCBsdWIocHJvcE5hbWVMYWJlbCwgcHJvcExhYmVsLmV4aXN0ZW5jZSkpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBHZXRQcm9wZXJ0eSwgOC4xMi4yIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgR2V0UHJvcGVydHkoczogVmFsdWU8c3RyaW5nIHwgbnVtYmVyPik6IFZhbHVlPExhYmVsZWRQcm9wZXJ0eURlc2NyaXB0b3IgfCB1bmRlZmluZWQ+IHtcbiAgICBsZXQgcHJvcCA9IHRoaXMuR2V0T3duUHJvcGVydHkocyk7XG4gICAgaWYgKHByb3AudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHByb3A7XG4gICAgfVxuXG4gICAgbGV0IHByb3RvID0gdGhpcy5Qcm90b3R5cGU7XG4gICAgbGV0IGxibCA9IGx1Yihwcm9wLmxhYmVsLCBwcm90by5sYWJlbCk7XG5cbiAgICBpZiAocHJvdG8udmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBuZXcgVmFsdWUodW5kZWZpbmVkLCBsYmwpO1xuICAgIH1cblxuICAgIC8vIERFQlVHOiByZW1vdmVcbiAgICBpZiAocHJvdG8udmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbW9uaXRvci5mYXRhbCgnRUNNQSBPYmplY3Qgd2l0aCB1bmRlZmluZWQgUHJvdG90eXBlJyk7XG4gICAgfVxuXG4gICAgbGV0IHJlcyA9IHByb3RvLkdldFByb3BlcnR5KHMpO1xuICAgIHJlcy5sYWJlbCA9IGx1YihsYmwsIHJlcy5sYWJlbCk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIC8vIEdldCwgOC4xMi4zIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICBHZXQoczogVmFsdWU8c3RyaW5nIHwgbnVtYmVyPik6IFZhbHVlPFZhbHVlVHlwZXM+IHtcblxuICAgIGxldCBkZXNjVmFsdWUgPSB0aGlzLkdldFByb3BlcnR5KHMpO1xuXG4gICAgaWYgKGRlc2NWYWx1ZS52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbmV3IFZhbHVlKHVuZGVmaW5lZCwgZGVzY1ZhbHVlLmxhYmVsKTtcbiAgICB9XG5cbiAgICBsZXQgdjogVmFsdWU8VmFsdWVUeXBlcz47XG4gICAgbGV0IGRlc2MgPSBkZXNjVmFsdWUudmFsdWU7XG5cbiAgICBtb25pdG9yLmNvbnRleHQucHVzaFBDKGRlc2NWYWx1ZS5sYWJlbCk7XG5cbiAgICBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7XG4gICAgICB2ID0gbmV3IFZhbHVlKGRlc2MudmFsdWUsIGRlc2MubGFiZWwpO1xuICAgIH0gZWxzZSBpZiAoZGVzYy5nZXQpIHtcbiAgICAgIG1vbml0b3IuY29udGV4dC5wdXNoUEMoZGVzYy5sYWJlbCk7XG4gICAgICB2ID0gZGVzYy5nZXQuY2FsbCh0aGlzKTtcbiAgICAgIG1vbml0b3IuY29udGV4dC5wb3BQQygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2ID0gbmV3IFZhbHVlKHVuZGVmaW5lZCwgZGVzY1ZhbHVlLmxhYmVsKTtcbiAgICB9XG5cbiAgICBtb25pdG9yLmNvbnRleHQucG9wUEMoKTtcblxuICAgIHYucmFpc2UoZGVzY1ZhbHVlLmxhYmVsKTtcbiAgICByZXR1cm4gdjtcbiAgfVxuXG4gIC8vIENhblB1dCwgOC4xMi40IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICBDYW5QdXQocDogVmFsdWU8c3RyaW5nIHwgbnVtYmVyPik6IFZhbHVlPGJvb2xlYW4+IHtcbiAgICBsZXQgbGFiZWxlZERlc2MgPSB0aGlzLkdldE93blByb3BlcnR5KHApO1xuXG4gICAgbGV0IGxhYmVsID0gbGFiZWxlZERlc2MubGFiZWw7XG5cbiAgICBpZiAobGFiZWxlZERlc2MudmFsdWUpIHtcbiAgICAgIGxldCBkZXNjID0gbGFiZWxlZERlc2MudmFsdWU7XG4gICAgICBsYWJlbCA9IGx1YihsYWJlbCwgZGVzYy5sYWJlbCk7XG5cbiAgICAgIGlmIChJc0FjY2Vzc29yRGVzY3JpcHRvcihkZXNjKSkge1xuICAgICAgICByZXR1cm4gbmV3IFZhbHVlKGRlc2Muc2V0ICE9PSB1bmRlZmluZWQsIGxhYmVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgVmFsdWUoISFkZXNjLndyaXRhYmxlLCBsYWJlbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHByb3RvID0gdGhpcy5Qcm90b3R5cGU7XG4gICAgaWYgKHByb3RvLnZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbmV3IFZhbHVlKHRoaXMuRXh0ZW5zaWJsZSwgbGFiZWwpO1xuICAgIH1cblxuICAgIGxldCBsYWJsZWxlZFByb3RvdHlwZURlc2MgPSBwcm90by5HZXRQcm9wZXJ0eShwKTtcbiAgICBsYWJlbCA9IGx1YihsYWJlbCwgbGFibGVsZWRQcm90b3R5cGVEZXNjLmxhYmVsKTtcblxuICAgIGlmIChsYWJsZWxlZFByb3RvdHlwZURlc2MudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG5ldyBWYWx1ZSh0aGlzLkV4dGVuc2libGUsIGxhYmVsKTtcbiAgICB9XG5cbiAgICBsZXQgcHJvdG90eXBlRGVzYyA9IGxhYmxlbGVkUHJvdG90eXBlRGVzYy52YWx1ZTtcbiAgICBsYWJlbCA9IGx1YihsYWJlbCwgcHJvdG90eXBlRGVzYy5sYWJlbCk7XG5cbiAgICBpZiAoSXNBY2Nlc3NvckRlc2NyaXB0b3IocHJvdG90eXBlRGVzYykpIHtcbiAgICAgIHJldHVybiBuZXcgVmFsdWUocHJvdG90eXBlRGVzYy5zZXQgIT09IHVuZGVmaW5lZCwgbGFiZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXRoaXMuRXh0ZW5zaWJsZSkge1xuICAgICAgICByZXR1cm4gbmV3IFZhbHVlKGZhbHNlLCBsYWJlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IFZhbHVlKCEhcHJvdG90eXBlRGVzYy53cml0YWJsZSwgbGFiZWwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFB1dCwgOC4xMi41IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICBQdXQoczogVmFsdWU8c3RyaW5nIHwgbnVtYmVyPiwgdjogVmFsdWU8VmFsdWVUeXBlcz4sIFRocm93OiBib29sZWFuKTogdm9pZCB7XG4gICAgbGV0IGMgPSBtb25pdG9yLmNvbnRleHQ7XG5cbiAgICBsZXQgY2FuUHV0ID0gdGhpcy5DYW5QdXQocyk7XG4gICAgaWYgKCFjYW5QdXQudmFsdWUpIHtcbiAgICAgIGlmIChUaHJvdykge1xuICAgICAgICBjLnB1c2hQQyhjYW5QdXQubGFiZWwpO1xuICAgICAgICBtb25pdG9yLlRocm93KFxuICAgICAgICAgIFwiVHlwZUVycm9yXCIsXG4gICAgICAgICAgJ2lsbGVnYWwgYWNjZXNzJyxcbiAgICAgICAgICBib3RcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGMucHVzaFBDKG5ldyBMYWJlbCgpKTtcblxuICAgIGxldCBvd25EZXNjID0gdGhpcy5HZXRPd25Qcm9wZXJ0eShzKTtcblxuICAgIGlmIChvd25EZXNjLnZhbHVlICYmIElzRGF0YURlc2NyaXB0b3Iob3duRGVzYy52YWx1ZSkpIHtcbiAgICAgIHRoaXMuRGVmaW5lT3duUHJvcGVydHkocywgeyB2YWx1ZTogdi52YWx1ZSwgbGFiZWw6IHYubGFiZWwgfSwgVGhyb3cpO1xuICAgICAgYy5wb3BQQygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBkZXNjID0gdGhpcy5HZXRQcm9wZXJ0eShzKTtcbiAgICBpZiAoZGVzYy52YWx1ZSAmJiBJc0FjY2Vzc29yRGVzY3JpcHRvcihkZXNjLnZhbHVlKSkge1xuXG4gICAgICB0aGlzLnN0cnVjdCA9IGx1Yih0aGlzLnN0cnVjdCwgcy5sYWJlbCk7XG4gICAgICBpZiAoZGVzYy52YWx1ZS5zZXQpIHtcbiAgICAgICAgYy5sYWJlbHMucGMgPSBsdWIoYy5sYWJlbHMucGMsIGRlc2MubGFiZWwpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZGVzYy52YWx1ZS5zZXQuY2FsbCh0aGlzLCB2KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIG1vbml0b3IudHJ5UmV0aHJvdyhlLCBUaHJvdyk7XG4gICAgICAgICAgbW9uaXRvci5mYXRhbChgRWNtYU9iamVjdC5QdXQsIHVuYWJsZSB0byBsaWZ0ICR7ZX0gb2YgdHlwZSAke3R5cGVvZiBlfSAoUHV0KCR7cy52YWx1ZX0sICR7di52YWx1ZX0pIG9uICR7dGhpcy5wcm9wZXJ0aWVzfSlgKTtcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIGMucG9wUEMoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjLmxhYmVscy5wYyA9IGx1YihjLmxhYmVscy5wYywgZGVzYy5sYWJlbCk7XG4gICAgdGhpcy5EZWZpbmVPd25Qcm9wZXJ0eShzLFxuICAgICAge1xuICAgICAgICB2YWx1ZTogdi52YWx1ZSxcbiAgICAgICAgbGFiZWw6IHYubGFiZWwsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0sIFRocm93KTtcbiAgICBjLnBvcFBDKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSGFzUHJvcGVydHksIDguMTIuNiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIEhhc1Byb3BlcnR5KHM6IFZhbHVlPHN0cmluZyB8IG51bWJlcj4pOiBWYWx1ZTxib29sZWFuPiB7XG4gICAgbGV0IGRlc2MgPSB0aGlzLkdldFByb3BlcnR5KHMpO1xuXG4gICAgbGV0IHZhbCA9IG5ldyBWYWx1ZShkZXNjLnZhbHVlICE9PSB1bmRlZmluZWQsIGRlc2MubGFiZWwpO1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICAvLyBEZWxldGUsIDguMTIuNyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgRGVsZXRlKHM6IFZhbHVlPHN0cmluZyB8IG51bWJlcj4sIFRocm93PzogYm9vbGVhbik6IFZhbHVlPGJvb2xlYW4+IHtcbiAgICBsZXQgYyA9IG1vbml0b3IuY29udGV4dDtcbiAgICBsZXQgcHJvcGVydHlOYW1lID0gcy52YWx1ZTtcblxuICAgIGxldCBkZXNjID0gdGhpcy5HZXRPd25Qcm9wZXJ0eShzKTtcblxuICAgIGlmIChkZXNjLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBuZXcgVmFsdWUodHJ1ZSwgZGVzYy5sYWJlbCk7XG4gICAgfVxuXG4gICAgaWYgKCFsZShjLmVmZmVjdGl2ZVBDLCB0aGlzLnN0cnVjdCkpIHtcbiAgICAgIGxldCBtc2cgPSBgRWNtYS5wcm90b3R5cGUuRGVsZXRlOiBzZWN1cml0eSBjb250ZXh0ICR7Yy5lZmZlY3RpdmVQQ30gbm90IGJlbG93IHN0cnVjdHVyZSAke3RoaXMuc3RydWN0fWA7XG4gICAgICBtb25pdG9yLnNlY3VyaXR5RXJyb3IobXNnKTtcblxuICAgICAgLy8gRm9yIG9ic2VydmFibGUgZmxvd3NcbiAgICAgIHRoaXMuc3RydWN0ID0gbHViKHRoaXMuc3RydWN0LCBjLmVmZmVjdGl2ZVBDKTtcbiAgICB9XG5cbiAgICBsZXQgbGJsID0gbHViKGMuZWZmZWN0aXZlUEMsIGRlc2MubGFiZWwpO1xuICAgIGxldCBleGlzdGVuY2UgPSB0aGlzLmxhYmVsc1twcm9wZXJ0eU5hbWVdLmV4aXN0ZW5jZTtcblxuICAgIC8vIHVzZSBwYyBzdGFjayBmb3IgdGFpbnQgbW9kZVxuICAgIGMucHVzaFBDKGxibCk7XG4gICAgaWYgKCFsZShjLmVmZmVjdGl2ZVBDLCBleGlzdGVuY2UpKSB7XG4gICAgICBsZXQgbXNnID0gYEVjbWEucHJvdG90eXBlLkRlbGV0ZTogc2VjdXJpdHkgY29udGV4dCAke2xibH0gbm90IGJlbG93IGV4c3RlbmNlIGxhYmVsICR7ZXhpc3RlbmNlfWA7XG4gICAgICBtb25pdG9yLnNlY3VyaXR5RXJyb3IobXNnKTtcblxuICAgICAgLy8gRm9yIG9ic2VydmFibGUgZmxvd3NcbiAgICAgIGV4aXN0ZW5jZSA9IGx1YihleGlzdGVuY2UsIGxibCk7XG4gICAgfVxuICAgIGMucG9wUEMoKTtcblxuICAgIGxldCByZXM7XG4gICAgdHJ5IHtcbiAgICAgIHJlcyA9IGRlbGV0ZSB0aGlzLnByb3BlcnRpZXNbcHJvcGVydHlOYW1lXTtcbiAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMubGFiZWxzW3Byb3BlcnR5TmFtZV07XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbW9uaXRvci50cnlSZXRocm93KGUsIFRocm93KTtcbiAgICAgIG1vbml0b3IuZmF0YWwoYEVjbWFPYmplY3QuRGVsZXRlLCB1bmFibGUgdG8gbGlmdCAke2V9IG9mIHR5cGUgJHt0eXBlb2YgZX0gKERlbGV0ZSgke3MudmFsdWV9KSBvbiAke3RoaXMucHJvcGVydGllc30pYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBWYWx1ZShyZXMsIGx1YihkZXNjLmxhYmVsLCBleGlzdGVuY2UpKTtcbiAgfVxuXG4gIC8vIERlZmF1bHRWYWx1ZSwgOC4xMi44IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICBEZWZhdWx0VmFsdWUoaGludD86IFwic3RyaW5nXCIgfCBcIm51bWJlclwiKTogVmFsdWU8UHJpbWl0aXZlVmFsdWVUeXBlcz4ge1xuXG4gICAgaWYgKGhpbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHRoaXMuQ2xhc3MgPT09ICdEYXRlJylcbiAgICAgICAgaGludCA9ICdzdHJpbmcnO1xuICAgICAgZWxzZVxuICAgICAgICBoaW50ID0gJ251bWJlcic7XG4gICAgfVxuXG4gICAgaWYgKGhpbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBsZXQgdG9TdHJpbmcgPSB0aGlzLkdldChjb25zdGFudHMudG9TdHJpbmcpO1xuXG4gICAgICBpZiAoSXNDYWxsYWJsZSh0b1N0cmluZykpIHtcbiAgICAgICAgbGV0IHN0ciA9IHRvU3RyaW5nLkNhbGwobmV3IFZhbHVlKHRoaXMsIGJvdCksIFtdKTtcblxuICAgICAgICBpZiAoaXNEZWZpbmVkUHJpbWl0aXZlVmFsdWUoc3RyKSlcbiAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuXG4gICAgICBtb25pdG9yLmNvbnRleHQucHVzaFBDKHRvU3RyaW5nLmxhYmVsKTtcblxuICAgICAgbGV0IHZhbHVlT2YgPSB0aGlzLkdldChjb25zdGFudHMudmFsdWVPZik7XG4gICAgICBpZiAoSXNDYWxsYWJsZSh2YWx1ZU9mKSkge1xuICAgICAgICBsZXQgc3RyID0gdmFsdWVPZi5DYWxsKG5ldyBWYWx1ZSh0aGlzLCBib3QpLCBbXSk7XG5cbiAgICAgICAgaWYgKGlzRGVmaW5lZFByaW1pdGl2ZVZhbHVlKHN0cikpIHtcbiAgICAgICAgICBzdHIucmFpc2UodG9TdHJpbmcubGFiZWwpO1xuICAgICAgICAgIG1vbml0b3IuY29udGV4dC5wb3BQQygpO1xuICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gcmV0dXJuIG5ldyBWYWx1ZSgnRGVmYXVsdFZhbHVlOiB1bmFibGUgdG8gY29udmVydCcsIGJvdCk7XG5cbiAgICAgIG1vbml0b3IuVGhyb3coXG4gICAgICAgIFwiVHlwZUVycm9yXCIsXG4gICAgICAgICdkZWZhdWx0IHZhbHVlLCB1bmFibGUgdG8gY29udmVydCcsXG4gICAgICAgIGx1Yih0b1N0cmluZy5sYWJlbCwgdmFsdWVPZi5sYWJlbClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gaGludCBtdXN0IGJlICdudW1iZXInXG5cblxuICAgIGxldCB2YWx1ZU9mID0gdGhpcy5HZXQoY29uc3RhbnRzLnZhbHVlT2YpO1xuICAgIGlmIChJc0NhbGxhYmxlKHZhbHVlT2YpKSB7XG4gICAgICBsZXQgc3RyID0gdmFsdWVPZi5DYWxsKG5ldyBWYWx1ZSh0aGlzLCBib3QpLCBbXSk7XG5cbiAgICAgIGlmIChpc0RlZmluZWRQcmltaXRpdmVWYWx1ZShzdHIpKVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIG1vbml0b3IuY29udGV4dC5wdXNoUEModmFsdWVPZi5sYWJlbCk7XG5cbiAgICBsZXQgdG9TdHJpbmcgPSB0aGlzLkdldChjb25zdGFudHMudG9TdHJpbmcpO1xuXG4gICAgaWYgKElzQ2FsbGFibGUodG9TdHJpbmcpKSB7XG4gICAgICBsZXQgc3RyID0gdG9TdHJpbmcuQ2FsbChuZXcgVmFsdWUodGhpcywgYm90KSwgW10pO1xuICAgICAgaWYgKGlzRGVmaW5lZFByaW1pdGl2ZVZhbHVlKHN0cikpIHtcbiAgICAgICAgc3RyLnJhaXNlKHZhbHVlT2YubGFiZWwpO1xuICAgICAgICBtb25pdG9yLmNvbnRleHQucG9wUEMoKTtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbW9uaXRvci5UaHJvdyhcbiAgICAgIFwiVHlwZUVycm9yXCIsXG4gICAgICAnZGVmYXVsdCB2YWx1ZSwgdW5hYmxlIHRvIGNvbnZlcnQnLFxuICAgICAgbHViKHRvU3RyaW5nLmxhYmVsLCB2YWx1ZU9mLmxhYmVsKVxuICAgICk7XG4gIH1cblxuICAvLyBEZWZpbmVPd25Qcm9wZXJ0eSwgOC4xMi45IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgRGVmaW5lT3duUHJvcGVydHkoczogVmFsdWU8c3RyaW5nIHwgbnVtYmVyPiwgZGVzYzogSlNGUHJvcGVydHlEZXNjcmlwdG9yLCBUaHJvdz86IEJvb2xlYW4pOiBWYWx1ZTxib29sZWFuPiB7XG4gICAgbGV0IGMgPSBtb25pdG9yLmNvbnRleHQ7XG5cbiAgICBsZXQgcHJvcE5hbWUgPSBzLnZhbHVlO1xuICAgIGxldCBwcm9wTmFtZUxhYmVsID0gcy5sYWJlbDtcblxuICAgIGxldCBjb250ZXh0TGFiZWwgPSBsdWIoYy5lZmZlY3RpdmVQQywgcHJvcE5hbWVMYWJlbCk7XG5cbiAgICB0cnkge1xuICAgICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMucHJvcGVydGllcywgcHJvcE5hbWUpKSB7XG4gICAgICAgIGxldCB2YWx1ZUxhYmVsID0gdGhpcy5sYWJlbHNbcHJvcE5hbWVdLnZhbHVlO1xuXG4gICAgICAgIC8vIHVzZSB0aGUgcGMgc3RhY2sgdG8gbWFrZSB0YWludCBtb2RlIGVhc2llclxuICAgICAgICBjLnB1c2hQQyhjb250ZXh0TGFiZWwpO1xuICAgICAgICBpZiAoIWxlKGMuZWZmZWN0aXZlUEMsIHZhbHVlTGFiZWwpKSB7XG4gICAgICAgICAgbGV0IG1zZyA9IGBFY21hLnByb3RvdHlwZS5EZWZpbmVPd25Qcm9wZXJ0eTogc2VjdXJpdHkgY29udGV4dCAke2NvbnRleHRMYWJlbH0gbm90IGJlbG93IGV4aXN0aW5nIHZhbHVlIGxhYmVsICR7dmFsdWVMYWJlbH0gZm9yIHByb3BlcnR5ICR7cHJvcE5hbWV9YDtcbiAgICAgICAgICBtb25pdG9yLnNlY3VyaXR5RXJyb3IobXNnKTtcblxuICAgICAgICAgIC8vIEZvciBvYnNlcnZhYmxlIGZsb3dzXG4gICAgICAgICAgdmFsdWVMYWJlbCA9IGx1Yih2YWx1ZUxhYmVsLCBjb250ZXh0TGFiZWwpO1xuICAgICAgICB9XG4gICAgICAgIGMucG9wUEMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghbGUoYy5lZmZlY3RpdmVQQywgdGhpcy5zdHJ1Y3QpKSB7XG4gICAgICAgICAgbGV0IG1zZyA9IGBFY21hLnByb3RvdHlwZS5EZWZpbmVPd25Qcm9wZXJ0eTogc2VjdXJpdHkgY29udGV4dCAke2MuZWZmZWN0aXZlUEN9IG5vdCBiZWxvdyBzdHJ1Y3R1cmUgJHt0aGlzLnN0cnVjdH1gO1xuICAgICAgICAgIG1vbml0b3Iuc2VjdXJpdHlFcnJvcihtc2cpO1xuXG4gICAgICAgICAgLy8gRm9yIG9ic2VydmFibGUgZmxvd3NcbiAgICAgICAgICB0aGlzLnN0cnVjdCA9IGx1Yih0aGlzLnN0cnVjdCwgYy5lZmZlY3RpdmVQQyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5zdHJ1Y3QgPSBsdWIodGhpcy5zdHJ1Y3QsIHByb3BOYW1lTGFiZWwpO1xuXG4gICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgbGV0IGdldCA9IGRlc2MuZ2V0O1xuICAgICAgICAvL0B0cy1pZ25vcmUgREVTQyBIRUxMXG4gICAgICAgIGRlc2MuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2V0LkNhbGwobmV3IFZhbHVlKHRoaXMsIGJvdCksIFtdKTsgfTtcbiAgICAgICAgLy9AdHMtaWdub3JlIERFU0MgSEVMTFxuICAgICAgICBkZXNjLmdldC5hY3R1YWxGdW5jdGlvbiA9IGdldDtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICAgIGxldCBzZXQgPSBkZXNjLnNldDtcbiAgICAgICAgLy9AdHMtaWdub3JlIERFU0MgSEVMTFxuICAgICAgICBkZXNjLnNldCA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBzZXQuQ2FsbChuZXcgVmFsdWUodGhpcywgYm90KSwgW3ZdKTsgfTtcbiAgICAgICAgLy9AdHMtaWdub3JlIERFU0MgSEVMTFxuICAgICAgICBkZXNjLnNldC5hY3R1YWxGdW5jdGlvbiA9IHNldDtcbiAgICAgIH1cblxuICAgICAgLy9AdHMtaWdub3JlIERFU0MgSEVMTFxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMucHJvcGVydGllcywgcHJvcE5hbWUsIGRlc2MpO1xuICAgICAgdGhpcy5sYWJlbHNbcHJvcE5hbWVdID0geyB2YWx1ZTogbHViKGRlc2MubGFiZWwsIGNvbnRleHRMYWJlbCksIGV4aXN0ZW5jZTogY29udGV4dExhYmVsIH07XG5cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvL0B0cy1pZ25vcmUgVFlQRVNcbiAgICAgIG1vbml0b3IudHJ5UmV0aHJvdyhlLCBUaHJvdyk7XG4gICAgICBtb25pdG9yLmZhdGFsKGBFY21hT2JqZWN0LkRlZmluZU93blByb3BlcnR5LCB1bmFibGUgdG8gbGlmdCAke2V9IG9mIHR5cGUgJHt0eXBlb2YgZX0gKERlZmluZU93blByb3BlcnR5KCR7cy52YWx1ZX0sICR7ZGVzY30pIG9uICR7dGhpcy5wcm9wZXJ0aWVzfSlgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFZhbHVlKHRydWUsIGJvdCk7XG4gIH1cblxufVxuXG5mdW5jdGlvbiBpc0RlZmluZWRQcmltaXRpdmVWYWx1ZSh2YWx1ZTogVmFsdWU8YW55Pik6IHZhbHVlIGlzIFZhbHVlPFByaW1pdGl2ZVZhbHVlVHlwZXM+IHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZS52YWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGVvZiB2YWx1ZS52YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlLnZhbHVlID09PSAnbnVtYmVyJ1xufSIsImltcG9ydCB7IFZhbHVlIH0gZnJvbSBcIi4uL1ZhbHVlXCI7XG5pbXBvcnQgeyBFY21hT2JqZWN0IH0gZnJvbSAnLi4vT2JqZWN0cy9FY21hT2JqZWN0JztcbmltcG9ydCAqIGFzIGNvbnN0YW50cyBmcm9tICcuLi9Db25zdGFudHMnO1xuaW1wb3J0IHsgVG9TdHJpbmcgfSBmcm9tICcuLi9Db252ZXJzaW9uL1RvU3RyaW5nJztcbmltcG9ydCB7IGJvdCB9IGZyb20gJy4uL0xhYmVsJztcbmltcG9ydCB7IE1vbml0b3JCYXNlIH0gZnJvbSAnLi4vTW9uaXRvckJhc2UnO1xuaW1wb3J0IHsgVmFsdWVUeXBlcyB9IGZyb20gXCIuLi9JbnRlcmZhY2VzXCI7XG5pbXBvcnQgeyBTdGFja1RyYWNlIH0gZnJvbSBcIi4uL1N0YWNrVHJhY2VcIjtcblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZGVjbGFyZSB2YXIgbW9uaXRvcjogTW9uaXRvckJhc2U7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgY2xhc3MgRXJyb3JPYmplY3QgZXh0ZW5kcyBFY21hT2JqZWN0IHtcblxuICBzdGFjazogU3RhY2tUcmFjZTtcbiAgbWVzc2FnZTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKHY6IFZhbHVlPFZhbHVlVHlwZXM+KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLlByb3RvdHlwZSA9IG5ldyBWYWx1ZShtb25pdG9yLmluc3RhbmNlcy5FcnJvclByb3RvdHlwZSwgYm90KTtcbiAgICB0aGlzLkNsYXNzID0gJ0Vycm9yJztcbiAgICB0aGlzLkV4dGVuc2libGUgPSB0cnVlO1xuXG4gICAgbGV0IG1lc3NhZ2UgPSBuZXcgVmFsdWUoXCJcIiwgYm90KTtcblxuICAgIGlmICh2LnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG1lc3NhZ2UgPSBUb1N0cmluZyh2KTtcbiAgICB9XG5cbiAgICB0aGlzLkRlZmluZU93blByb3BlcnR5KFxuICAgICAgY29uc3RhbnRzLm1lc3NhZ2UsXG4gICAgICB7XG4gICAgICAgIHZhbHVlOiBtZXNzYWdlLnZhbHVlLFxuICAgICAgICBsYWJlbDogbWVzc2FnZS5sYWJlbCxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gZm9yIHRvU3RyaW5nXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZS52YWx1ZTtcbiAgICB0aGlzLnN0YWNrID0gbW9uaXRvci5zdGFja1RyYWNlKCk7XG4gIH1cblxuICB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgIGxldCBzdHIgPSAnRXJyb3I6ICcgKyB0aGlzLm1lc3NhZ2UgKyAnXFxuJyArIHRoaXMuc3RhY2sudG9TdHJpbmcoKTtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59IiwiaW1wb3J0IHsgTW9uaXRvckJhc2UgfSBmcm9tICcuLi9Nb25pdG9yQmFzZSc7XG5cbmltcG9ydCB7IE5hdGl2ZUVycm9yT2JqZWN0IH0gZnJvbSAnLi9OYXRpdmVFcnJvck9iamVjdCc7XG5pbXBvcnQgeyBWYWx1ZSB9IGZyb20gJy4uL1ZhbHVlJztcbmltcG9ydCB7IFZhbHVlVHlwZXMgfSBmcm9tICcuLi9JbnRlcmZhY2VzJztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmRlY2xhcmUgdmFyIG1vbml0b3I6IE1vbml0b3JCYXNlO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGNsYXNzIEV2YWxFcnJvck9iamVjdCBleHRlbmRzIE5hdGl2ZUVycm9yT2JqZWN0IHtcbiAgVHlwZSA9ICdOYXRpdmVFcnJvcic7XG5cbiAgY29uc3RydWN0b3IodjogVmFsdWU8VmFsdWVUeXBlcz4pIHtcbiAgICBzdXBlcihtb25pdG9yLmluc3RhbmNlcy5FdmFsRXJyb3JQcm90b3R5cGUsIHYpO1xuICB9XG59IiwiaW1wb3J0IHsgbHViLCBib3QgfSBmcm9tICcuLi9MYWJlbCc7XG5pbXBvcnQgeyBWYWx1ZSB9IGZyb20gXCIuLi9WYWx1ZVwiO1xuaW1wb3J0IHsgRGVmaW5lRkZGLCBEZWZpbmVURlQsIERlZmluZVRGRiwgRGVmaW5lRkZUIH0gZnJvbSAnLi4vRGVmaW5lJztcbmltcG9ydCB7IEVjbWFPYmplY3QgfSBmcm9tICcuLi9PYmplY3RzL0VjbWFPYmplY3QnO1xuXG5pbXBvcnQgKiBhcyBjb25zdGFudHMgZnJvbSAnLi4vQ29uc3RhbnRzJztcbmltcG9ydCB7IE1vbml0b3JCYXNlIH0gZnJvbSAnLi4vTW9uaXRvckJhc2UnO1xuXG5pbXBvcnQgeyBPYmplY3RPYmplY3QgfSBmcm9tICcuLi9PYmplY3RzL09iamVjdE9iamVjdCc7XG5pbXBvcnQgeyBIYXNJbnN0YW5jZSB9IGZyb20gJy4uL0hhc0luc3RhbmNlJztcblxuaW1wb3J0ICogYXMgZXN0cmVlIGZyb20gJ2VzdHJlZSc7XG5pbXBvcnQgeyBMZXhpY2FsRW52aXJvbm1lbnQgfSBmcm9tICcuLi9MZXhpY2FsRW52aXJvbm1lbnQnO1xuaW1wb3J0IHsgVmFsdWVUeXBlcywgSXNJRWNtYU9iamVjdCB9IGZyb20gJy4uL0ludGVyZmFjZXMnO1xuaW1wb3J0IHsgV29ya0xpc3RQdHIsIEFzeW5jQ29uc3RydWN0Q2xvc3VyZURhdGEgfSBmcm9tICcuLi9Db250ZXh0JztcbmltcG9ydCB7IHByZXR0eSB9IGZyb20gJy4uL1BQJztcbmltcG9ydCB7IGV4ZWN1dGUgfSBmcm9tICcuLi9FbmdpbmUvRXhlY3V0ZSc7XG5pbXBvcnQgeyBUb09iamVjdCB9IGZyb20gJy4uL0NvbnZlcnNpb24vVG9PYmplY3QnO1xuaW1wb3J0IHsgTmV3RGVjbGFyYXRpdmVFbnZpcm9ubWVudCB9IGZyb20gJy4uL0RlY2xhcmF0aXZlRW52aXJvbm1lbnRSZWNvcmQnO1xuaW1wb3J0IHsgRGVjbGFyYXRpb25CaW5kaW5nSW5zdGFudGlhdGlvbiB9IGZyb20gJy4uL0VuZ2luZS9CaW5kaW5nJztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmRlY2xhcmUgdmFyIG1vbml0b3I6IE1vbml0b3JCYXNlO1xuXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gMTAuNC4zXG5mdW5jdGlvbiBlbnRlckZ1bmN0aW9uQ29kZShGOiBGdW5jdGlvbk9iamVjdCwgdGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pIHtcbiAgbGV0IGMgPSBtb25pdG9yLmNvbnRleHQ7XG5cbiAgbGV0IHRoaXNCaW5kaW5nOiBWYWx1ZTxFY21hT2JqZWN0PjtcblxuICBpZiAodGhpc0FyZy52YWx1ZSA9PT0gbnVsbCB8fCB0aGlzQXJnLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzQmluZGluZyA9IG5ldyBWYWx1ZShtb25pdG9yLkdsb2JhbE9iamVjdCwgdGhpc0FyZy5sYWJlbCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHRoaXNBcmcudmFsdWUgIT09ICdvYmplY3QnICYmIHR5cGVvZiB0aGlzQXJnLnZhbHVlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpc0JpbmRpbmcgPSBUb09iamVjdCh0aGlzQXJnKTtcbiAgfSBlbHNlIHtcbiAgICAvL0B0cy1pZ25vcmUgVHlwZVNjcmlwdCBkb2Vzbid0IG5hcnJvdyBnZW5lcmljIHR5cGVzXG4gICAgdGhpc0JpbmRpbmcgPSB0aGlzQXJnO1xuICB9XG5cbiAgdmFyIGxvY2FsRW52ID0gbmV3IFZhbHVlKE5ld0RlY2xhcmF0aXZlRW52aXJvbm1lbnQoRi5TY29wZSksXG4gICAgYy5lZmZlY3RpdmVQQyk7XG5cbiAgdmFyIG5ld0NvbnRleHQgPSBjLmNsb25lKHRoaXNCaW5kaW5nLCBsb2NhbEVudiwgbG9jYWxFbnYpO1xuICBuZXdDb250ZXh0LmxhYmVscy5yZXQgPSBsdWIobmV3Q29udGV4dC5sYWJlbHMucmV0LCBuZXdDb250ZXh0LmxhYmVscy5wYyk7XG4gIG5ld0NvbnRleHQub3duZXIgPSBGLk5hbWU7XG4gIERlY2xhcmF0aW9uQmluZGluZ0luc3RhbnRpYXRpb24obmV3Q29udGV4dCwgRiwgYXJncyk7XG5cbiAgcmV0dXJuIG5ld0NvbnRleHQ7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRnVuY3Rpb24gb2JqZWN0cywgMTMuMlxuXG5leHBvcnQgY2xhc3MgRnVuY3Rpb25PYmplY3QgZXh0ZW5kcyBFY21hT2JqZWN0IHtcblxuICBTb3VyY2U/OiBlc3RyZWUuRnVuY3Rpb247XG4gIE5hbWU/OiBzdHJpbmc7XG5cbiAgU2NvcGU6IFZhbHVlPExleGljYWxFbnZpcm9ubWVudD47XG4gIEZvcm1hbFBhcmFtZXRlcnM6IGVzdHJlZS5QYXR0ZXJuW107XG4gIENvZGU6IGVzdHJlZS5CbG9ja1N0YXRlbWVudCB8IGVzdHJlZS5FeHByZXNzaW9uO1xuXG4gIGNvbnN0cnVjdG9yKHBhcm1zOiBlc3RyZWUuUGF0dGVybltdLCBjb2RlOiBlc3RyZWUuQmxvY2tTdGF0ZW1lbnQgfCBlc3RyZWUuRXhwcmVzc2lvbiwgc2NvcGU6IFZhbHVlPExleGljYWxFbnZpcm9ubWVudD4pIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5DbGFzcyA9ICdGdW5jdGlvbic7XG4gICAgdGhpcy5Qcm90b3R5cGUgPSBuZXcgVmFsdWUobW9uaXRvci5pbnN0YW5jZXMuRnVuY3Rpb25Qcm90b3R5cGUsIGJvdCk7XG5cbiAgICB0aGlzLlNjb3BlID0gc2NvcGU7XG4gICAgdGhpcy5Gb3JtYWxQYXJhbWV0ZXJzID0gcGFybXMgPyBwYXJtcyA6IFtdO1xuICAgIHRoaXMuQ29kZSA9IGNvZGU7XG5cbiAgICB0aGlzLkV4dGVuc2libGUgPSB0cnVlO1xuXG4gICAgRGVmaW5lRkZUKHRoaXMsIGNvbnN0YW50cy5sZW5ndGgsIHRoaXMuRm9ybWFsUGFyYW1ldGVycy5sZW5ndGgpO1xuICAgIC8vIE5PVEU6IHdpbGwgYmUgdXBkYXRlZCB3aGVuIGNhbGxlZCBhbmQgc2luY2Ugd2UgcGlnZ3liYWNrIHByb3BlcnRpZXMgb24gbmF0aXZlIHByb3BlcnRpZXNcbiAgICAvLyBkZWZpbmluZyBhcyBGRkYgd2lsbCBjYXVzZSBmdXR1cmUgdXBkYXRlcyB0byBmYWlsLiBUaHVzIHdlIGRlZmluZSBpdCBhcyBURlQgZXZlbiB0aG91Z2hcbiAgICAvLyB0aGlzIHZpb2xhdGVzIHRoZSBzdGFuZGFyZC5cbiAgICBEZWZpbmVGRkYodGhpcywgY29uc3RhbnRzLmFyZ3VtZW50cywgbnVsbCk7XG4gICAgRGVmaW5lRkZGKHRoaXMsIGNvbnN0YW50cy5jYWxsZXIsIG51bGwpO1xuXG5cbiAgICBsZXQgcHJvdG8gPSBuZXcgT2JqZWN0T2JqZWN0KCk7XG4gICAgRGVmaW5lVEZUKHByb3RvLCBjb25zdGFudHMuY29uc3RydWN0b3IsIHRoaXMpO1xuXG4gICAgRGVmaW5lVEZGKHRoaXMsIGNvbnN0YW50cy5wcm90b3R5cGUsIHByb3RvKTtcbiAgfVxuXG4gIC8vIC0tLVxuXG4gIEFzeW5jQ2FsbCh0aGlzQXJnOiBWYWx1ZTxWYWx1ZVR5cGVzPiwgYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IHZvaWQge1xuICAgIC8vIHN0ZXAgMSwgYXMgaW4gMTAuNC4zIGVtYm9kaWVkIGluIGVudGVyRnVuY3Rpb25Db2RlXG4gICAgbGV0IGZ1bmNDdHggPSBlbnRlckZ1bmN0aW9uQ29kZSh0aGlzLCB0aGlzQXJnLCBhcmdzKTtcblxuICAgIC8vIGZvciBzdGFjayB0cmFjZVxuICAgIGZ1bmNDdHgub3duZXIgPSB0aGlzLk5hbWU7XG5cbiAgICBtb25pdG9yLmNvbnRleHRTdGFjay5wdXNoKGZ1bmNDdHgpO1xuICAgIGxldCBpcCA9IGZ1bmNDdHgud29ya0xpc3QudG9wKCk7XG5cbiAgICBpZiAodGhpcy5Db2RlKSB7XG4gICAgICBpcC50aGVuKHRoaXMuQ29kZSk7XG4gICAgICBpcC50aGVuKEFzeW5jQ2FsbEVuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlwLnRoZW4oQXN5bmNDYWxsRW5kKTtcbiAgICB9XG5cbiAgfVxuXG4gIC8vIC0tLVxuXG4gIC8vIDEzLjIuMSBcbiAgQ2FsbCh0aGlzQXJnOiBWYWx1ZTxWYWx1ZVR5cGVzPiwgYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPFZhbHVlVHlwZXM+IHtcblxuICAgIC8vIHN0ZXAgMSwgYXMgaW4gMTAuNC4zIGVtYm9kaWVkIGluIGVudGVyRnVuY3Rpb25Db2RlXG4gICAgbGV0IGZ1bmNDdHggPSBlbnRlckZ1bmN0aW9uQ29kZSh0aGlzLCB0aGlzQXJnLCBhcmdzKTtcblxuICAgIC8vIGZvciBzdGFjayB0cmFjZVxuICAgIGZ1bmNDdHgub3duZXIgPSB0aGlzLk5hbWU7XG5cbiAgICBsZXQgcmVzO1xuICAgIG1vbml0b3IuY29udGV4dFN0YWNrLnB1c2goZnVuY0N0eCk7XG5cblxuICAgIGlmICh0aGlzLkNvZGUpIHtcbiAgICAgIHJlcyA9IGV4ZWN1dGUodGhpcy5Db2RlLCBmYWxzZSk7XG4gICAgfVxuXG5cbiAgICBpZiAoZnVuY0N0eC5yZXN1bHQudmFsdWUpIHtcbiAgICAgIGZ1bmNDdHgucmVzdWx0LnZhbHVlLnJhaXNlKGZ1bmNDdHgubGFiZWxzLnJldCk7XG4gICAgfVxuXG4gICAgbW9uaXRvci5jb250ZXh0U3RhY2sucG9wKCk7XG5cbiAgICAvLyBjb3B5IG91dCB0aGUgaW5uZXIgZXhjZXB0aW9uIGxldmVsXG4gICAgbW9uaXRvci5jb250ZXh0LmxhYmVscy5leGMgPSBsdWIobW9uaXRvci5jb250ZXh0LmxhYmVscy5leGMsIGZ1bmNDdHgubGFiZWxzLmV4Yyk7XG5cbiAgICBpZiAocmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHN3aXRjaCAocmVzLnR5cGUpIHtcbiAgICAgICAgY2FzZSAndGhyb3cnOlxuICAgICAgICAgIHRocm93IHJlcy52YWx1ZTtcblxuICAgICAgICBjYXNlICdyZXR1cm4nOlxuICAgICAgICAgIC8vIFRPRE86IHNob3VsZCBiZSBmaXhlZCBieSBtYWtpbmcgUmVzdWx0IGEgdGFnZ2VkIHVuaW9uXG4gICAgICAgICAgaWYgKHJlcy52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgbW9uaXRvci5mYXRhbCgnQ2FsbDogbWFsZm9ybWVkIHJlc3VsdCcpO1xuICAgICAgICAgICAgdGhyb3cgJ1R5cGVTY3JpcHQnO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzLnZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgVmFsdWUodW5kZWZpbmVkLCBmdW5jQ3R4LmxhYmVscy5yZXQpO1xuICB9XG5cbiAgLy8gLS0tXG5cbiAgQXN5bmNDb25zdHJ1Y3QoYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFdvcmtMaXN0UHRyIHtcbiAgICBsZXQgb2JqID0gbmV3IEVjbWFPYmplY3QoKTtcbiAgICBvYmouQ2xhc3MgPSAnT2JqZWN0JztcbiAgICBvYmouRXh0ZW5zaWJsZSA9IHRydWU7XG5cbiAgICBsZXQgcHJvdG8gPSB0aGlzLkdldChjb25zdGFudHMucHJvdG90eXBlKTtcbiAgICBpZiAoIUlzSUVjbWFPYmplY3QocHJvdG8pKSB7XG4gICAgICBwcm90byA9IG5ldyBWYWx1ZShtb25pdG9yLmluc3RhbmNlcy5PYmplY3RQcm90b3R5cGUsIGJvdCk7XG4gICAgfVxuXG4gICAgLy8gQHRzLWlnbm9yZSwgd2Uga25vdyBwcm90byBpcyBWYWx1ZTxFY21hT2JqZWN0PlxuICAgIG9iai5Qcm90b3R5cGUgPSBwcm90bztcblxuICAgIGxldCBpcCA9IG1vbml0b3IuY29udGV4dC53b3JrTGlzdC50b3AoKTtcblxuICAgIHRoaXMuQXN5bmNDYWxsKG5ldyBWYWx1ZShvYmosIGJvdCksIGFyZ3MpO1xuICAgIC8vIFRPRE86IGl0IHNlZW1zIHRoYXQgdGhlIGNsb3N1cmUgZGF0YSBpcyBub3QgdXNlZFxuICAgIGlwLnRoZW4oQXN5bmNDb25zdHJ1Y3RFbmQsIHsgb2JqZWN0OiBvYmogfSk7XG5cbiAgICByZXR1cm4gaXA7XG4gIH1cblxuICAvLyAtLS1cblxuXG4gIC8vIC0tLVxuICAvLyAxMy4yLjJcbiAgQ29uc3RydWN0KGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxFY21hT2JqZWN0PiB7XG4gICAgbGV0IG9iaiA9IG5ldyBFY21hT2JqZWN0KCk7XG4gICAgb2JqLkNsYXNzID0gJ09iamVjdCc7XG4gICAgb2JqLkV4dGVuc2libGUgPSB0cnVlO1xuXG4gICAgbGV0IHByb3RvID0gdGhpcy5HZXQoY29uc3RhbnRzLnByb3RvdHlwZSk7XG4gICAgaWYgKCFJc0lFY21hT2JqZWN0KHByb3RvKSkge1xuICAgICAgcHJvdG8gPSBuZXcgVmFsdWUobW9uaXRvci5pbnN0YW5jZXMuT2JqZWN0UHJvdG90eXBlLCBib3QpO1xuICAgIH1cblxuICAgIC8vIEB0cy1pZ25vcmUsIHdlIGtub3cgcHJvdG8gaXMgVmFsdWU8RWNtYU9iamVjdD5cbiAgICBvYmouUHJvdG90eXBlID0gcHJvdG87XG5cbiAgICBsZXQgcmVzdWx0ID0gdGhpcy5DYWxsKG5ldyBWYWx1ZShvYmosIGJvdCksIGFyZ3MpO1xuXG4gICAgaWYgKCFJc0lFY21hT2JqZWN0KHJlc3VsdCkpIHtcbiAgICAgIHJlc3VsdCA9IG5ldyBWYWx1ZShvYmosIGJvdCk7XG4gICAgfVxuXG4gICAgLy8gQHRzLWlnbm9yZSwgd2Uga25vdyByZXN1bHQgaXMgVmFsdWU8RWNtYU9iamVjdD5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgSGFzSW5zdGFuY2UoVjogYW55KSB7XG4gICAgcmV0dXJuIEhhc0luc3RhbmNlLmNhbGwodGhpcywgVik7XG4gIH1cblxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBwcmV0dHkodGhpcy5Tb3VyY2UpO1xuICB9XG59XG5cbi8vIC0tLVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBBc3luY0NhbGxFbmQoKTogdm9pZCB7XG4gIGxldCBjYWxsQ29udGV4dCA9IG1vbml0b3IuY29udGV4dDtcbiAgbW9uaXRvci5jb250ZXh0U3RhY2sucG9wKCk7XG4gIGxldCBjYWxsZXJDb250ZXh0ID0gbW9uaXRvci5jb250ZXh0O1xuXG4gIGxldCByZXN1bHQgPSBjYWxsQ29udGV4dC5yZXN1bHQ7XG4gIGxldCByZXRsYWJlbCA9IGNhbGxDb250ZXh0LmxhYmVscy5yZXQ7XG5cbiAgaWYgKHJlc3VsdC50eXBlICE9PSAnbm9ybWFsJyAmJiByZXN1bHQudmFsdWUpIHtcbiAgICByZXN1bHQudmFsdWUucmFpc2UocmV0bGFiZWwpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC52YWx1ZSA9IG5ldyBWYWx1ZSh1bmRlZmluZWQsIHJldGxhYmVsKTtcbiAgfVxuXG4gIC8vIGNvcHkgb3V0IHRoZSBpbm5lciBleGNlcHRpb24gbGV2ZWxcbiAgY2FsbGVyQ29udGV4dC5sYWJlbHMuZXhjID0gbHViKGNhbGxlckNvbnRleHQubGFiZWxzLmV4YywgY2FsbENvbnRleHQubGFiZWxzLmV4Yyk7XG4gIGNhbGxlckNvbnRleHQudmFsdWVTdGFjay5wdXNoKHJlc3VsdCk7XG59XG5Bc3luY0NhbGxFbmQucnVuZm9yID0geyAncmV0dXJuJzogdHJ1ZSwgJ3Rocm93JzogdHJ1ZSB9O1xuXG5cblxuZXhwb3J0IGZ1bmN0aW9uIEFzeW5jQ29uc3RydWN0RW5kKFxuICB0aGlzOiBBc3luY0NvbnN0cnVjdENsb3N1cmVEYXRhXG4pIHtcbiAgLy8gQHRzLWlnbm9yZVxuICBsZXQgcmV0dmFsOiBSZXN1bHQgPSBtb25pdG9yLmNvbnRleHQudmFsdWVTdGFjay5wZWVrKCk7XG4gIFxuICAvLyBUT0RPOiB3aGF0IGFib3V0IHRocm93P1xuICAvLyBUT0RPOiB0aGlzIGlzIG5vdCBhIGNvcnJlY3Qgd2F5IG9mIGNoZWNraW5nIGlmIHJldHVybmVkIG9iamVjdCBpcyBhbiBlY21hb2JqZWN0XG4gIFxuICBpZiAodHlwZW9mIHJldHZhbC52YWx1ZS52YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR2YWwudmFsdWUgPSBuZXcgVmFsdWUodGhpcy5vYmplY3QsIGJvdCk7XG4gIH1cblxufVxuQXN5bmNDb25zdHJ1Y3RFbmQucnVuZm9yID0geyAncmV0dXJuJzogdHJ1ZSwgJ3Rocm93JzogdHJ1ZSB9O1xuXG5cbiIsIlxuaW1wb3J0IHsgVmFsdWUgfSBmcm9tIFwiLi4vVmFsdWVcIjtcbmltcG9ydCAqIGFzIGNvbnN0YW50cyBmcm9tICcuLi9Db25zdGFudHMnO1xuaW1wb3J0ICogYXMgZXNwcmltYSBmcm9tICdlc3ByaW1hJztcbmltcG9ydCB7IEJ1aWx0aW5GdW5jdGlvbk9iamVjdCB9IGZyb20gXCIuL0J1aWx0aW5GdW5jdGlvbk9iamVjdFwiO1xuaW1wb3J0IHsgVG9OdW1iZXIgfSBmcm9tICcuLi9Db252ZXJzaW9uL1RvTnVtYmVyJztcbmltcG9ydCB7IFRvU3RyaW5nIH0gZnJvbSAnLi4vQ29udmVyc2lvbi9Ub1N0cmluZyc7XG5pbXBvcnQgeyBNb25pdG9yQmFzZSB9IGZyb20gJy4uL01vbml0b3JCYXNlJztcblxuaW1wb3J0IHsgRGVmaW5lRkZGLCBEZWZpbmVURlQgfSBmcm9tICcuLi9EZWZpbmUnO1xuaW1wb3J0IHsgRWNtYU9iamVjdCB9IGZyb20gJy4uL09iamVjdHMvRWNtYU9iamVjdCc7XG5cbmltcG9ydCB7IGJvdCwgdG9wLCBsdWIsIGxlLCBMYWJlbCB9IGZyb20gJy4uL0xhYmVsJztcbmltcG9ydCB7IFZhbHVlVHlwZXMsIElzSUVjbWFPYmplY3QgfSBmcm9tIFwiLi4vSW50ZXJmYWNlc1wiO1xuaW1wb3J0IHsgVG9JbnQzMiB9IGZyb20gXCIuLi9Db252ZXJzaW9uL1RvSW50MzJcIjtcbmltcG9ydCB7IGVudGVyRXZhbENvZGUsIGV4ZWN1dGUgfSBmcm9tIFwiLi4vRW5naW5lL0V4ZWN1dGVcIjtcblxuZGVjbGFyZSB2YXIgbW9uaXRvcjogTW9uaXRvckJhc2U7XG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjbGFzcyBHbG9iYWxPYmplY3QgZXh0ZW5kcyBFY21hT2JqZWN0IHtcblxuICAgIGhvc3Q6IGFueTtcblxuICAgIGNvbnN0cnVjdG9yKGhvc3Q6IGFueSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLkNsYXNzID0gJ2dsb2JhbCc7XG5cbiAgICAgICAgaWYgKHRoaXMuUHJvdG90eXBlID09PSB1bmRlZmluZWQgfHwgdGhpcy5Qcm90b3R5cGUudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuUHJvdG90eXBlID0gbmV3IFZhbHVlKG1vbml0b3IuaW5zdGFuY2VzLk9iamVjdFByb3RvdHlwZSwgYm90KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG5cbiAgICAgICAgLy8gMTUuMS4xXG4gICAgICAgIERlZmluZUZGRih0aGlzLCBjb25zdGFudHMuTmFOLCBOYU4pO1xuICAgICAgICBEZWZpbmVGRkYodGhpcywgY29uc3RhbnRzWydJbmZpbml0eSddLCBJbmZpbml0eSk7XG4gICAgICAgIERlZmluZUZGRih0aGlzLCBjb25zdGFudHNbJ3VuZGVmaW5lZCddLCB1bmRlZmluZWQpO1xuXG4gICAgICAgIC8vIDE1LjEuMlxuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzWydldmFsJ10sIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3QoX19ldmFsLCAxLCBob3N0LmV2YWwpKTtcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5wYXJzZUludCwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChfX3BhcnNlSW50LCAyLCBob3N0LnBhcnNlSW50KSk7XG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMucGFyc2VGbG9hdCwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChfX3BhcnNlRmxvYXQsIDEsIGhvc3QucGFyc2VGbG9hdCkpO1xuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLmlzTmFOLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KF9faXNOYU4sIDEsIGhvc3QuaXNOYU4pKTtcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5pc0Zpbml0ZSwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChfX2lzRmluaXRlLCAxLCBob3N0LmlzRmluaXRlKSk7XG5cbiAgICAgICAgLy8gMTUuMS4zXG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuZGVjb2RlVVJJLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KF9fZGVjb2RlVVJJLCAxLCBob3N0LmRlY29kZVVSSSkpO1xuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLmRlY29kZVVSSUNvbXBvbmVudCwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChfX2RlY29kZVVSSUNvbXBvbmVudCwgMSwgaG9zdC5kZWNvZGVVUklDb21wb25lbnQpKTtcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5lbmNvZGVVUkksIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3QoX19lbmNvZGVVUkksIDEsIGhvc3QuZW5jb2RlVVJJKSk7XG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuZW5jb2RlVVJJQ29tcG9uZW50LCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KF9fZW5jb2RlVVJJQ29tcG9uZW50LCAxLCBob3N0LmVuY29kZVVSSUNvbXBvbmVudCkpO1xuXG4gICAgICAgIC8vIDE1LjEuNFxuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLk9iamVjdCwgbW9uaXRvci5pbnN0YW5jZXMuT2JqZWN0Q29uc3RydWN0b3IpO1xuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLkZ1bmN0aW9uLCBtb25pdG9yLmluc3RhbmNlcy5GdW5jdGlvbkNvbnN0cnVjdG9yKTtcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5BcnJheSwgbW9uaXRvci5pbnN0YW5jZXMuQXJyYXlDb25zdHJ1Y3Rvcik7XG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuU3RyaW5nLCBtb25pdG9yLmluc3RhbmNlcy5TdHJpbmdDb25zdHJ1Y3Rvcik7XG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuQm9vbGVhbiwgbW9uaXRvci5pbnN0YW5jZXMuQm9vbGVhbkNvbnN0cnVjdG9yKTtcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5OdW1iZXIsIG1vbml0b3IuaW5zdGFuY2VzLk51bWJlckNvbnN0cnVjdG9yKTtcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5EYXRlLCBtb25pdG9yLmluc3RhbmNlcy5EYXRlQ29uc3RydWN0b3IpO1xuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLlJlZ0V4cCwgbW9uaXRvci5pbnN0YW5jZXMuUmVnRXhwQ29uc3RydWN0b3IpO1xuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLkVycm9yLCBtb25pdG9yLmluc3RhbmNlcy5FcnJvckNvbnN0cnVjdG9yKTtcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5FdmFsRXJyb3IsIG1vbml0b3IuaW5zdGFuY2VzLkV2YWxFcnJvckNvbnN0cnVjdG9yKTtcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5SYW5nZUVycm9yLCBtb25pdG9yLmluc3RhbmNlcy5SYW5nZUVycm9yQ29uc3RydWN0b3IpO1xuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLlJlZmVyZW5jZUVycm9yLCBtb25pdG9yLmluc3RhbmNlcy5SZWZlcmVuY2VFcnJvckNvbnN0cnVjdG9yKTtcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5TeW50YXhFcnJvciwgbW9uaXRvci5pbnN0YW5jZXMuU3ludGF4RXJyb3JDb25zdHJ1Y3Rvcik7XG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuVHlwZUVycm9yLCBtb25pdG9yLmluc3RhbmNlcy5UeXBlRXJyb3JDb25zdHJ1Y3Rvcik7XG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuVVJJRXJyb3IsIG1vbml0b3IuaW5zdGFuY2VzLlVSSUVycm9yQ29uc3RydWN0b3IpO1xuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLk1hdGgsIG1vbml0b3IuaW5zdGFuY2VzLk1hdGhPYmplY3QpO1xuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLkpTT04sIG1vbml0b3IuaW5zdGFuY2VzLkpTT05PYmplY3QpO1xuXG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBuZXcgVmFsdWUoXCJnbG9iYWxUaGlzXCIsIGJvdCksIHRoaXMpO1xuXG5cbiAgICAgICAgLy8gQi4yXG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuZXNjYXBlLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KF9fZXNjYXBlLCAxLCBob3N0LmVzY2FwZSkpO1xuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLnVuZXNjYXBlLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KF9fdW5lc2NhcGUsIDEsIGhvc3QudW5lc2NhcGUpKTtcblxuICAgICAgICBEZWZpbmVURlQodGhpcywgbmV3IFZhbHVlKCd3cml0ZScsIGJvdCksIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3QoX19wcmludCwgMCwgJ3dyaXRlJykpO1xuICAgICAgICBEZWZpbmVURlQodGhpcywgbmV3IFZhbHVlKCdwcmludCcsIGJvdCksIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3QoX19scHJpbnQsIDAsICdwcmludCcpKTtcbiAgICAgICAgLy8gbGVnYWN5XG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBuZXcgVmFsdWUoJ2pzZmxvZycsIGJvdCksIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3QoX19scHJpbnQsIDAsICdscHJpbnQnKSk7XG5cbiAgICAgICAgRGVmaW5lRkZGKHRoaXMsIG5ldyBWYWx1ZSgndXBnJywgYm90KSwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChfX2R1cGcsIDEsIHVuZGVmaW5lZCkpO1xuICAgICAgICBEZWZpbmVGRkYodGhpcywgbmV3IFZhbHVlKCd1cGdzJywgYm90KSwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChfX2R1cGdzLCAxLCB1bmRlZmluZWQpKTtcbiAgICAgICAgRGVmaW5lRkZGKHRoaXMsIG5ldyBWYWx1ZSgndXBnZScsIGJvdCksIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3QoX19kdXBnZSwgMSwgdW5kZWZpbmVkKSk7XG5cbiAgICAgICAgRGVmaW5lRkZGKHRoaXMsIG5ldyBWYWx1ZSgnbGJsJywgYm90KSwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChfX3VwZywgMSwgdW5kZWZpbmVkKSk7XG4gICAgICAgIERlZmluZUZGRih0aGlzLCBuZXcgVmFsdWUoJ2xibHMnLCBib3QpLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KF9fdXBncywgMSwgdW5kZWZpbmVkKSk7XG4gICAgICAgIERlZmluZUZGRih0aGlzLCBuZXcgVmFsdWUoJ2xibGUnLCBib3QpLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KF9fdXBnZSwgMSwgdW5kZWZpbmVkKSk7XG4gICAgICAgIERlZmluZUZGRih0aGlzLCBuZXcgVmFsdWUoJ2xibHBhcnRzJywgYm90KSwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChfX3VwZ3BhcnRzLCAxLCB1bmRlZmluZWQpKTtcblxuXG4gICAgICAgIERlZmluZUZGRih0aGlzLCBuZXcgVmFsdWUoJ3VwZ2wnLCBib3QpLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KF9fdXBnbCwgMSwgdW5kZWZpbmVkKSk7XG5cbiAgICAgICAgRGVmaW5lRkZGKHRoaXMsIG5ldyBWYWx1ZSgnZGVjbGFzc2lmeScsIGJvdCksIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3QoX19kZWNsYXNzaWZ5LCAxLCB1bmRlZmluZWQpKTtcblxuICAgICAgICAvKlxuICAgICAgICBEZWZpbmVGRkYodGhpcyAsIG5ldyBWYWx1ZSgndXBncycgICAsIGJvdCkgLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KF9fdXBncyAgICwgMSwgdW5kZWZpbmVkKSk7XG4gICAgICAgIERlZmluZUZGRih0aGlzICwgbmV3IFZhbHVlKCdkdXBncycgICwgYm90KSAsIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3QoX19kdXBncyAgLCAxLCB1bmRlZmluZWQpKTtcbiAgICAgICAgRGVmaW5lRkZGKHRoaXMgLCBuZXcgVmFsdWUoJ2dldFBDJyAgLCBib3QpICwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChfX2dldFBDICAsIDAsIHVuZGVmaW5lZCkpO1xuICAgICAgICBEZWZpbmVGRkYodGhpcyAsIG5ldyBWYWx1ZSgnc2V0UEMnICAsIGJvdCkgLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KF9fc2V0UEMgICwgMSwgdW5kZWZpbmVkKSk7XG4gICAgICAgIERlZmluZUZGRih0aGlzICwgbmV3IFZhbHVlKCdnZXRFWEMnICwgYm90KSAsIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3QoX19nZXRFWEMgLCAwLCB1bmRlZmluZWQpKTtcbiAgICAgICAgRGVmaW5lRkZGKHRoaXMgLCBuZXcgVmFsdWUoJ3NldEVYQycgLCBib3QpICwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChfX3NldEVYQyAsIDEsIHVuZGVmaW5lZCkpO1xuICAgICAgICBEZWZpbmVGRkYodGhpcyAsIG5ldyBWYWx1ZSgnZ2V0UkVUJyAsIGJvdCkgLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KF9fZ2V0UkVUICwgMCwgdW5kZWZpbmVkKSk7XG4gICAgICAgIERlZmluZUZGRih0aGlzICwgbmV3IFZhbHVlKCdzZXRSRVQnICwgYm90KSAsIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3QoX19zZXRSRVQgLCAxLCB1bmRlZmluZWQpKTtcbiAgICAgICAgKi9cbiAgICB9XG5cbiAgICB0b1N0cmluZygpIHsgcmV0dXJuICdbZ2xvYmFsIG9iamVjdF0nOyB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gQi4yLjFcbmZ1bmN0aW9uIF9fZXNjYXBlKHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8c3RyaW5nPiB7XG4gICAgbGV0IGFyZyA9IGFyZ3NbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3NbMF0gOiBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgIGxldCBzdHIgPSBUb1N0cmluZyhhcmcpO1xuICAgIHJldHVybiBuZXcgVmFsdWUoZXNjYXBlKHN0ci52YWx1ZSksIHN0ci5sYWJlbCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdW5lc2NhcGUsIEIuMi4yXG5mdW5jdGlvbiBfX3VuZXNjYXBlKHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8c3RyaW5nPiB7XG4gICAgbGV0IGFyZyA9IGFyZ3NbMF0gPyBhcmdzWzBdIDogbmV3IFZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgICBsZXQgc3RyID0gVG9TdHJpbmcoYXJnKTtcblxuICAgIHJldHVybiBuZXcgVmFsdWUodW5lc2NhcGUoc3RyLnZhbHVlKSwgc3RyLmxhYmVsKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAxNS4xLjIuMVxuZnVuY3Rpb24gX19ldmFsKHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8VmFsdWVUeXBlcz4ge1xuICAgIGxldCBhcmcwID0gYXJnc1swXTtcbiAgICBpZiAoYXJnMCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gbmV3IFZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgICBpZiAodHlwZW9mIGFyZzAudmFsdWUgIT09ICdzdHJpbmcnKSByZXR1cm4gYXJnMDtcblxuICAgIGxldCBwcm9nO1xuXG4gICAgLy8gcmFpc2UgdGhlIHBjIHcuci50LiB0aGUgcHJvZ3JhbSBzdHJpbmc7IHBhcnNpbmcgbWF5IHJlc3VsdCBpbiBhbiBleGNlcHRpb25cbiAgICBtb25pdG9yLmNvbnRleHQucHVzaFBDKGFyZzAubGFiZWwpO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkID0gbW9uaXRvci50cmFuc2Zvcm0oYXJnMC52YWx1ZSk7XG4gICAgICAgIHByb2cgPSBlc3ByaW1hLnBhcnNlKHRyYW5zZm9ybWVkLCB7IGxvYzogdHJ1ZSB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxldCBtc2cgPSBlLmRlc2NyaXB0aW9uICsgJyBpbiBldmFsOicgKyBlLmxpbmVOdW1iZXIgKyAnOicgKyBlLmNvbHVtbjtcbiAgICAgICAgbW9uaXRvci5UaHJvdyhcbiAgICAgICAgICAgIFwiU3ludGF4RXJyb3JcIixcbiAgICAgICAgICAgIG1zZyxcbiAgICAgICAgICAgIGFyZzAubGFiZWxcbiAgICAgICAgKTtcbiAgICAgICAgdGhyb3cgJ1R5cGVTY3JpcHQnO1xuICAgIH1cblxuICAgIGxldCBldmFsQ3R4ID0gZW50ZXJFdmFsQ29kZShwcm9nLCBfX2V2YWwpO1xuICAgIG1vbml0b3IuY29udGV4dFN0YWNrLnB1c2goZXZhbEN0eCk7XG5cbiAgICAvLyB0aGlzIGlzIG5vdCBhIHZhbHVlLCBpdCBpcyBhIHJlc3VsdCEhXG4gICAgbGV0IHJlc3VsdCA9IGV4ZWN1dGUocHJvZywgZmFsc2UpO1xuXG5cbiAgICAvLyBpZiB2YWx1ZSBpcyAnZW1wdHknIChyZXByZXNlbnRlZCBieSBudWxsKVxuICAgIGlmICghcmVzdWx0LnZhbHVlKSB7XG4gICAgICAgIHJlc3VsdC52YWx1ZSA9IG5ldyBWYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG4gICAgfVxuXG4gICAgcmVzdWx0LnZhbHVlLnJhaXNlKGFyZzAubGFiZWwpO1xuXG4gICAgLy8gTk9URTogcGFyc2VyIHNob3VsZCBndWFyYW50ZWUgdGhlIHJlc3VsdCB0eXBlIGlzIG5ldmVyIHJldHVyblxuICAgIG1vbml0b3IuY29udGV4dFN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKHJlc3VsdC50eXBlID09PSAndGhyb3cnKSB7XG4gICAgICAgIHRocm93IHJlc3VsdC52YWx1ZTtcbiAgICB9XG5cblxuXG4gICAgbW9uaXRvci5jb250ZXh0LnBvcFBDKCk7XG5cbiAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIDE1LjEuMi4yXG5mdW5jdGlvbiBfX3BhcnNlSW50KHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8bnVtYmVyPiB7XG4gICAgbGV0IHN0cmluZ0FyZyA9IGFyZ3NbMF0gfHwgbmV3IFZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgICBsZXQgYXJnMSA9IGFyZ3NbMV0gfHwgbmV3IFZhbHVlKHVuZGVmaW5lZCwgYm90KTtcblxuICAgIGxldCBzdHJpbmcgPSBUb1N0cmluZyhzdHJpbmdBcmcpO1xuICAgIGxldCByYWRpeCA9IFRvSW50MzIoYXJnMSk7XG4gICAgbGV0IHZhbHVlID0gcGFyc2VJbnQoc3RyaW5nLnZhbHVlLCByYWRpeC52YWx1ZSk7XG4gICAgcmV0dXJuIG5ldyBWYWx1ZSh2YWx1ZSwgbHViKHN0cmluZy5sYWJlbCwgcmFkaXgubGFiZWwpKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAxNS4xLjIuM1xuZnVuY3Rpb24gX19wYXJzZUZsb2F0KHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8bnVtYmVyPiB7XG4gICAgbGV0IHN0cmluZ0FyZyA9IGFyZ3NbMF0gfHwgbmV3IFZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgICBsZXQgc3RyaW5nID0gVG9TdHJpbmcoc3RyaW5nQXJnKTtcbiAgICBsZXQgdmFsdWUgPSBwYXJzZUZsb2F0KHN0cmluZy52YWx1ZSk7XG4gICAgcmV0dXJuIG5ldyBWYWx1ZSh2YWx1ZSwgc3RyaW5nLmxhYmVsKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAxNS4xLjIuNFxuZnVuY3Rpb24gX19pc05hTih0aGlzQXJnOiBWYWx1ZTxWYWx1ZVR5cGVzPiwgYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPGJvb2xlYW4+IHtcbiAgICBsZXQgbnVtYmVyQXJnID0gYXJnc1swXSB8fCBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgIGxldCBudW1iZXIgPSBUb051bWJlcihudW1iZXJBcmcpO1xuICAgIGxldCB2YWx1ZSA9IGlzTmFOKG51bWJlci52YWx1ZSk7XG4gICAgcmV0dXJuIG5ldyBWYWx1ZSh2YWx1ZSwgbnVtYmVyLmxhYmVsKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAxNS4xLjIuNVxuZnVuY3Rpb24gX19pc0Zpbml0ZSh0aGlzQXJnOiBWYWx1ZTxWYWx1ZVR5cGVzPiwgYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPGJvb2xlYW4+IHtcbiAgICBsZXQgbnVtYmVyQXJnID0gYXJnc1swXSB8fCBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgIGxldCBudW1iZXIgPSBUb051bWJlcihudW1iZXJBcmcpO1xuICAgIGxldCB2YWx1ZSA9IGlzRmluaXRlKG51bWJlci52YWx1ZSk7XG4gICAgcmV0dXJuIG5ldyBWYWx1ZSh2YWx1ZSwgbnVtYmVyLmxhYmVsKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAxNS4xLjMuMVxuZnVuY3Rpb24gX19kZWNvZGVVUkkodGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxzdHJpbmc+IHtcbiAgICBsZXQgYXJnMCA9IGFyZ3NbMF0gPyBhcmdzWzBdIDogbmV3IFZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgICBsZXQgZW5jID0gVG9TdHJpbmcoYXJnMCk7XG4gICAgbGV0IHJlcyA9IG5ldyBWYWx1ZShkZWNvZGVVUkkoZW5jLnZhbHVlKSwgZW5jLmxhYmVsKTtcbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIDE1LjEuMy4yXG5mdW5jdGlvbiBfX2RlY29kZVVSSUNvbXBvbmVudCh0aGlzQXJnOiBWYWx1ZTxWYWx1ZVR5cGVzPiwgYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPHN0cmluZz4ge1xuICAgIGxldCBhcmcwID0gYXJnc1swXSA/IGFyZ3NbMF0gOiBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgIGxldCBlbmMgPSBUb1N0cmluZyhhcmcwKTtcbiAgICBsZXQgcmVzID0gbmV3IFZhbHVlKGRlY29kZVVSSUNvbXBvbmVudChlbmMudmFsdWUpLCBlbmMubGFiZWwpO1xuICAgIHJldHVybiByZXM7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gMTUuMS4yLjNcbmxldCBfX2VuY29kZVVSSSA9IGZ1bmN0aW9uIF9fZW5jb2RlVVJJKHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8c3RyaW5nPiB7XG4gICAgbGV0IGFyZzAgPSBhcmdzWzBdID8gYXJnc1swXSA6IG5ldyBWYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG4gICAgbGV0IGVuYyA9IFRvU3RyaW5nKGFyZzApO1xuICAgIGxldCByZXMgPSBuZXcgVmFsdWUoZW5jb2RlVVJJKGVuYy52YWx1ZSksIGVuYy5sYWJlbCk7XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAxNS4xLjMuNFxuZnVuY3Rpb24gX19lbmNvZGVVUklDb21wb25lbnQodGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxzdHJpbmc+IHtcbiAgICBsZXQgYXJnMCA9IGFyZ3NbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3NbMF0gOiBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgIGxldCBjb21wb25lbnRTdHJpbmcgPSBUb1N0cmluZyhhcmcwKTtcbiAgICByZXR1cm4gbmV3IFZhbHVlKGVuY29kZVVSSUNvbXBvbmVudChjb21wb25lbnRTdHJpbmcudmFsdWUpLCBjb21wb25lbnRTdHJpbmcubGFiZWwpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gX19wcmludCh0aGlzQXJnOiBWYWx1ZTxWYWx1ZVR5cGVzPiwgYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPHVuZGVmaW5lZD4ge1xuICAgIGxldCBzdHIgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspXG4gICAgICAgIHN0ciArPSBhcmdzW2ldLnZhbHVlO1xuICAgIG1vbml0b3IucHJpbnQoc3RyKTtcblxuICAgIHJldHVybiBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xufVxuXG5mdW5jdGlvbiBfX2xwcmludCh0aGlzQXJnOiBWYWx1ZTxWYWx1ZVR5cGVzPiwgYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPHVuZGVmaW5lZD4ge1xuICAgIGlmIChtb25pdG9yLm9wdGlvbnMuZ2V0KCdtb25pdG9yLnRlc3RNb2RlJykpIHtcbiAgICAgICAgX19wcmludCh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG4gICAgfVxuXG4gICAgbGV0IHN0ciA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKylcbiAgICAgICAgc3RyICs9IFRvU3RyaW5nKGFyZ3NbaV0pO1xuXG4gICAgaWYgKG1vbml0b3Iub3B0aW9ucy5nZXQoJ21vbml0b3IudGFpbnRNb2RlJykpIHtcbiAgICAgICAgbW9uaXRvci5wcmludChzdHIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG1vbml0b3IucHJpbnQoJygnICsgbW9uaXRvci5jb250ZXh0LmVmZmVjdGl2ZVBDICsgJyk6JyArIHN0cik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBWYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBfX3VwZ2wodGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTx1bmRlZmluZWQ+IHtcbiAgICBsZXQgYXJnMCA9IGFyZ3NbMF0gPyBhcmdzWzBdIDogbmV3IFZhbHVlKCdkZWZhdWx0JywgYm90KTtcbiAgICBsZXQgbGFiZWxOYW1lID0gVG9TdHJpbmcoYXJnMCk7XG5cbiAgICBtb25pdG9yLmFzc2VydChsZShsYWJlbE5hbWUubGFiZWwsIGJvdCksICd1cGdsIGV4cGVjdGVkIGxhYmVsIG9mIGxhYmVsIHN0cmluZyB0byBiZSBib3QnKTtcblxuICAgIGxldCBsYmwgPSBib3Q7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBhcmcgPSBUb1N0cmluZyhhcmdzW2ldKTtcblxuICAgICAgICBtb25pdG9yLmFzc2VydChsZShhcmcubGFiZWwsIGJvdCksICd1cGdsIGV4cGVjdGVkIGxhYmVsIG9mIGxhYmVsIHN0cmluZyB0byBiZSBib3QnKTtcbiAgICAgICAgbGJsID0gbHViKGxibCwgTGFiZWwuZnJvbVN0cmluZyhhcmcudmFsdWUpKTtcbiAgICB9XG5cbiAgICBsYmwgPSBsYmwuZXF1YWxzKGJvdCkgPyB0b3AgOiBsYmw7XG5cbiAgICBsZXQgbGJsbWFwID0gbW9uaXRvci5jb250ZXh0LmxhYmVscy5sYWJlbG1hcDtcbiAgICBsZXQgbmFtZSA9IGxhYmVsTmFtZS52YWx1ZTtcbiAgICBpZiAoIWxibG1hcFtuYW1lXSkge1xuICAgICAgICBsYmxtYXBbbmFtZV0gPSB7XG4gICAgICAgICAgICBsYWJlbDogbGJsLFxuICAgICAgICAgICAgcGNtYXJrZXI6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGxibG1hcFtuYW1lXS5sYWJlbCA9IGx1YihsYmxtYXBbbmFtZV0ubGFiZWwsIGxibCk7XG4gICAgbGV0IG1hcmtlciA9IGxibG1hcFtuYW1lXS5wY21hcmtlcjtcbiAgICBpZiAobWFya2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbW9uaXRvci5jb250ZXh0LnBjU3RhY2subWFwKFxuICAgICAgICAgICAgZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbHViKGwsIGxibCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWFya2VyXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBWYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBfX3VwZyh0aGlzQXJnOiBWYWx1ZTxWYWx1ZVR5cGVzPiwgYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPFZhbHVlVHlwZXM+IHtcbiAgICBsZXQgYXJnMCA9IGFyZ3NbMF0gPyBhcmdzWzBdIDogbmV3IFZhbHVlKHVuZGVmaW5lZCwgYm90KTtcblxuICAgIGxldCBsYmwgPSBib3Q7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBhcmcgPSBUb1N0cmluZyhhcmdzW2ldKTtcbiAgICAgICAgbW9uaXRvci5hc3NlcnQobGUoYXJnLmxhYmVsLCBib3QpLCAndXBnIGV4cGVjdGVkIGxhYmVsIG9mIGxhYmVsIHN0cmluZyB0byBiZSBib3QnKTtcbiAgICAgICAgbGJsID0gbHViKGxibCwgTGFiZWwuZnJvbVN0cmluZyhhcmcudmFsdWUpKTtcbiAgICB9XG5cbiAgICBsYmwgPSBsYmwuZXF1YWxzKGJvdCkgPyB0b3AgOiBsYmw7XG5cbiAgICByZXR1cm4gbmV3IFZhbHVlKGFyZzAudmFsdWUsIGx1YihhcmcwLmxhYmVsLCBsYmwpKTtcbn1cblxuLy8gLS0tXG5cbmZ1bmN0aW9uIF9fdXBncGFydHModGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxWYWx1ZVR5cGVzPiB7XG4gICAgbGV0IGFyZzAgPSBhcmdzWzBdID8gYXJnc1swXSA6IG5ldyBWYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG5cbiAgICBsZXQgbGJsID0gYm90O1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgYXJnID0gVG9TdHJpbmcoYXJnc1tpXSk7XG4gICAgICAgIG1vbml0b3IuYXNzZXJ0KGxlKGFyZy5sYWJlbCwgYm90KSwgJ3VwZyBleHBlY3RlZCBsYWJlbCBvZiBsYWJlbCBzdHJpbmcgdG8gYmUgYm90Jyk7XG4gICAgICAgIGxibCA9IGx1YihsYmwsIExhYmVsLmZyb21TdHJpbmcoYXJnLnZhbHVlKSk7XG4gICAgfVxuXG4gICAgbGJsID0gbGJsLmVxdWFscyhib3QpID8gdG9wIDogbGJsO1xuXG4gICAgaWYgKElzSUVjbWFPYmplY3QoYXJnMCkpIHtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBhcmcwLnZhbHVlLmxhYmVscykge1xuICAgICAgICAgICAgbGV0IGxhYmVsRGF0YSA9IGFyZzAudmFsdWUubGFiZWxzW3Byb3BdO1xuICAgICAgICAgICAgbGFiZWxEYXRhLnZhbHVlID0gbHViKGxhYmVsRGF0YS52YWx1ZSwgbGJsKTtcbiAgICAgICAgICAgIGxhYmVsRGF0YS5leGlzdGVuY2UgPSBsdWIobGFiZWxEYXRhLmV4aXN0ZW5jZSwgbGJsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFyZzAudmFsdWUuc3RydWN0ID0gbHViKGFyZzAudmFsdWUuc3RydWN0LCBsYmwpO1xuICAgICAgICByZXR1cm4gYXJnMDtcbiAgICB9IFxuXG4gICAgcmV0dXJuIG5ldyBWYWx1ZShhcmcwLnZhbHVlLCBsdWIoYXJnMC5sYWJlbCwgbGJsKSk7XG59XG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIF9fZHVwZyh0aGlzQXJnOiBWYWx1ZTxWYWx1ZVR5cGVzPiwgYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPFZhbHVlVHlwZXM+IHtcbiAgICBsZXQgYXJnMCA9IGFyZ3NbMF0gPyBhcmdzWzBdIDogbmV3IFZhbHVlKHVuZGVmaW5lZCwgYm90KTtcblxuICAgIGxldCBsYmwgPSBib3Q7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxibCA9IGx1YihsYmwsIGFyZ3NbaV0ubGFiZWwpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgVmFsdWUoYXJnMC52YWx1ZSwgbHViKGFyZzAubGFiZWwsIGxibCkpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gX191cGdzKHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8VmFsdWVUeXBlcz4ge1xuICAgIGxldCBvYmogPSBhcmdzWzBdID8gYXJnc1swXSA6IG5ldyBWYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG5cbiAgICBsZXQgbGJsID0gYm90O1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgYXJnID0gVG9TdHJpbmcoYXJnc1tpXSk7XG4gICAgICAgIG1vbml0b3IuYXNzZXJ0KGxlKGFyZy5sYWJlbCwgYm90KSwgJ3VwZ3MgZXhwZWN0ZWQgbGFiZWwgb2YgbGFiZWwgc3RyaW5nIHRvIGJlIGJvdCcpO1xuICAgICAgICBsYmwgPSBsdWIobGJsLCBMYWJlbC5mcm9tU3RyaW5nKGFyZy52YWx1ZSkpO1xuICAgIH1cblxuICAgIGxibCA9IGxibC5lcXVhbHMoYm90KSA/IHRvcCA6IGxibDtcblxuXG4gICAgaWYgKElzSUVjbWFPYmplY3Qob2JqKSkge1xuICAgICAgICBvYmoudmFsdWUuc3RydWN0ID0gbHViKG9iai52YWx1ZS5zdHJ1Y3QsIGxibCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIF9fZHVwZ3ModGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxWYWx1ZVR5cGVzPiB7XG4gICAgbGV0IGFyZzAgPSBhcmdzWzBdID8gYXJnc1swXSA6IG5ldyBWYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG5cbiAgICBsZXQgbGJsID0gYm90O1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsYmwgPSBsdWIobGJsLCBhcmdzW2ldLmxhYmVsKTtcbiAgICB9XG5cbiAgICBpZiAoSXNJRWNtYU9iamVjdChhcmcwKSkge1xuICAgICAgICBhcmcwLnZhbHVlLnN0cnVjdCA9IGx1YihhcmcwLnZhbHVlLnN0cnVjdCwgbGJsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJnMDtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIF9fdXBnZSh0aGlzQXJnOiBWYWx1ZTxWYWx1ZVR5cGVzPiwgYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPHVuZGVmaW5lZD4ge1xuICAgIGxldCBvYmogPSBhcmdzWzBdID8gYXJnc1swXSA6IG5ldyBWYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG4gICAgbGV0IGFyZzEgPSBhcmdzWzFdID8gYXJnc1sxXSA6IG5ldyBWYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG5cbiAgICBpZiAob2JqLnZhbHVlID09PSB1bmRlZmluZWQgfHwgb2JqLnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgIH1cblxuICAgIGxldCBpeCA9IFRvU3RyaW5nKGFyZzEpO1xuXG4gICAgbGV0IGxibCA9IGJvdDtcbiAgICBmb3IgKGxldCBpID0gMjsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGFyZyA9IFRvU3RyaW5nKGFyZ3NbaV0pO1xuICAgICAgICBtb25pdG9yLmFzc2VydChsZShhcmcubGFiZWwsIGJvdCksICd1cGdlIGV4cGVjdGVkIGxhYmVsIG9mIGxhYmVsIHN0cmluZyB0byBiZSBib3QnKTtcbiAgICAgICAgbGJsID0gbHViKGxibCwgTGFiZWwuZnJvbVN0cmluZyhhcmcudmFsdWUpKTtcbiAgICB9XG5cbiAgICBsYmwgPSBsYmwuZXF1YWxzKGJvdCkgPyB0b3AgOiBsYmw7XG5cbiAgICBpZiAoSXNJRWNtYU9iamVjdChvYmopKSB7XG4gICAgICAgIGxldCBwcm9wID0gb2JqLnZhbHVlLmxhYmVsc1tpeC52YWx1ZV07XG4gICAgICAgIGlmIChwcm9wKSB7XG4gICAgICAgICAgICBwcm9wLmV4aXN0ZW5jZSA9IGx1Yihwcm9wLmV4aXN0ZW5jZSwgbGJsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gX19kdXBnZSh0aGlzQXJnOiBWYWx1ZTxWYWx1ZVR5cGVzPiwgYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPHVuZGVmaW5lZD4ge1xuICAgIGxldCBvYmogPSBhcmdzWzBdID8gYXJnc1swXSA6IG5ldyBWYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG4gICAgbGV0IGFyZzEgPSBhcmdzWzFdID8gYXJnc1sxXSA6IG5ldyBWYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG5cbiAgICBpZiAob2JqLnZhbHVlID09PSB1bmRlZmluZWQgfHwgb2JqLnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgIH1cblxuICAgIGxldCBpeCA9IFRvU3RyaW5nKGFyZzEpO1xuXG4gICAgbGV0IGxibCA9IGJvdDtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGJsID0gbHViKGxibCwgYXJnc1tpXS5sYWJlbCk7XG4gICAgfVxuXG4gICAgaWYgKElzSUVjbWFPYmplY3Qob2JqKSkge1xuICAgICAgICBsZXQgcHJvcCA9IG9iai52YWx1ZS5sYWJlbHNbaXgudmFsdWVdO1xuICAgICAgICBpZiAocHJvcCkge1xuICAgICAgICAgICAgcHJvcC5leGlzdGVuY2UgPSBsdWIocHJvcC5leGlzdGVuY2UsIGxibCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbn1cblxuZnVuY3Rpb24gX19kZWNsYXNzaWZ5KHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8VmFsdWVUeXBlcz4ge1xuXG4gICAgdmFyIHZhbCA9IG5ldyBWYWx1ZShhcmdzWzBdID8gYXJnc1swXS52YWx1ZSA6IHVuZGVmaW5lZCwgYm90KTtcbiAgICByZXR1cm4gdmFsO1xuXG59XG4iLCJpbXBvcnQgeyBWYWx1ZSB9IGZyb20gXCIuLi9WYWx1ZVwiO1xuaW1wb3J0ICogYXMgY29uc3RhbnRzIGZyb20gJy4uL0NvbnN0YW50cyc7XG5pbXBvcnQgeyBCdWlsdGluRnVuY3Rpb25PYmplY3QgfSBmcm9tIFwiLi9CdWlsdGluRnVuY3Rpb25PYmplY3RcIjtcbmltcG9ydCB7IE9iamVjdE9iamVjdCB9IGZyb20gJy4uL09iamVjdHMvT2JqZWN0T2JqZWN0JztcbmltcG9ydCB7IEFycmF5T2JqZWN0IH0gZnJvbSAnLi4vT2JqZWN0cy9BcnJheU9iamVjdCc7XG5pbXBvcnQgeyBUb051bWJlciB9IGZyb20gJy4uL0NvbnZlcnNpb24vVG9OdW1iZXInO1xuaW1wb3J0IHsgVG9JbnRlZ2VyIH0gZnJvbSAnLi4vQ29udmVyc2lvbi9Ub0ludGVnZXInO1xuaW1wb3J0IHsgVG9TdHJpbmcgfSBmcm9tICcuLi9Db252ZXJzaW9uL1RvU3RyaW5nJztcbmltcG9ydCB7IElzQ2FsbGFibGUgfSBmcm9tICcuLi9VdGlsaXR5L0lzQ2FsbGFibGUnO1xuaW1wb3J0IHsgTW9uaXRvckJhc2UgfSBmcm9tICcuLi9Nb25pdG9yQmFzZSc7XG5cbmltcG9ydCB7IERlZmluZUZGRiwgRGVmaW5lVEZUIH0gZnJvbSAnLi4vRGVmaW5lJztcbmltcG9ydCB7IEVjbWFPYmplY3QgfSBmcm9tICcuLi9PYmplY3RzL0VjbWFPYmplY3QnO1xuXG5pbXBvcnQgeyBib3QsIGx1YiB9IGZyb20gJy4uL0xhYmVsJztcbmltcG9ydCB7IFZhbHVlVHlwZXMsIElFY21hT2JqZWN0IH0gZnJvbSBcIi4uL0ludGVyZmFjZXNcIjtcblxuZGVjbGFyZSB2YXIgbW9uaXRvcjogTW9uaXRvckJhc2U7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVGhlIEpTT04gb2JqZWN0LCAxNS4xMlxuZXhwb3J0IGNsYXNzIEpTT05PYmplY3QgZXh0ZW5kcyBFY21hT2JqZWN0IHtcblxuICAgIGhvc3Q6IGFueTtcbiAgICBjb25zdHJ1Y3Rvcihob3N0OiBhbnkpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLkNsYXNzID0gJ0pTT04nO1xuICAgICAgICB0aGlzLkV4dGVuc2libGUgPSB0cnVlO1xuICAgICAgICB0aGlzLmhvc3QgPSBob3N0O1xuICAgIH1cblxuICAgIFNldHVwKCkge1xuICAgICAgICB0aGlzLlByb3RvdHlwZSA9IG5ldyBWYWx1ZShtb25pdG9yLmluc3RhbmNlcy5PYmplY3RQcm90b3R5cGUsIGJvdCk7XG5cbiAgICAgICAgRGVmaW5lRkZGKHRoaXMsIGNvbnN0YW50cy5wcm90b3R5cGUsIG1vbml0b3IuaW5zdGFuY2VzLk9iamVjdFByb3RvdHlwZSk7XG5cbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5wYXJzZSwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChwYXJzZSwgMiwgdGhpcy5ob3N0LnBhcnNlKSk7XG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuc3RyaW5naWZ5LCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHN0cmluZ2lmeSwgMywgdGhpcy5ob3N0LnN0cmluZ2lmeSkpO1xuICAgIH1cblxuICAgIC8vIEJ5IHRoZSBzdGFuZGFyZCwgdGhlcmUgc2hvdWxkIGJlIG5vIENhbGwgb3IgQ29uc3RydWN0IGZvciBKU09OIG9iamVjdCxcbiAgICAvLyBzbyB0aHJvdyBhIFR5cGVFcnJvciAoYXMgU3BpZGVyTW9ua2V5IHNlZW0gdG8gZG8pXG4gICAgQ2FsbCh0aGlzQXJnOiBWYWx1ZTxWYWx1ZVR5cGVzPiwgYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPFZhbHVlVHlwZXM+IHtcbiAgICAgICAgbW9uaXRvci5UaHJvdyhcbiAgICAgICAgICAgIFwiVHlwZUVycm9yXCIsXG4gICAgICAgICAgICAnSlNPTiBpcyBub3QgYSBmdW5jdGlvbicsXG4gICAgICAgICAgICBib3RcbiAgICAgICAgKTtcbiAgICAgICAgdGhyb3cgJ1R5cGVTY3JpcHQnO1xuICAgIH1cblxuICAgIENvbnN0cnVjdChhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8SUVjbWFPYmplY3Q+IHtcbiAgICAgICAgbW9uaXRvci5UaHJvdyhcbiAgICAgICAgICAgIFwiVHlwZUVycm9yXCIsXG4gICAgICAgICAgICAnSlNPTiBpcyBub3QgYSBjb25zdHJ1Y3RvcicsXG4gICAgICAgICAgICBib3RcbiAgICAgICAgKTtcbiAgICAgICAgdGhyb3cgJ1R5cGVTY3JpcHQnO1xuICAgIH1cbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBwYXJzZSwgMTUuMTIuMlxuZnVuY3Rpb24gcGFyc2UodGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxWYWx1ZVR5cGVzPiB7XG4gICAgaWYgKGFyZ3NbMF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtb25pdG9yLlRocm93KFxuICAgICAgICAgICAgXCJTeW50YXhFcnJvclwiLFxuICAgICAgICAgICAgJ0pTT04ucGFyc2U6IE5vIHN0cmluZyB0byBwYXJzZScsXG4gICAgICAgICAgICBib3RcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgSlRleHQgPSBUb1N0cmluZyhhcmdzWzBdKSB8fCBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgIHZhciByZXZpdmVyID0gYXJnc1sxXSB8fCBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuXG4gICAgdmFyIHVuZmlsdGVyZWQgPSBwYXJzZUFuZEV2YWx1YXRlKEpUZXh0KTtcblxuICAgIC8vIERvIHdlIGhhdmUgYW55IGp1bmsgY2hhcmFjdGVycyBsZWZ0PyBJZiBzbywgYSBiYWQgc3RyaW5nIVxuICAgIC8vQHRzLWlnbm9yZSBKU09OXG4gICAgaWYgKHVuZmlsdGVyZWQuZmluYWxJbmRleCA8PSBKVGV4dC52YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgbW9uaXRvci5UaHJvdyhcbiAgICAgICAgICAgIFwiU3ludGF4RXJyb3JcIixcbiAgICAgICAgICAgICdKU09OLnBhcnNlOiBTdHJpbmcgY29udGFpbnMgYmFkIHN5bWJvbHMgaW4gdGhlIGVuZCcsXG4gICAgICAgICAgICBib3RcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgaXNSZXZpdmVyQ2FsbGFibGUgPSBJc0NhbGxhYmxlKHJldml2ZXIpO1xuXG4gICAgbW9uaXRvci5jb250ZXh0LnB1c2hQQyhyZXZpdmVyLmxhYmVsKTtcbiAgICBpZiAoaXNSZXZpdmVyQ2FsbGFibGUpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBuZXcgT2JqZWN0T2JqZWN0KCk7XG5cbiAgICAgICAgcm9vdC5EZWZpbmVPd25Qcm9wZXJ0eShuZXcgVmFsdWUoXCJcIiwgYm90KSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdW5maWx0ZXJlZC52YWx1ZSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBsYWJlbDogdW5maWx0ZXJlZC5sYWJlbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICk7XG5cbiAgICAgICAgbW9uaXRvci5jb250ZXh0LnBvcFBDKCk7XG4gICAgICAgIHJldHVybiBXYWxrKG5ldyBWYWx1ZShyb290LCBib3QpLCBuZXcgVmFsdWUoXCJcIiwgbHViKHVuZmlsdGVyZWQubGFiZWwsIGx1YihKVGV4dC5sYWJlbCwgcmV2aXZlci5sYWJlbCkpKSwgcmV2aXZlcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBtb25pdG9yLmNvbnRleHQucG9wUEMoKTtcbiAgICAgICAgcmV0dXJuIHVuZmlsdGVyZWQ7XG4gICAgfVxufVxuXG4vLyBXYWxrLCBwYXJ0IG9mIDE1LjEyLjJcbmZ1bmN0aW9uIFdhbGsoaG9sZGVyLCBuYW1lLCByZXZpdmVyKSB7XG4gICAgdmFyIHZhbCA9IGhvbGRlci5HZXQobmFtZSk7XG5cbiAgICBtb25pdG9yLmNvbnRleHQucHVzaFBDKHZhbC5sYWJlbCk7XG4gICAgaWYgKHZhbC52YWx1ZSAmJiB0eXBlb2YgdmFsLnZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICB2YWwgPSB2YWwudmFsdWU7XG4gICAgICAgIG1vbml0b3IuY29udGV4dC5wdXNoUEModmFsLmxhYmVsKTtcbiAgICAgICAgaWYgKHZhbC52YWx1ZS5DbGFzcyA9PT0gJ0FycmF5Jykge1xuICAgICAgICAgICAgdmFyIEkgPSBuZXcgVmFsdWUoMCwgYm90KTtcbiAgICAgICAgICAgIHZhciBsZW4gPSB2YWwudmFsdWUuR2V0KGNvbnN0YW50cy5sZW5ndGgpO1xuXG4gICAgICAgICAgICB3aGlsZSAoSS52YWx1ZSA8IGxlbi52YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdFbGVtZW50ID0gV2Fsayh2YWwsIFRvU3RyaW5nKEkpLCByZXZpdmVyKTtcbiAgICAgICAgICAgICAgICBpZiAobmV3RWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbC5EZWxldGUoVG9TdHJpbmcoSSksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbC5EZWZpbmVPd25Qcm9wZXJ0eShUb1N0cmluZyhJKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmV3RWxlbWVudC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogdmFsLmxhYmVsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBJLnZhbHVlKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IFtdO1xuICAgICAgICAgICAgdmFyIGFsbEtleXMgPSBPYmplY3Qua2V5cyh2YWwudmFsdWUucHJvcGVydGllcyk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBrZXlWYWwgPSB2YWwuR2V0UHJvcGVydHkobmV3IFZhbHVlKGFsbEtleXNbaV0sIGJvdCkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGtleVZhbC52YWx1ZSAmJiBrZXlWYWwudmFsdWUuZW51bWVyYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2gobmV3IFZhbHVlKGFsbEtleXNbaV0sIGJvdCkpOyAvL2tleVZhbC5sYWJlbD9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBQID0gVG9TdHJpbmcoa2V5c1tpXSk7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0VsZW1lbnQgPSBXYWxrKHZhbCwgUCwgcmV2aXZlcik7XG5cbiAgICAgICAgICAgICAgICBpZiAobmV3RWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbC5EZWxldGUoUCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsLkRlZmluZU93blByb3BlcnR5KFAsXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG5ld0VsZW1lbnQudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IHZhbC5sYWJlbFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1vbml0b3IuY29udGV4dC5wb3BQQygpO1xuICAgIH1cblxuICAgIG1vbml0b3IuY29udGV4dC5wb3BQQygpO1xuICAgIHJldHVybiByZXZpdmVyLkNhbGwoaG9sZGVyLCBbbmFtZSwgdmFsXSk7XG59XG5cbi8vIEluc3BpcmF0aW9uIGZyb20gRG91Z2xhcyBDcm9ja2ZvcmQsIGh0dHBzOi8vZ2l0aHViLmNvbS9kb3VnbGFzY3JvY2tmb3JkL0pTT04tanMvYmxvYi9tYXN0ZXIvanNvbl9wYXJzZS5qc1xuLy8gVGhpcyBpcyB1c2VkIGZvciB0aGUgMm5kIGFuZCAzcmQgc3RlcCBpbiBwYXJzZSwgMTUuMTIuMlxuZnVuY3Rpb24gcGFyc2VBbmRFdmFsdWF0ZSh0ZXh0KSB7XG4gICAgdmFyIGN1cnJlbnRDaGFyID0gJyAnO1xuICAgIHZhciBjdXJyZW50SW5kZXggPSAwO1xuXG4gICAgLy8gRnJvbSAxNS4xMi4xLjEsIEpTT05Fc2NhcGVDaGFyYWN0ZXIgOjogb25lIG9mIFwiIC8gXFwgYiBmIG4gciB0XG4gICAgdmFyIGVzY2FwZUNoYXJhY3RlcnMgPSB7XG4gICAgICAgICdcIic6ICdcIicsXG4gICAgICAgICcvJzogJy8nLFxuICAgICAgICAnXFxcXCc6ICdcXFxcJyxcbiAgICAgICAgYjogJ1xcYicsXG4gICAgICAgIGY6ICdcXGYnLFxuICAgICAgICBuOiAnXFxuJyxcbiAgICAgICAgcjogJ1xccicsXG4gICAgICAgIHQ6ICdcXHQnXG4gICAgfTtcblxuICAgIC8vIFRoZXNlIGFyZSBub3QgYWxsb3dlZCB0byBoYXZlIGluIGEgc3RyaW5nIVxuICAgIHZhciBpbnZhbGlkU3RyaW5nQ2hhcmFjdGVycyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAweDAwOyBpIDw9IDB4MUY7IGkrKykge1xuICAgICAgICB2YXIgcyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSk7XG4gICAgICAgIGludmFsaWRTdHJpbmdDaGFyYWN0ZXJzW3NdID0gcztcbiAgICB9XG5cbiAgICB2YXIgbWtFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIG1vbml0b3IuVGhyb3coXG4gICAgICAgICAgICBcIlN5bnRheEVycm9yXCIsXG4gICAgICAgICAgICAnSlNPTi5wYXJzZTogJyArIG1lc3NhZ2UsXG4gICAgICAgICAgICBib3RcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgdmFyIG5leHRDaGFyID0gZnVuY3Rpb24gKGNoYXIpIHtcbiAgICAgICAgaWYgKGNoYXIgJiYgY2hhciAhPT0gY3VycmVudENoYXIpIHtcbiAgICAgICAgICAgIG1rRXJyb3IoJ2V4cGVjdGVkICcgKyBjaGFyICsgJyB0byBtYXRjaCAnICsgY3VycmVudENoYXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudENoYXIgPSB0ZXh0LmNoYXJBdChjdXJyZW50SW5kZXgpO1xuICAgICAgICBjdXJyZW50SW5kZXgrKztcblxuICAgICAgICByZXR1cm4gY3VycmVudENoYXI7XG4gICAgfTtcblxuICAgIC8vSlNPTldoaXRlU3BhY2UgOjogPFRBQj4gPENSPiA8TEY+IDxTUD5cbiAgICB2YXIgZWF0V2hpdGVTcGFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnRDaGFyICYmIGN1cnJlbnRDaGFyIDw9ICcgJykge1xuICAgICAgICAgICAgLy9AdHMtaWdub3JlIEpTT05cbiAgICAgICAgICAgIG5leHRDaGFyKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyogSlNPTlZhbHVlIDpcbiAgICAgICAgIEpTT05OdWxsTGl0ZXJhbFxuICAgICAgICAgSlNPTkJvb2xlYW5MaXRlcmFsXG4gICAgICAgICBKU09OT2JqZWN0XG4gICAgICAgICBKU09OQXJyYXlcbiAgICAgICAgIEpTT05TdHJpbmdcbiAgICAgICAgIEpTT05OdW1iZXJcbiAgICAqL1xuICAgIHZhciBqc29uVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVhdFdoaXRlU3BhY2UoKTtcbiAgICAgICAgc3dpdGNoIChjdXJyZW50Q2hhcikge1xuICAgICAgICAgICAgY2FzZSAneyc6XG4gICAgICAgICAgICAgICAgLy8gSXQgbXVzdCBiZSBhbiBvYmplY3RcbiAgICAgICAgICAgICAgICByZXR1cm4ganNvbk9iamVjdCgpO1xuXG4gICAgICAgICAgICBjYXNlICdbJzpcbiAgICAgICAgICAgICAgICAvLyBJdCBtdXN0IGJlIGFuIGFycmF5XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpzb25BcnJheSgpO1xuXG4gICAgICAgICAgICBjYXNlICdcIic6XG4gICAgICAgICAgICAgICAgLy8gSXQgbXVzdCBiZSBhIHN0cmluZ1xuICAgICAgICAgICAgICAgIHJldHVybiBqc29uU3RyaW5nKCk7XG5cbiAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgIC8vIEl0IG11c3QgYmUgYSBudW1iZXJcbiAgICAgICAgICAgICAgICByZXR1cm4ganNvbk51bWJlcigpO1xuXG4gICAgICAgICAgICBjYXNlICduJzpcbiAgICAgICAgICAgICAgICAvLyBJdCBtdXN0IGJlIGEgbnVsbCBsaXRlcmFsXG4gICAgICAgICAgICAgICAgcmV0dXJuIGpzb25OdWxsKCk7XG5cbiAgICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICAgICAgLy8gSXQgbXVzdCBiZSBhIGJvb2xlYW4gbGl0ZXJhbFxuICAgICAgICAgICAgICAgIHJldHVybiBqc29uQm9vbCgpO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Q2hhciA+PSAnMCcgJiYgY3VycmVudENoYXIgPD0gJzknKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEl0IG11c3QgYmUgYSBudW1iZXJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGpzb25OdW1iZXIoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIHNvbWV0aGluZyBoYXMgZ29uZSB3cm9uZyFcbiAgICAgICAgICAgICAgICBta0Vycm9yKCdDYW5ub3QgcGFyc2UgdGhlIHN0cnVjdHVyZSEnKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIganNvbk9iamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBPYmplY3RPYmplY3QoKTtcblxuICAgICAgICBpZiAoY3VycmVudENoYXIgPT09ICd7Jykge1xuICAgICAgICAgICAgbmV4dENoYXIoJ3snKTtcbiAgICAgICAgICAgIGVhdFdoaXRlU3BhY2UoKTtcblxuICAgICAgICAgICAgLy9AdHMtaWdub3JlIFRZUEVTQ1JJUFRcbiAgICAgICAgICAgIGlmIChjdXJyZW50Q2hhciA9PT0gJ30nKSB7XG4gICAgICAgICAgICAgICAgLy8gRW50ZXIgaGVyZSBhbmQgd2UgaGF2ZSBhbiBcImVtcHR5XCIgb2JqZWN0XG4gICAgICAgICAgICAgICAgbmV4dENoYXIoJ30nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudENoYXIpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0ganNvblN0cmluZygpO1xuICAgICAgICAgICAgICAgIGVhdFdoaXRlU3BhY2UoKTtcbiAgICAgICAgICAgICAgICBuZXh0Q2hhcignOicpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1rRXJyb3IoJ0JhZCBvYmplY3QsIGR1cGxpY2F0ZSBrZXkgJyArIGtleSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzdWx0LkRlZmluZU93blByb3BlcnR5KG5ldyBWYWx1ZShrZXksIGJvdCksXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBqc29uVmFsdWUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBib3RcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgZWF0V2hpdGVTcGFjZSgpO1xuICAgICAgICAgICAgICAgIC8vQHRzLWlnbm9yZSBUWVBFU0NSSVBUXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFyID09PSAnfScpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dENoYXIoJ30nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBuZXh0Q2hhcignLCcpO1xuICAgICAgICAgICAgICAgIGVhdFdoaXRlU3BhY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1rRXJyb3IoJ01hbGZvcm1lZCBvYmplY3QnKTtcbiAgICB9O1xuXG4gICAgdmFyIGpzb25BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGlmIChjdXJyZW50Q2hhciA9PT0gJ1snKSB7XG4gICAgICAgICAgICBuZXh0Q2hhcignWycpO1xuICAgICAgICAgICAgZWF0V2hpdGVTcGFjZSgpO1xuXG4gICAgICAgICAgICAvL0B0cy1pZ25vcmUgVFlQRVNDUklQVFxuICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFyID09PSAnXScpIHtcbiAgICAgICAgICAgICAgICAvLyBFbnRlciBoZXJlIGFuZCB3ZSBoYXZlIGFuIGVtcHR5IGFycmF5Li5cbiAgICAgICAgICAgICAgICBuZXh0Q2hhcignXScpO1xuICAgICAgICAgICAgICAgIC8vQHRzLWlnbm9yZSBKU09OXG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5T2JqZWN0LmZyb21WYWx1ZUFycmF5KHJlc3VsdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50Q2hhcikge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGpzb25WYWx1ZSgpKTtcbiAgICAgICAgICAgICAgICBlYXRXaGl0ZVNwYWNlKCk7XG5cbiAgICAgICAgICAgICAgICAvL0B0cy1pZ25vcmUgVFlQRVNDUklQVFxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Q2hhciA9PT0gJ10nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVudGVyIGhlcmUgYW5kIHdlIGFyZSBkb25lLi5cbiAgICAgICAgICAgICAgICAgICAgbmV4dENoYXIoJ10nKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IG5ldyBWYWx1ZShyZXN1bHRbaV0sIGJvdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvL0B0cy1pZ25vcmUgSlNPTlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXlPYmplY3QuZnJvbVZhbHVlQXJyYXkocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBuZXh0Q2hhcignLCcpOyAvLyBJZiB3ZSBhcmUgbm90IGRvbmUsIHdlIGV4cGVjdCBhICcsJ1xuICAgICAgICAgICAgICAgIGVhdFdoaXRlU3BhY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1rRXJyb3IoJ0NvdWxkIG5vdCBwYXJzZSB0aGUgYXJyYXknKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICAgIEpTT05TdHJpbmcgOjogXCIgSlNPTlN0cmluZ0NoYXJhY3RlcnNfb3B0IFwiXG4gICAgICBKU09OU3RyaW5nQ2hhcmFjdGVycyA6OiBKU09OU3RyaW5nQ2hhcmFjdGVyIEpTT05TdHJpbmdDaGFyYWN0ZXJzX29wdFxuICAgICAgSlNPTlN0cmluZ0NoYXJhY3RlciA6OiBTb3VyY2VDaGFyYWN0ZXIgYnV0IG5vdCBvbmUgb2YgXCIgb3IgXFwgb3IgVSswMDAwIHRocm91Z2ggVSswMDFGIFxcIEpTT05Fc2NhcGVTZXF1ZW5jZVxuICAgICAgSlNPTkVzY2FwZVNlcXVlbmNlIDo6IEpTT05Fc2NhcGVDaGFyYWN0ZXIgVW5pY29kZUVzY2FwZVNlcXVlbmNlXG4gICAgICovXG4gICAgdmFyIGpzb25TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBcIlwiO1xuXG4gICAgICAgIGlmIChjdXJyZW50Q2hhciA9PT0gJ1wiJykge1xuICAgICAgICAgICAgLy9AdHMtaWdub3JlIEpTT05cbiAgICAgICAgICAgIHdoaWxlIChuZXh0Q2hhcigpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFyID09PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vQHRzLWlnbm9yZSBKU09OXG4gICAgICAgICAgICAgICAgICAgIG5leHRDaGFyKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGlzIGFuIGludmFsaWQgc3RyaW5nXG4gICAgICAgICAgICAgICAgaWYgKGludmFsaWRTdHJpbmdDaGFyYWN0ZXJzW2N1cnJlbnRDaGFyXSkge1xuICAgICAgICAgICAgICAgICAgICBta0Vycm9yKFwiSW52YWxpZCBjaGFyYWN0ZXIgaW4gc3RyaW5nXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Q2hhciA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vQHRzLWlnbm9yZSBKU09OXG4gICAgICAgICAgICAgICAgICAgIG5leHRDaGFyKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFyID09PSAndScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoZXhWYWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vQHRzLWlnbm9yZSBKU09OXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhleCA9IHBhcnNlSW50KG5leHRDaGFyKCksIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRmluaXRlKGhleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGV4VmFsdWUgPSBoZXhWYWx1ZSAqIDE2ICsgaGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShoZXhWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGVzY2FwZUNoYXJhY3RlcnNbY3VycmVudENoYXJdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGVzY2FwZUNoYXJhY3RlcnNbY3VycmVudENoYXJdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBjdXJyZW50Q2hhcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBta0Vycm9yKCdCYWQgaW5wdXQgc3RyaW5nJyk7XG4gICAgfTtcblxuICAgIC8vIEpTT05OdW1iZXIgOjogLV9vcHQgRGVjaW1hbEludGVnZXJMaXRlcmFsIEpTT05GcmFjdGlvbl9vcHQgRXhwb25lbnRQYXJ0X29wdFxuICAgIHZhciBqc29uTnVtYmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIiwgY2hlY2tPY3RhbCA9IGZhbHNlLCBjaGVja0Zsb2F0ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRDaGFyID09PSAnLScpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBjdXJyZW50Q2hhcjtcbiAgICAgICAgICAgIG5leHRDaGFyKCctJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudENoYXIgPT09ICcwJykge1xuICAgICAgICAgICAgY2hlY2tPY3RhbCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgYWxsIHRoZSBudW1iZXJzXG4gICAgICAgIHdoaWxlIChjdXJyZW50Q2hhciA+PSAnMCcgJiYgY3VycmVudENoYXIgPD0gJzknKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gY3VycmVudENoYXI7XG4gICAgICAgICAgICAvL0B0cy1pZ25vcmUgSlNPTlxuICAgICAgICAgICAgbmV4dENoYXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGVja09jdGFsICYmIHJlc3VsdC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBta0Vycm9yKFwiSlNPTi5wYXJzZTogTnVtYmVycyBjYW5ub3Qgc3RhcnQgd2l0aCBhIDBcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpZiBpdCBpcyBhIGZsb2F0XG4gICAgICAgIGlmIChjdXJyZW50Q2hhciA9PT0gJy4nKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gY3VycmVudENoYXI7XG4gICAgICAgICAgICBjaGVja0Zsb2F0ID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gR2V0IGFsbCB0aGUgcmVtYWluaW5nIG51bWJlcnMgaW4gdGhlIGZsb2F0XG4gICAgICAgICAgICAvL0B0cy1pZ25vcmUgSlNPTlxuICAgICAgICAgICAgd2hpbGUgKG5leHRDaGFyKCkgJiYgY3VycmVudENoYXIgPj0gJzAnICYmIGN1cnJlbnRDaGFyIDw9ICc5Jykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBjdXJyZW50Q2hhcjtcbiAgICAgICAgICAgICAgICBjaGVja0Zsb2F0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hlY2tGbG9hdCkge1xuICAgICAgICAgICAgbWtFcnJvcihcIkpTT04ucGFyc2U6IE51bWJlciB3aXRoIG5vdGhpbmcgYWZ0ZXIgdGhlIGRlY2ltYWxcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudENoYXIgPT09ICdlJyB8fCBjdXJyZW50Q2hhciA9PT0gJ0UnKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gY3VycmVudENoYXI7XG4gICAgICAgICAgICAvL0B0cy1pZ25vcmUgSlNPTlxuICAgICAgICAgICAgbmV4dENoYXIoKTtcbiAgICAgICAgICAgIC8vQHRzLWlnbm9yZSBUWVBFU0NSSVBUXG4gICAgICAgICAgICBpZiAoY3VycmVudENoYXIgPT09ICctJyB8fCBjdXJyZW50Q2hhciA9PT0gJysnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGN1cnJlbnRDaGFyO1xuICAgICAgICAgICAgICAgIC8vQHRzLWlnbm9yZSBKU09OXG4gICAgICAgICAgICAgICAgbmV4dENoYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50Q2hhciA+PSAnMCcgJiYgY3VycmVudENoYXIgPD0gJzknKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGN1cnJlbnRDaGFyO1xuICAgICAgICAgICAgICAgIC8vQHRzLWlnbm9yZSBKU09OXG4gICAgICAgICAgICAgICAgbmV4dENoYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBudW0gPSArcmVzdWx0OyAvLyBOYXN0eSBjb252ZXJzaW9uLiA6KVxuICAgICAgICBpZiAoIWlzRmluaXRlKG51bSkpIHtcbiAgICAgICAgICAgIG1rRXJyb3IoJ0JhZCBudW1iZXIsIG5vdCBmaW5pdGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudW07XG4gICAgfTtcblxuICAgIC8vIEpTT05OdWxsTGl0ZXJhbCA6OiBOdWxsTGl0ZXJhbFxuICAgIHZhciBqc29uTnVsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbmV4dENoYXIoJ24nKTtcbiAgICAgICAgbmV4dENoYXIoJ3UnKTtcbiAgICAgICAgbmV4dENoYXIoJ2wnKTtcbiAgICAgICAgbmV4dENoYXIoJ2wnKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIC8vIEpTT05Cb29sZWFuTGl0ZXJhbCA6OiBCb29sZWFuTGl0ZXJhbFxuICAgIHZhciBqc29uQm9vbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3dpdGNoIChjdXJyZW50Q2hhcikge1xuICAgICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICAgICAgbmV4dENoYXIoJ3QnKTtcbiAgICAgICAgICAgICAgICBuZXh0Q2hhcigncicpO1xuICAgICAgICAgICAgICAgIG5leHRDaGFyKCd1Jyk7XG4gICAgICAgICAgICAgICAgbmV4dENoYXIoJ2UnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICAgICAgbmV4dENoYXIoJ2YnKTtcbiAgICAgICAgICAgICAgICBuZXh0Q2hhcignYScpO1xuICAgICAgICAgICAgICAgIG5leHRDaGFyKCdsJyk7XG4gICAgICAgICAgICAgICAgbmV4dENoYXIoJ3MnKTtcbiAgICAgICAgICAgICAgICBuZXh0Q2hhcignZScpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBta0Vycm9yKCdDb3VsZCBub3QgZGVkdWNlIGEgYm9vbGVhbicpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGlmICh0ZXh0LnZhbHVlKSB7XG4gICAgICAgIHZhciB0ZXh0TGFiZWwgPSB0ZXh0LmxhYmVsO1xuICAgICAgICB0ZXh0ID0gdGV4dC52YWx1ZTtcbiAgICAgICAgdmFyIHJlcyA9IG5ldyBWYWx1ZShqc29uVmFsdWUoKSwgdGV4dExhYmVsKTtcbiAgICAgICAgZWF0V2hpdGVTcGFjZSgpOyAgLy8gRWF0IGFsbCB0cmFpbGluZyB3aGl0ZSBzcGFjZXNcbiAgICAgICAgLy9AdHMtaWdub3JlIEpTT05cbiAgICAgICAgcmVzLmZpbmFsSW5kZXggPSBjdXJyZW50SW5kZXg7ICAvLyBUaGlzIGlzIG5lZWRlZCB0byBrbm93IGlmIHdlIGhhdmUgc29tZSBnYXJiYWdlIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZ1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbWtFcnJvcignQmFkIGZvcm1hdCBvbiBpbnB1dCcpO1xuICAgIH1cbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBzdHJpbmdpZnksIDE1LjEyLjNcbmZ1bmN0aW9uIHN0cmluZ2lmeSh0aGlzQXJnLCBhcmdzKSB7XG4gICAgLy8gVGhlc2UgYXJlIHVzZWQgZm9yIGN5Y2xlIGRldGVjdGlvblxuICAgIHZhciBKQV9jb3VudGVyID0gMDtcbiAgICB2YXIgSk9fY291bnRlciA9IDA7XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICB2YXIgaW5kZW50ID0gXCJcIjtcbiAgICB2YXIgUHJvcGVydHlMaXN0LCBSZXBsYWNlckZ1bmN0aW9uO1xuICAgIHZhciBnYXAgPSBcIlwiO1xuXG4gICAgdmFyIHZhbHVlID0gYXJnc1swXSB8fCBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgIHZhciByZXBsYWNlciA9IGFyZ3NbMV0gfHwgbmV3IFZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgICB2YXIgc3BhY2UgPSBhcmdzWzJdIHx8IG5ldyBWYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG5cbiAgICB2YXIgcmV0TGFiZWwgPSBsdWIodmFsdWUubGFiZWwsIGx1YihyZXBsYWNlci5sYWJlbCwgc3BhY2UubGFiZWwpKTtcblxuICAgIG1vbml0b3IuY29udGV4dC5wdXNoUEMocmVwbGFjZXIubGFiZWwpO1xuICAgIGlmICh0eXBlb2YgcmVwbGFjZXIudmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiByZXBsYWNlci52YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAoSXNDYWxsYWJsZShyZXBsYWNlcikpIHtcbiAgICAgICAgICAgIFJlcGxhY2VyRnVuY3Rpb24gPSByZXBsYWNlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXBsYWNlci52YWx1ZSAmJiByZXBsYWNlci52YWx1ZS5DbGFzcyA9PT0gJ0FycmF5Jykge1xuICAgICAgICAgICAgUHJvcGVydHlMaXN0ID0gW107XG5cbiAgICAgICAgICAgIHZhciBpbml0aWFsUmVwbGFjZXJMZW5ndGggPSByZXBsYWNlci52YWx1ZS5wcm9wZXJ0aWVzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5pdGlhbFJlcGxhY2VyTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB2YXIgdiA9IHJlcGxhY2VyLkdldChuZXcgVmFsdWUoaSwgYm90KSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodi52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygdi52YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gPSB2O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2LnZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSA9IFRvU3RyaW5nKHYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2LnZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYudmFsdWUgJiYgKHYudmFsdWUuQ2xhc3MgPT09ICdTdHJpbmcnIHx8IHYudmFsdWUuQ2xhc3MgPT09ICdOdW1iZXInKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gPSBUb1N0cmluZyh2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1Ob3RJbkFycmF5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgUHJvcGVydHlMaXN0Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udmFsdWUgPT09IFByb3BlcnR5TGlzdFtqXS52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtTm90SW5BcnJheSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtTm90SW5BcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFByb3BlcnR5TGlzdC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG1vbml0b3IuY29udGV4dC5wb3BQQygpO1xuXG4gICAgbW9uaXRvci5jb250ZXh0LnB1c2hQQyhzcGFjZS5sYWJlbCk7XG4gICAgaWYgKHR5cGVvZiBzcGFjZS52YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKHNwYWNlLnZhbHVlLkNsYXNzID09PSAnTnVtYmVyJykge1xuICAgICAgICAgICAgc3BhY2UgPSBUb051bWJlcihzcGFjZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3BhY2UudmFsdWUuQ2xhc3MgPT09ICdTdHJpbmcnKSB7XG4gICAgICAgICAgICBzcGFjZSA9IFRvU3RyaW5nKHNwYWNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc3BhY2UudmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciBpbnRTcGFjZSA9IFRvSW50ZWdlcihzcGFjZSk7XG4gICAgICAgIGlmIChpbnRTcGFjZS52YWx1ZSA+IDEwKSB7XG4gICAgICAgICAgICBzcGFjZSA9IG5ldyBWYWx1ZSgxMCwgc3BhY2UubGFiZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3BhY2UgPSBpbnRTcGFjZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BhY2UudmFsdWU7IGkrKykge1xuICAgICAgICAgICAgZ2FwID0gZ2FwICsgXCIgXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHNwYWNlLnZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoc3BhY2UudmFsdWUubGVuZ3RoIDw9IDEwKSB7XG4gICAgICAgICAgICBnYXAgPSBzcGFjZS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdhcCA9IHNwYWNlLnZhbHVlLnN1YnN0cmluZygwLCAxMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTGVhdmUgdGhlIGxhc3QgZWxzZSwgZ2FwIHdpbGwgYmUgZW1wdHkgc3RyaW5nIGlmIG5vbmUgb2YgdGhlIGFib3ZlIGhhcyBiZWVuIGhpdFxuICAgIG1vbml0b3IuY29udGV4dC5wb3BQQygpOyAgLy8gUG9wIHNwYWNlLmxhYmVsIGZyb20gdGhlIFBDIHN0YWNrXG5cbiAgICB2YXIgd3JhcHBlciA9IG5ldyBPYmplY3RPYmplY3QoKTtcbiAgICB3cmFwcGVyLkRlZmluZU93blByb3BlcnR5KG5ldyBWYWx1ZShcIlwiLCBib3QpLFxuICAgICAgICB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUudmFsdWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBsYWJlbDogdmFsdWUubGFiZWxcbiAgICAgICAgfSxcbiAgICAgICAgZmFsc2VcbiAgICApO1xuXG4gICAgdmFyIFN0ciA9IGZ1bmN0aW9uIChrZXksIGhvbGRlcikge1xuICAgICAgICB2YXIgdmFsdWUgPSBob2xkZXIuR2V0KGtleSk7XG5cbiAgICAgICAgcmV0TGFiZWwgPSBsdWIocmV0TGFiZWwsIHZhbHVlLmxhYmVsKTtcblxuICAgICAgICBtb25pdG9yLmNvbnRleHQucHVzaFBDKHZhbHVlLmxhYmVsKTtcbiAgICAgICAgaWYgKHZhbHVlLnZhbHVlICYmIHR5cGVvZiB2YWx1ZS52YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHZhciB0b0pTT04gPSB2YWx1ZS5HZXQobmV3IFZhbHVlKFwidG9KU09OXCIsIGJvdCkpO1xuXG4gICAgICAgICAgICBpZiAoSXNDYWxsYWJsZSh0b0pTT04pKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0b0pTT04uQ2FsbCh2YWx1ZSwgW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1vbml0b3IuY29udGV4dC5wb3BQQygpOyAgLy8gQXMgaXQgaXMgYmVpbmcgcHVzaGVkIGFnYWluIGxhdGVyLCBpcyB0aGlzIG5lZWRlZD9cblxuICAgICAgICBpZiAoUmVwbGFjZXJGdW5jdGlvbikge1xuICAgICAgICAgICAgbW9uaXRvci5jb250ZXh0LnB1c2hQQyhSZXBsYWNlckZ1bmN0aW9uLmxhYmVsKTtcbiAgICAgICAgICAgIGlmIChSZXBsYWNlckZ1bmN0aW9uLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBSZXBsYWNlckZ1bmN0aW9uLkNhbGwoaG9sZGVyLCBba2V5LCB2YWx1ZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbW9uaXRvci5jb250ZXh0LnBvcFBDKCk7XG4gICAgICAgIH1cblxuICAgICAgICBtb25pdG9yLmNvbnRleHQucHVzaFBDKHZhbHVlLmxhYmVsKTtcbiAgICAgICAgaWYgKHZhbHVlLnZhbHVlICYmIHR5cGVvZiB2YWx1ZS52YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS52YWx1ZS5DbGFzcyA9PT0gJ051bWJlcicpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFRvTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLnZhbHVlLkNsYXNzID09PSAnU3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gVG9TdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUudmFsdWUuQ2xhc3MgPT09ICdCb29sZWFuJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IFZhbHVlKHZhbHVlLnZhbHVlLlByaW1pdGl2ZVZhbHVlLnZhbHVlT2YoKSwgcmV0TGFiZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlLnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICBtb25pdG9yLmNvbnRleHQucG9wUEMoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmFsdWUoXCJudWxsXCIsIHJldExhYmVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUudmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIG1vbml0b3IuY29udGV4dC5wb3BQQygpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZShcInRydWVcIiwgcmV0TGFiZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS52YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG1vbml0b3IuY29udGV4dC5wb3BQQygpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZShcImZhbHNlXCIsIHJldExhYmVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUudmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YXIgcmVzID0gUXVvdGUodmFsdWUpO1xuICAgICAgICAgICAgbW9uaXRvci5jb250ZXh0LnBvcFBDKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZS52YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGlmIChpc0Zpbml0ZSh2YWx1ZS52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gVG9TdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgICAgIG1vbml0b3IuY29udGV4dC5wb3BQQygpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1vbml0b3IuY29udGV4dC5wb3BQQygpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZShcIm51bGxcIiwgcmV0TGFiZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZS52YWx1ZSA9PT0gJ29iamVjdCcgJiYgIUlzQ2FsbGFibGUodmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUudmFsdWUuQ2xhc3MgPT09ICdBcnJheScpIHtcbiAgICAgICAgICAgICAgICAvL0B0cy1pZ25vcmUgSlNPTlxuICAgICAgICAgICAgICAgIHZhciByZXMgPSBKQSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgbW9uaXRvci5jb250ZXh0LnBvcFBDKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9AdHMtaWdub3JlIEpTT05cbiAgICAgICAgICAgIHZhciByZXMgPSBKTyh2YWx1ZSk7XG4gICAgICAgICAgICBtb25pdG9yLmNvbnRleHQucG9wUEMoKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cblxuICAgICAgICBtb25pdG9yLmNvbnRleHQucG9wUEMoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZSh1bmRlZmluZWQsIHJldExhYmVsKTtcbiAgICB9O1xuXG4gICAgdmFyIFF1b3RlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBwcm9kdWN0ID0gXCJcXFwiXCI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUudmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBDID0gdmFsdWUudmFsdWVbaV07XG4gICAgICAgICAgICB2YXIgY0NvZGVQb2ludFZhbHVlID0gQy5jb2RlUG9pbnRBdCgwKTtcbiAgICAgICAgICAgIHZhciBzcGFjZUNvZGVQb2ludFZhbHVlID0gKFwiIFwiKS5jb2RlUG9pbnRBdCgwKTtcblxuICAgICAgICAgICAgaWYgKEMgPT09IFwiXFxcIlwiIHx8IEMgPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgICAgICAgcHJvZHVjdCArPSBcIlxcXFxcIjtcbiAgICAgICAgICAgICAgICBwcm9kdWN0ICs9IEM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChDID09PSBcIlxcYlwiIHx8IEMgPT09IFwiXFxmXCIgfHwgQyA9PT0gXCJcXG5cIiB8fCBDID09PSBcIlxcclwiIHx8IEMgPT09IFwiXFx0XCIpIHtcbiAgICAgICAgICAgICAgICBwcm9kdWN0ICs9IFwiXFxcXFwiO1xuICAgICAgICAgICAgICAgIHZhciBhYmJyZXY7XG4gICAgICAgICAgICAgICAgaWYgKEMgPT09IFwiXFxiXCIpIGFiYnJldiA9IFwiYlwiO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKEMgPT09IFwiXFxmXCIpIGFiYnJldiA9IFwiZlwiO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKEMgPT09IFwiXFxuXCIpIGFiYnJldiA9IFwiblwiO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKEMgPT09IFwiXFxyXCIpIGFiYnJldiA9IFwiclwiO1xuICAgICAgICAgICAgICAgIGVsc2UgYWJicmV2ID0gXCJ0XCI7XG5cbiAgICAgICAgICAgICAgICBwcm9kdWN0ICs9IGFiYnJldjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNDb2RlUG9pbnRWYWx1ZSA8IHNwYWNlQ29kZVBvaW50VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBwcm9kdWN0ICs9IFwiXFxcXFwiO1xuICAgICAgICAgICAgICAgIHByb2R1Y3QgKz0gXCJ1XCI7XG4gICAgICAgICAgICAgICAgdmFyIGhleCA9IGNDb2RlUG9pbnRWYWx1ZS50b1N0cmluZygxNik7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IGhleC5sZW5ndGg7IGogPCA0OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaGV4ID0gXCIwXCIgKyBoZXg7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcHJvZHVjdCArPSBoZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9kdWN0ICs9IEM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwcm9kdWN0ICs9IFwiXFxcIlwiO1xuICAgICAgICByZXR1cm4gbmV3IFZhbHVlKHByb2R1Y3QsIGx1Yihtb25pdG9yLmNvbnRleHQuZWZmZWN0aXZlUEMsIHZhbHVlLmxhYmVsKSk7XG4gICAgfTtcblxuICAgIHZhciBKTyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgSk9fa2V5ID0gbmV3IFZhbHVlKFwiSk9fcHJvcGVydHlcIiwgYm90KTtcbiAgICAgICAgaWYgKCF2YWx1ZS5HZXQoSk9fa2V5KS52YWx1ZSkge1xuICAgICAgICAgICAgSk9fY291bnRlcisrO1xuICAgICAgICAgICAgdmFsdWUuRGVmaW5lT3duUHJvcGVydHkoSk9fa2V5LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IEpPX2NvdW50ZXIsXG4gICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBib3RcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNoZWNrQ3ljbGUoSk9fa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFjay5wdXNoKHZhbHVlKTtcbiAgICAgICAgdmFyIHN0ZXBiYWNrID0gaW5kZW50O1xuICAgICAgICBpbmRlbnQgPSBpbmRlbnQgKyBnYXA7XG5cbiAgICAgICAgaWYgKFByb3BlcnR5TGlzdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgSyA9IFByb3BlcnR5TGlzdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vQHRzLWlnbm9yZSBKU09OXG4gICAgICAgICAgICB2YXIgSyA9IFtdO1xuICAgICAgICAgICAgdmFyIGFsbEtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZS52YWx1ZS5wcm9wZXJ0aWVzKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleVZhbCA9IHZhbHVlLkdldFByb3BlcnR5KG5ldyBWYWx1ZShhbGxLZXlzW2ldLCBib3QpKTtcblxuICAgICAgICAgICAgICAgIGlmIChrZXlWYWwudmFsdWUgJiYga2V5VmFsLnZhbHVlLmVudW1lcmFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgSy5wdXNoKG5ldyBWYWx1ZShhbGxLZXlzW2ldLCByZXRMYWJlbCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJ0aWFsID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgSy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIFAgPSBLW2ldO1xuICAgICAgICAgICAgdmFyIHN0clAgPSBTdHIoUCwgdmFsdWUpO1xuXG4gICAgICAgICAgICBpZiAoc3RyUCAmJiBzdHJQLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWVtYmVyID0gUXVvdGUoUCk7XG4gICAgICAgICAgICAgICAgbWVtYmVyLnZhbHVlICs9IFwiOlwiO1xuICAgICAgICAgICAgICAgIGlmIChnYXAgIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVtYmVyLnZhbHVlICs9ICcgJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtZW1iZXIudmFsdWUgKz0gc3RyUC52YWx1ZTtcbiAgICAgICAgICAgICAgICBwYXJ0aWFsLnB1c2gobWVtYmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmaW5hbDtcbiAgICAgICAgaWYgKHBhcnRpYWwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBmaW5hbCA9IFwie31cIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChnYXAgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRpYWwubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMgKz0gcGFydGlhbFtpXS52YWx1ZSArICcsJztcbiAgICAgICAgICAgICAgICAgICAgcmV0TGFiZWwgPSBsdWIocmV0TGFiZWwsIHBhcnRpYWxbaV0ubGFiZWwpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMgKz0gcGFydGlhbFtwYXJ0aWFsLmxlbmd0aCAtIDFdLnZhbHVlO1xuICAgICAgICAgICAgICAgIHJldExhYmVsID0gbHViKHJldExhYmVsLCBwYXJ0aWFsW3BhcnRpYWwubGVuZ3RoIC0gMV0ubGFiZWwpO1xuXG4gICAgICAgICAgICAgICAgZmluYWwgPSAneycgKyBwcm9wZXJ0aWVzICsgJ30nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlcGFyYXRvciA9IFwiLFxcblwiICsgaW5kZW50O1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0aWFsLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzICs9IHBhcnRpYWxbaV0udmFsdWUgKyBzZXBhcmF0b3I7XG4gICAgICAgICAgICAgICAgICAgIHJldExhYmVsID0gbHViKHJldExhYmVsLCBwYXJ0aWFsW2ldLmxhYmVsKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzICs9IHBhcnRpYWxbcGFydGlhbC5sZW5ndGggLSAxXS52YWx1ZTtcbiAgICAgICAgICAgICAgICByZXRMYWJlbCA9IGx1YihyZXRMYWJlbCwgcGFydGlhbFtwYXJ0aWFsLmxlbmd0aCAtIDFdLmxhYmVsKTtcblxuICAgICAgICAgICAgICAgIGZpbmFsID0gJ3tcXG4nICsgaW5kZW50ICsgcHJvcGVydGllcyArICdcXG4nICsgc3RlcGJhY2sgKyAnfSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQb3AgYW5kIHJlbW92ZSBKT19wcm9wZXJ0eVxuICAgICAgICB2YXIgdiA9IHN0YWNrLnBvcCgpO1xuICAgICAgICB2LkRlbGV0ZShKT19rZXkpO1xuXG4gICAgICAgIGluZGVudCA9IHN0ZXBiYWNrO1xuICAgICAgICByZXR1cm4gbmV3IFZhbHVlKGZpbmFsLCByZXRMYWJlbCk7XG4gICAgfTtcblxuICAgIHZhciBKQSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgSkFfa2V5ID0gbmV3IFZhbHVlKFwiSkFfcHJvcGVydHlcIiwgYm90KTtcbiAgICAgICAgaWYgKCF2YWx1ZS5HZXQoSkFfa2V5KS52YWx1ZSkge1xuICAgICAgICAgICAgSkFfY291bnRlcisrO1xuICAgICAgICAgICAgdmFsdWUuRGVmaW5lT3duUHJvcGVydHkoSkFfa2V5LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IEpBX2NvdW50ZXIsXG4gICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBib3RcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNoZWNrQ3ljbGUoSkFfa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFjay5wdXNoKHZhbHVlKTtcbiAgICAgICAgdmFyIHN0ZXBiYWNrID0gaW5kZW50O1xuICAgICAgICBpbmRlbnQgPSBpbmRlbnQgKyBnYXA7XG4gICAgICAgIHZhciBwYXJ0aWFsID0gW107XG5cbiAgICAgICAgdmFyIGxlbiA9IHZhbHVlLkdldChuZXcgVmFsdWUoJ2xlbmd0aCcsIGJvdCkpO1xuICAgICAgICB2YXIgaW5kZXggPSBuZXcgVmFsdWUoMCwgYm90KTtcblxuICAgICAgICB3aGlsZSAoaW5kZXgudmFsdWUgPCBsZW4udmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBzdHJQID0gU3RyKFRvU3RyaW5nKGluZGV4KSwgdmFsdWUpO1xuICAgICAgICAgICAgaWYgKCFzdHJQIHx8IHN0clAudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHBhcnRpYWwucHVzaChuZXcgVmFsdWUoXCJudWxsXCIsIHJldExhYmVsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJ0aWFsLnB1c2goc3RyUCk7XG4gICAgICAgICAgICAgICAgcmV0TGFiZWwgPSBsdWIocmV0TGFiZWwsIHN0clAubGFiZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kZXgudmFsdWUrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmaW5hbDtcbiAgICAgICAgaWYgKHBhcnRpYWwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBmaW5hbCA9IFwiW11cIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChnYXAgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRpYWwubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMgKz0gcGFydGlhbFtpXS52YWx1ZSArICcsJztcbiAgICAgICAgICAgICAgICAgICAgcmV0TGFiZWwgPSBsdWIocmV0TGFiZWwsIHBhcnRpYWxbaV0ubGFiZWwpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMgKz0gcGFydGlhbFtwYXJ0aWFsLmxlbmd0aCAtIDFdLnZhbHVlO1xuICAgICAgICAgICAgICAgIHJldExhYmVsID0gbHViKHJldExhYmVsLCBwYXJ0aWFsW3BhcnRpYWwubGVuZ3RoIC0gMV0ubGFiZWwpO1xuXG4gICAgICAgICAgICAgICAgZmluYWwgPSAnWycgKyBwcm9wZXJ0aWVzICsgJ10nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlcGFyYXRvciA9IFwiLFxcblwiICsgaW5kZW50O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydGlhbC5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllcyArPSBwYXJ0aWFsW2ldLnZhbHVlICsgc2VwYXJhdG9yO1xuICAgICAgICAgICAgICAgICAgICByZXRMYWJlbCA9IGx1YihyZXRMYWJlbCwgcGFydGlhbFtpXS5sYWJlbCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcHJvcGVydGllcyArPSBwYXJ0aWFsW3BhcnRpYWwubGVuZ3RoIC0gMV0udmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0TGFiZWwgPSBsdWIocmV0TGFiZWwsIHBhcnRpYWxbcGFydGlhbC5sZW5ndGggLSAxXS5sYWJlbCk7XG5cbiAgICAgICAgICAgICAgICBmaW5hbCA9ICdbXFxuJyArIGluZGVudCArIHByb3BlcnRpZXMgKyAnXFxuJyArIHN0ZXBiYWNrICsgJ10nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUG9wIGFuZCByZW1vdmUgcHJvcGVydHkgb2YgSkFfa2V5XG4gICAgICAgIHZhciB2ID0gc3RhY2sucG9wKCk7XG4gICAgICAgIHYuRGVsZXRlKEpBX2tleSk7XG5cbiAgICAgICAgaW5kZW50ID0gc3RlcGJhY2s7XG4gICAgICAgIHJldHVybiBuZXcgVmFsdWUoZmluYWwsIHJldExhYmVsKTtcbiAgICB9O1xuXG4gICAgdmFyIGNoZWNrQ3ljbGUgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUuR2V0KGtleSkudmFsdWUgPT09IHN0YWNrW2ldLkdldChrZXkpLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbW9uaXRvci5UaHJvdyhcbiAgICAgICAgICAgICAgICAgICAgXCJUeXBlRXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgJ0pTT04uc3RyaW5naWZ5OiBDeWNsaWMgc3RydWN0dXJlJyxcbiAgICAgICAgICAgICAgICAgICAgYm90XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gU3RyKG5ldyBWYWx1ZShcIlwiLCBib3QpLCBuZXcgVmFsdWUod3JhcHBlciwgYm90KSk7XG59IiwiaW1wb3J0IHsgVmFsdWUgfSBmcm9tIFwiLi4vVmFsdWVcIjtcbmltcG9ydCAqIGFzIGNvbnN0YW50cyBmcm9tICcuLi9Db25zdGFudHMnO1xuaW1wb3J0IHsgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0IH0gZnJvbSBcIi4vQnVpbHRpbkZ1bmN0aW9uT2JqZWN0XCI7XG5pbXBvcnQgeyBUb051bWJlciB9IGZyb20gJy4uL0NvbnZlcnNpb24vVG9OdW1iZXInO1xuaW1wb3J0IHsgTW9uaXRvckJhc2UgfSBmcm9tICcuLi9Nb25pdG9yQmFzZSc7XG5cbmltcG9ydCB7IERlZmluZUZGRiwgRGVmaW5lVEZUIH0gZnJvbSAnLi4vRGVmaW5lJztcbmltcG9ydCB7IEVjbWFPYmplY3QgfSBmcm9tICcuLi9PYmplY3RzL0VjbWFPYmplY3QnO1xuXG5pbXBvcnQgeyBib3QsIGx1YiB9IGZyb20gJy4uL0xhYmVsJztcbmltcG9ydCB7IFZhbHVlVHlwZXMgfSBmcm9tIFwiLi4vSW50ZXJmYWNlc1wiO1xuXG5kZWNsYXJlIHZhciBtb25pdG9yOiBNb25pdG9yQmFzZTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBUaGUgTWF0aCBPYmplY3QsIDE1LjguMlxuXG5leHBvcnQgY2xhc3MgTWF0aE9iamVjdCBleHRlbmRzIEVjbWFPYmplY3Qge1xuXG4gICAgaG9zdDogTWF0aDtcblxuICAgIGNvbnN0cnVjdG9yKGhvc3Q6IGFueSkge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMuQ2xhc3MgPSAnTWF0aCc7XG4gICAgICAgIC8vIG5vdCBtYW5kYXRlZCBieSBzdGFuZGFyZFxuICAgICAgICB0aGlzLkV4dGVuc2libGUgPSB0cnVlO1xuICAgICAgICB0aGlzLmhvc3QgPSBob3N0O1xuXG4gICAgfVxuXG4gICAgU2V0dXAoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuUHJvdG90eXBlID0gbmV3IFZhbHVlKG1vbml0b3IuaW5zdGFuY2VzLk9iamVjdFByb3RvdHlwZSwgYm90KTtcblxuICAgICAgICBEZWZpbmVGRkYodGhpcywgY29uc3RhbnRzLmxlbmd0aCwgMSk7XG4gICAgICAgIERlZmluZUZGRih0aGlzLCBjb25zdGFudHMucHJvdG90eXBlLCBtb25pdG9yLmluc3RhbmNlcy5PYmplY3RQcm90b3R5cGUpO1xuXG4gICAgICAgIERlZmluZUZGRih0aGlzLCBjb25zdGFudHMuRSwgdGhpcy5ob3N0LkUpO1xuICAgICAgICBEZWZpbmVGRkYodGhpcywgY29uc3RhbnRzLkxOMTAsIHRoaXMuaG9zdC5MTjEwKTtcbiAgICAgICAgRGVmaW5lRkZGKHRoaXMsIGNvbnN0YW50cy5MTjIsIHRoaXMuaG9zdC5MTjIpO1xuICAgICAgICBEZWZpbmVGRkYodGhpcywgY29uc3RhbnRzLkxPRzJFLCB0aGlzLmhvc3QuTE9HMkUpO1xuICAgICAgICBEZWZpbmVGRkYodGhpcywgY29uc3RhbnRzLkxPRzEwRSwgdGhpcy5ob3N0LkxPRzEwRSk7XG4gICAgICAgIERlZmluZUZGRih0aGlzLCBjb25zdGFudHMuUEksIHRoaXMuaG9zdC5QSSk7XG4gICAgICAgIERlZmluZUZGRih0aGlzLCBjb25zdGFudHMuU1FSVDFfMiwgdGhpcy5ob3N0LlNRUlQxXzIpO1xuICAgICAgICBEZWZpbmVGRkYodGhpcywgY29uc3RhbnRzLlNRUlQyLCB0aGlzLmhvc3QuU1FSVDIpO1xuXG4gICAgICAgIC8vQHRzLWlnbm9yZSBUWVBFU1xuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLmFicywgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChhYnMsIDEsIHRoaXMuaG9zdC5hYnMpKTtcbiAgICAgICAgLy9AdHMtaWdub3JlIFRZUEVTXG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuYWNvcywgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChhY29zLCAxLCB0aGlzLmhvc3QuYWNvcykpO1xuICAgICAgICAvL0B0cy1pZ25vcmUgVFlQRVNcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5hc2luLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KGFzaW4sIDEsIHRoaXMuaG9zdC5hc2luKSk7XG4gICAgICAgIC8vQHRzLWlnbm9yZSBUWVBFU1xuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLmF0YW4sIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3QoYXRhbiwgMSwgdGhpcy5ob3N0LmF0YW4pKTtcbiAgICAgICAgLy9AdHMtaWdub3JlIFRZUEVTXG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuYXRhbjIsIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3QoYXRhbjIsIDIsIHRoaXMuaG9zdC5hdGFuMikpO1xuICAgICAgICAvL0B0cy1pZ25vcmUgVFlQRVNcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5jZWlsLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KGNlaWwsIDEsIHRoaXMuaG9zdC5jZWlsKSk7XG4gICAgICAgIC8vQHRzLWlnbm9yZSBUWVBFU1xuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLmNvcywgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChjb3MsIDEsIHRoaXMuaG9zdC5jb3MpKTtcbiAgICAgICAgLy9AdHMtaWdub3JlIFRZUEVTXG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuZXhwLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KGV4cCwgMSwgdGhpcy5ob3N0LmV4cCkpO1xuICAgICAgICAvL0B0cy1pZ25vcmUgVFlQRVNcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5mbG9vciwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChmbG9vciwgMSwgdGhpcy5ob3N0LmZsb29yKSk7XG4gICAgICAgIC8vQHRzLWlnbm9yZSBUWVBFU1xuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLmxvZywgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChsb2csIDEsIHRoaXMuaG9zdC5sb2cpKTtcbiAgICAgICAgLy9AdHMtaWdub3JlIFRZUEVTXG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMubWF4LCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KG1heCwgMiwgdGhpcy5ob3N0Lm1heCkpO1xuICAgICAgICAvL0B0cy1pZ25vcmUgVFlQRVNcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5taW4sIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3QobWluLCAyLCB0aGlzLmhvc3QubWluKSk7XG4gICAgICAgIC8vQHRzLWlnbm9yZSBUWVBFU1xuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLnBvdywgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChwb3csIDIsIHRoaXMuaG9zdC5wb3cpKTtcbiAgICAgICAgLy9AdHMtaWdub3JlIFRZUEVTXG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMucmFuZG9tLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHJhbmRvbSwgMCwgdGhpcy5ob3N0LnJhbmRvbSkpO1xuICAgICAgICAvL0B0cy1pZ25vcmUgVFlQRVNcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5yb3VuZCwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChyb3VuZCwgMSwgdGhpcy5ob3N0LnJvdW5kKSk7XG4gICAgICAgIC8vQHRzLWlnbm9yZSBUWVBFU1xuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLnNpbiwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChzaW4sIDEsIHRoaXMuaG9zdC5zaW4pKTtcbiAgICAgICAgLy9AdHMtaWdub3JlIFRZUEVTXG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuc3FydCwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChzcXJ0LCAxLCB0aGlzLmhvc3Quc3FydCkpO1xuICAgICAgICAvL0B0cy1pZ25vcmUgVFlQRVNcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy50YW4sIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3QodGFuLCAxLCB0aGlzLmhvc3QudGFuKSk7XG4gICAgfVxufVxuXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gYWJzLCAxNS44LjIuMVxuZnVuY3Rpb24gYWJzKHRoaXM6IHsgaG9zdCh4OiBudW1iZXIpOiBudW1iZXIgfSwgdGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxudW1iZXI+IHtcbiAgICBsZXQgeCA9IGFyZ3NbMF0gPyBUb051bWJlcihhcmdzWzBdKSA6IG5ldyBWYWx1ZShOYU4sIGJvdCk7XG4gICAgcmV0dXJuIG5ldyBWYWx1ZSh0aGlzLmhvc3QoeC52YWx1ZSksIHgubGFiZWwpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGFjb3MsIDE1LjguMi4yXG5mdW5jdGlvbiBhY29zKHRoaXM6IHsgaG9zdCh4OiBudW1iZXIpOiBudW1iZXIgfSwgdGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxudW1iZXI+IHtcbiAgICBsZXQgeCA9IGFyZ3NbMF0gPyBUb051bWJlcihhcmdzWzBdKSA6IG5ldyBWYWx1ZShOYU4sIGJvdCk7XG4gICAgcmV0dXJuIG5ldyBWYWx1ZSh0aGlzLmhvc3QoeC52YWx1ZSksIHgubGFiZWwpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGFzaW4sIDE1LjguMi4zXG5mdW5jdGlvbiBhc2luKHRoaXM6IHsgaG9zdCh4OiBudW1iZXIpOiBudW1iZXIgfSwgdGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxudW1iZXI+IHtcbiAgICBsZXQgeCA9IGFyZ3NbMF0gPyBUb051bWJlcihhcmdzWzBdKSA6IG5ldyBWYWx1ZShOYU4sIGJvdCk7XG4gICAgcmV0dXJuIG5ldyBWYWx1ZSh0aGlzLmhvc3QoeC52YWx1ZSksIHgubGFiZWwpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGF0YW4sIDE1LjguMi40XG5mdW5jdGlvbiBhdGFuKHRoaXM6IHsgaG9zdCh4OiBudW1iZXIpOiBudW1iZXIgfSwgdGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxudW1iZXI+IHtcbiAgICBsZXQgeCA9IGFyZ3NbMF0gPyBUb051bWJlcihhcmdzWzBdKSA6IG5ldyBWYWx1ZShOYU4sIGJvdCk7XG4gICAgcmV0dXJuIG5ldyBWYWx1ZSh0aGlzLmhvc3QoeC52YWx1ZSksIHgubGFiZWwpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGF0YW4yLCAxNS44LjIuNVxuZnVuY3Rpb24gYXRhbjIodGhpczogeyBob3N0KHg6IG51bWJlciwgeTogbnVtYmVyKTogbnVtYmVyIH0sIHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8bnVtYmVyPiB7XG4gICAgbGV0IHggPSBhcmdzWzBdID8gVG9OdW1iZXIoYXJnc1swXSkgOiBuZXcgVmFsdWUoTmFOLCBib3QpO1xuICAgIGxldCB5ID0gYXJnc1sxXSA/IFRvTnVtYmVyKGFyZ3NbMV0pIDogbmV3IFZhbHVlKE5hTiwgYm90KTtcbiAgICByZXR1cm4gbmV3IFZhbHVlKHRoaXMuaG9zdCh4LnZhbHVlLCB5LnZhbHVlKSwgbHViKHgubGFiZWwsIHkubGFiZWwpKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBjZWlsLCAxNS44LjIuNlxuZnVuY3Rpb24gY2VpbCh0aGlzOiB7IGhvc3QoeDogbnVtYmVyKTogbnVtYmVyIH0sIHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8bnVtYmVyPiB7XG4gICAgbGV0IHggPSBhcmdzWzBdID8gVG9OdW1iZXIoYXJnc1swXSkgOiBuZXcgVmFsdWUoTmFOLCBib3QpO1xuICAgIHJldHVybiBuZXcgVmFsdWUodGhpcy5ob3N0KHgudmFsdWUpLCB4LmxhYmVsKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBjb3MsIDE1LjguMi43XG5mdW5jdGlvbiBjb3ModGhpczogeyBob3N0KHg6IG51bWJlcik6IG51bWJlciB9LCB0aGlzQXJnOiBWYWx1ZTxWYWx1ZVR5cGVzPiwgYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPG51bWJlcj4ge1xuICAgIGxldCB4ID0gYXJnc1swXSA/IFRvTnVtYmVyKGFyZ3NbMF0pIDogbmV3IFZhbHVlKE5hTiwgYm90KTtcbiAgICByZXR1cm4gbmV3IFZhbHVlKHRoaXMuaG9zdCh4LnZhbHVlKSwgeC5sYWJlbCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gZXhwLCAxNS44LjIuOFxuZnVuY3Rpb24gZXhwKHRoaXM6IHsgaG9zdCh4OiBudW1iZXIpOiBudW1iZXIgfSwgdGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxudW1iZXI+IHtcbiAgICBsZXQgeCA9IGFyZ3NbMF0gPyBUb051bWJlcihhcmdzWzBdKSA6IG5ldyBWYWx1ZShOYU4sIGJvdCk7XG4gICAgcmV0dXJuIG5ldyBWYWx1ZSh0aGlzLmhvc3QoeC52YWx1ZSksIHgubGFiZWwpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGZsb29yLCAxNS44LjIuOVxuZnVuY3Rpb24gZmxvb3IodGhpczogeyBob3N0KHg6IG51bWJlcik6IG51bWJlciB9LCB0aGlzQXJnOiBWYWx1ZTxWYWx1ZVR5cGVzPiwgYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPG51bWJlcj4ge1xuICAgIGxldCB4ID0gYXJnc1swXSA/IFRvTnVtYmVyKGFyZ3NbMF0pIDogbmV3IFZhbHVlKE5hTiwgYm90KTtcbiAgICByZXR1cm4gbmV3IFZhbHVlKHRoaXMuaG9zdCh4LnZhbHVlKSwgeC5sYWJlbCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gbG9nLCAxNS44LjIuMTBcbmZ1bmN0aW9uIGxvZyh0aGlzOiB7IGhvc3QoeDogbnVtYmVyKTogbnVtYmVyIH0sIHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8bnVtYmVyPiB7XG4gICAgbGV0IHggPSBhcmdzWzBdID8gVG9OdW1iZXIoYXJnc1swXSkgOiBuZXcgVmFsdWUoTmFOLCBib3QpO1xuICAgIHJldHVybiBuZXcgVmFsdWUodGhpcy5ob3N0KHgudmFsdWUpLCB4LmxhYmVsKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBtYXgsIDE1LjguMi4xMVxuZnVuY3Rpb24gbWF4KHRoaXM6IHsgaG9zdCguLi52YWx1ZXM6IG51bWJlcltdKTogbnVtYmVyIH0sIHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8bnVtYmVyPiB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSByZXR1cm4gbmV3IFZhbHVlKE51bWJlci5ORUdBVElWRV9JTkZJTklUWSwgYm90KTtcbiAgICBsZXQgbXlBcmdzOiBhbnlbXSA9IFtdO1xuICAgIGxldCBsID0gYm90O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICBteUFyZ3NbaV0gPSBhcmdzW2ldLnZhbHVlO1xuICAgICAgICBsID0gbHViKGwsIGFyZ3NbaV0ubGFiZWwpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFZhbHVlKHRoaXMuaG9zdC5hcHBseShudWxsLCBteUFyZ3MpLCBsKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBtaW4sIDE1LjguMi4xMlxuZnVuY3Rpb24gbWluKHRoaXM6IHsgaG9zdCguLi52YWx1ZXM6IG51bWJlcltdKTogbnVtYmVyIH0sIHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8bnVtYmVyPiB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSByZXR1cm4gbmV3IFZhbHVlKE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgYm90KTtcbiAgICBsZXQgbXlBcmdzOiBhbnlbXSA9IFtdO1xuICAgIGxldCBsID0gYm90O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICBteUFyZ3NbaV0gPSBhcmdzW2ldLnZhbHVlO1xuICAgICAgICBsID0gbHViKGwsIGFyZ3NbaV0ubGFiZWwpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFZhbHVlKHRoaXMuaG9zdC5hcHBseShudWxsLCBteUFyZ3MpLCBsKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBwb3csIDE1LjguMi4xM1xuZnVuY3Rpb24gcG93KHRoaXMgOiB7IGhvc3QoeDogbnVtYmVyLCB5IDpudW1iZXIpIDogbnVtYmVyIH0sdGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxudW1iZXI+IHtcbiAgICBsZXQgeCA9IGFyZ3NbMF0gPyBUb051bWJlcihhcmdzWzBdKSA6IG5ldyBWYWx1ZShOYU4sIGJvdCk7XG4gICAgbGV0IHkgPSBhcmdzWzFdID8gVG9OdW1iZXIoYXJnc1sxXSkgOiBuZXcgVmFsdWUoTmFOLCBib3QpO1xuICAgIHJldHVybiBuZXcgVmFsdWUodGhpcy5ob3N0KHgudmFsdWUsIHkudmFsdWUpLCBsdWIoeC5sYWJlbCwgeS5sYWJlbCkpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHJhbmRvbSwgMTUuOC4yLjE0XG5mdW5jdGlvbiByYW5kb20odGhpcyA6IHsgaG9zdCgpIDogbnVtYmVyIH0sdGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxudW1iZXI+IHtcbiAgICByZXR1cm4gbmV3IFZhbHVlKHRoaXMuaG9zdCgpLCBib3QpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHJvdW5kLCAxNS44LjIuMTVcbmZ1bmN0aW9uIHJvdW5kKHRoaXMgOiB7IGhvc3QoeDogbnVtYmVyKSA6IG51bWJlciB9LHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8bnVtYmVyPiB7XG4gICAgbGV0IHggPSBhcmdzWzBdID8gVG9OdW1iZXIoYXJnc1swXSkgOiBuZXcgVmFsdWUoTmFOLCBib3QpO1xuICAgIHJldHVybiBuZXcgVmFsdWUodGhpcy5ob3N0KHgudmFsdWUpLCB4LmxhYmVsKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBzaW4sIDE1LjguMi4xNlxuZnVuY3Rpb24gc2luKHRoaXMgOiB7IGhvc3QoeDogbnVtYmVyKSA6IG51bWJlciB9LHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8bnVtYmVyPiB7XG4gICAgbGV0IHggPSBhcmdzWzBdID8gVG9OdW1iZXIoYXJnc1swXSkgOiBuZXcgVmFsdWUoTmFOLCBib3QpO1xuICAgIHJldHVybiBuZXcgVmFsdWUodGhpcy5ob3N0KHgudmFsdWUpLCB4LmxhYmVsKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBzcXJ0LCAxNS44LjIuMTdcbmZ1bmN0aW9uIHNxcnQodGhpcyA6IHsgaG9zdCh4OiBudW1iZXIpIDogbnVtYmVyIH0sdGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxudW1iZXI+IHtcbiAgICBsZXQgeCA9IGFyZ3NbMF0gPyBUb051bWJlcihhcmdzWzBdKSA6IG5ldyBWYWx1ZShOYU4sIGJvdCk7XG4gICAgcmV0dXJuIG5ldyBWYWx1ZSh0aGlzLmhvc3QoeC52YWx1ZSksIHgubGFiZWwpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHRhbiwgMTUuOC4yLjE4XG5mdW5jdGlvbiB0YW4odGhpcyA6IHsgaG9zdCh4OiBudW1iZXIpIDogbnVtYmVyIH0sdGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxWYWx1ZVR5cGVzPiB7XG4gICAgbGV0IHggPSBhcmdzWzBdID8gVG9OdW1iZXIoYXJnc1swXSkgOiBuZXcgVmFsdWUoTmFOLCBib3QpO1xuICAgIHJldHVybiBuZXcgVmFsdWUodGhpcy5ob3N0KHgudmFsdWUpLCB4LmxhYmVsKTtcbn0iLCJpbXBvcnQgeyBWYWx1ZSB9IGZyb20gXCIuLi9WYWx1ZVwiO1xuaW1wb3J0IHsgRWNtYU9iamVjdCB9IGZyb20gJy4uL09iamVjdHMvRWNtYU9iamVjdCc7XG5pbXBvcnQgKiBhcyBjb25zdGFudHMgZnJvbSAnLi4vQ29uc3RhbnRzJztcbmltcG9ydCB7IFRvU3RyaW5nIH0gZnJvbSAnLi4vQ29udmVyc2lvbi9Ub1N0cmluZyc7XG5pbXBvcnQgeyBib3QgfSBmcm9tICcuLi9MYWJlbCc7XG5pbXBvcnQgeyBNb25pdG9yQmFzZSB9IGZyb20gJy4uL01vbml0b3JCYXNlJztcbmltcG9ydCB7IFN0YWNrVHJhY2UgfSBmcm9tIFwiLi4vU3RhY2tUcmFjZVwiO1xuaW1wb3J0IHsgVmFsdWVUeXBlcyB9IGZyb20gXCIuLi9JbnRlcmZhY2VzXCI7XG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmRlY2xhcmUgdmFyIG1vbml0b3I6IE1vbml0b3JCYXNlO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIE5hdGl2ZUVycm9yT2JqZWN0IGV4dGVuZHMgRWNtYU9iamVjdCB7XG5cbiAgICBhYnN0cmFjdCBUeXBlOiBzdHJpbmc7XG4gICAgbWVzc2FnZTogc3RyaW5nO1xuICAgIHN0YWNrOiBTdGFja1RyYWNlO1xuICAgIG5hdGl2ZVN0YWNrIDogc3RyaW5nO1xuXG4gICAgY29uc3RydWN0b3IocHJvdG86IEVjbWFPYmplY3QsIHY6IFZhbHVlPFZhbHVlVHlwZXM+KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuUHJvdG90eXBlID0gbmV3IFZhbHVlKHByb3RvLCBib3QpO1xuICAgICAgICB0aGlzLkNsYXNzID0gJ0Vycm9yJztcbiAgICAgICAgdGhpcy5FeHRlbnNpYmxlID0gdHJ1ZTtcblxuICAgICAgICBsZXQgbWVzc2FnZSA9IG5ldyBWYWx1ZShcIlwiLCBib3QpO1xuXG4gICAgICAgIGlmICh2LnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBUb1N0cmluZyh2KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuRGVmaW5lT3duUHJvcGVydHkoXG4gICAgICAgICAgICBjb25zdGFudHMubWVzc2FnZSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbWVzc2FnZS52YWx1ZSxcbiAgICAgICAgICAgICAgICBsYWJlbDogbWVzc2FnZS5sYWJlbCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICAvLyBmb3IgdG9TdHJpbmdcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZS52YWx1ZTtcbiAgICAgICAgdGhpcy5zdGFjayA9IG1vbml0b3Iuc3RhY2tUcmFjZSgpO1xuICAgICAgICB0aGlzLm5hdGl2ZVN0YWNrID0gRXJyb3IoKS5zdGFjaztcbiAgICB9XG5cbiAgICB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgICAgICBsZXQgc3RyID0gdGhpcy5UeXBlICsgJzogJyArIHRoaXMubWVzc2FnZSArICdcXG4nICsgdGhpcy5zdGFjay50b1N0cmluZygpICsgJ1xcbicgKyB0aGlzLm5hdGl2ZVN0YWNrO1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbn0iLCJcbmltcG9ydCB7IExhYmVsLCBib3QgfSBmcm9tICcuLi9MYWJlbCc7XG5pbXBvcnQgeyBWYWx1ZSB9IGZyb20gXCIuLi9WYWx1ZVwiO1xuaW1wb3J0IHsgRWNtYU9iamVjdCB9IGZyb20gJy4uL09iamVjdHMvRWNtYU9iamVjdCc7XG5cbmltcG9ydCB7IE1vbml0b3JCYXNlIH0gZnJvbSAnLi4vTW9uaXRvckJhc2UnO1xuXG5kZWNsYXJlIHZhciBtb25pdG9yOiBNb25pdG9yQmFzZTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBOdW1iZXIgT2JqZWN0LCAxNS43LjVcblxuZXhwb3J0IGNsYXNzIE51bWJlck9iamVjdCBleHRlbmRzIEVjbWFPYmplY3Qge1xuXG4gICAgUHJpbWl0aXZlVmFsdWU6IE51bWJlcjtcbiAgICBQcmltaXRpdmVMYWJlbDogTGFiZWw7XG5cbiAgICBjb25zdHJ1Y3Rvcih2YWwgOiBhbnksIGxibCA6IExhYmVsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuQ2xhc3MgPSAnTnVtYmVyJztcbiAgICAgICAgdGhpcy5QcmltaXRpdmVWYWx1ZSA9IG5ldyBtb25pdG9yLmluc3RhbmNlcy5OdW1iZXJDb25zdHJ1Y3Rvci5ob3N0KHZhbCk7XG4gICAgICAgIHRoaXMuUHJpbWl0aXZlTGFiZWwgPSBsYmw7XG4gICAgICAgIHRoaXMuRXh0ZW5zaWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMuUHJvdG90eXBlID0gbmV3IFZhbHVlKG1vbml0b3IuaW5zdGFuY2VzLk51bWJlclByb3RvdHlwZSwgYm90KTtcbiAgICB9XG59XG5cbi8vIC0tLVxuXG5leHBvcnQgZnVuY3Rpb24gSXNOdW1iZXJPYmplY3QoeCA6IFZhbHVlPGFueT4pIDogeCBpcyBWYWx1ZTxOdW1iZXJPYmplY3Q+IHtcbiAgICByZXR1cm4gdHlwZW9mIHgudmFsdWUgPT09ICdvYmplY3QnICYmIHgudmFsdWUgIT09IG51bGwgJiYgeC52YWx1ZS5DbGFzcyA9PT0gJ051bWJlcic7XG59IiwiaW1wb3J0IHsgYm90IH0gZnJvbSAnLi4vTGFiZWwnO1xuaW1wb3J0IHsgVmFsdWUgfSBmcm9tIFwiLi4vVmFsdWVcIjtcbmltcG9ydCB7IEVjbWFPYmplY3QgfSBmcm9tICcuLi9PYmplY3RzL0VjbWFPYmplY3QnO1xuaW1wb3J0IHsgTW9uaXRvckJhc2UgfSBmcm9tICcuLi9Nb25pdG9yQmFzZSc7XG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmRlY2xhcmUgdmFyIG1vbml0b3I6IE1vbml0b3JCYXNlO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9iamVjdCBvYmplY3RzLCAxNS4yLjIuMVxuXG5leHBvcnQgY2xhc3MgT2JqZWN0T2JqZWN0IGV4dGVuZHMgRWNtYU9iamVjdCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuICBcbiAgICAgIHRoaXMuUHJvdG90eXBlID0gbmV3IFZhbHVlKG1vbml0b3IuaW5zdGFuY2VzLk9iamVjdFByb3RvdHlwZSwgYm90KTtcbiAgICAgIHRoaXMuQ2xhc3MgPSAnT2JqZWN0JztcbiAgICAgIHRoaXMuRXh0ZW5zaWJsZSA9IHRydWU7XG4gIFxuICAgICAgLy8gdGhpcy5ob3N0ICAgICAgPSB7fTtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIC0tLVxuICBcbiAgT2JqZWN0T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgcHJvcGVydGllcyA6IHN0cmluZ1tdID0gW107XG4gICAgZm9yIChsZXQgeCBpbiB0aGlzLnByb3BlcnRpZXMpIHtcbiAgICAgIGlmICh0aGlzLnByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoeCkpIHtcbiAgICAgICAgcHJvcGVydGllcy5wdXNoKHggKyAnOiAnICsgdGhpcy5wcm9wZXJ0aWVzW3hdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICd7JyArIHByb3BlcnRpZXMuam9pbignLCAnKSArICd9JztcbiAgfTtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICIsImltcG9ydCB7IE1vbml0b3JCYXNlIH0gZnJvbSAnLi4vTW9uaXRvckJhc2UnO1xuXG5pbXBvcnQgeyBOYXRpdmVFcnJvck9iamVjdCB9IGZyb20gJy4vTmF0aXZlRXJyb3JPYmplY3QnO1xuaW1wb3J0IHsgVmFsdWUgfSBmcm9tICcuLi9WYWx1ZSc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5kZWNsYXJlIHZhciBtb25pdG9yOiBNb25pdG9yQmFzZTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjbGFzcyBSYW5nZUVycm9yT2JqZWN0IGV4dGVuZHMgTmF0aXZlRXJyb3JPYmplY3Qge1xuICAgIFR5cGUgPSAnUmFuZ2VFcnJvcic7XG4gICAgXG4gICAgY29uc3RydWN0b3IodiA6IFZhbHVlPHN0cmluZz4pIHtcbiAgICAgICAgc3VwZXIobW9uaXRvci5pbnN0YW5jZXMuUmFuZ2VFcnJvclByb3RvdHlwZSwgdik7XG4gICAgfVxufSIsImltcG9ydCB7IE1vbml0b3JCYXNlIH0gZnJvbSAnLi4vTW9uaXRvckJhc2UnO1xuXG5pbXBvcnQgeyBOYXRpdmVFcnJvck9iamVjdCB9IGZyb20gJy4vTmF0aXZlRXJyb3JPYmplY3QnO1xuaW1wb3J0IHsgVmFsdWUgfSBmcm9tICcuLi9WYWx1ZSc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5kZWNsYXJlIHZhciBtb25pdG9yOiBNb25pdG9yQmFzZTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjbGFzcyBSZWZlcmVuY2VFcnJvck9iamVjdCBleHRlbmRzIE5hdGl2ZUVycm9yT2JqZWN0IHtcbiAgICBUeXBlID0gJ1JlZmVyZW5jZUVycm9yJztcblxuICAgIGNvbnN0cnVjdG9yKHYgOiBWYWx1ZTxzdHJpbmc+KSB7XG4gICAgICAgIHN1cGVyKG1vbml0b3IuaW5zdGFuY2VzLlJlZmVyZW5jZUVycm9yUHJvdG90eXBlLCB2KTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBWYWx1ZSB9IGZyb20gXCIuLi9WYWx1ZVwiO1xuaW1wb3J0ICogYXMgY29uc3RhbnRzIGZyb20gJy4uL0NvbnN0YW50cyc7XG5pbXBvcnQgKiBhcyBfIGZyb20gJ3VuZGVyc2NvcmUnO1xuaW1wb3J0IHsgTW9uaXRvckJhc2UgfSBmcm9tICcuLi9Nb25pdG9yQmFzZSc7XG5cbmltcG9ydCB7IGJvdCwgTGFiZWwgfSBmcm9tICcuLi9MYWJlbCc7XG5pbXBvcnQgeyBFY21hT2JqZWN0IH0gZnJvbSAnLi4vT2JqZWN0cy9FY21hT2JqZWN0JztcblxuZGVjbGFyZSB2YXIgbW9uaXRvcjogTW9uaXRvckJhc2U7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUmVnRXhwIE9iamVjdCwgMTUuMTAuNC4xXG5cbmV4cG9ydCBjbGFzcyBSZWdFeHBPYmplY3QgZXh0ZW5kcyBFY21hT2JqZWN0IHtcblxuICAgIFByaW1pdGl2ZVZhbHVlOiBSZWdFeHA7XG4gICAgUHJpbWl0aXZlTGFiZWw6IExhYmVsO1xuXG4gICAgY29uc3RydWN0b3IobmF0aXZlUmVnRXhwOiBSZWdFeHAsIGw6IExhYmVsKSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5DbGFzcyA9ICdSZWdFeHAnO1xuICAgICAgICB0aGlzLlByaW1pdGl2ZVZhbHVlID0gbmF0aXZlUmVnRXhwO1xuICAgICAgICB0aGlzLlByaW1pdGl2ZUxhYmVsID0gbDtcblxuICAgICAgICB0aGlzLkV4dGVuc2libGUgPSB0cnVlO1xuICAgICAgICB0aGlzLlByb3RvdHlwZSA9IG5ldyBWYWx1ZShtb25pdG9yLmluc3RhbmNlcy5SZWdFeHBQcm90b3R5cGUsIGJvdCk7XG5cbiAgICAgICAgdGhpcy5EZWZpbmVPd25Qcm9wZXJ0eShjb25zdGFudHMuc291cmNlLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLlByaW1pdGl2ZVZhbHVlLnNvdXJjZSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBsYWJlbDogbFxuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuRGVmaW5lT3duUHJvcGVydHkoY29uc3RhbnRzLmdsb2JhbCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5QcmltaXRpdmVWYWx1ZS5nbG9iYWwsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgbGFiZWw6IGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLkRlZmluZU93blByb3BlcnR5KGNvbnN0YW50cy5pZ25vcmVDYXNlLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLlByaW1pdGl2ZVZhbHVlLmlnbm9yZUNhc2UsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgbGFiZWw6IGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLkRlZmluZU93blByb3BlcnR5KGNvbnN0YW50cy5tdWx0aWxpbmUsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuUHJpbWl0aXZlVmFsdWUubXVsdGlsaW5lLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGxhYmVsOiBsXG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5EZWZpbmVPd25Qcm9wZXJ0eShjb25zdGFudHMubGFzdEluZGV4LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLlByaW1pdGl2ZVZhbHVlLmxhc3RJbmRleCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGxhYmVsOiBsXG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG5cblxuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICB2YXIgdiA9IHRoaXMuUHJpbWl0aXZlVmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gSXNSZWdFeHBPYmplY3QoeDogVmFsdWU8YW55Pik6IHggaXMgVmFsdWU8UmVnRXhwT2JqZWN0PiB7XG4gICAgcmV0dXJuIHR5cGVvZiB4LnZhbHVlID09PSAnb2JqZWN0JyAmJiB4LnZhbHVlICE9PSBudWxsICYmIHgudmFsdWUgIT09IHVuZGVmaW5lZCAmJiB4LnZhbHVlLkNsYXNzID09PSAnUmVnRXhwJztcbn0iLCJcbmltcG9ydCB7IFZhbHVlIH0gZnJvbSBcIi4uL1ZhbHVlXCI7XG5pbXBvcnQgeyBNb25pdG9yQmFzZSB9IGZyb20gJy4uL01vbml0b3JCYXNlJztcblxuaW1wb3J0IHsgRWNtYU9iamVjdCB9IGZyb20gJy4uL09iamVjdHMvRWNtYU9iamVjdCc7XG5pbXBvcnQgeyBib3QsIExhYmVsIH0gZnJvbSAnLi4vTGFiZWwnO1xuaW1wb3J0IHsgVmFsdWVUeXBlcyB9IGZyb20gXCIuLi9JbnRlcmZhY2VzXCI7XG5cbmRlY2xhcmUgdmFyIG1vbml0b3I6IE1vbml0b3JCYXNlO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFN0cmluZyBPYmplY3QsIDE1LjUuNVxuXG5leHBvcnQgY2xhc3MgU3RyaW5nT2JqZWN0IGV4dGVuZHMgRWNtYU9iamVjdCB7XG5cbiAgICBQcmltaXRpdmVWYWx1ZTogc3RyaW5nO1xuICAgIFByaW1pdGl2ZUxhYmVsOiBMYWJlbDtcblxuICAgIGNvbnN0cnVjdG9yKHZhbCA6IHN0cmluZywgbGJsPzogTGFiZWwpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5DbGFzcyA9ICdTdHJpbmcnO1xuICAgICAgICB0aGlzLlByaW1pdGl2ZVZhbHVlID0gdmFsO1xuXG4gICAgICAgIGxibCA9IGxibCB8fCBib3Q7XG4gICAgICAgIHRoaXMuUHJpbWl0aXZlTGFiZWwgPSBsYmw7XG5cbiAgICAgICAgLy8gVE9ETzogaG93IHRvIHNvbHZlIHRoaXMgdG8gd29yayB3aXRoIEVjbWFPYmplY3QgcHJvcGVybHlcbiAgICAgICAgLy9AdHMtaWdub3JlIFRZUEVTXG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IG5ldyBTdHJpbmcodmFsKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdGhpcy5sYWJlbHNbaV0gPSB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGxibCxcbiAgICAgICAgICAgICAgICBleGlzdGVuY2U6IGxibFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubGFiZWxzLmxlbmd0aCA9IHtcbiAgICAgICAgICAgIHZhbHVlOiBsYmwsXG4gICAgICAgICAgICBleGlzdGVuY2U6IGxibFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuRXh0ZW5zaWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMuUHJvdG90eXBlID0gbmV3IFZhbHVlKG1vbml0b3IuaW5zdGFuY2VzLlN0cmluZ1Byb3RvdHlwZSwgYm90KTtcblxuICAgICAgICAvLyBsZW5ndGggaXMgbm90IG1vZGVsZWQgaW4gdGhpcyB3YXksIGJ1dCBieSBHZXRPd25Qcm9wZXJ0eTsgaG93ZXZlciwgZS5nLixcbiAgICAgICAgLy8gZGVsZXRlIHdpbGwgdXNlIHRoZSBwcm9wZXJ0aWVzIGZpZWxkIGZvciBkZWxldGlvbi4gVGh1cywgd2UgYWRkIGEgZmFrZSBtb2RlbC5cbiAgICAgICAgLy8gICBlY21hLkRlZmluZUZGRih0aGlzLCBjb25zdGFudHMubGVuZ3RoLCAwKTtcblxuICAgIH1cbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gSXNTdHJpbmdPYmplY3QoeCA6IFZhbHVlPGFueT4pIDogeCBpcyBWYWx1ZTxTdHJpbmdPYmplY3Q+IHtcbiAgICByZXR1cm4gdHlwZW9mIHgudmFsdWUgPT09ICdvYmplY3QnICYmIHgudmFsdWUgIT09IG51bGwgJiYgeC52YWx1ZS5DbGFzcyA9PT0gJ1N0cmluZyc7XG59IiwiaW1wb3J0IHsgTW9uaXRvckJhc2UgfSBmcm9tICcuLi9Nb25pdG9yQmFzZSc7XG5cbmltcG9ydCB7IE5hdGl2ZUVycm9yT2JqZWN0IH0gZnJvbSAnLi9OYXRpdmVFcnJvck9iamVjdCc7XG5pbXBvcnQgeyBWYWx1ZSB9IGZyb20gJy4uL1ZhbHVlJztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmRlY2xhcmUgdmFyIG1vbml0b3I6IE1vbml0b3JCYXNlO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGNsYXNzIFN5bnRheEVycm9yT2JqZWN0IGV4dGVuZHMgTmF0aXZlRXJyb3JPYmplY3Qge1xuICAgIFR5cGUgPSAnU3ludGF4RXJyb3InO1xuXG4gICAgY29uc3RydWN0b3IodiA6IFZhbHVlPHN0cmluZz4pIHtcbiAgICAgICAgc3VwZXIobW9uaXRvci5pbnN0YW5jZXMuU3ludGF4RXJyb3JQcm90b3R5cGUsIHYpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IE1vbml0b3JCYXNlIH0gZnJvbSAnLi4vTW9uaXRvckJhc2UnO1xuXG5pbXBvcnQgeyBOYXRpdmVFcnJvck9iamVjdCB9IGZyb20gJy4vTmF0aXZlRXJyb3JPYmplY3QnO1xuaW1wb3J0IHsgVmFsdWUgfSBmcm9tICcuLi9WYWx1ZSc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5kZWNsYXJlIHZhciBtb25pdG9yOiBNb25pdG9yQmFzZTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjbGFzcyBUeXBlRXJyb3JPYmplY3QgZXh0ZW5kcyBOYXRpdmVFcnJvck9iamVjdCB7XG4gICAgVHlwZSA9ICdUeXBlRXJyb3InO1xuXG4gICAgY29uc3RydWN0b3IodiA6IFZhbHVlPHN0cmluZz4pIHtcbiAgICAgICAgc3VwZXIobW9uaXRvci5pbnN0YW5jZXMuVHlwZUVycm9yUHJvdG90eXBlLCB2KTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBNb25pdG9yQmFzZSB9IGZyb20gJy4uL01vbml0b3JCYXNlJztcblxuaW1wb3J0IHsgTmF0aXZlRXJyb3JPYmplY3QgfSBmcm9tICcuL05hdGl2ZUVycm9yT2JqZWN0JztcbmltcG9ydCB7IFZhbHVlIH0gZnJvbSAnLi4vVmFsdWUnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZGVjbGFyZSB2YXIgbW9uaXRvcjogTW9uaXRvckJhc2U7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgY2xhc3MgVVJJRXJyb3JPYmplY3QgZXh0ZW5kcyBOYXRpdmVFcnJvck9iamVjdCB7XG4gICAgVHlwZSA9ICdVUklFcnJvcic7XG5cbiAgICBjb25zdHJ1Y3Rvcih2IDogVmFsdWU8c3RyaW5nPikge1xuICAgICAgICBzdXBlcihtb25pdG9yLmluc3RhbmNlcy5VUklFcnJvclByb3RvdHlwZSwgdik7XG4gICAgfVxufVxuXG4iLCIvKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLiAqL1xuXG5pbXBvcnQgeyBNb25pdG9yQmFzZSB9IGZyb20gXCIuL01vbml0b3JCYXNlXCI7XG5cbiAvLyAtLS0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZGVjbGFyZSB2YXIgbW9uaXRvcjogTW9uaXRvckJhc2U7XG5cbi8vIC0tLSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbmV4cG9ydCB0eXBlIE9wdGlvblR5cGUgPSAnc3RyaW5nJyB8ICdib29sZWFuJyB8ICdudW1iZXInO1xuXG4gY2xhc3MgT3B0aW9uIHtcblxuICB0eXBlIDogT3B0aW9uVHlwZTtcbiAgZGVmIDogc3RyaW5nIHwgYm9vbGVhbiB8IG51bWJlcjtcbiAgdmFsdWUgOiBzdHJpbmcgfCBib29sZWFuIHwgbnVtYmVyO1xuICBkZXNjcmlwdGlvbiA6IHN0cmluZztcblxuXG4gIGNvbnN0cnVjdG9yKHR5cGUgOiBPcHRpb25UeXBlLCB2YWwgOiBzdHJpbmcgfCBib29sZWFuIHwgbnVtYmVyLCBkZXNjIDogc3RyaW5nKSB7XG5cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuc2V0KHZhbCk7XG4gICAgdGhpcy5kZWYgPSB0aGlzLnZhbHVlO1xuXG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2M7XG4gIH1cblxuICBzZXQodmFsIDogc3RyaW5nIHwgYm9vbGVhbiB8IG51bWJlcikgOiB2b2lkIHtcblxuICAgIHZhciB2ID0gU3RyaW5nKHZhbCk7XG5cbiAgICBpZiAodGhpcy50eXBlID09PSAnc3RyaW5nJykge1xuXG4gICAgICB0aGlzLnZhbHVlID0gdjtcblxuICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSAnYm9vbGVhbicpIHtcblxuICAgICAgdGhpcy52YWx1ZSA9IHYgPT09ICd0cnVlJyB8fCB2ID09PSAnMSc7XG5cbiAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gJ251bWJlcicpIHtcblxuICAgICAgdGhpcy52YWx1ZSA9IE51bWJlcih2KTtcblxuICAgIH1cbiAgfVxuXG4gIGdldERlZmF1bHQoKSA6IHN0cmluZyB8IGJvb2xlYW4gfCBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmRlZjtcbiAgfVxuXG4gIHZhbHVlT2YoKSA6IHN0cmluZyB8IGJvb2xlYW4gfCBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICB9XG5cbiAgdG9TdHJpbmcoKSA6IHN0cmluZyB7XG4gICAgcmV0dXJuIFN0cmluZyh0aGlzLnZhbHVlKTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPcHRpb25zXG5cbmV4cG9ydCBjbGFzcyBPcHRpb25zIHtcblxuICBvcHRpb25zIDoge1xuICAgIFtrZXk6c3RyaW5nXSA6IE9wdGlvbiB8IHVuZGVmaW5lZFxuICB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gIH1cblxuICBkZWNsYXJlKG5hbWUgOiBzdHJpbmcsIHR5cGUgOiBPcHRpb25UeXBlLCBkZWYgOiBzdHJpbmcgfCBib29sZWFuIHwgbnVtYmVyLCBkZXNjIDogc3RyaW5nKSB7XG4gICAgdmFyIGRlc2NyaXB0aW9uID0gZGVzYyA/IGRlc2MgOiBuYW1lO1xuICAgIHRoaXMub3B0aW9uc1tuYW1lXSA9IG5ldyBPcHRpb24odHlwZSwgZGVmLCBkZXNjcmlwdGlvbik7XG4gIH1cblxuICBoYXMobmFtZSA6IHN0cmluZykgOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zW25hbWVdICE9PSB1bmRlZmluZWQ7XG4gIH1cblxuICBnZXQobmFtZSA6IHN0cmluZykgOiBzdHJpbmcgfCBib29sZWFuIHwgbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zW25hbWVdLnZhbHVlT2YoKTtcbiAgfVxuXG4gIGdldE9wdGlvbihuYW1lIDogc3RyaW5nKSA6IE9wdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9uc1tuYW1lXTtcbiAgfVxuXG4gIHNldChuYW1lIDogc3RyaW5nLCB2YWx1ZSA6IHN0cmluZyB8IGJvb2xlYW4gfCBudW1iZXIpIHtcbiAgICB0aGlzLm9wdGlvbnNbbmFtZV0uc2V0KHZhbHVlKTtcbiAgfVxuXG4gIGtleXMoKSA6IEFycmF5PHN0cmluZz4ge1xuICAgIHZhciByZXMgPSBbXTtcblxuICAgIGZvciAodmFyIHggaW4gdGhpcy5vcHRpb25zKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhhc093blByb3BlcnR5KHgpKSB7XG4gICAgICAgIHJlcy5wdXNoKHgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgcmVwb3J0KCkgOiB2b2lkIHtcbiAgICBmb3IgKGxldCBuYW1lIGluIHRoaXMub3B0aW9ucykge1xuICAgICAgbW9uaXRvci5pbmZvKGAke25hbWV9IDogJHt0aGlzLm9wdGlvbnNbbmFtZV0udG9TdHJpbmcoKX1gKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uICovXG5cbiBpbXBvcnQgeyBnZW5lcmF0ZSB9IGZyb20gXCJlc2NvZGVnZW5cIjtcbiBleHBvcnQgdmFyIHByZXR0eSA9IGdlbmVyYXRlO1xuICIsImltcG9ydCB7IExhYmVsIH0gZnJvbSBcIi4vTGFiZWxcIjtcbmltcG9ydCB7IElFY21hRnVuY3Rpb24gfSBmcm9tIFwiLi9JbnRlcmZhY2VzXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGFiZWxlZFByb3BlcnR5RGVzY3JpcHRvciBleHRlbmRzIFByb3BlcnR5RGVzY3JpcHRvciB7XG4gIGxhYmVsOiBMYWJlbDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBKU0ZQcm9wZXJ0eURlc2NyaXB0b3Ige1xuICBjb25maWd1cmFibGU/OiBib29sZWFuO1xuICBlbnVtZXJhYmxlPzogYm9vbGVhbjtcbiAgdmFsdWU/OiBhbnk7XG4gIHdyaXRhYmxlPzogYm9vbGVhbjtcbiAgZ2V0PzogSUVjbWFGdW5jdGlvbjtcbiAgc2V0PzogSUVjbWFGdW5jdGlvbjtcbiAgbGFiZWw6IExhYmVsO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFByb3BlcnR5IGRlc2NyaXB0b3JzLCA4LjEwXG5cbmV4cG9ydCBmdW5jdGlvbiBJc0FjY2Vzc29yRGVzY3JpcHRvcihwZCkge1xuICBpZiAocGQgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKCdnZXQnIGluIHBkIHx8ICdwdXQnIGluIHBkKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gSXNEYXRhRGVzY3JpcHRvcihwZCkge1xuICBpZiAocGQgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKCd2YWx1ZScgaW4gcGQgfHwgJ3dyaXRhYmxlJyBpbiBwZCk7XG4gIH1cbn0iLCJcbmltcG9ydCB7IFZhbHVlIH0gZnJvbSBcIi4uL1ZhbHVlXCI7XG5pbXBvcnQgKiBhcyBjb25zdGFudHMgZnJvbSAnLi4vQ29uc3RhbnRzJztcbmltcG9ydCAqIGFzIF8gZnJvbSAndW5kZXJzY29yZSc7XG5pbXBvcnQgeyBCdWlsdGluRnVuY3Rpb25PYmplY3QgfSBmcm9tIFwiLi4vT2JqZWN0cy9CdWlsdGluRnVuY3Rpb25PYmplY3RcIjtcbmltcG9ydCB7IE1vbml0b3JCYXNlIH0gZnJvbSAnLi4vTW9uaXRvckJhc2UnO1xuXG5pbXBvcnQgeyBib3QsIGx1YiwgTGFiZWwgfSBmcm9tICcuLi9MYWJlbCc7XG5pbXBvcnQgeyBEZWZpbmUsIERlZmluZVRGVCwgRGVmaW5lVEZGIH0gZnJvbSAnLi4vRGVmaW5lJztcbmltcG9ydCB7IEVjbWFPYmplY3QgfSBmcm9tICcuLi9PYmplY3RzL0VjbWFPYmplY3QnO1xuXG5pbXBvcnQgeyBBcnJheU9iamVjdCB9IGZyb20gJy4uL09iamVjdHMvQXJyYXlPYmplY3QnO1xuaW1wb3J0IHsgVG9Cb29sZWFuIH0gZnJvbSAnLi4vQ29udmVyc2lvbi9Ub0Jvb2xlYW4nO1xuaW1wb3J0IHsgVG9JbnRlZ2VyIH0gZnJvbSAnLi4vQ29udmVyc2lvbi9Ub0ludGVnZXInO1xuaW1wb3J0IHsgVG9TdHJpbmcgfSBmcm9tICcuLi9Db252ZXJzaW9uL1RvU3RyaW5nJztcbmltcG9ydCB7IFRvT2JqZWN0IH0gZnJvbSAnLi4vQ29udmVyc2lvbi9Ub09iamVjdCc7XG5pbXBvcnQgeyBJc0NhbGxhYmxlIH0gZnJvbSAnLi4vVXRpbGl0eS9Jc0NhbGxhYmxlJztcbmltcG9ydCB7IFRvVUludDMyIH0gZnJvbSAnLi4vQ29udmVyc2lvbi9Ub1VJbnQzMic7XG5pbXBvcnQgeyBWYWx1ZVR5cGVzIH0gZnJvbSBcIi4uL0ludGVyZmFjZXNcIjtcbmltcG9ydCB7IGV4ZWMgfSBmcm9tIFwiY2hpbGRfcHJvY2Vzc1wiO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZGVjbGFyZSB2YXIgbW9uaXRvcjogTW9uaXRvckJhc2U7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gMTUuNC40XG5leHBvcnQgY2xhc3MgQXJyYXlQcm90b3R5cGUgZXh0ZW5kcyBFY21hT2JqZWN0IHtcblxuICAgIGhvc3Q6IEFycmF5PGFueT47XG5cbiAgICBjb25zdHJ1Y3Rvcihob3N0OiBBcnJheTxhbnk+KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuQ2xhc3MgPSAnQXJyYXknO1xuXG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgfVxuXG4gICAgU2V0dXAoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuUHJvdG90eXBlID0gbmV3IFZhbHVlKG1vbml0b3IuaW5zdGFuY2VzLk9iamVjdFByb3RvdHlwZSwgYm90KTtcblxuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLmNvbnN0cnVjdG9yLCBtb25pdG9yLmluc3RhbmNlcy5BcnJheUNvbnN0cnVjdG9yKTtcbiAgICAgICAgRGVmaW5lVEZGKHRoaXMsIGNvbnN0YW50cy5sZW5ndGgsIDApO1xuXG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMudG9TdHJpbmcsIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3QodG9TdHJpbmcsIDAsIEFycmF5LnByb3RvdHlwZS50b1N0cmluZykpO1xuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLnRvTG9jYWxlU3RyaW5nLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHRvTG9jYWxlU3RyaW5nLCAwLCBBcnJheS5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcpKTtcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5jb25jYXQsIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3QoY29uY2F0LCAxLCBBcnJheS5wcm90b3R5cGUuY29uY2F0KSk7XG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuam9pbiwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChqb2luLCAxLCBBcnJheS5wcm90b3R5cGUuam9pbikpO1xuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLnBvcCwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChwb3AsIDAsIEFycmF5LnByb3RvdHlwZS5wb3ApKTtcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5wdXNoLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHB1c2gsIDEsIEFycmF5LnByb3RvdHlwZS5wdXNoKSk7XG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMucmV2ZXJzZSwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChyZXZlcnNlLCAwLCBBcnJheS5wcm90b3R5cGUucmV2ZXJzZSkpO1xuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLnNoaWZ0LCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHNoaWZ0LCAwLCBBcnJheS5wcm90b3R5cGUuc2hpZnQpKTtcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5zbGljZSwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChzbGljZSwgMiwgQXJyYXkucHJvdG90eXBlLnNsaWNlKSk7XG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuc29ydCwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChzb3J0LCAxLCBBcnJheS5wcm90b3R5cGUuc29ydCkpO1xuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLnNwbGljZSwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChzcGxpY2UsIDIsIEFycmF5LnByb3RvdHlwZS5zcGxpY2UpKTtcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy51bnNoaWZ0LCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHVuc2hpZnQsIDEsIEFycmF5LnByb3RvdHlwZS51bnNoaWZ0KSk7XG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuaW5kZXhPZiwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChpbmRleE9mLCAxLCBBcnJheS5wcm90b3R5cGUuaW5kZXhPZikpO1xuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLmxhc3RJbmRleE9mLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KGxhc3RJbmRleE9mLCAxLCBBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YpKTtcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5ldmVyeSwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChldmVyeSwgMSwgQXJyYXkucHJvdG90eXBlLmV2ZXJ5KSk7XG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuc29tZSwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChzb21lLCAxLCBBcnJheS5wcm90b3R5cGUuc29tZSkpO1xuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLmZvckVhY2gsIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3QoZm9yRWFjaCwgMSwgQXJyYXkucHJvdG90eXBlLmZvckVhY2gpKTtcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5tYXAsIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3QobWFwLCAxLCBBcnJheS5wcm90b3R5cGUubWFwKSk7XG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuZmlsdGVyLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KGZpbHRlciwgMSwgQXJyYXkucHJvdG90eXBlLmZpbHRlcikpO1xuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLnJlZHVjZSwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChyZWR1Y2UsIDEsIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UpKTtcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5yZWR1Y2VSaWdodCwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChyZWR1Y2VSaWdodCwgMSwgQXJyYXkucHJvdG90eXBlLnJlZHVjZVJpZ2h0KSk7XG5cbiAgICB9XG5cbn1cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdG9TdHJpbmcsIDE1LjQuNC4yXG5cbmZ1bmN0aW9uIHRvU3RyaW5nKHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8c3RyaW5nPiB7XG4gICAgbGV0IGFycmF5ID0gVG9PYmplY3QodGhpc0FyZyk7XG4gICAgbGV0IGZ1bmMgPSBhcnJheS5HZXQoY29uc3RhbnRzLmpvaW4pO1xuXG4gICAgaWYgKCFJc0NhbGxhYmxlKGZ1bmMpKSB7XG4gICAgICAgIGZ1bmMgPSBtb25pdG9yLmluc3RhbmNlcy5PYmplY3RQcm90b3R5cGUuR2V0KGNvbnN0YW50cy50b1N0cmluZyk7XG4gICAgfVxuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiBmdW5jLnZhbHVlLkNhbGwoYXJyYXksIFtdKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyB0b0xvY2FsZVN0cmluZywgMTUuNC40LjNcbmZ1bmN0aW9uIHRvTG9jYWxlU3RyaW5nKHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8c3RyaW5nPiB7XG5cbiAgICBsZXQgYXJyYXkgPSBUb09iamVjdCh0aGlzQXJnKTtcbiAgICBsZXQgYXJyYXlMZW4gPSBhcnJheS5HZXQobmV3IFZhbHVlKFwibGVuZ3RoXCIsIGJvdCkpO1xuICAgIGxldCBsZW4gPSBUb1VJbnQzMihhcnJheUxlbik7XG4gICAgbGV0IHNlcGFyYXRvciA9ICcsJztcblxuICAgIGxldCBsYWJlbCA9IGx1Yihtb25pdG9yLmNvbnRleHQuZWZmZWN0aXZlUEMsIGFycmF5LmxhYmVsKTtcblxuICAgIGlmIChsZW4udmFsdWUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZShcIlwiLCBsYWJlbCk7XG4gICAgfVxuXG4gICAgbGV0IGZpcnN0RWxlbWVudCA9IGFycmF5LkdldChuZXcgVmFsdWUoXCIwXCIsIGJvdCkpO1xuICAgIGxldCBSOiBWYWx1ZTxWYWx1ZVR5cGVzPjtcblxuICAgIGlmIChmaXJzdEVsZW1lbnQudmFsdWUgPT09IHVuZGVmaW5lZCB8fCBmaXJzdEVsZW1lbnQudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgUiA9IG5ldyBWYWx1ZShcIlwiLCBsYWJlbCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgZWxlbWVudE9iaiA9IFRvT2JqZWN0KGZpcnN0RWxlbWVudCk7XG4gICAgICAgIGxldCBmdW5jID0gZWxlbWVudE9iai5HZXQobmV3IFZhbHVlKFwidG9Mb2NhbGVTdHJpbmdcIiwgYm90KSk7XG5cbiAgICAgICAgaWYgKCFJc0NhbGxhYmxlKGZ1bmMpKSB7XG4gICAgICAgICAgICBtb25pdG9yLlRocm93KFxuICAgICAgICAgICAgICAgIFwiVHlwZUVycm9yXCIsXG4gICAgICAgICAgICAgICAgJ0FycmF5LnByb3RvdHlwZS50b0xvY2FsZVN0cmluZzogbm90IGEgZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgIGJvdFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRocm93ICdUeXBlU2NyaXB0OydcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVTNiBzdGFuZGFyZCBpcyBkb2luZyB0aGlzLCBhbmQgRVM1IHNob3VsZCBiZSBhYmxlIHRvIGhhbmRsZSBpdFxuICAgICAgICBSID0gVG9TdHJpbmcoZnVuYy52YWx1ZS5DYWxsKGVsZW1lbnRPYmosIFtdKSk7XG4gICAgfVxuXG4gICAgbGV0IGsgPSAxO1xuICAgIHdoaWxlIChrIDwgbGVuLnZhbHVlKSB7XG4gICAgICAgIC8vQHRzLWlnbm9yZSBUWVBFU1xuICAgICAgICBsZXQgUyA9IFIudmFsdWUuY29uY2F0KHNlcGFyYXRvcik7XG5cbiAgICAgICAgbGV0IG5leHRFbGVtZW50ID0gYXJyYXkuR2V0KG5ldyBWYWx1ZSgnJyArIGssIGJvdCkpO1xuXG4gICAgICAgIGlmIChuZXh0RWxlbWVudC52YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IGZpcnN0RWxlbWVudC52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgUiA9IG5ldyBWYWx1ZShcIlwiLCBsYWJlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZWxlbWVudE9iaiA9IFRvT2JqZWN0KG5leHRFbGVtZW50KTtcbiAgICAgICAgICAgIGxldCBmdW5jID0gZWxlbWVudE9iai5HZXQobmV3IFZhbHVlKFwidG9Mb2NhbGVTdHJpbmdcIiwgYm90KSk7XG5cbiAgICAgICAgICAgIGlmICghSXNDYWxsYWJsZShmdW5jKSkge1xuICAgICAgICAgICAgICAgIG1vbml0b3IuVGhyb3coXG4gICAgICAgICAgICAgICAgICAgIFwiVHlwZUVycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgICdBcnJheS5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmc6IG5vdCBhIGZ1bmN0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgYm90XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB0aHJvdyAnVHlwZVNjcmlwdDsnXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEVTNiBzdGFuZGFyZCBpcyBkb2luZyB0aGlzLCBhbmQgRVM1IHNob3VsZCBiZSBhYmxlIHRvIGhhbmRsZSBpdFxuICAgICAgICAgICAgUiA9IFRvU3RyaW5nKGZ1bmMudmFsdWUuQ2FsbChlbGVtZW50T2JqLCBbXSkpO1xuICAgICAgICB9XG4gICAgICAgIFIgPSBuZXcgVmFsdWUoUy5jb25jYXQoUi52YWx1ZSksIFIubGFiZWwpO1xuICAgICAgICBrKys7XG4gICAgfVxuXG4gICAgUi5yYWlzZShsYWJlbCk7XG4gICAgLy9AdHMtaWdub3JlIFRZUEVTXG4gICAgcmV0dXJuIFI7XG59XG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBjb25jYXQsIDE1LjQuNC40XG5mdW5jdGlvbiBjb25jYXQodGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxBcnJheU9iamVjdD4ge1xuICAgIGxldCBPID0gVG9PYmplY3QodGhpc0FyZyk7XG4gICAgbGV0IEEgPSBuZXcgQXJyYXlPYmplY3QoKTtcblxuICAgIGxldCBuID0gMDtcbiAgICBsZXQgYyA9IG1vbml0b3IuY29udGV4dDtcbiAgICBsZXQgbGFiZWwgPSBuZXcgTGFiZWwoKTtcblxuICAgIGZ1bmN0aW9uIGF1eChFKSB7XG4gICAgICAgIGMucHVzaFBDKEUubGFiZWwpO1xuXG4gICAgICAgIGxhYmVsID0gbHViKGxhYmVsLCBFLmxhYmVsKTtcblxuICAgICAgICBpZiAoRS52YWx1ZSAmJiBFLnZhbHVlLkNsYXNzID09PSAnQXJyYXknKSB7XG4gICAgICAgICAgICBsZXQgayA9IDA7XG4gICAgICAgICAgICBsZXQgbGVuID0gRS5HZXQoY29uc3RhbnRzLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIGxhYmVsID0gbHViKGxhYmVsLCBsZW4ubGFiZWwpO1xuXG4gICAgICAgICAgICBtb25pdG9yLmNvbnRleHQucHVzaFBDKGxlbi5sYWJlbCk7XG5cbiAgICAgICAgICAgIHdoaWxlIChrIDwgbGVuLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbGV0IF9rID0gbmV3IFZhbHVlKGssIGJvdCk7XG4gICAgICAgICAgICAgICAgbGV0IGV4aXN0cyA9IEUuSGFzUHJvcGVydHkoX2spO1xuXG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0cy52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBtb25pdG9yLmNvbnRleHQucHVzaFBDKGV4aXN0cy5sYWJlbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHN1YkVsZW1lbnQgPSBFLkdldChfayk7XG5cbiAgICAgICAgICAgICAgICAgICAgQS5EZWZpbmVPd25Qcm9wZXJ0eShuZXcgVmFsdWUobiwgbGFiZWwpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc3ViRWxlbWVudC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBzdWJFbGVtZW50LmxhYmVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0sIGZhbHNlKTtcblxuICAgICAgICAgICAgICAgICAgICBtb25pdG9yLmNvbnRleHQucG9wUEMoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBuKys7XG4gICAgICAgICAgICAgICAgaysrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtb25pdG9yLmNvbnRleHQucG9wUEMoKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgQS5EZWZpbmVPd25Qcm9wZXJ0eShuZXcgVmFsdWUobiwgbGFiZWwpLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IEUudmFsdWUsXG4gICAgICAgICAgICAgICAgbGFiZWw6IEUubGFiZWwsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgICAgIG4rKztcbiAgICAgICAgfVxuXG4gICAgICAgIGMucG9wUEMoKTtcbiAgICB9XG5cbiAgICBhdXgoTyk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGFyZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgYXV4KGFyZ3NbaV0pO1xuICAgIH1cblxuICAgIC8vIFRoaXMgaXMgYSBmaXggdGhleSBhZGRlZCBpbiBFQ01BLTI2MiB2NiBzdGFuZGFyZCwgYnV0IGJyb3dzZXJzIHVzZWQgaXRcbiAgICAvLyBpbiBFQ01BLTI2MiB2NSBhcyB3ZWxsLlxuICAgIEEuUHV0KG5ldyBWYWx1ZShcImxlbmd0aFwiLCBib3QpLCBuZXcgVmFsdWUobiwgYm90KSwgZmFsc2UpO1xuXG4gICAgcmV0dXJuIG5ldyBWYWx1ZShBLCBib3QpO1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBqb2luLCAxNS40LjQuNVxuXG5mdW5jdGlvbiBqb2luKHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8c3RyaW5nPiB7XG4gICAgbGV0IE8gPSBUb09iamVjdCh0aGlzQXJnKTtcbiAgICBsZXQgbGVuID0gVG9VSW50MzIoTy5HZXQoY29uc3RhbnRzLmxlbmd0aCkpO1xuXG4gICAgbGV0IGFyZzAgPSBhcmdzWzBdIHx8IG5ldyBWYWx1ZSgnLCcsIGJvdCk7XG4gICAgbGV0IHNlcGFyYXRvcjogVmFsdWU8c3RyaW5nPjtcblxuICAgIGlmIChhcmcwLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc2VwYXJhdG9yID0gbmV3IFZhbHVlKCcsJywgYXJnMC5sYWJlbCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzZXBhcmF0b3IgPSBUb1N0cmluZyhhcmcwKTtcbiAgICB9XG5cbiAgICBsZXQgbGFiZWwgPSBsdWIobGVuLmxhYmVsLCBzZXBhcmF0b3IubGFiZWwpO1xuICAgIGxldCBhcnI6IHN0cmluZ1tdID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW4udmFsdWU7IGkrKykge1xuXG4gICAgICAgIGxldCB2ID0gTy5HZXQobmV3IFZhbHVlKGksIGJvdCkpO1xuICAgICAgICBsZXQgeTogVmFsdWU8c3RyaW5nPjtcbiAgICAgICAgaWYgKHYudmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2LnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICB5ID0gbmV3IFZhbHVlKCcnLCB2LmxhYmVsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHkgPSBUb1N0cmluZyh2KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFycltpXSA9IHkudmFsdWU7XG5cbiAgICAgICAgbGFiZWwgPSBsdWIobGFiZWwsIHkubGFiZWwpO1xuICAgIH1cblxuICAgIGxldCByZXMgPSBhcnIuam9pbihzZXBhcmF0b3IudmFsdWUpO1xuICAgIHJldHVybiBuZXcgVmFsdWUocmVzLCBsYWJlbCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gcG9wLCAxNS40LjQuNlxuXG5mdW5jdGlvbiBwb3AodGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxWYWx1ZVR5cGVzPiB7XG4gICAgbGV0IE8gPSBUb09iamVjdCh0aGlzQXJnKTtcbiAgICBsZXQgbGVuID0gVG9VSW50MzIoTy5HZXQoY29uc3RhbnRzLmxlbmd0aCkpO1xuXG4gICAgaWYgKGxlbi52YWx1ZSA9PT0gMCkge1xuICAgICAgICBPLlB1dChjb25zdGFudHMubGVuZ3RoLCBsZW4sIHRydWUpO1xuICAgICAgICByZXR1cm4gbmV3IFZhbHVlKHVuZGVmaW5lZCwgbGVuLmxhYmVsKTtcbiAgICB9XG5cbiAgICBsZXQgaW5keCA9IG5ldyBWYWx1ZShsZW4udmFsdWUgLSAxLCBsZW4ubGFiZWwpO1xuICAgIGxldCBlbGVtZW50ID0gTy5HZXQoaW5keCk7XG5cbiAgICBPLkRlbGV0ZShpbmR4LCB0cnVlKTtcblxuICAgIE8uUHV0KGNvbnN0YW50cy5sZW5ndGgsIGluZHgsIHRydWUpO1xuICAgIHJldHVybiBlbGVtZW50O1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHB1c2gsIDE1LjQuNC43XG5cbmZ1bmN0aW9uIHB1c2godGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxudW1iZXI+IHtcbiAgICBsZXQgTyA9IFRvT2JqZWN0KHRoaXNBcmcpO1xuICAgIGxldCBuID0gVG9VSW50MzIoTy5HZXQoY29uc3RhbnRzLmxlbmd0aCkpO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGFyZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbGV0IEUgPSBhcmdzW2ldO1xuICAgICAgICBPLlB1dChuLCBFKTtcbiAgICAgICAgbi52YWx1ZSsrO1xuICAgIH1cblxuICAgIE8uUHV0KGNvbnN0YW50cy5sZW5ndGgsIG4sIHRydWUpO1xuXG4gICAgcmV0dXJuIG47XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gcmV2ZXJzZSwgMTUuNC40LjhcblxuZnVuY3Rpb24gcmV2ZXJzZSh0aGlzQXJnOiBWYWx1ZTxWYWx1ZVR5cGVzPiwgYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPEVjbWFPYmplY3Q+IHtcbiAgICBsZXQgTyA9IFRvT2JqZWN0KHRoaXNBcmcpO1xuICAgIGxldCBsZW4gPSBUb1VJbnQzMihPLkdldChjb25zdGFudHMubGVuZ3RoKSk7XG5cbiAgICBsZXQgbWlkZGxlID0gTWF0aC5mbG9vcihsZW4udmFsdWUgLyAyKTtcbiAgICBsZXQgbG93ZXIgPSAwO1xuXG4gICAgbGV0IGMgPSBtb25pdG9yLmNvbnRleHQ7XG5cbiAgICB3aGlsZSAobG93ZXIgIT09IG1pZGRsZSAmJiBsb3dlciA+IC0yKSB7XG4gICAgICAgIGxldCB1cHBlciA9IGxlbi52YWx1ZSAtIGxvd2VyIC0gMTtcblxuICAgICAgICBsZXQgdXBwZXJQID0gVG9TdHJpbmcobmV3IFZhbHVlKHVwcGVyLCBsZW4ubGFiZWwpKTtcbiAgICAgICAgbGV0IGxvd2VyUCA9IFRvU3RyaW5nKG5ldyBWYWx1ZShsb3dlciwgbGVuLmxhYmVsKSk7XG5cbiAgICAgICAgbGV0IGxvd2VyVmFsdWUgPSBPLkdldChsb3dlclApO1xuICAgICAgICBsZXQgdXBwZXJWYWx1ZSA9IE8uR2V0KHVwcGVyUCk7XG4gICAgICAgIGxldCBsb3dlckV4aXN0cyA9IE8uSGFzUHJvcGVydHkobG93ZXJQKTtcbiAgICAgICAgbGV0IHVwcGVyRXhpc3RzID0gTy5IYXNQcm9wZXJ0eSh1cHBlclApO1xuXG4gICAgICAgIGMucHVzaFBDKGx1Yihsb3dlckV4aXN0cy5sYWJlbCwgdXBwZXJFeGlzdHMubGFiZWwsIGxlbi5sYWJlbCkpO1xuXG4gICAgICAgIGlmIChsb3dlckV4aXN0cy52YWx1ZSAmJiB1cHBlckV4aXN0cy52YWx1ZSkge1xuICAgICAgICAgICAgTy5QdXQobG93ZXJQLCB1cHBlclZhbHVlLCB0cnVlKTtcbiAgICAgICAgICAgIE8uUHV0KHVwcGVyUCwgbG93ZXJWYWx1ZSwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWxvd2VyRXhpc3RzLnZhbHVlICYmIHVwcGVyRXhpc3RzLnZhbHVlKSB7XG4gICAgICAgICAgICBPLlB1dChsb3dlclAsIHVwcGVyVmFsdWUsIHRydWUpO1xuICAgICAgICAgICAgTy5EZWxldGUodXBwZXJQLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChsb3dlckV4aXN0cy52YWx1ZSAmJiAhdXBwZXJFeGlzdHMudmFsdWUpIHtcbiAgICAgICAgICAgIE8uRGVsZXRlKGxvd2VyUCwgdHJ1ZSk7XG4gICAgICAgICAgICBPLlB1dCh1cHBlclAsIGxvd2VyVmFsdWUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGMucG9wUEMoKTtcbiAgICAgICAgbG93ZXIrKztcbiAgICB9XG5cbiAgICByZXR1cm4gTztcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBzaGlmdCwgMTUuNC40LjlcblxuZnVuY3Rpb24gc2hpZnQodGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxWYWx1ZVR5cGVzPiB7XG4gICAgbGV0IE8gPSBUb09iamVjdCh0aGlzQXJnKTtcbiAgICBsZXQgbGVuVmFsID0gTy5HZXQoY29uc3RhbnRzLmxlbmd0aCk7XG4gICAgbGV0IGxlbiA9IFRvVUludDMyKGxlblZhbCk7XG5cbiAgICBpZiAobGVuLnZhbHVlID09PSAwKSB7XG4gICAgICAgIG1vbml0b3IuY29udGV4dC5wdXNoUEMobGVuLmxhYmVsKTtcbiAgICAgICAgTy5QdXQoY29uc3RhbnRzLmxlbmd0aCwgbGVuLCB0cnVlKTtcbiAgICAgICAgbW9uaXRvci5jb250ZXh0LnBvcFBDKCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZSh1bmRlZmluZWQsIGxlbi5sYWJlbCk7XG4gICAgfVxuXG4gICAgbGV0IGZpcnN0ID0gTy5HZXQobmV3IFZhbHVlKDAsIGJvdCkpO1xuICAgIGxldCBrID0gMTtcblxuICAgIG1vbml0b3IuY29udGV4dC5wdXNoUEMobGVuLmxhYmVsKTtcblxuICAgIHdoaWxlIChrIDwgbGVuLnZhbHVlKSB7XG5cbiAgICAgICAgbGV0IGZyb20gPSBrO1xuICAgICAgICBsZXQgX2Zyb20gPSBuZXcgVmFsdWUoZnJvbSwgbGVuLmxhYmVsKTtcbiAgICAgICAgbGV0IHRvID0gayAtIDE7XG4gICAgICAgIGxldCBfdG8gPSBuZXcgVmFsdWUodG8sIGxlbi5sYWJlbCk7XG5cbiAgICAgICAgbGV0IGZyb21QcmVzZW50ID0gTy5IYXNQcm9wZXJ0eShfZnJvbSk7XG5cbiAgICAgICAgaWYgKGZyb21QcmVzZW50LnZhbHVlKSB7XG4gICAgICAgICAgICBtb25pdG9yLmNvbnRleHQucHVzaFBDKGZyb21QcmVzZW50LmxhYmVsKTtcblxuICAgICAgICAgICAgbGV0IGZyb21WYWwgPSBPLkdldChfZnJvbSk7XG4gICAgICAgICAgICBPLlB1dChfdG8sIGZyb21WYWwsIHRydWUpO1xuXG4gICAgICAgICAgICBtb25pdG9yLmNvbnRleHQucG9wUEMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIE8uRGVsZXRlKF90bywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaysrO1xuICAgIH1cbiAgICBtb25pdG9yLmNvbnRleHQucG9wUEMoKTtcblxuICAgIGxlbi52YWx1ZS0tO1xuICAgIE8uRGVsZXRlKGxlbiwgdHJ1ZSk7XG4gICAgTy5QdXQoY29uc3RhbnRzLmxlbmd0aCwgbGVuLCB0cnVlKTtcblxuICAgIHJldHVybiBmaXJzdDtcbn1cblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHNsaWNlLCAxNS40LjQuMTBcblxuZnVuY3Rpb24gc2xpY2UodGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxBcnJheU9iamVjdD4ge1xuICAgIGxldCBPID0gVG9PYmplY3QodGhpc0FyZyk7XG4gICAgbGV0IEEgPSBuZXcgQXJyYXlPYmplY3QoKTtcblxuICAgIGxldCBsZW5WYWwgPSBPLkdldChjb25zdGFudHMubGVuZ3RoKTtcbiAgICBsZXQgbGVuID0gVG9VSW50MzIobGVuVmFsKTtcblxuICAgIGxldCBzdGFydCA9IGFyZ3NbMF0gPyBhcmdzWzBdIDogbmV3IFZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgICBsZXQgZW5kID0gYXJnc1sxXSA/IGFyZ3NbMV0gOiBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuXG4gICAgbGV0IHJlbGF0aXZlU3RhcnQgPSBUb0ludGVnZXIoc3RhcnQpO1xuXG4gICAgbGV0IGsgPSBuZXcgVmFsdWUoMCwgbHViKGxlbi5sYWJlbCwgcmVsYXRpdmVTdGFydC5sYWJlbCkpO1xuXG4gICAgaWYgKHJlbGF0aXZlU3RhcnQudmFsdWUgPCAwKSB7XG4gICAgICAgIGsudmFsdWUgPSBNYXRoLm1heChsZW4udmFsdWUgKyByZWxhdGl2ZVN0YXJ0LnZhbHVlLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBrLnZhbHVlID0gTWF0aC5taW4ocmVsYXRpdmVTdGFydC52YWx1ZSwgbGVuLnZhbHVlKTtcbiAgICB9XG5cbiAgICBsZXQgcmVsYXRpdmVFbmQgOiBWYWx1ZTxudW1iZXI+O1xuICAgIGlmIChlbmQudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZWxhdGl2ZUVuZCA9IGxlbjtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZWxhdGl2ZUVuZCA9IFRvSW50ZWdlcihlbmQpO1xuICAgIH1cblxuICAgIGxldCBfZmluYWwgPSBuZXcgVmFsdWUoMCwgbHViKGxlbi5sYWJlbCwgcmVsYXRpdmVTdGFydC5sYWJlbCkpO1xuXG4gICAgaWYgKHJlbGF0aXZlRW5kLnZhbHVlIDwgMCkge1xuICAgICAgICBfZmluYWwudmFsdWUgPSBNYXRoLm1heChsZW4udmFsdWUgKyByZWxhdGl2ZUVuZC52YWx1ZSwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgX2ZpbmFsLnZhbHVlID0gTWF0aC5taW4ocmVsYXRpdmVFbmQudmFsdWUsIGxlbi52YWx1ZSk7XG4gICAgfVxuXG4gICAgbGV0IG4gPSAwO1xuXG4gICAgbW9uaXRvci5jb250ZXh0LnB1c2hQQyhsdWIoay5sYWJlbCwgX2ZpbmFsLmxhYmVsKSk7XG5cbiAgICB3aGlsZSAoay52YWx1ZSA8IF9maW5hbC52YWx1ZSkge1xuICAgICAgICBsZXQgUGsgPSBUb1N0cmluZyhrKTtcbiAgICAgICAgbGV0IGtQcmVzZW50ID0gTy5IYXNQcm9wZXJ0eShQayk7XG4gICAgICAgIGlmIChrUHJlc2VudC52YWx1ZSkge1xuICAgICAgICAgICAgbGV0IGtWYWx1ZSA9IE8uR2V0KFBrKTtcbiAgICAgICAgICAgIEEuRGVmaW5lT3duUHJvcGVydHkobmV3IFZhbHVlKG4sIGJvdCksIHtcbiAgICAgICAgICAgICAgICB2YWx1ZToga1ZhbHVlLnZhbHVlLFxuICAgICAgICAgICAgICAgIGxhYmVsOiBrVmFsdWUubGFiZWwsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBrLnZhbHVlKys7XG4gICAgICAgIG4rKztcbiAgICB9XG5cbiAgICBtb25pdG9yLmNvbnRleHQucG9wUEMoKTtcbiAgICByZXR1cm4gbmV3IFZhbHVlKEEsIGJvdCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc29ydCwgMTUuNC40LjExXG5cbmZ1bmN0aW9uIHNvcnQodGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxFY21hT2JqZWN0PiB7XG4gICAgbGV0IGNvbXBhcmVmdW4gPSBhcmdzWzBdIHx8IG5ldyBWYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG5cbiAgICBsZXQgTyA9IFRvT2JqZWN0KHRoaXNBcmcpO1xuICAgIGxldCBsZW5WYWwgPSBPLkdldChjb25zdGFudHMubGVuZ3RoKTtcbiAgICBsZXQgbGVuID0gVG9VSW50MzIobGVuVmFsKTtcblxuICAgIGxldCBsYWJlbCA9IGx1YihPLmxhYmVsLCBsZW4ubGFiZWwpO1xuXG4gICAgbGV0IGMgPSBtb25pdG9yLmNvbnRleHQ7XG4gICAgYy5wdXNoUEMobGVuLmxhYmVsKTtcblxuICAgIGxldCBhcnJheSA6IFZhbHVlPFZhbHVlVHlwZXM+W10gPSBbXTtcbiAgICBsZXQgayA9IG5ldyBWYWx1ZSgwLCBsZW4ubGFiZWwpO1xuICAgIHdoaWxlIChrLnZhbHVlIDwgbGVuLnZhbHVlKSB7XG4gICAgICAgIGxldCBrUHJlc2VudCA9IE8uSGFzUHJvcGVydHkoayk7XG5cbiAgICAgICAgYy5sYWJlbHMucGMgPSBsdWIoYy5sYWJlbHMucGMsIGtQcmVzZW50LmxhYmVsKTtcbiAgICAgICAgbGFiZWwgPSBsdWIobGFiZWwsIGtQcmVzZW50LmxhYmVsKTtcblxuICAgICAgICBpZiAoa1ByZXNlbnQudmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBrVmFsdWUgPSBPLkdldChrKTtcbiAgICAgICAgICAgIGtWYWx1ZS5yYWlzZShsYWJlbCk7XG5cbiAgICAgICAgICAgIGFycmF5W2sudmFsdWVdID0ga1ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGsudmFsdWUrKztcbiAgICB9XG5cbiAgICBsZXQgaXNDYWxsYWJsZSA9IElzQ2FsbGFibGUoY29tcGFyZWZ1bik7XG4gICAgYy5sYWJlbHMucGMgPSBsdWIoYy5sYWJlbHMucGMsIGNvbXBhcmVmdW4ubGFiZWwpO1xuXG4gICAgaWYgKGNvbXBhcmVmdW4udmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhaXNDYWxsYWJsZSkge1xuICAgICAgICBtb25pdG9yLlRocm93KFxuICAgICAgICAgICAgXCJUeXBlRXJyb3JcIixcbiAgICAgICAgICAgICdBcnJheS5wcm90b3R5cGUuc29ydDogbm90IGEgZnVuY3Rpb24nLFxuICAgICAgICAgICAgYm90XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgbGV0IGNvbXBhcmVmdW5XcmFwcGVyIDogKHggOiBWYWx1ZTxWYWx1ZVR5cGVzPiwgeSA6IFZhbHVlPFZhbHVlVHlwZXM+KSA9PiBWYWx1ZVR5cGVzO1xuICAgIGlmIChjb21wYXJlZnVuLnZhbHVlKSB7XG5cbiAgICAgICAgY29tcGFyZWZ1bldyYXBwZXIgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgaWYgKHgudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxhYmVsID0gbHViKGxhYmVsLCB4LmxhYmVsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5LnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsYWJlbCA9IGx1YihsYWJlbCwgeS5sYWJlbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGNvbXBhcmVmdW4uQ2FsbChuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpLCBbeCwgeV0pO1xuICAgICAgICAgICAgYy5sYWJlbHMucGMgPSBsdWIoYy5sYWJlbHMucGMsIHJlc3VsdC5sYWJlbCwgeC5sYWJlbCwgeS5sYWJlbCk7XG4gICAgICAgICAgICBsYWJlbCA9IGx1YihsYWJlbCwgcmVzdWx0LmxhYmVsLCB4LmxhYmVsLCB5LmxhYmVsKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gICAgICAgIH07XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIGNvbXBhcmVmdW5XcmFwcGVyID0gZnVuY3Rpb24gKHgsIHkpIHtcblxuICAgICAgICAgICAgaWYgKHgudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxhYmVsID0gbHViKGxhYmVsLCB4LmxhYmVsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5LnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsYWJlbCA9IGx1YihsYWJlbCwgeS5sYWJlbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgeFN0cmluZyA9IFRvU3RyaW5nKHgpO1xuICAgICAgICAgICAgbGV0IHlTdHJpbmcgPSBUb1N0cmluZyh5KTtcblxuICAgICAgICAgICAgYy5sYWJlbHMucGMgPSBsdWIoYy5sYWJlbHMucGMsIHhTdHJpbmcubGFiZWwsIHlTdHJpbmcubGFiZWwpO1xuICAgICAgICAgICAgbGFiZWwgPSBsdWIobGFiZWwsIHhTdHJpbmcubGFiZWwsIHlTdHJpbmcubGFiZWwpO1xuXG4gICAgICAgICAgICBpZiAoeFN0cmluZy52YWx1ZSA8IHlTdHJpbmcudmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh4U3RyaW5nLnZhbHVlID4geVN0cmluZy52YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfTtcblxuICAgIH1cbiAgICAvL0B0cy1pZ25vcmUgVFlQRVNcbiAgICBhcnJheSA9IGFycmF5LnNvcnQoY29tcGFyZWZ1bldyYXBwZXIpO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGxldCB2ID0gYXJyYXlbaV07XG5cbiAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgIE8uUHV0KG5ldyBWYWx1ZShpLCBsYWJlbCksIHYsIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgTy5EZWxldGUobmV3IFZhbHVlKGksIGxhYmVsKSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjLnBvcFBDKCk7XG4gICAgcmV0dXJuIE87XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc3BsaWNlLCAxNS40LjQuMTJcbmZ1bmN0aW9uIHNwbGljZSh0aGlzQXJnOiBWYWx1ZTxWYWx1ZVR5cGVzPiwgYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPFZhbHVlVHlwZXM+IHtcblxuICAgIGxldCBzdGFydCA9IGFyZ3NbMF0gfHwgbmV3IFZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgICBsZXQgYXJnMSA9IGFyZ3NbMV0gfHwgbmV3IFZhbHVlKHVuZGVmaW5lZCwgYm90KTtcblxuICAgIGxldCBPID0gVG9PYmplY3QodGhpc0FyZyk7XG4gICAgbGV0IEEgPSBuZXcgQXJyYXlPYmplY3QoKTtcblxuICAgIGxldCBsZW5WYWwgPSBPLkdldChjb25zdGFudHMubGVuZ3RoKTtcbiAgICBsZXQgbGVuID0gVG9VSW50MzIobGVuVmFsKTtcblxuICAgIGxldCByZWxhdGl2ZVN0YXJ0ID0gVG9JbnRlZ2VyKHN0YXJ0KTtcbiAgICBsZXQgYWN0dWFsU3RhcnQgOiBWYWx1ZTxudW1iZXIgfCBudWxsPiA9IG5ldyBWYWx1ZShudWxsLCBsdWIobGVuLmxhYmVsLCByZWxhdGl2ZVN0YXJ0LmxhYmVsKSk7XG5cbiAgICBpZiAocmVsYXRpdmVTdGFydC52YWx1ZSA8IDApIHtcbiAgICAgICAgYWN0dWFsU3RhcnQudmFsdWUgPSBNYXRoLm1heCgobGVuLnZhbHVlICsgcmVsYXRpdmVTdGFydC52YWx1ZSksIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdHVhbFN0YXJ0LnZhbHVlID0gTWF0aC5taW4ocmVsYXRpdmVTdGFydC52YWx1ZSwgbGVuLnZhbHVlKTtcbiAgICB9XG5cbiAgICBsZXQgZGVsZXRlQ291bnQgPSBUb0ludGVnZXIoYXJnMSk7XG4gICAgbGV0IGFjdHVhbERlbGV0ZUNvdW50IDogVmFsdWU8bnVtYmVyIHwgbnVsbD4gPSBuZXcgVmFsdWUobnVsbCwgbHViKGRlbGV0ZUNvdW50LmxhYmVsLCBhY3R1YWxTdGFydC5sYWJlbCkpO1xuICAgIGFjdHVhbERlbGV0ZUNvdW50LnZhbHVlID0gTWF0aC5taW4oTWF0aC5tYXgoZGVsZXRlQ291bnQudmFsdWUsIDApLCBsZW4udmFsdWUgLSBhY3R1YWxTdGFydC52YWx1ZSk7XG5cbiAgICBsZXQgayA9IDA7XG4gICAgbW9uaXRvci5jb250ZXh0LnB1c2hQQyhhY3R1YWxEZWxldGVDb3VudC5sYWJlbCk7XG4gICAgd2hpbGUgKGsgPCBhY3R1YWxEZWxldGVDb3VudC52YWx1ZSkge1xuICAgICAgICBsZXQgZnJvbSA9IG5ldyBWYWx1ZShhY3R1YWxTdGFydC52YWx1ZSArIGssIGFjdHVhbFN0YXJ0LmxhYmVsKTtcbiAgICAgICAgbGV0IGZyb21QcmVzZW50ID0gTy5IYXNQcm9wZXJ0eShmcm9tKTtcblxuICAgICAgICBtb25pdG9yLmNvbnRleHQucHVzaFBDKGZyb21QcmVzZW50LmxhYmVsKTtcbiAgICAgICAgaWYgKGZyb21QcmVzZW50LnZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgZnJvbVZhbHVlID0gTy5HZXQoZnJvbSk7XG4gICAgICAgICAgICBBLkRlZmluZU93blByb3BlcnR5KG5ldyBWYWx1ZShrLCBhY3R1YWxEZWxldGVDb3VudC5sYWJlbCksIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZnJvbVZhbHVlLnZhbHVlLFxuICAgICAgICAgICAgICAgIGxhYmVsOiBmcm9tVmFsdWUubGFiZWwsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgbW9uaXRvci5jb250ZXh0LnBvcFBDKCk7XG5cbiAgICAgICAgaysrO1xuICAgIH1cbiAgICBtb25pdG9yLmNvbnRleHQucG9wUEMoKTtcblxuICAgIGxldCBpdGVtcyA6IFZhbHVlPFZhbHVlVHlwZXM+W10gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgIGl0ZW1zW2ldID0gYXJnc1tpICsgMl07XG4gICAgfVxuXG4gICAgbGV0IGl0ZW1Db3VudCA9IGl0ZW1zLmxlbmd0aDtcbiAgICBpZiAoaXRlbUNvdW50IDwgYWN0dWFsRGVsZXRlQ291bnQudmFsdWUpIHtcbiAgICAgICAgbGV0IGsgPSBhY3R1YWxTdGFydC52YWx1ZTtcblxuICAgICAgICBtb25pdG9yLmNvbnRleHQucHVzaFBDKGFjdHVhbFN0YXJ0LmxhYmVsKTtcblxuICAgICAgICB3aGlsZSAoayA8IGxlbi52YWx1ZSAtIGFjdHVhbERlbGV0ZUNvdW50LnZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IG5ldyBWYWx1ZShrICsgYWN0dWFsRGVsZXRlQ291bnQudmFsdWUsIGx1YihhY3R1YWxTdGFydC5sYWJlbCwgYWN0dWFsRGVsZXRlQ291bnQubGFiZWwpKTtcbiAgICAgICAgICAgIGxldCB0byA9IG5ldyBWYWx1ZShrICsgaXRlbUNvdW50LCBhY3R1YWxTdGFydC5sYWJlbCk7XG4gICAgICAgICAgICBsZXQgZnJvbVByZXNlbnQgPSBPLkhhc1Byb3BlcnR5KGZyb20pO1xuXG4gICAgICAgICAgICBtb25pdG9yLmNvbnRleHQucHVzaFBDKGZyb21QcmVzZW50LmxhYmVsKTtcblxuICAgICAgICAgICAgaWYgKGZyb21QcmVzZW50LnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb21WYWx1ZSA9IE8uR2V0KGZyb20pO1xuICAgICAgICAgICAgICAgIE8uUHV0KHRvLCBmcm9tVmFsdWUsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBPLkRlbGV0ZSh0bywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGsrKztcblxuICAgICAgICAgICAgbW9uaXRvci5jb250ZXh0LnBvcFBDKCk7XG4gICAgICAgIH1cblxuICAgICAgICBtb25pdG9yLmNvbnRleHQucG9wUEMoKTtcblxuICAgICAgICBrID0gbGVuLnZhbHVlO1xuXG4gICAgICAgIG1vbml0b3IuY29udGV4dC5wdXNoUEMobHViKGxlbi5sYWJlbCwgYWN0dWFsRGVsZXRlQ291bnQubGFiZWwpKTtcblxuICAgICAgICB3aGlsZSAoayA+IChsZW4udmFsdWUgLSBhY3R1YWxEZWxldGVDb3VudC52YWx1ZSArIGl0ZW1Db3VudCkpIHtcbiAgICAgICAgICAgIE8uRGVsZXRlKG5ldyBWYWx1ZShrLCBsZW4ubGFiZWwpKTtcbiAgICAgICAgICAgIGstLTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1vbml0b3IuY29udGV4dC5wb3BQQygpO1xuXG4gICAgfSBlbHNlIGlmIChpdGVtQ291bnQgPiBhY3R1YWxEZWxldGVDb3VudC52YWx1ZSkge1xuXG4gICAgICAgIGxldCBrID0gbGVuLnZhbHVlIC0gYWN0dWFsRGVsZXRlQ291bnQudmFsdWU7XG5cbiAgICAgICAgbW9uaXRvci5jb250ZXh0LnB1c2hQQyhsdWIobGVuLmxhYmVsLCBhY3R1YWxEZWxldGVDb3VudC5sYWJlbCkpO1xuXG4gICAgICAgIHdoaWxlIChrID4gYWN0dWFsU3RhcnQudmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gbmV3IFZhbHVlKGsgKyBhY3R1YWxEZWxldGVDb3VudC52YWx1ZSAtIDEsIGFjdHVhbERlbGV0ZUNvdW50LmxhYmVsKTtcbiAgICAgICAgICAgIGxldCB0byA9IG5ldyBWYWx1ZShrICsgaXRlbUNvdW50IC0gMSwgYm90KTtcbiAgICAgICAgICAgIGxldCBmcm9tUHJlc2VudCA9IE8uSGFzUHJvcGVydHkoZnJvbSk7XG5cblxuICAgICAgICAgICAgaWYgKGZyb21QcmVzZW50LnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb21WYWx1ZSA9IE8uR2V0KGZyb20pO1xuICAgICAgICAgICAgICAgIE8uUHV0KHRvLCBmcm9tVmFsdWUsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBPLkRlbGV0ZSh0bywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrLS07XG4gICAgICAgIH1cblxuICAgICAgICBtb25pdG9yLmNvbnRleHQucG9wUEMoKTtcblxuICAgIH1cblxuICAgIGsgPSBhY3R1YWxTdGFydC52YWx1ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIE8uUHV0KG5ldyBWYWx1ZShrICsgaSwgYWN0dWFsU3RhcnQubGFiZWwpLCBpdGVtc1tpXSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgTy5QdXQoY29uc3RhbnRzLmxlbmd0aCwgbmV3IFZhbHVlKGxlbi52YWx1ZSAtIGFjdHVhbERlbGV0ZUNvdW50LnZhbHVlICsgaXRlbUNvdW50LCBsdWIobGVuLmxhYmVsLCBhY3R1YWxEZWxldGVDb3VudC5sYWJlbCkpLCB0cnVlKTtcbiAgICByZXR1cm4gbmV3IFZhbHVlKEEsIGJvdCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdW5zaGlmdCwgMTUuNC40LjEzXG5cbmZ1bmN0aW9uIHVuc2hpZnQodGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxudW1iZXI+IHtcbiAgICBsZXQgTyA9IFRvT2JqZWN0KHRoaXNBcmcpO1xuICAgIGxldCBsZW5WYWwgPSBPLkdldChjb25zdGFudHMubGVuZ3RoKTtcbiAgICBsZXQgbGVuID0gVG9VSW50MzIobGVuVmFsKTtcbiAgICBsZXQgYXJnQ291bnQgPSBhcmdzLmxlbmd0aDtcbiAgICBsZXQgayA9IGxlbi52YWx1ZTtcblxuICAgIG1vbml0b3IuY29udGV4dC5wdXNoUEMobGVuLmxhYmVsKTtcbiAgICB3aGlsZSAoayA+IDApIHtcbiAgICAgICAgbGV0IGZyb20gPSBuZXcgVmFsdWUoayAtIDEsIGxlbi5sYWJlbCk7XG4gICAgICAgIGxldCB0byA9IG5ldyBWYWx1ZShrICsgYXJnQ291bnQgLSAxLCBsZW4ubGFiZWwpO1xuICAgICAgICBsZXQgZnJvbVByZXNlbnQgPSBPLkhhc1Byb3BlcnR5KGZyb20pO1xuXG4gICAgICAgIG1vbml0b3IuY29udGV4dC5wdXNoUEMoZnJvbVByZXNlbnQubGFiZWwpO1xuICAgICAgICBpZiAoZnJvbVByZXNlbnQudmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBmcm9tVmFsdWUgPSBPLkdldChmcm9tKTtcbiAgICAgICAgICAgIE8uUHV0KHRvLCBmcm9tVmFsdWUsIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgTy5EZWxldGUodG8sIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIG1vbml0b3IuY29udGV4dC5wb3BQQygpO1xuXG4gICAgICAgIGstLTtcbiAgICB9XG4gICAgbW9uaXRvci5jb250ZXh0LnBvcFBDKCk7XG5cbiAgICBsZXQgaiA9IDA7XG4gICAgbGV0IGl0ZW1zID0gYXJncztcbiAgICBmb3IgKDsgaiA8IGFyZ0NvdW50OyBqKyspIHtcbiAgICAgICAgbGV0IEUgPSBpdGVtc1tqXTtcbiAgICAgICAgTy5QdXQobmV3IFZhbHVlKGosIGJvdCksIEUsIHRydWUpO1xuICAgIH1cblxuICAgIE8uUHV0KGNvbnN0YW50cy5sZW5ndGgsIG5ldyBWYWx1ZShsZW4udmFsdWUgKyBhcmdDb3VudCwgbGVuLmxhYmVsKSk7XG4gICAgcmV0dXJuIG5ldyBWYWx1ZShsZW4udmFsdWUgKyBhcmdDb3VudCwgbGVuLmxhYmVsKTtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gaW5kZXhPZiwgMTUuNC40LjE0XG5cbmZ1bmN0aW9uIGluZGV4T2YodGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxudW1iZXI+IHtcbiAgICBsZXQgc2VhcmNoRWxlbWVudCA9IGFyZ3NbMF0gfHwgbmV3IFZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgICBsZXQgZnJvbUluZGV4ID0gYXJnc1sxXTtcblxuICAgIGxldCBPID0gVG9PYmplY3QodGhpc0FyZyk7XG4gICAgbGV0IGxlblZhbCA9IE8uR2V0KGNvbnN0YW50cy5sZW5ndGgpO1xuICAgIGxldCBsZW4gPSBUb1VJbnQzMihsZW5WYWwpO1xuXG4gICAgbGV0IGMgPSBtb25pdG9yLmNvbnRleHQ7XG5cbiAgICBpZiAobGVuLnZhbHVlID09PSAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmFsdWUoLTEsIGxlbi5sYWJlbCk7XG4gICAgfVxuXG4gICAgbGV0IGxhYmVsID0gbHViKGxlbi5sYWJlbCk7XG4gICAgYy5wdXNoUEMobGVuLmxhYmVsKTtcblxuICAgIGxldCBuID0gZnJvbUluZGV4ID8gVG9JbnRlZ2VyKGZyb21JbmRleCkgOiBuZXcgVmFsdWUoMCwgYm90KTtcblxuICAgIGMubGFiZWxzLnBjID0gbHViKGMubGFiZWxzLnBjLCBuLmxhYmVsKTtcbiAgICBsYWJlbCA9IGx1YihsYWJlbCwgbi5sYWJlbCk7XG5cbiAgICBpZiAobi52YWx1ZSA+PSBsZW4udmFsdWUpIHtcbiAgICAgICAgYy5wb3BQQygpO1xuICAgICAgICByZXR1cm4gbmV3IFZhbHVlKC0xLCBsYWJlbCk7XG4gICAgfVxuXG4gICAgbGV0IGsgOiBWYWx1ZTxudW1iZXI+O1xuICAgIGlmIChuLnZhbHVlID49IDApIHtcbiAgICAgICAgayA9IG47XG4gICAgfSBlbHNlIHtcbiAgICAgICAgayA9IG5ldyBWYWx1ZShsZW4udmFsdWUgLSBNYXRoLmFicyhuLnZhbHVlKSwgbHViKGxlbi5sYWJlbCwgbi5sYWJlbCkpO1xuICAgICAgICBpZiAoay52YWx1ZSA8IDApIHtcbiAgICAgICAgICAgIGsudmFsdWUgPSAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgd2hpbGUgKGsudmFsdWUgPCBsZW4udmFsdWUpIHtcbiAgICAgICAgbGV0IGtTdHJpbmcgPSBUb1N0cmluZyhrKTtcbiAgICAgICAgbGV0IGtQcmVzZW50ID0gTy5IYXNQcm9wZXJ0eShrU3RyaW5nKTtcblxuICAgICAgICBjLmxhYmVscy5wYyA9IGx1YihjLmxhYmVscy5wYywga1ByZXNlbnQubGFiZWwpO1xuICAgICAgICBsYWJlbCA9IGx1YihsYWJlbCwga1ByZXNlbnQubGFiZWwpO1xuXG4gICAgICAgIGlmIChrUHJlc2VudC52YWx1ZSkge1xuICAgICAgICAgICAgbGV0IGVsZW1lbnRLID0gTy5HZXQoa1N0cmluZyk7XG5cbiAgICAgICAgICAgIGMubGFiZWxzLnBjID0gbHViKGMubGFiZWxzLnBjLCBlbGVtZW50Sy5sYWJlbCk7XG4gICAgICAgICAgICBsYWJlbCA9IGx1YihsYWJlbCwgZWxlbWVudEsubGFiZWwpO1xuXG4gICAgICAgICAgICBsZXQgc2FtZSA9IHNlYXJjaEVsZW1lbnQudmFsdWUgPT09IGVsZW1lbnRLLnZhbHVlO1xuXG4gICAgICAgICAgICBpZiAoc2FtZSkge1xuICAgICAgICAgICAgICAgIGsubGFiZWwgPSBsYWJlbDtcbiAgICAgICAgICAgICAgICBjLnBvcFBDKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBrLnZhbHVlKys7XG4gICAgfVxuXG4gICAgYy5wb3BQQygpO1xuICAgIGsudmFsdWUgPSAtMTtcbiAgICBrLmxhYmVsID0gbGFiZWw7XG4gICAgcmV0dXJuIGs7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gbGFzdEluZGV4T2YsIDE1LjQuNC4xNVxuXG5mdW5jdGlvbiBsYXN0SW5kZXhPZih0aGlzQXJnOiBWYWx1ZTxWYWx1ZVR5cGVzPiwgYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPG51bWJlcj4ge1xuICAgIGxldCBzZWFyY2hFbGVtZW50ID0gYXJnc1swXSB8fCBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgIGxldCBmcm9tSW5kZXggPSBhcmdzWzFdO1xuXG4gICAgbGV0IE8gPSBUb09iamVjdCh0aGlzQXJnKTtcbiAgICBsZXQgbGVuVmFsID0gTy5HZXQoY29uc3RhbnRzLmxlbmd0aCk7XG4gICAgbGV0IGxlbiA9IFRvVUludDMyKGxlblZhbCk7XG5cbiAgICBsZXQgYyA9IG1vbml0b3IuY29udGV4dDtcblxuICAgIGlmIChsZW4udmFsdWUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZSgtMSwgbGVuLmxhYmVsKTtcbiAgICB9XG5cbiAgICBsZXQgbGFiZWwgPSBsdWIobGVuLmxhYmVsKTtcblxuICAgIGMucHVzaFBDKGxlbi5sYWJlbCk7XG5cbiAgICBsZXQgbiA9IGZyb21JbmRleCA/IFRvSW50ZWdlcihmcm9tSW5kZXgpIDogbmV3IFZhbHVlKGxlbi52YWx1ZSAtIDEsIGxlbi5sYWJlbCk7XG5cbiAgICBsZXQgayA6IFZhbHVlPG51bWJlcj47XG4gICAgaWYgKG4udmFsdWUgPj0gMCkge1xuICAgICAgICBrID0gbmV3IFZhbHVlKE1hdGgubWluKG4udmFsdWUsIGxlbi52YWx1ZSAtIDEpLCBsdWIobi5sYWJlbCwgbGVuLmxhYmVsKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgayA9IG5ldyBWYWx1ZShsZW4udmFsdWUgLSBNYXRoLmFicyhuLnZhbHVlKSwgbHViKG4ubGFiZWwsIGxlbi5sYWJlbCkpO1xuICAgIH1cblxuICAgIGMubGFiZWxzLnBjID0gbHViKGMubGFiZWxzLnBjLCBrLmxhYmVsKTtcbiAgICBsYWJlbCA9IGx1YihsYWJlbCwgay5sYWJlbCk7XG5cbiAgICB3aGlsZSAoay52YWx1ZSA+PSAwKSB7XG4gICAgICAgIGxldCBrUHJlc2VudCA9IE8uSGFzUHJvcGVydHkoayk7XG4gICAgICAgIGMubGFiZWxzLnBjID0gbHViKGMubGFiZWxzLnBjLCBrUHJlc2VudC5sYWJlbCk7XG4gICAgICAgIGxhYmVsID0gbHViKGxhYmVsLCBrUHJlc2VudC5sYWJlbCk7XG5cbiAgICAgICAgaWYgKGtQcmVzZW50LnZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgZWxlbWVudEsgPSBPLkdldChrKTtcblxuICAgICAgICAgICAgYy5sYWJlbHMucGMgPSBsdWIoYy5sYWJlbHMucGMsIGVsZW1lbnRLLmxhYmVsKTtcbiAgICAgICAgICAgIGxhYmVsID0gbHViKGxhYmVsLCBlbGVtZW50Sy5sYWJlbCk7XG5cbiAgICAgICAgICAgIGxldCBzYW1lID0gc2VhcmNoRWxlbWVudC52YWx1ZSA9PT0gZWxlbWVudEsudmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChzYW1lKSB7XG4gICAgICAgICAgICAgICAgay5sYWJlbCA9IGxhYmVsO1xuICAgICAgICAgICAgICAgIGMucG9wUEMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBrLnZhbHVlLS07XG4gICAgfVxuXG4gICAgYy5wb3BQQygpO1xuXG4gICAgay52YWx1ZSA9IC0xO1xuICAgIGsubGFiZWwgPSBsYWJlbDtcbiAgICByZXR1cm4gaztcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBldmVyeSwgMTUuNC40LjE2XG5cbmZ1bmN0aW9uIGV2ZXJ5KHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8Ym9vbGVhbj4ge1xuICAgIGxldCBjYWxsYmFja2ZuID0gYXJnc1swXSB8fCBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgIGxldCBjYWxsYmFja3RoaXNBcmcgPSBhcmdzWzFdIHx8IG5ldyBWYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG5cbiAgICBsZXQgTyA9IFRvT2JqZWN0KHRoaXNBcmcpO1xuICAgIGxldCBsZW5WYWwgPSBPLkdldChjb25zdGFudHMubGVuZ3RoKTtcbiAgICBsZXQgbGVuID0gVG9VSW50MzIobGVuVmFsKTtcblxuICAgIGxldCBjID0gbW9uaXRvci5jb250ZXh0O1xuICAgIGxldCBpc0NhbGxhYmxlID0gSXNDYWxsYWJsZShjYWxsYmFja2ZuKTtcblxuICAgIGxldCBsYWJlbCA9IGx1YihjYWxsYmFja2ZuLmxhYmVsKTtcblxuICAgIGMucHVzaFBDKGNhbGxiYWNrZm4ubGFiZWwpO1xuXG4gICAgaWYgKCFpc0NhbGxhYmxlKSB7XG4gICAgICAgIG1vbml0b3IuVGhyb3coXG4gICAgICAgICAgICBcIlR5cGVFcnJvclwiLFxuICAgICAgICAgICAgJ0FycmF5LnByb3RvdHlwZS5ldmVyeTogbm90IGEgZnVuY3Rpb24nLFxuICAgICAgICAgICAgYm90XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgbGV0IGsgPSBuZXcgVmFsdWUoMCwgbGVuLmxhYmVsKTtcbiAgICBjLmxhYmVscy5wYyA9IGx1YihjLmxhYmVscy5wYywgbGVuLmxhYmVsKTtcbiAgICBsYWJlbCA9IGx1YihsYWJlbCwgbGVuLmxhYmVsKTtcbiAgICB3aGlsZSAoay52YWx1ZSA8IGxlbi52YWx1ZSkge1xuICAgICAgICBsZXQga1ByZXNlbnQgPSBPLkhhc1Byb3BlcnR5KGspO1xuICAgICAgICBjLmxhYmVscy5wYyA9IGx1YihjLmxhYmVscy5wYywga1ByZXNlbnQubGFiZWwpO1xuICAgICAgICBsYWJlbCA9IGx1YihsYWJlbCwga1ByZXNlbnQubGFiZWwpO1xuXG4gICAgICAgIGlmIChrUHJlc2VudC52YWx1ZSkge1xuICAgICAgICAgICAgbGV0IGtWYWx1ZSA9IE8uR2V0KGspO1xuICAgICAgICAgICAgbGV0IHRlc3RSZXN1bHQgPSBjYWxsYmFja2ZuLkNhbGwoY2FsbGJhY2t0aGlzQXJnLCBba1ZhbHVlLCBrLCBPXSk7XG4gICAgICAgICAgICBsZXQgYiA9IFRvQm9vbGVhbih0ZXN0UmVzdWx0KTtcbiAgICAgICAgICAgIGMubGFiZWxzLnBjID0gbHViKGMubGFiZWxzLnBjLCBiLmxhYmVsKTtcbiAgICAgICAgICAgIGxhYmVsID0gbHViKGxhYmVsLCBiLmxhYmVsKTtcblxuICAgICAgICAgICAgaWYgKCFiLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYy5wb3BQQygpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmFsdWUoZmFsc2UsIGxhYmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBrLnZhbHVlKys7XG4gICAgfVxuXG4gICAgYy5wb3BQQygpO1xuICAgIHJldHVybiBuZXcgVmFsdWUodHJ1ZSwgbGFiZWwpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHNvbWUsIDE1LjQuNC4xN1xuXG5mdW5jdGlvbiBzb21lKHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8Ym9vbGVhbj4ge1xuICAgIGxldCBjYWxsYmFja2ZuID0gYXJnc1swXSB8fCBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgIGxldCBjYWxsYmFja3RoaXNBcmcgPSBhcmdzWzFdIHx8IG5ldyBWYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG5cbiAgICBsZXQgTyA9IFRvT2JqZWN0KHRoaXNBcmcpO1xuICAgIGxldCBsZW5WYWwgPSBPLkdldChjb25zdGFudHMubGVuZ3RoKTtcbiAgICBsZXQgbGVuID0gVG9VSW50MzIobGVuVmFsKTtcblxuICAgIGxldCBjID0gbW9uaXRvci5jb250ZXh0O1xuICAgIGxldCBpc0NhbGxhYmxlID0gSXNDYWxsYWJsZShjYWxsYmFja2ZuKTtcblxuICAgIGxldCBsYWJlbCA9IGx1YihjYWxsYmFja2ZuLmxhYmVsKTtcblxuICAgIGMucHVzaFBDKGNhbGxiYWNrZm4ubGFiZWwpO1xuXG4gICAgaWYgKCFpc0NhbGxhYmxlKSB7XG4gICAgICAgIG1vbml0b3IuVGhyb3coXG4gICAgICAgICAgICBcIlR5cGVFcnJvclwiLFxuICAgICAgICAgICAgJ0FycmF5LnByb3RvdHlwZS5ldmVyeTogbm90IGEgZnVuY3Rpb24nLFxuICAgICAgICAgICAgYm90XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgbGV0IGsgPSBuZXcgVmFsdWUoMCwgbGVuLmxhYmVsKTtcbiAgICBjLmxhYmVscy5wYyA9IGx1YihjLmxhYmVscy5wYywgbGVuLmxhYmVsKTtcbiAgICBsYWJlbCA9IGx1YihsYWJlbCwgbGVuLmxhYmVsKTtcbiAgICB3aGlsZSAoay52YWx1ZSA8IGxlbi52YWx1ZSkge1xuICAgICAgICBsZXQga1ByZXNlbnQgPSBPLkhhc1Byb3BlcnR5KGspO1xuICAgICAgICBjLmxhYmVscy5wYyA9IGx1YihjLmxhYmVscy5wYywga1ByZXNlbnQubGFiZWwpO1xuICAgICAgICBsYWJlbCA9IGx1YihsYWJlbCwga1ByZXNlbnQubGFiZWwpO1xuXG4gICAgICAgIGlmIChrUHJlc2VudC52YWx1ZSkge1xuICAgICAgICAgICAgbGV0IGtWYWx1ZSA9IE8uR2V0KGspO1xuICAgICAgICAgICAgbGV0IHRlc3RSZXN1bHQgPSBjYWxsYmFja2ZuLkNhbGwoY2FsbGJhY2t0aGlzQXJnLCBba1ZhbHVlLCBrLCBPXSk7XG4gICAgICAgICAgICBsZXQgYiA9IFRvQm9vbGVhbih0ZXN0UmVzdWx0KTtcbiAgICAgICAgICAgIGMubGFiZWxzLnBjID0gbHViKGMubGFiZWxzLnBjLCBiLmxhYmVsKTtcbiAgICAgICAgICAgIGxhYmVsID0gbHViKGxhYmVsLCBiLmxhYmVsKTtcblxuICAgICAgICAgICAgaWYgKGIudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjLnBvcFBDKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZSh0cnVlLCBsYWJlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgay52YWx1ZSsrO1xuICAgIH1cblxuICAgIGMucG9wUEMoKTtcbiAgICByZXR1cm4gbmV3IFZhbHVlKGZhbHNlLCBsYWJlbCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gZm9yRWFjaCwgMTUuNC40LjE4XG5cbmZ1bmN0aW9uIGZvckVhY2godGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTx1bmRlZmluZWQ+IHtcbiAgICBsZXQgY2FsbGJhY2tmbiA9IGFyZ3NbMF0gfHwgbmV3IFZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgICBsZXQgY2FsbGJhY2t0aGlzQXJnID0gYXJnc1sxXSB8fCBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuXG4gICAgbGV0IE8gPSBUb09iamVjdCh0aGlzQXJnKTtcbiAgICBsZXQgbGVuVmFsID0gTy5HZXQoY29uc3RhbnRzLmxlbmd0aCk7XG4gICAgbGV0IGxlbiA9IFRvVUludDMyKGxlblZhbCk7XG5cbiAgICBsZXQgYyA9IG1vbml0b3IuY29udGV4dDtcbiAgICBsZXQgaXNDYWxsYWJsZSA9IElzQ2FsbGFibGUoY2FsbGJhY2tmbik7XG5cbiAgICBjLnB1c2hQQyhjYWxsYmFja2ZuLmxhYmVsKTtcblxuICAgIGlmICghaXNDYWxsYWJsZSkge1xuICAgICAgICBtb25pdG9yLlRocm93KFxuICAgICAgICAgICAgXCJUeXBlRXJyb3JcIixcbiAgICAgICAgICAgICdBcnJheS5wcm90b3R5cGUuZXZlcnk6IG5vdCBhIGZ1bmN0aW9uJyxcbiAgICAgICAgICAgIGJvdFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGxldCBrID0gbmV3IFZhbHVlKDAsIGxlbi5sYWJlbCk7XG4gICAgYy5sYWJlbHMucGMgPSBsdWIoYy5sYWJlbHMucGMsIGxlbi5sYWJlbCk7XG5cbiAgICB3aGlsZSAoay52YWx1ZSA8IGxlbi52YWx1ZSkge1xuICAgICAgICBsZXQga1ByZXNlbnQgPSBPLkhhc1Byb3BlcnR5KGspO1xuICAgICAgICBjLmxhYmVscy5wYyA9IGx1YihjLmxhYmVscy5wYywga1ByZXNlbnQubGFiZWwpO1xuXG4gICAgICAgIGlmIChrUHJlc2VudC52YWx1ZSkge1xuICAgICAgICAgICAgbGV0IGtWYWx1ZSA9IE8uR2V0KGspO1xuICAgICAgICAgICAgY2FsbGJhY2tmbi5DYWxsKGNhbGxiYWNrdGhpc0FyZywgW2tWYWx1ZSwgaywgT10pO1xuICAgICAgICB9XG4gICAgICAgIGsudmFsdWUrKztcbiAgICB9XG5cbiAgICBjLnBvcFBDKCk7XG4gICAgcmV0dXJuIG5ldyBWYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gbWFwLCAxNS40LjQuMTlcblxuZnVuY3Rpb24gbWFwKHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8QXJyYXlPYmplY3Q+IHtcbiAgICBsZXQgY2FsbGJhY2tmbiA9IGFyZ3NbMF0gfHwgbmV3IFZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgICBsZXQgY2FsbGJhY2t0aGlzQXJnID0gYXJnc1sxXSB8fCBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuXG4gICAgbGV0IE8gPSBUb09iamVjdCh0aGlzQXJnKTtcbiAgICBsZXQgbGVuVmFsID0gTy5HZXQoY29uc3RhbnRzLmxlbmd0aCk7XG4gICAgbGV0IGxlbiA9IFRvVUludDMyKGxlblZhbCk7XG5cbiAgICBsZXQgYyA9IG1vbml0b3IuY29udGV4dDtcbiAgICBsZXQgaXNDYWxsYWJsZSA9IElzQ2FsbGFibGUoY2FsbGJhY2tmbik7XG5cbiAgICBjLnB1c2hQQyhjYWxsYmFja2ZuLmxhYmVsKTtcblxuICAgIGlmICghaXNDYWxsYWJsZSkge1xuICAgICAgICBtb25pdG9yLlRocm93KFxuICAgICAgICAgICAgXCJUeXBlRXJyb3JcIixcbiAgICAgICAgICAgICdBcnJheS5wcm90b3R5cGUuZXZlcnk6IG5vdCBhIGZ1bmN0aW9uJyxcbiAgICAgICAgICAgIGJvdFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGxldCBBID0gbmV3IEFycmF5T2JqZWN0KCk7XG4gICAgQS5wcm9wZXJ0aWVzLmxlbmd0aCA9IGxlbi52YWx1ZTtcbiAgICBBLmxhYmVscy5sZW5ndGggPSB7XG4gICAgICAgIHZhbHVlOiBsZW4ubGFiZWwsXG4gICAgICAgIGV4aXN0ZW5jZTogYm90XG4gICAgfTtcblxuICAgIGxldCBrID0gbmV3IFZhbHVlKDAsIGxlbi5sYWJlbCk7XG4gICAgYy5sYWJlbHMucGMgPSBsdWIoYy5sYWJlbHMucGMsIGxlbi5sYWJlbCk7XG5cbiAgICB3aGlsZSAoay52YWx1ZSA8IGxlbi52YWx1ZSkge1xuICAgICAgICBsZXQga1ByZXNlbnQgPSBPLkhhc1Byb3BlcnR5KGspO1xuICAgICAgICBjLmxhYmVscy5wYyA9IGx1YihjLmxhYmVscy5wYywga1ByZXNlbnQubGFiZWwpO1xuXG4gICAgICAgIGlmIChrUHJlc2VudC52YWx1ZSkge1xuICAgICAgICAgICAgbGV0IGtWYWx1ZSA9IE8uR2V0KGspO1xuICAgICAgICAgICAgbGV0IG1hcHBlZFZhbHVlID0gY2FsbGJhY2tmbi5DYWxsKGNhbGxiYWNrdGhpc0FyZywgW2tWYWx1ZSwgaywgT10pO1xuXG4gICAgICAgICAgICBBLkRlZmluZU93blByb3BlcnR5KGssIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbWFwcGVkVmFsdWUudmFsdWUsXG4gICAgICAgICAgICAgICAgbGFiZWw6IG1hcHBlZFZhbHVlLmxhYmVsLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LCBmYWxzZSk7XG5cbiAgICAgICAgfVxuICAgICAgICBrLnZhbHVlKys7XG4gICAgfVxuXG4gICAgYy5wb3BQQygpO1xuICAgIHJldHVybiBuZXcgVmFsdWUoQSwgYm90KTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBmaWx0ZXIsIDE1LjQuNC4yMFxuXG5mdW5jdGlvbiBmaWx0ZXIodGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxBcnJheU9iamVjdD4ge1xuICAgIGxldCBjYWxsYmFja2ZuID0gYXJnc1swXSB8fCBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgIGxldCBjYWxsYmFja3RoaXNBcmcgPSBhcmdzWzFdIHx8IG5ldyBWYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG5cbiAgICBsZXQgTyA9IFRvT2JqZWN0KHRoaXNBcmcpO1xuICAgIGxldCBsZW5WYWwgPSBPLkdldChjb25zdGFudHMubGVuZ3RoKTtcbiAgICBsZXQgbGVuID0gVG9VSW50MzIobGVuVmFsKTtcblxuICAgIGxldCBjID0gbW9uaXRvci5jb250ZXh0O1xuICAgIGxldCBpc0NhbGxhYmxlID0gSXNDYWxsYWJsZShjYWxsYmFja2ZuKTtcblxuICAgIGMucHVzaFBDKGNhbGxiYWNrZm4ubGFiZWwpO1xuXG4gICAgaWYgKCFpc0NhbGxhYmxlKSB7XG4gICAgICAgIG1vbml0b3IuVGhyb3coXG4gICAgICAgICAgICBcIlR5cGVFcnJvclwiLFxuICAgICAgICAgICAgJ0FycmF5LnByb3RvdHlwZS5ldmVyeTogbm90IGEgZnVuY3Rpb24nLFxuICAgICAgICAgICAgYm90XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgbGV0IEEgPSBuZXcgQXJyYXlPYmplY3QoKTtcblxuICAgIGxldCBrID0gbmV3IFZhbHVlKDAsIGxlbi5sYWJlbCk7XG4gICAgbGV0IHRvID0gbmV3IFZhbHVlKDAsIGxlbi5sYWJlbCk7XG5cbiAgICBjLmxhYmVscy5wYyA9IGx1YihjLmxhYmVscy5wYywgbGVuLmxhYmVsKTtcblxuICAgIHdoaWxlIChrLnZhbHVlIDwgbGVuLnZhbHVlKSB7XG4gICAgICAgIGxldCBrUHJlc2VudCA9IE8uSGFzUHJvcGVydHkoayk7XG4gICAgICAgIGMubGFiZWxzLnBjID0gbHViKGMubGFiZWxzLnBjLCBrUHJlc2VudC5sYWJlbCk7XG5cbiAgICAgICAgaWYgKGtQcmVzZW50LnZhbHVlKSB7XG4gICAgICAgICAgICBsZXQga1ZhbHVlID0gTy5HZXQoayk7XG4gICAgICAgICAgICBsZXQgc2VsZWN0ZWQgPSBjYWxsYmFja2ZuLkNhbGwoY2FsbGJhY2t0aGlzQXJnLCBba1ZhbHVlLCBrLCBPXSk7XG4gICAgICAgICAgICBzZWxlY3RlZCA9IFRvQm9vbGVhbihzZWxlY3RlZCk7XG5cbiAgICAgICAgICAgIGMubGFiZWxzLnBjID0gbHViKGMubGFiZWxzLnBjLCBzZWxlY3RlZC5sYWJlbCk7XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3RlZC52YWx1ZSkge1xuICAgICAgICAgICAgICAgIEEuRGVmaW5lT3duUHJvcGVydHkodG8sIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGtWYWx1ZS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGtWYWx1ZS5sYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0sIGZhbHNlKTtcblxuICAgICAgICAgICAgICAgIHRvLnZhbHVlKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgay52YWx1ZSsrO1xuICAgIH1cblxuICAgIGMucG9wUEMoKTtcbiAgICByZXR1cm4gbmV3IFZhbHVlKEEsIGJvdCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gcmVkdWNlLCAxNS40LjQuMjFcblxuZnVuY3Rpb24gcmVkdWNlKHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8VmFsdWVUeXBlcz4ge1xuICAgIGxldCBjYWxsYmFja2ZuID0gYXJnc1swXSB8fCBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgIGxldCBpbml0aWFsVmFsdWUgPSBhcmdzWzFdO1xuXG4gICAgbGV0IE8gPSBUb09iamVjdCh0aGlzQXJnKTtcbiAgICBsZXQgbGVuVmFsID0gTy5HZXQoY29uc3RhbnRzLmxlbmd0aCk7XG4gICAgbGV0IGxlbiA9IFRvVUludDMyKGxlblZhbCk7XG5cbiAgICBsZXQgYyA9IG1vbml0b3IuY29udGV4dDtcbiAgICBsZXQgaXNDYWxsYWJsZSA9IElzQ2FsbGFibGUoY2FsbGJhY2tmbik7XG5cbiAgICBsZXQgbGFiZWwgPSBsdWIoY2FsbGJhY2tmbi5sYWJlbCk7XG5cbiAgICBjLnB1c2hQQyhjYWxsYmFja2ZuLmxhYmVsKTtcblxuICAgIGlmICghaXNDYWxsYWJsZSkge1xuICAgICAgICBtb25pdG9yLlRocm93KFxuICAgICAgICAgICAgXCJUeXBlRXJyb3JcIixcbiAgICAgICAgICAgICdBcnJheS5wcm90b3R5cGUuZXZlcnk6IG5vdCBhIGZ1bmN0aW9uJyxcbiAgICAgICAgICAgIGJvdFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGxldCBrID0gbmV3IFZhbHVlKDAsIGxlbi5sYWJlbCk7XG4gICAgbGV0IGFjY3VtdWxhdG9yIDogVmFsdWU8VmFsdWVUeXBlcz4gPSBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuXG4gICAgaWYgKGluaXRpYWxWYWx1ZSkge1xuICAgICAgICBhY2N1bXVsYXRvciA9IGluaXRpYWxWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsZXQga1ByZXNlbnQgPSBuZXcgVmFsdWUoZmFsc2UsIGJvdCk7XG5cbiAgICAgICAgYy5sYWJlbHMucGMgPSBsdWIoYy5sYWJlbHMucGMsIGxlbi5sYWJlbCk7XG4gICAgICAgIGxhYmVsID0gbHViKGxhYmVsLCBsZW4ubGFiZWwpO1xuXG4gICAgICAgIHdoaWxlICgha1ByZXNlbnQudmFsdWUgJiYgay52YWx1ZSA8IGxlbi52YWx1ZSkge1xuICAgICAgICAgICAga1ByZXNlbnQgPSBPLkhhc1Byb3BlcnR5KGspO1xuXG4gICAgICAgICAgICBjLmxhYmVscy5wYyA9IGx1YihjLmxhYmVscy5wYywga1ByZXNlbnQubGFiZWwpO1xuICAgICAgICAgICAgbGFiZWwgPSBsdWIobGFiZWwsIGtQcmVzZW50LmxhYmVsKTtcblxuICAgICAgICAgICAgaWYgKGtQcmVzZW50LnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYWNjdW11bGF0b3IgPSBPLkdldChrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGsudmFsdWUrKztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgha1ByZXNlbnQudmFsdWUpIHtcbiAgICAgICAgICAgIG1vbml0b3IuVGhyb3coXG4gICAgICAgICAgICAgICAgXCJUeXBlRXJyb3JcIixcbiAgICAgICAgICAgICAgICAnQXJyYXkucHJvdG90eXBlLnJlZHVjZTogZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyxcbiAgICAgICAgICAgICAgICBib3RcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB3aGlsZSAoay52YWx1ZSA8IGxlbi52YWx1ZSkge1xuICAgICAgICBsZXQga1ByZXNlbnQgPSBPLkhhc1Byb3BlcnR5KGspO1xuXG4gICAgICAgIGMubGFiZWxzLnBjID0gbHViKGMubGFiZWxzLnBjLCBrUHJlc2VudC5sYWJlbCk7XG4gICAgICAgIGxhYmVsID0gbHViKGxhYmVsLCBrUHJlc2VudC5sYWJlbCk7XG5cbiAgICAgICAgaWYgKGtQcmVzZW50LnZhbHVlKSB7XG4gICAgICAgICAgICBsZXQga1ZhbHVlID0gTy5HZXQoayk7XG4gICAgICAgICAgICBhY2N1bXVsYXRvciA9IGNhbGxiYWNrZm4uQ2FsbChuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpLCBbYWNjdW11bGF0b3IsIGtWYWx1ZSwgaywgT10pO1xuICAgICAgICB9XG4gICAgICAgIGsudmFsdWUrKztcbiAgICB9XG5cbiAgICBjLnBvcFBDKCk7XG4gICAgYWNjdW11bGF0b3IucmFpc2UobGFiZWwpO1xuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyByZWR1Y2VSaWdodCwgMTUuNC40LjIyXG5cbmZ1bmN0aW9uIHJlZHVjZVJpZ2h0KHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8VmFsdWVUeXBlcz4ge1xuICAgIGxldCBjYWxsYmFja2ZuID0gYXJnc1swXSB8fCBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgIGxldCBpbml0aWFsVmFsdWUgPSBhcmdzWzFdO1xuXG4gICAgbGV0IE8gPSBUb09iamVjdCh0aGlzQXJnKTtcbiAgICBsZXQgbGVuVmFsID0gTy5HZXQoY29uc3RhbnRzLmxlbmd0aCk7XG4gICAgbGV0IGxlbiA9IFRvVUludDMyKGxlblZhbCk7XG5cbiAgICBsZXQgYyA9IG1vbml0b3IuY29udGV4dDtcbiAgICBsZXQgaXNDYWxsYWJsZSA9IElzQ2FsbGFibGUoY2FsbGJhY2tmbik7XG5cbiAgICBsZXQgbGFiZWwgPSBsdWIoY2FsbGJhY2tmbi5sYWJlbCk7XG5cbiAgICBjLnB1c2hQQyhjYWxsYmFja2ZuLmxhYmVsKTtcblxuICAgIGlmICghaXNDYWxsYWJsZSkge1xuICAgICAgICBtb25pdG9yLlRocm93KFxuICAgICAgICAgICAgXCJUeXBlRXJyb3JcIixcbiAgICAgICAgICAgICdBcnJheS5wcm90b3R5cGUuZXZlcnk6IG5vdCBhIGZ1bmN0aW9uJyxcbiAgICAgICAgICAgIGJvdFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGxldCBrID0gbmV3IFZhbHVlKGxlbi52YWx1ZSAtIDEsIGxlbi5sYWJlbCk7XG4gICAgbGV0IGFjY3VtdWxhdG9yIDogVmFsdWU8VmFsdWVUeXBlcz4gPSBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuXG4gICAgaWYgKGluaXRpYWxWYWx1ZSkge1xuICAgICAgICBhY2N1bXVsYXRvciA9IGluaXRpYWxWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsZXQga1ByZXNlbnQgPSBuZXcgVmFsdWUoZmFsc2UsIGJvdCk7XG5cbiAgICAgICAgYy5sYWJlbHMucGMgPSBsdWIoYy5sYWJlbHMucGMsIGxlbi5sYWJlbCk7XG4gICAgICAgIGxhYmVsID0gbHViKGxhYmVsLCBsZW4ubGFiZWwpO1xuXG4gICAgICAgIHdoaWxlICgha1ByZXNlbnQudmFsdWUgJiYgay52YWx1ZSA+PSAwKSB7XG4gICAgICAgICAgICBrUHJlc2VudCA9IE8uSGFzUHJvcGVydHkoayk7XG5cbiAgICAgICAgICAgIGMubGFiZWxzLnBjID0gbHViKGMubGFiZWxzLnBjLCBrUHJlc2VudC5sYWJlbCk7XG4gICAgICAgICAgICBsYWJlbCA9IGx1YihsYWJlbCwga1ByZXNlbnQubGFiZWwpO1xuXG4gICAgICAgICAgICBpZiAoa1ByZXNlbnQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhY2N1bXVsYXRvciA9IE8uR2V0KGspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgay52YWx1ZS0tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFrUHJlc2VudC52YWx1ZSkge1xuICAgICAgICAgICAgbW9uaXRvci5UaHJvdyhcbiAgICAgICAgICAgICAgICBcIlR5cGVFcnJvclwiLFxuICAgICAgICAgICAgICAgICdBcnJheS5wcm90b3R5cGUucmVkdWNlOiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnLFxuICAgICAgICAgICAgICAgIGJvdFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHdoaWxlIChrLnZhbHVlID49IDApIHtcbiAgICAgICAgbGV0IGtQcmVzZW50ID0gTy5IYXNQcm9wZXJ0eShrKTtcblxuICAgICAgICBjLmxhYmVscy5wYyA9IGx1YihjLmxhYmVscy5wYywga1ByZXNlbnQubGFiZWwpO1xuICAgICAgICBsYWJlbCA9IGx1YihsYWJlbCwga1ByZXNlbnQubGFiZWwpO1xuXG4gICAgICAgIGlmIChrUHJlc2VudC52YWx1ZSkge1xuICAgICAgICAgICAgbGV0IGtWYWx1ZSA9IE8uR2V0KGspO1xuICAgICAgICAgICAgYWNjdW11bGF0b3IgPSBjYWxsYmFja2ZuLkNhbGwobmV3IFZhbHVlKHVuZGVmaW5lZCwgYm90KSwgW2FjY3VtdWxhdG9yLCBrVmFsdWUsIGssIE9dKTtcbiAgICAgICAgfVxuICAgICAgICBrLnZhbHVlLS07XG4gICAgfVxuXG4gICAgYy5wb3BQQygpO1xuICAgIGFjY3VtdWxhdG9yLnJhaXNlKGxhYmVsKTtcbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG59IiwiaW1wb3J0IHsgVmFsdWUgfSBmcm9tIFwiLi4vVmFsdWVcIjtcbmltcG9ydCAqIGFzIGNvbnN0YW50cyBmcm9tICcuLi9Db25zdGFudHMnO1xuaW1wb3J0IHsgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0IH0gZnJvbSBcIi4uL09iamVjdHMvQnVpbHRpbkZ1bmN0aW9uT2JqZWN0XCI7XG5pbXBvcnQgeyBEZWZpbmVGRkYsIERlZmluZVRGVCB9IGZyb20gJy4uL0RlZmluZSc7XG5pbXBvcnQgeyBFY21hT2JqZWN0IH0gZnJvbSAnLi4vT2JqZWN0cy9FY21hT2JqZWN0JztcbmltcG9ydCB7IGJvdCB9IGZyb20gJy4uL0xhYmVsJztcbmltcG9ydCB7IE1vbml0b3JCYXNlIH0gZnJvbSAnLi4vTW9uaXRvckJhc2UnO1xuaW1wb3J0IHsgVmFsdWVUeXBlcyB9IGZyb20gXCIuLi9JbnRlcmZhY2VzXCI7XG5pbXBvcnQgeyBJc0Jvb2xlYW5PYmplY3QgfSBmcm9tIFwiLi4vT2JqZWN0cy9Cb29sZWFuT2JqZWN0XCI7XG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmRlY2xhcmUgdmFyIG1vbml0b3I6IE1vbml0b3JCYXNlO1xuXG4vLyAxNS42LjQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjbGFzcyBCb29sZWFuUHJvdG90eXBlIGV4dGVuZHMgRWNtYU9iamVjdCB7XG4gICAgUHJpbWl0aXZlVmFsdWUgOiBCb29sZWFuO1xuICAgIGhvc3QgOiBhbnk7XG5cbiAgICBjb25zdHJ1Y3Rvcihob3N0IDogQm9vbGVhbikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLkNsYXNzID0gJ0Jvb2xlYW4nO1xuICAgICAgICB0aGlzLlByaW1pdGl2ZVZhbHVlID0gbmV3IEJvb2xlYW4oZmFsc2UpO1xuICAgICAgICB0aGlzLmhvc3QgPSBob3N0O1xuICAgIH1cblxuICAgIFNldHVwKCkgOiB2b2lkIHtcbiAgICAgICAgdGhpcy5Qcm90b3R5cGUgPSBuZXcgVmFsdWUobW9uaXRvci5pbnN0YW5jZXMuT2JqZWN0UHJvdG90eXBlLCBib3QpO1xuXG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuY29uc3RydWN0b3IsIG1vbml0b3IuaW5zdGFuY2VzLkJvb2xlYW5Db25zdHJ1Y3Rvcik7XG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMudG9TdHJpbmcsIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3QodG9TdHJpbmcsIDAsIHRoaXMuaG9zdC50b1N0cmluZykpO1xuICAgICAgICBEZWZpbmVURlQodGhpcywgbmV3IFZhbHVlKCd2YWx1ZU9mJywgYm90KSwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdCh2YWx1ZU9mLCAwLCB0aGlzLmhvc3QudmFsdWVPZikpO1xuICAgIH1cbn1cblxuXG4vLyB0b1N0cmluZywgMTUuNi40LjIgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gdG9TdHJpbmcodGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxWYWx1ZVR5cGVzPiB7XG4gICAgbGV0IGIgPSB2YWx1ZU9mKHRoaXNBcmcsIGFyZ3MpO1xuICAgIGxldCBzID0gYi52YWx1ZSA/ICd0cnVlJyA6ICdmYWxzZSc7XG4gICAgcmV0dXJuIG5ldyBWYWx1ZShzLCBiLmxhYmVsKTtcbn07XG5cbi8vIHZhbHVlT2YsIDE1LjYuNC4zIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBcblxuZnVuY3Rpb24gdmFsdWVPZih0aGlzQXJnOiBWYWx1ZTxWYWx1ZVR5cGVzPiwgYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPGJvb2xlYW4+IHtcblxuICAgIGlmICh0eXBlb2YgdGhpc0FyZy52YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmFsdWUodGhpc0FyZy52YWx1ZSwgdGhpc0FyZy5sYWJlbCk7XG4gICAgfVxuXG4gICAgaWYgKElzQm9vbGVhbk9iamVjdCh0aGlzQXJnKSkge1xuICAgICAgICByZXR1cm4gbmV3IFZhbHVlKHRoaXNBcmcudmFsdWUuUHJpbWl0aXZlVmFsdWUudmFsdWVPZigpLCB0aGlzQXJnLmxhYmVsKTtcbiAgICB9XG5cbiAgICBtb25pdG9yLlRocm93KFxuICAgICAgICBcIlR5cGVFcnJvclwiLFxuICAgICAgICAnQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZiBpcyBub3QgZ2VuZXJpYycsXG4gICAgICAgIHRoaXNBcmcubGFiZWxcbiAgICApO1xuICAgIHRocm93ICdUeXBlU2NyaXB0Jztcbn07IiwiaW1wb3J0IHsgVmFsdWUgfSBmcm9tIFwiLi4vVmFsdWVcIjtcbmltcG9ydCAqIGFzIGNvbnN0YW50cyBmcm9tICcuLi9Db25zdGFudHMnO1xuaW1wb3J0IHsgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0IH0gZnJvbSBcIi4uL09iamVjdHMvQnVpbHRpbkZ1bmN0aW9uT2JqZWN0XCI7XG5pbXBvcnQgeyBUb051bWJlciB9IGZyb20gJy4uL0NvbnZlcnNpb24vVG9OdW1iZXInO1xuaW1wb3J0IHsgTW9uaXRvckJhc2UgfSBmcm9tICcuLi9Nb25pdG9yQmFzZSc7XG5cbmltcG9ydCB7IERlZmluZUZGRiwgRGVmaW5lVEZUIH0gZnJvbSAnLi4vRGVmaW5lJztcbmltcG9ydCB7IEVjbWFPYmplY3QgfSBmcm9tICcuLi9PYmplY3RzL0VjbWFPYmplY3QnO1xuXG5pbXBvcnQgeyBib3QsIGx1YiwgTGFiZWwsIGxlIH0gZnJvbSAnLi4vTGFiZWwnO1xuaW1wb3J0IHsgSXNEYXRlT2JqZWN0LCBEYXRlT2JqZWN0IH0gZnJvbSBcIi4uL09iamVjdHMvRGF0ZU9iamVjdFwiO1xuaW1wb3J0IHsgQm9vbGVhblByb3RvdHlwZSB9IGZyb20gXCIuL0Jvb2xlYW5Qcm90b3R5cGVcIjtcbmltcG9ydCB7IFZhbHVlVHlwZXMgfSBmcm9tIFwiLi4vSW50ZXJmYWNlc1wiO1xuXG5kZWNsYXJlIHZhciBtb25pdG9yOiBNb25pdG9yQmFzZTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBUaGUgRGF0ZSBQcm90b3R5cGUsIDE1LjkuNVxuZXhwb3J0IGNsYXNzIERhdGVQcm90b3R5cGUgZXh0ZW5kcyBFY21hT2JqZWN0IHtcblxuICAgIGhvc3Q6IERhdGU7XG5cbiAgICBQcmltaXRpdmVWYWx1ZTogVmFsdWU8bnVtYmVyPjtcblxuICAgIGNvbnN0cnVjdG9yKGhvc3QgOiBEYXRlKSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5DbGFzcyA9ICdEYXRlJztcbiAgICAgICAgdGhpcy5QcmltaXRpdmVWYWx1ZSA9IG5ldyBWYWx1ZShOYU4sIGJvdCk7XG5cbiAgICAgICAgdGhpcy5ob3N0ID0gaG9zdDtcbiAgICB9XG5cbiAgICBTZXR1cCgpIDogdm9pZCB7XG5cbiAgICAgICAgdGhpcy5Qcm90b3R5cGUgPSBuZXcgVmFsdWUobW9uaXRvci5pbnN0YW5jZXMuT2JqZWN0UHJvdG90eXBlLCBib3QpO1xuXG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuY29uc3RydWN0b3IsIG1vbml0b3IuaW5zdGFuY2VzLkRhdGVDb25zdHJ1Y3Rvcik7XG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMudG9TdHJpbmcsIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3QodG9TdHJpbmcsIDAsIHRoaXMuaG9zdC50b1N0cmluZykpO1xuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLnRvRGF0ZVN0cmluZywgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdCh0b0RhdGVTdHJpbmcsIDAsIHRoaXMuaG9zdC50b0RhdGVTdHJpbmcpKTtcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy50b1RpbWVTdHJpbmcsIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3QodG9UaW1lU3RyaW5nLCAwLCB0aGlzLmhvc3QudG9UaW1lU3RyaW5nKSk7XG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMudG9Mb2NhbGVTdHJpbmcsIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3QodG9Mb2NhbGVTdHJpbmcsIDAsIHRoaXMuaG9zdC50b0xvY2FsZVN0cmluZykpO1xuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLnRvTG9jYWxlRGF0ZVN0cmluZywgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdCh0b0xvY2FsZURhdGVTdHJpbmcsIDAsIHRoaXMuaG9zdC50b0xvY2FsZURhdGVTdHJpbmcpKTtcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy50b0xvY2FsZVRpbWVTdHJpbmcsIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3QodG9Mb2NhbGVUaW1lU3RyaW5nLCAwLCB0aGlzLmhvc3QudG9Mb2NhbGVUaW1lU3RyaW5nKSk7XG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBuZXcgVmFsdWUoJ3ZhbHVlT2YnLCBib3QpLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHZhbHVlT2YsIDAsIHRoaXMuaG9zdC52YWx1ZU9mKSk7XG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuZ2V0VGltZSwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChnZXRUaW1lLCAwLCB0aGlzLmhvc3QuZ2V0VGltZSkpO1xuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLmdldEZ1bGxZZWFyLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KGdldEZ1bGxZZWFyLCAwLCB0aGlzLmhvc3QuZ2V0RnVsbFllYXIpKTtcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5nZXRVVENGdWxsWWVhciwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChnZXRVVENGdWxsWWVhciwgMCwgdGhpcy5ob3N0LmdldFVUQ0Z1bGxZZWFyKSk7XG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuZ2V0TW9udGgsIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3QoZ2V0TW9udGgsIDAsIHRoaXMuaG9zdC5nZXRNb250aCkpO1xuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLmdldFVUQ01vbnRoLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KGdldFVUQ01vbnRoLCAwLCB0aGlzLmhvc3QuZ2V0VVRDTW9udGgpKTtcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5nZXREYXRlLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KGdldERhdGUsIDAsIHRoaXMuaG9zdC5nZXREYXRlKSk7XG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuZ2V0VVRDRGF0ZSwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChnZXRVVENEYXRlLCAwLCB0aGlzLmhvc3QuZ2V0VVRDRGF0ZSkpO1xuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLmdldERheSwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChnZXREYXksIDAsIHRoaXMuaG9zdC5nZXREYXkpKTtcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5nZXRVVENEYXksIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3QoZ2V0VVRDRGF5LCAwLCB0aGlzLmhvc3QuZ2V0VVRDRGF5KSk7XG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuZ2V0SG91cnMsIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3QoZ2V0SG91cnMsIDAsIHRoaXMuaG9zdC5nZXRIb3VycykpO1xuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLmdldFVUQ0hvdXJzLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KGdldFVUQ0hvdXJzLCAwLCB0aGlzLmhvc3QuZ2V0VVRDSG91cnMpKTtcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5nZXRNaW51dGVzLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KGdldE1pbnV0ZXMsIDAsIHRoaXMuaG9zdC5nZXRNaW51dGVzKSk7XG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuZ2V0VVRDTWludXRlcywgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChnZXRVVENNaW51dGVzLCAwLCB0aGlzLmhvc3QuZ2V0VVRDTWludXRlcykpO1xuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLmdldFNlY29uZHMsIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3QoZ2V0U2Vjb25kcywgMCwgdGhpcy5ob3N0LmdldFNlY29uZHMpKTtcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5nZXRVVENTZWNvbmRzLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KGdldFVUQ1NlY29uZHMsIDAsIHRoaXMuaG9zdC5nZXRVVENTZWNvbmRzKSk7XG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuZ2V0TWlsbGlzZWNvbmRzLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KGdldE1pbGxpc2Vjb25kcywgMCwgdGhpcy5ob3N0LmdldE1pbGxpc2Vjb25kcykpO1xuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLmdldFVUQ01pbGxpc2Vjb25kcywgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChnZXRVVENNaWxsaXNlY29uZHMsIDAsIHRoaXMuaG9zdC5nZXRVVENNaWxsaXNlY29uZHMpKTtcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5nZXRUaW1lem9uZU9mZnNldCwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChnZXRUaW1lem9uZU9mZnNldCwgMCwgdGhpcy5ob3N0LmdldFRpbWV6b25lT2Zmc2V0KSk7XG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuc2V0VGltZSwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChzZXRUaW1lLCAxLCB0aGlzLmhvc3Quc2V0VGltZSkpO1xuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLnNldE1pbGxpc2Vjb25kcywgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChzZXRNaWxsaXNlY29uZHMsIDAsIHRoaXMuaG9zdC5zZXRNaWxsaXNlY29uZHMpKTtcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5zZXRVVENNaWxsaXNlY29uZHMsIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3Qoc2V0VVRDTWlsbGlzZWNvbmRzLCAwLCB0aGlzLmhvc3Quc2V0VVRDTWlsbGlzZWNvbmRzKSk7XG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuc2V0U2Vjb25kcywgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChzZXRTZWNvbmRzLCAwLCB0aGlzLmhvc3Quc2V0U2Vjb25kcykpO1xuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLnNldFVUQ1NlY29uZHMsIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3Qoc2V0VVRDU2Vjb25kcywgMCwgdGhpcy5ob3N0LnNldFVUQ1NlY29uZHMpKTtcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5zZXRNaW51dGVzLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHNldE1pbnV0ZXMsIDAsIHRoaXMuaG9zdC5zZXRNaW51dGVzKSk7XG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuc2V0VVRDTWludXRlcywgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChzZXRVVENNaW51dGVzLCAwLCB0aGlzLmhvc3Quc2V0VVRDTWludXRlcykpO1xuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLnNldEhvdXJzLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHNldEhvdXJzLCAwLCB0aGlzLmhvc3Quc2V0SG91cnMpKTtcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5zZXRVVENIb3VycywgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChzZXRVVENIb3VycywgMCwgdGhpcy5ob3N0LnNldFVUQ0hvdXJzKSk7XG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuc2V0RGF0ZSwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChzZXREYXRlLCAwLCB0aGlzLmhvc3Quc2V0RGF0ZSkpO1xuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLnNldFVUQ0RhdGUsIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3Qoc2V0VVRDRGF0ZSwgMCwgdGhpcy5ob3N0LnNldFVUQ0RhdGUpKTtcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5zZXRNb250aCwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChzZXRNb250aCwgMiwgdGhpcy5ob3N0LnNldE1vbnRoKSk7XG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuc2V0VVRDTW9udGgsIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3Qoc2V0VVRDTW9udGgsIDAsIHRoaXMuaG9zdC5zZXRVVENNb250aCkpO1xuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLnNldEZ1bGxZZWFyLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHNldEZ1bGxZZWFyLCAwLCB0aGlzLmhvc3Quc2V0RnVsbFllYXIpKTtcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5zZXRVVENGdWxsWWVhciwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChzZXRVVENGdWxsWWVhciwgMCwgdGhpcy5ob3N0LnNldFVUQ0Z1bGxZZWFyKSk7XG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMudG9VVENTdHJpbmcsIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3QodG9VVENTdHJpbmcsIDAsIHRoaXMuaG9zdC50b1VUQ1N0cmluZykpO1xuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLnRvSVNPU3RyaW5nLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHRvSVNPU3RyaW5nLCAwLCB0aGlzLmhvc3QudG9JU09TdHJpbmcpKTtcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy50b0pTT04sIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3QodG9KU09OLCAwLCB0aGlzLmhvc3QudG9KU09OKSk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5zZXRZZWFyLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHNldFllYXIsIDEsIHRoaXMuaG9zdC5zZXRZZWFyKSk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5nZXRZZWFyLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KGdldFllYXIsIDAsIHRoaXMuaG9zdC5nZXRZZWFyKSk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy50b0dNVFN0cmluZywgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdCh0b1VUQ1N0cmluZywgMCwgdGhpcy5ob3N0LnRvR1RNU3RyaW5nKSk7XG4gICAgfVxuXG59XG5cbmZ1bmN0aW9uIGFzc2VydERhdGUodiA6IFZhbHVlPGFueT4sIGNhbGxlciA6IHN0cmluZykgOiB2b2lkIHtcblxuICAgIGlmICghSXNEYXRlT2JqZWN0KHYpKSB7XG4gICAgICAgIG1vbml0b3IuY29udGV4dC5wdXNoUEModi5sYWJlbCk7XG4gICAgICAgIG1vbml0b3IuVGhyb3coXG4gICAgICAgICAgICBcIlR5cGVFcnJvclwiLFxuICAgICAgICAgICAgY2FsbGVyICsgJyBpcyBub3QgZ2VuZXJpYycsXG4gICAgICAgICAgICBib3RcbiAgICAgICAgKTtcbiAgICB9XG5cbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIG1rR2VuZXJpY0dldChmbmFtZSA6IHN0cmluZykge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGhpc0FyZzogVmFsdWU8RGF0ZU9iamVjdD4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxWYWx1ZVR5cGVzPiB7XG4gICAgICAgIGFzc2VydERhdGUodGhpc0FyZywgZm5hbWUpO1xuXG4gICAgICAgIGxldCBsYWJlbCA9IGx1Yih0aGlzQXJnLmxhYmVsLCB0aGlzQXJnLnZhbHVlLlByaW1pdGl2ZUxhYmVsKTtcbiAgICAgICAgbGV0IGRhdGUgPSB0aGlzQXJnLnZhbHVlLlByaW1pdGl2ZVZhbHVlO1xuXG4gICAgICAgIGxldCB2YWx1ZSA9IGRhdGVbZm5hbWVdLmNhbGwoZGF0ZSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZSh2YWx1ZSwgbGFiZWwpO1xuICAgIH07XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBta0dlbmVyaWNTZXQoZm5hbWUgOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRoaXNBcmc6IFZhbHVlPERhdGVPYmplY3Q+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8VmFsdWVUeXBlcz4ge1xuICAgICAgICBhc3NlcnREYXRlKHRoaXNBcmcsIGZuYW1lKTtcblxuICAgICAgICBsZXQgY29udGV4dCA9IGx1Yih0aGlzQXJnLmxhYmVsLCBtb25pdG9yLmNvbnRleHQuZWZmZWN0aXZlUEMpO1xuXG4gICAgICAgIG1vbml0b3IuYXNzZXJ0KGxlKGNvbnRleHQsIHRoaXNBcmcudmFsdWUuUHJpbWl0aXZlTGFiZWwpLFxuICAgICAgICAgICAgZm5hbWUgKyAnOiBjb250ZXh0ICcgKyBjb250ZXh0ICsgJyBub3QgYmVsb3cgc3RhdGUgbGFiZWwgb2YgRGF0ZSBvYmplY3QgJyArIHRoaXNBcmcudmFsdWUuUHJpbWl0aXZlTGFiZWxcbiAgICAgICAgKTtcblxuICAgICAgICBsZXQgX2FyZ3MgOiBudW1iZXJbXSA9IFtdO1xuICAgICAgICBsZXQgbGFiZWwgPSBuZXcgTGFiZWwoKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gYXJncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgbGV0IHggPSBUb051bWJlcihhcmdzW2ldKTtcbiAgICAgICAgICAgIGxhYmVsID0gbHViKGxhYmVsLCB4LmxhYmVsKTtcbiAgICAgICAgICAgIF9hcmdzW2ldID0geC52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXNBcmcudmFsdWUuUHJpbWl0aXZlTGFiZWwgPSBsdWIodGhpc0FyZy52YWx1ZS5QcmltaXRpdmVMYWJlbCwgbGFiZWwpO1xuICAgICAgICBsYWJlbCA9IGx1Yih0aGlzQXJnLmxhYmVsLCB0aGlzQXJnLnZhbHVlLlByaW1pdGl2ZUxhYmVsKTtcblxuICAgICAgICBsZXQgZGF0ZSA9IHRoaXNBcmcudmFsdWUuUHJpbWl0aXZlVmFsdWU7XG4gICAgICAgIGxldCB2YWx1ZSA9IGRhdGVbZm5hbWVdLmFwcGx5KGRhdGUsIF9hcmdzKTtcblxuICAgICAgICByZXR1cm4gbmV3IFZhbHVlKHZhbHVlLCBsYWJlbCk7XG4gICAgfTtcbn1cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdG9JU09TdHJpbmcsIDE1LjkuNS40M1xubGV0IHRvSVNPU3RyaW5nID0gbWtHZW5lcmljR2V0KCd0b0lTT1N0cmluZycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHRvU3RyaW5nLCAxNS45LjUuMlxubGV0IHRvU3RyaW5nID0gbWtHZW5lcmljR2V0KCd0b1N0cmluZycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHRvRGF0ZVN0cmluZywgMTUuOS41Lj9cbmxldCB0b0RhdGVTdHJpbmcgPSBta0dlbmVyaWNHZXQoJ3RvRGF0ZVN0cmluZycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHRvVGltZVN0cmluZywgMTUuOS41Lj9cbmxldCB0b1RpbWVTdHJpbmcgPSBta0dlbmVyaWNHZXQoJ3RvVGltZVN0cmluZycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHRvTG9jYWxlU3RyaW5nLCAxNS45LjUuP1xubGV0IHRvTG9jYWxlU3RyaW5nID0gbWtHZW5lcmljR2V0KCd0b0xvY2FsZVN0cmluZycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHRvTG9jYWxlRGF0ZVN0cmluZywgMTUuOS41Lj9cbmxldCB0b0xvY2FsZURhdGVTdHJpbmcgPSBta0dlbmVyaWNHZXQoJ3RvTG9jYWxlRGF0ZVN0cmluZycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHRvTG9jYWxlVGltZVN0cmluZywgMTUuOS41Lj9cbmxldCB0b0xvY2FsZVRpbWVTdHJpbmcgPSBta0dlbmVyaWNHZXQoJ3RvTG9jYWxlVGltZVN0cmluZycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHZhbHVlT2YsIDE1LjkuNS4/XG5mdW5jdGlvbiB2YWx1ZU9mKHRoaXNBcmcsIGFyZ3MpIHtcbiAgICBhc3NlcnREYXRlKHRoaXNBcmcsICd2YWx1ZU9mJyk7XG4gICAgcmV0dXJuIG5ldyBWYWx1ZSh0aGlzQXJnLnZhbHVlLlByaW1pdGl2ZVZhbHVlLnZhbHVlT2YoKSwgdGhpc0FyZy5sYWJlbCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gZ2V0VGltZSwgMTUuOS41LjlcbmxldCBnZXRUaW1lID0gbWtHZW5lcmljR2V0KCdnZXRUaW1lJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gZ2V0RnVsbFllYXIsIDE1LjkuNS4/XG5sZXQgZ2V0RnVsbFllYXIgPSBta0dlbmVyaWNHZXQoJ2dldEZ1bGxZZWFyJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gZ2V0VVRDRnVsbFllYXIsIDE1LjkuNS4/XG5sZXQgZ2V0VVRDRnVsbFllYXIgPSBta0dlbmVyaWNHZXQoJ2dldFVUQ0Z1bGxZZWFyJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gZ2V0TW9udGgsIDE1LjkuNS4/XG5sZXQgZ2V0TW9udGggPSBta0dlbmVyaWNHZXQoJ2dldE1vbnRoJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gZ2V0VVRDTW9udGgsIDE1LjkuNS4/XG5sZXQgZ2V0VVRDTW9udGggPSBta0dlbmVyaWNHZXQoJ2dldFVUQ01vbnRoJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gZ2V0RGF0ZSwgMTUuOS41Lj9cbmxldCBnZXREYXRlID0gbWtHZW5lcmljR2V0KCdnZXREYXRlJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gZ2V0VVRDRGF0ZSwgMTUuOS41Lj9cbmxldCBnZXRVVENEYXRlID0gbWtHZW5lcmljR2V0KCdnZXRVVENEYXRlJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gZ2V0RGF5LCAxNS45LjUuP1xubGV0IGdldERheSA9IG1rR2VuZXJpY0dldCgnZ2V0RGF5Jyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gZ2V0VVRDRGF5LCAxNS45LjUuP1xubGV0IGdldFVUQ0RheSA9IG1rR2VuZXJpY0dldCgnZ2V0VVRDRGF5Jyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gZ2V0SG91cnMsIDE1LjkuNS4/XG5sZXQgZ2V0SG91cnMgPSBta0dlbmVyaWNHZXQoJ2dldEhvdXJzJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gZ2V0VVRDSG91cnMsIDE1LjkuNS4/XG5sZXQgZ2V0VVRDSG91cnMgPSBta0dlbmVyaWNHZXQoJ2dldFVUQ0hvdXJzJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gZ2V0TWludXRlcywgMTUuOS41Lj9cbmxldCBnZXRNaW51dGVzID0gbWtHZW5lcmljR2V0KCdnZXRNaW51dGVzJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gZ2V0VVRDTWludXRlcywgMTUuOS41Lj9cbmxldCBnZXRVVENNaW51dGVzID0gbWtHZW5lcmljR2V0KCdnZXRVVENNaW51dGVzJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gZ2V0U2Vjb25kcywgMTUuOS41Lj9cbmxldCBnZXRTZWNvbmRzID0gbWtHZW5lcmljR2V0KCdnZXRTZWNvbmRzJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gZ2V0VVRDU2Vjb25kcywgMTUuOS41Lj9cbmxldCBnZXRVVENTZWNvbmRzID0gbWtHZW5lcmljR2V0KCdnZXRVVENTZWNvbmRzJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gZ2V0TWlsbGlzZWNvbmRzLCAxNS45LjUuP1xubGV0IGdldE1pbGxpc2Vjb25kcyA9IG1rR2VuZXJpY0dldCgnZ2V0TWlsbGlzZWNvbmRzJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gZ2V0VVRDTWlsbGlzZWNvbmRzLCAxNS45LjUuP1xubGV0IGdldFVUQ01pbGxpc2Vjb25kcyA9IG1rR2VuZXJpY0dldCgnZ2V0VVRDTWlsbGlzZWNvbmRzJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gZ2V0VGltZXpvbmVPZmZzZXQsIDE1LjkuNS4/XG5sZXQgZ2V0VGltZXpvbmVPZmZzZXQgPSBta0dlbmVyaWNHZXQoJ2dldFRpbWV6b25lT2Zmc2V0Jyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc2V0VGltZSwgMTUuOS41Lj9cbmxldCBzZXRUaW1lID0gbWtHZW5lcmljU2V0KCdzZXRUaW1lJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc2V0TWlsbGlzZWNvbmRzLCAxNS45LjUuP1xubGV0IHNldE1pbGxpc2Vjb25kcyA9IG1rR2VuZXJpY1NldCgnc2V0TWlsbGlzZWNvbmRzJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc2V0VVRDTWlsbGlzZWNvbmRzLCAxNS45LjUuP1xubGV0IHNldFVUQ01pbGxpc2Vjb25kcyA9IG1rR2VuZXJpY1NldCgnc2V0VVRDTWlsbGlzZWNvbmRzJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc2V0U2Vjb25kcywgMTUuOS41Lj9cbmxldCBzZXRTZWNvbmRzID0gbWtHZW5lcmljU2V0KCdzZXRTZWNvbmRzJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc2V0VVRDU2Vjb25kcywgMTUuOS41Lj9cbmxldCBzZXRVVENTZWNvbmRzID0gbWtHZW5lcmljU2V0KCdzZXRVVENTZWNvbmRzJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc2V0TWludXRlcywgMTUuOS41Lj9cbmxldCBzZXRNaW51dGVzID0gbWtHZW5lcmljU2V0KCdzZXRNaW51dGVzJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc2V0VVRDTWludXRlcywgMTUuOS41Lj9cbmxldCBzZXRVVENNaW51dGVzID0gbWtHZW5lcmljU2V0KCdzZXRVVENNaW51dGVzJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc2V0SG91cnMsIDE1LjkuNS4/XG5sZXQgc2V0SG91cnMgPSBta0dlbmVyaWNTZXQoJ3NldEhvdXJzJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc2V0VVRDSG91cnMsIDE1LjkuNS4/XG5sZXQgc2V0VVRDSG91cnMgPSBta0dlbmVyaWNTZXQoJ3NldFVUQ0hvdXJzJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc2V0RGF0ZSwgMTUuOS41Lj9cbmxldCBzZXREYXRlID0gbWtHZW5lcmljU2V0KCdzZXREYXRlJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc2V0VVRDRGF0ZSwgMTUuOS41Lj9cbmxldCBzZXRVVENEYXRlID0gbWtHZW5lcmljU2V0KCdzZXRVVENEYXRlJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc2V0TW9udGgsIDE1LjkuNS4/XG5sZXQgc2V0TW9udGggPSBta0dlbmVyaWNTZXQoJ3NldE1vbnRoJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc2V0VVRDTW9udGgsIDE1LjkuNS4/XG5sZXQgc2V0VVRDTW9udGggPSBta0dlbmVyaWNTZXQoJ3NldFVUQ01vbnRoJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc2V0RnVsbFllYXIsIDE1LjkuNS4/XG5sZXQgc2V0RnVsbFllYXIgPSBta0dlbmVyaWNTZXQoJ3NldEZ1bGxZZWFyJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc2V0VVRDRnVsbFllYXIsIDE1LjkuNS4/XG5sZXQgc2V0VVRDRnVsbFllYXIgPSBta0dlbmVyaWNTZXQoJ3NldFVUQ0Z1bGxZZWFyJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdG9VVENTdHJpbmcsIDE1LjkuNS4/XG5sZXQgdG9VVENTdHJpbmcgPSBta0dlbmVyaWNHZXQoJ3RvVVRDU3RyaW5nJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdG9KU09OLCAxNS45LjUuP1xubGV0IHRvSlNPTiA9IG1rR2VuZXJpY0dldCgndG9KU09OJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gZ2V0WWVhciwgQi4yLjRcbmxldCBnZXRZZWFyID0gbWtHZW5lcmljR2V0KCdnZXRZZWFyJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc2V0WWVhciwgQi4yLjVcbmxldCBzZXRZZWFyID0gbWtHZW5lcmljU2V0KCdzZXRZZWFyJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc2V0WWVhciwgQi4yLjZcbmxldCB0b0dNVFN0cmluZyA9IG1rR2VuZXJpY1NldCgndG9HTVRTdHJpbmcnKTsiLCJpbXBvcnQgeyBWYWx1ZSB9IGZyb20gXCIuLi9WYWx1ZVwiO1xuaW1wb3J0IHsgRWNtYU9iamVjdCB9IGZyb20gJy4uL09iamVjdHMvRWNtYU9iamVjdCc7XG5pbXBvcnQgKiBhcyBjb25zdGFudHMgZnJvbSAnLi4vQ29uc3RhbnRzJztcbmltcG9ydCB7IEJ1aWx0aW5GdW5jdGlvbk9iamVjdCB9IGZyb20gXCIuLi9PYmplY3RzL0J1aWx0aW5GdW5jdGlvbk9iamVjdFwiO1xuaW1wb3J0IHsgVG9TdHJpbmcgfSBmcm9tICcuLi9Db252ZXJzaW9uL1RvU3RyaW5nJztcbmltcG9ydCB7IERlZmluZVRGVCB9IGZyb20gJy4uL0RlZmluZSc7XG5pbXBvcnQgeyBib3QgfSBmcm9tICcuLi9MYWJlbCc7XG5pbXBvcnQgeyBNb25pdG9yQmFzZSB9IGZyb20gJy4uL01vbml0b3JCYXNlJztcblxuaW1wb3J0IHsgRXJyb3JDb25zdHJ1Y3RvciB9IGZyb20gJy4uL0NvbnN0cnVjdG9ycy9FcnJvckNvbnN0cnVjdG9yJztcbmltcG9ydCB7IFZhbHVlVHlwZXMgfSBmcm9tIFwiLi4vSW50ZXJmYWNlc1wiO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZGVjbGFyZSB2YXIgbW9uaXRvcjogTW9uaXRvckJhc2U7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gMTUuMTEuNCBUaGUgRXJyb3IgUHJvdG90eXBlXG5cbmV4cG9ydCBjbGFzcyBFcnJvclByb3RvdHlwZSBleHRlbmRzIEVjbWFPYmplY3Qge1xuXG4gICAgaG9zdDogRXJyb3I7XG5cbiAgICBjb25zdHJ1Y3Rvcihob3N0OiBFcnJvcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLkNsYXNzID0gJ0Vycm9yJztcbiAgICAgICAgdGhpcy5ob3N0ID0gaG9zdDtcbiAgICB9XG5cbiAgICBTZXR1cCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5TZXR1cEJhc2UobW9uaXRvci5pbnN0YW5jZXMuRXJyb3JDb25zdHJ1Y3RvciwgJ0Vycm9yJyk7XG4gICAgfVxuXG4gICAgU2V0dXBCYXNlKGNvbnN0cnVjdG9yOiBFcnJvckNvbnN0cnVjdG9yLCBuYW1lOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5Qcm90b3R5cGUgPSBuZXcgVmFsdWUobW9uaXRvci5pbnN0YW5jZXMuT2JqZWN0UHJvdG90eXBlLCBib3QpO1xuXG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuY29uc3RydWN0b3IsIGNvbnN0cnVjdG9yKTtcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5uYW1lLCBuYW1lKTtcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5tZXNzYWdlLCAnJyk7XG5cbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy50b1N0cmluZywgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdCh0b3N0cmluZywgMCwgdW5kZWZpbmVkKSk7XG4gICAgfVxufVxuXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiB0b3N0cmluZyh0aGlzQXJnOiBWYWx1ZTxWYWx1ZVR5cGVzPiwgYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPFZhbHVlVHlwZXM+ICB7XG4gICAgdmFyIGMgPSBtb25pdG9yLmNvbnRleHQ7XG5cbiAgICBpZiAodGhpc0FyZy52YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdGhpc0FyZy52YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgYy5wdXNoUEModGhpc0FyZy5sYWJlbCk7XG4gICAgICAgIG1vbml0b3IuVGhyb3coXG4gICAgICAgICAgICBcIlR5cGVFcnJvclwiLFxuICAgICAgICAgICAgJ0Vycm9yIG9iamVjdCBleHBlY3RlZCcsXG4gICAgICAgICAgICBib3RcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgbmFtZSA9IHRoaXNBcmcuR2V0KGNvbnN0YW50cy5uYW1lKTtcblxuICAgIGlmIChuYW1lLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmFtZS52YWx1ZSA9ICdFcnJvcic7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYy5wdXNoUEMobmFtZS5sYWJlbCk7XG4gICAgICAgIG5hbWUgPSBUb1N0cmluZyhuYW1lKTtcbiAgICAgICAgYy5wb3BQQygpO1xuICAgIH1cblxuICAgIHZhciBtc2cgPSB0aGlzQXJnLkdldChjb25zdGFudHMubWVzc2FnZSk7XG5cbiAgICBpZiAobXNnLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbXNnLnZhbHVlID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYy5wdXNoUEMobXNnLmxhYmVsKTtcbiAgICAgICAgbXNnID0gVG9TdHJpbmcobXNnKTtcbiAgICAgICAgYy5wb3BQQygpO1xuICAgIH1cblxuICAgIGlmIChuYW1lLnZhbHVlID09PSAnJykge1xuICAgICAgICBtc2cucmFpc2UobmFtZS5sYWJlbCk7XG4gICAgICAgIHJldHVybiBtc2c7XG4gICAgfVxuXG4gICAgaWYgKG1zZy52YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgbmFtZS5yYWlzZShtc2cubGFiZWwpO1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG5cbiAgICBuYW1lLnZhbHVlICs9ICc6ICcgKyBtc2cudmFsdWU7XG4gICAgbmFtZS5yYWlzZShtc2cubGFiZWwpO1xuICAgIHJldHVybiBuYW1lO1xufSIsImltcG9ydCB7IEVycm9yUHJvdG90eXBlIH0gZnJvbSBcIi4vRXJyb3JQcm90b3R5cGVcIjtcbmltcG9ydCB7IE1vbml0b3JCYXNlIH0gZnJvbSBcIi4uL01vbml0b3JCYXNlXCI7XG5cbmRlY2xhcmUgdmFyIG1vbml0b3I6IE1vbml0b3JCYXNlO1xuXG5leHBvcnQgY2xhc3MgRXZhbEVycm9yUHJvdG90eXBlIGV4dGVuZHMgRXJyb3JQcm90b3R5cGUge1xuXG4gICAgY29uc3RydWN0b3IoaG9zdCA6IEV2YWxFcnJvcikge1xuICAgICAgICBzdXBlcihob3N0KTtcbiAgICB9XG5cbiAgICBTZXR1cCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5TZXR1cEJhc2UobW9uaXRvci5pbnN0YW5jZXMuRXJyb3JDb25zdHJ1Y3RvciwgJ0V2YWxFcnJvcicpO1xuICAgIH1cbiAgICBcbn0iLCJpbXBvcnQgeyBib3QgfSBmcm9tICcuLi9MYWJlbCc7XG5pbXBvcnQgKiBhcyBwcCBmcm9tICcuLi9QUCc7XG5pbXBvcnQgeyBWYWx1ZSB9IGZyb20gXCIuLi9WYWx1ZVwiO1xuaW1wb3J0IHsgRGVmaW5lRkZGLCBEZWZpbmVURlQsIERlZmluZUZGVCB9IGZyb20gJy4uL0RlZmluZSc7XG5pbXBvcnQgeyBFY21hT2JqZWN0IH0gZnJvbSAnLi4vT2JqZWN0cy9FY21hT2JqZWN0JztcbmltcG9ydCAqIGFzIGNvbnN0YW50cyBmcm9tICcuLi9Db25zdGFudHMnO1xuaW1wb3J0IHsgTW9uaXRvckJhc2UgfSBmcm9tICcuLi9Nb25pdG9yQmFzZSc7XG5cbmltcG9ydCB7IEJ1aWx0aW5GdW5jdGlvbk9iamVjdCB9IGZyb20gXCIuLi9PYmplY3RzL0J1aWx0aW5GdW5jdGlvbk9iamVjdFwiO1xuaW1wb3J0IHsgVG9VSW50MzIgfSBmcm9tICcuLi9Db252ZXJzaW9uL1RvVUludDMyJztcbmltcG9ydCB7IElzQ2FsbGFibGUgfSBmcm9tICcuLi9VdGlsaXR5L0lzQ2FsbGFibGUnO1xuaW1wb3J0IHsgVGhyb3dUeXBlRXJyb3IgfSBmcm9tICcuLi9UaHJvd1R5cGVFcnJvcic7XG5pbXBvcnQgeyBWYWx1ZVR5cGVzLCBJRWNtYU9iamVjdCB9IGZyb20gJy4uL0ludGVyZmFjZXMnO1xuaW1wb3J0IHsgRnVuY3Rpb25PYmplY3QgfSBmcm9tICcuLi9PYmplY3RzL0Z1bmN0aW9uT2JqZWN0JztcblxuLy8gaW1wb3J0IHsgTW9uaXRvckJhc2UgfSBcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmRlY2xhcmUgdmFyIG1vbml0b3I6IE1vbml0b3JCYXNlO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEZ1bmN0aW9uIFByb3RvdHlwZSwgMTUuMy40XG5cbmV4cG9ydCBjbGFzcyBGdW5jdGlvblByb3RvdHlwZSBleHRlbmRzIEVjbWFPYmplY3Qge1xuXG4gIGhvc3Q6IEZ1bmN0aW9uO1xuXG4gIGNvbnN0cnVjdG9yKGhvc3Q6IEZ1bmN0aW9uKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8vIDE1LjMuNFxuICAgIHRoaXMuQ2xhc3MgPSAnRnVuY3Rpb24nO1xuICAgIHRoaXMuRXh0ZW5zaWJsZSA9IHRydWU7XG5cbiAgICB0aGlzLmhvc3QgPSBob3N0O1xuXG4gIH1cblxuICBTZXR1cCgpOiB2b2lkIHtcbiAgICAvLyAxNS4zLjQuMVxuICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuY29uc3RydWN0b3IsIG1vbml0b3IuaW5zdGFuY2VzLkZ1bmN0aW9uQ29uc3RydWN0b3IpO1xuICAgIHRoaXMuUHJvdG90eXBlID0gbmV3IFZhbHVlKG1vbml0b3IuaW5zdGFuY2VzLk9iamVjdFByb3RvdHlwZSwgYm90KTtcbiAgICBEZWZpbmVGRlQodGhpcywgY29uc3RhbnRzLmxlbmd0aCwgMCk7XG5cbiAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLnRvU3RyaW5nLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHRvU3RyaW5nLCAwLCBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmcpKTtcbiAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLmFwcGx5LCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KGFwcGx5LCAyLCBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkpKTtcbiAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLmNhbGwsIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3QoY2FsbCwgMSwgRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwpKTtcbiAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLmJpbmQsIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3QoYmluZCwgMSwgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQpKTtcbiAgfVxuXG4gIC8vIDE1LjMuNFxuICBDYWxsKHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8VmFsdWVUeXBlcz4ge1xuICAgIHJldHVybiBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICB9XG5cbiAgQ29uc3RydWN0KGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxJRWNtYU9iamVjdD4ge1xuICAgIHJldHVybiBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gMTUuMy40LjIgLSBJbXBsZW1lbnRhdGlvbiBEZXBlbmRlbnRcbmZ1bmN0aW9uIHRvU3RyaW5nKHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8c3RyaW5nPiB7XG4gIHJldHVybiBuZXcgVmFsdWUoU3RyaW5nKHRoaXNBcmcudmFsdWUpLCB0aGlzQXJnLmxhYmVsKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAxNS4zLjQuM1xuZnVuY3Rpb24gYXBwbHkodGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxWYWx1ZVR5cGVzPiB7XG4gIGxldCBfdGhpcyA9IGFyZ3NbMF0gPyBhcmdzWzBdIDogbmV3IFZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgbGV0IGFyZ0FycmF5ID0gYXJnc1sxXSA/IGFyZ3NbMV0gOiBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuXG4gIG1vbml0b3IuY29udGV4dC5wdXNoUEModGhpc0FyZy5sYWJlbCk7XG5cbiAgaWYgKCFJc0NhbGxhYmxlKHRoaXNBcmcpKSB7XG4gICAgbW9uaXRvci5UaHJvdyhcbiAgICAgIFwiVHlwZUVycm9yXCIsXG4gICAgICAnYXBwbHksIG5vdCBhIGZ1bmN0aW9uJyxcbiAgICAgIGJvdFxuICAgICk7XG4gIH1cblxuICBtb25pdG9yLmNvbnRleHQucmFpc2VQQyhhcmdBcnJheS5sYWJlbCk7XG5cbiAgaWYgKGFyZ0FycmF5LnZhbHVlID09PSBudWxsIHx8IGFyZ0FycmF5LnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICBsZXQgcmVzID0gdGhpc0FyZy5DYWxsKF90aGlzLCBbXSk7XG4gICAgbW9uaXRvci5jb250ZXh0LnBvcFBDKCk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIGlmICh0eXBlb2YgYXJnQXJyYXkudmFsdWUgIT09ICdvYmplY3QnIHx8IGFyZ0FycmF5LnZhbHVlLkNsYXNzID09PSB1bmRlZmluZWQpIHtcbiAgICBtb25pdG9yLlRocm93KFxuICAgICAgXCJUeXBlRXJyb3JcIixcbiAgICAgICdhcHBseSwgYXJndW1lbnQgYXJyYXkgbm90IGFuIG9iamVjdCcsXG4gICAgICBib3RcbiAgICApO1xuICB9XG5cbiAgbGV0IGxlbiA9IGFyZ0FycmF5LkdldChjb25zdGFudHMubGVuZ3RoKTtcbiAgbGV0IG4gPSBUb1VJbnQzMihsZW4pO1xuXG4gIGxldCBhcmdMaXN0OiBWYWx1ZTxWYWx1ZVR5cGVzPltdID0gW107XG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBuLnZhbHVlOyBpbmRleCsrKSB7XG4gICAgbGV0IG5leHRBcmcgPSBhcmdBcnJheS5HZXQobmV3IFZhbHVlKGluZGV4LCBuLmxhYmVsKSk7XG4gICAgYXJnTGlzdC5wdXNoKG5leHRBcmcpO1xuICB9XG5cbiAgLy8gU2luY2Ugd2UgY2Fubm90IHRyYW5zZmVyIHRoZSBzdHJ1Y3R1cmFsIG9yIGV4aXN0ZW5jZSBpbmZvIHRvXG4gIC8vICB0aGUgYXJyYXkgdXNlZCBieSBDYWxsLCB3ZSByYWlzZSB0aGUgY29udGV4dCBhY2NvcmRpbmdseS5cbiAgLy8gIFRoaXMgaXMgc291bmQsIGJ1dCBwb3RlbnRpYWxseSBhbiBvdmVyIGFwcHJveGltYXRpb24uXG5cbiAgbW9uaXRvci5jb250ZXh0LnJhaXNlUEMobi5sYWJlbCk7XG5cbiAgbGV0IHJlcyA9IHRoaXNBcmcuQ2FsbChfdGhpcywgYXJnTGlzdCk7XG5cbiAgbW9uaXRvci5jb250ZXh0LnBvcFBDKCk7XG4gIHJldHVybiByZXM7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gMTUuMy40LjRcbmZ1bmN0aW9uIGNhbGwodGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxWYWx1ZVR5cGVzPiB7XG5cbiAgbGV0IF90aGlzID0gYXJnc1swXSA/IGFyZ3NbMF0gOiBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICBsZXQgYXJnTGlzdDogVmFsdWU8VmFsdWVUeXBlcz5bXSA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAxOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgIGFyZ0xpc3RbaSAtIDFdID0gYXJnc1tpXTtcbiAgfVxuXG4gIG1vbml0b3IuY29udGV4dC5wdXNoUEModGhpc0FyZy5sYWJlbCk7XG5cbiAgaWYgKCFJc0NhbGxhYmxlKHRoaXNBcmcpKSB7XG4gICAgbW9uaXRvci5UaHJvdyhcbiAgICAgIFwiVHlwZUVycm9yXCIsXG4gICAgICAnY2FsbCwgbm90IGEgZnVuY3Rpb24nLFxuICAgICAgYm90XG4gICAgKTtcbiAgfVxuXG4gIGxldCByZXMgPSB0aGlzQXJnLkNhbGwoX3RoaXMsIGFyZ0xpc3QpO1xuICBtb25pdG9yLmNvbnRleHQucG9wUEMoKTtcbiAgcmV0dXJuIHJlcztcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAxNS4zLjQuNVxuZnVuY3Rpb24gYmluZCh0aGlzQXJnOiBWYWx1ZTxWYWx1ZVR5cGVzPiwgYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPFZhbHVlVHlwZXM+IHtcbiAgbGV0IFRhcmdldCA9IHRoaXNBcmc7XG4gIGxldCBfdGhpcyA9IGFyZ3NbMF0gPyBhcmdzWzBdIDogbmV3IFZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgbGV0IGFyZ0xpc3QgOiBWYWx1ZTxWYWx1ZVR5cGVzPltdID0gW107XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgIGFyZ0xpc3RbaSAtIDFdID0gYXJnc1tpXTtcbiAgfVxuXG4gIGlmICghSXNDYWxsYWJsZShUYXJnZXQpKSB7XG4gICAgbW9uaXRvci5UaHJvdyhcbiAgICAgIFwiVHlwZUVycm9yXCIsXG4gICAgICAnYmluZDogVGFyZ2V0IGlzIG5vdCBhIGZ1bmN0aW9uJyxcbiAgICAgIGJvdFxuICAgICk7XG4gIH1cblxuICBsZXQgRiA9IG5ldyBFY21hT2JqZWN0KCk7XG4gIC8vQHRzLWlnbm9yZSBUWVBFU1xuICBGLlRhcmdldEZ1bmN0aW9uID0gVGFyZ2V0O1xuICAvL0B0cy1pZ25vcmUgVFlQRVNcbiAgRi5Cb3VuZFRoaXMgPSBfdGhpcztcbiAgLy9AdHMtaWdub3JlIFRZUEVTXG4gIEYuQm91bmRBcmdzID0gYXJnTGlzdDtcbiAgRi5DbGFzcyA9ICdGdW5jdGlvbic7XG4gIEYuUHJvdG90eXBlID0gbmV3IFZhbHVlKG1vbml0b3IuaW5zdGFuY2VzLkZ1bmN0aW9uUHJvdG90eXBlLCBib3QpO1xuXG4gIC8vQHRzLWlnbm9yZSBUWVBFU1xuICBGLkNhbGwgPSBmdW5jdGlvbiAoX3RoaXNWYWwsIEV4dHJhQXJncykge1xuICAgIC8vQHRzLWlnbm9yZSBUWVBFU1xuICAgIGxldCBib3VuZEFyZ3MgPSBGLkJvdW5kQXJncztcbiAgICAvL0B0cy1pZ25vcmUgVFlQRVNcbiAgICBsZXQgYm91bmRUaGlzID0gRi5Cb3VuZFRoaXM7XG4gICAgLy9AdHMtaWdub3JlIFRZUEVTXG4gICAgbGV0IHRhcmdldCA9IEYuVGFyZ2V0RnVuY3Rpb247XG4gICAgbGV0IGFyZ3MgPSBib3VuZEFyZ3MuY29uY2F0KEV4dHJhQXJncyk7XG4gICAgcmV0dXJuIHRhcmdldC5DYWxsKGJvdW5kVGhpcywgYXJncyk7XG4gIH1cblxuICAvL0B0cy1pZ25vcmUgVFlQRVNcbiAgRi5Db25zdHJ1Y3QgPSBmdW5jdGlvbiAoRXh0cmFBcmdzKSB7XG4gICAgLy9AdHMtaWdub3JlIFRZUEVTXG4gICAgbGV0IHRhcmdldCA9IEYuVGFyZ2V0RnVuY3Rpb247XG4gICAgaWYgKCF0YXJnZXQuQ29uc3RydWN0KSB7XG4gICAgICBtb25pdG9yLlRocm93KFxuICAgICAgICBcIlR5cGVFcnJvclwiLFxuICAgICAgICAnYmluZCBjb25zdHJ1Y3Q6IG5vIGludGVybmFsIG1ldGhvZCBDb25zdHJ1Y3QnLFxuICAgICAgICBib3RcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy9AdHMtaWdub3JlIFRZUEVTXG4gICAgbGV0IGJvdW5kQXJncyA9IEYuQm91bmRBcmdzO1xuICAgIGxldCBhcmdzID0gYm91bmRBcmdzLmNvbmNhdChFeHRyYUFyZ3MpO1xuXG4gICAgcmV0dXJuIHRhcmdldC5Db25zdHJ1Y3QoYXJncyk7XG4gIH1cblxuICAvL0B0cy1pZ25vcmUgVFlQRVNcbiAgRi5IYXNJbnN0YW5jZSA9IGZ1bmN0aW9uIChWKSB7XG4gICAgLy9AdHMtaWdub3JlIFRZUEVTXG4gICAgbGV0IHRhcmdldCA9IEYuVGFyZ2V0RnVuY3Rpb247XG4gICAgaWYgKCF0YXJnZXQuSGFzSW5zdGFuY2UpIHtcbiAgICAgIG1vbml0b3IuVGhyb3coXG4gICAgICAgIFwiVHlwZUVycm9yXCIsXG4gICAgICAgICdiaW5kIEhhc0luc3RhbmNlOiBubyBpbnRlcm5hbCBtZXRob2QgSGFzSW5zdGFuY2UnLFxuICAgICAgICBib3RcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldC5IYXNJbnN0YW5jZShWKTtcbiAgfVxuXG4gIC8vQHRzLWlnbm9yZSBUWVBFU1xuICBpZiAoVGFyZ2V0LkNsYXNzID09PSBcIkZ1bmN0aW9uXCIpIHtcbiAgICAvL0B0cy1pZ25vcmUgVFlQRVNcbiAgICBsZXQgTCA9IFRhcmdldC5sZW5ndGggLSBhcmdzLmxlbmd0aDtcbiAgICAvL0B0cy1pZ25vcmUgVFlQRVNcbiAgICBGLmxlbmd0aCA9IEwgPiAwID8gTCA6IDA7XG4gIH0gZWxzZSB7XG4gICAgLy9AdHMtaWdub3JlIFRZUEVTXG4gICAgRi5sZW5ndGggPSAwO1xuICB9XG5cbiAgLy9AdHMtaWdub3JlIFRZUEVTXG4gIERlZmluZUZGRihGLCBjb25zdGFudHMubGVuZ3RoLCBGLmxlbmd0aCk7XG4gIEYuRXh0ZW5zaWJsZSA9IHRydWU7XG5cbiAgbGV0IHRocm93ZXIgPSBUaHJvd1R5cGVFcnJvci5JbnN0YW5jZTtcbiAgRi5EZWZpbmVPd25Qcm9wZXJ0eShcbiAgICBjb25zdGFudHMuY2FsbGVyLFxuICAgIHtcbiAgICAgIC8vQHRzLWlnbm9yZSBUWVBFU1xuICAgICAgZ2V0OiB0aHJvd2VyLFxuICAgICAgLy9AdHMtaWdub3JlIFRZUEVTXG4gICAgICBzZXQ6IHRocm93ZXIsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGxhYmVsOiBib3RcbiAgICB9LFxuICAgIGZhbHNlXG4gICk7XG4gIEYuRGVmaW5lT3duUHJvcGVydHkoXG4gICAgY29uc3RhbnRzLmFyZ3VtZW50cyxcbiAgICB7XG4gICAgICAvL0B0cy1pZ25vcmUgVFlQRVNcbiAgICAgIGdldDogdGhyb3dlcixcbiAgICAgIC8vQHRzLWlnbm9yZSBUWVBFU1xuICAgICAgc2V0OiB0aHJvd2VyLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBsYWJlbDogYm90XG4gICAgfSxcbiAgICBmYWxzZVxuICApO1xuXG4gIHJldHVybiBuZXcgVmFsdWUoRiwgYm90KTtcbn0iLCJpbXBvcnQgeyBMYWJlbCwgYm90LCBsdWIgfSBmcm9tICcuLi9MYWJlbCc7XG5pbXBvcnQgeyBWYWx1ZSB9IGZyb20gXCIuLi9WYWx1ZVwiO1xuaW1wb3J0IHsgRGVmaW5lRkZGLCBEZWZpbmVURlQgfSBmcm9tICcuLi9EZWZpbmUnO1xuaW1wb3J0IHsgRWNtYU9iamVjdCB9IGZyb20gJy4uL09iamVjdHMvRWNtYU9iamVjdCc7XG5cbmltcG9ydCAqIGFzIGNvbnN0YW50cyBmcm9tICcuLi9Db25zdGFudHMnO1xuaW1wb3J0IHsgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0IH0gZnJvbSBcIi4uL09iamVjdHMvQnVpbHRpbkZ1bmN0aW9uT2JqZWN0XCI7XG5cbmltcG9ydCB7IE1vbml0b3JCYXNlIH0gZnJvbSAnLi4vTW9uaXRvckJhc2UnO1xuXG5pbXBvcnQgeyBUb0ludGVnZXIgfSBmcm9tICcuLi9Db252ZXJzaW9uL1RvSW50ZWdlcic7XG5pbXBvcnQgeyBUb1N0cmluZyB9IGZyb20gJy4uL0NvbnZlcnNpb24vVG9TdHJpbmcnO1xuaW1wb3J0IHsgVG9PYmplY3QgfSBmcm9tICcuLi9Db252ZXJzaW9uL1RvT2JqZWN0JztcbmltcG9ydCB7IENoZWNrT2JqZWN0Q29lcmNpYmxlIH0gZnJvbSAnLi4vVXRpbGl0eS9DaGVja09iamVjdENvZXJjaWJsZSc7XG5pbXBvcnQgeyBWYWx1ZVR5cGVzIH0gZnJvbSAnLi4vSW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBJc051bWJlck9iamVjdCwgTnVtYmVyT2JqZWN0IH0gZnJvbSAnLi4vT2JqZWN0cy9OdW1iZXJPYmplY3QnO1xuaW1wb3J0IHsgVG9OdW1iZXIgfSBmcm9tICcuLi9Db252ZXJzaW9uL1RvTnVtYmVyJztcblxuZGVjbGFyZSB2YXIgIG1vbml0b3I6IE1vbml0b3JCYXNlO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFRoZSBOdW1iZXIgUHJvdG90eXBlLCAxNS43LjRcbmV4cG9ydCBjbGFzcyBOdW1iZXJQcm90b3R5cGUgZXh0ZW5kcyBFY21hT2JqZWN0IHtcblxuICAgIGhvc3Q6IE51bWJlcjtcbiAgICBQcmltaXRpdmVWYWx1ZTogTnVtYmVyO1xuICAgIFByaW1pdGl2ZUxhYmVsOiBMYWJlbDtcblxuICAgIGNvbnN0cnVjdG9yKGhvc3Q6IE51bWJlcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLkNsYXNzID0gJ051bWJlcic7XG4gICAgICAgIHRoaXMuUHJpbWl0aXZlVmFsdWUgPSBuZXcgTnVtYmVyKDApO1xuICAgICAgICB0aGlzLlByaW1pdGl2ZUxhYmVsID0gYm90O1xuXG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgfVxuXG4gICAgU2V0dXAoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuUHJvdG90eXBlID0gbmV3IFZhbHVlKG1vbml0b3IuaW5zdGFuY2VzLk9iamVjdFByb3RvdHlwZSwgYm90KTtcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5jb25zdHJ1Y3RvciwgbW9uaXRvci5pbnN0YW5jZXMuTnVtYmVyQ29uc3RydWN0b3IpO1xuXG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMudG9TdHJpbmcsIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3QodG9TdHJpbmcsIDEsIHRoaXMuaG9zdC50b1N0cmluZykpO1xuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLnRvTG9jYWxlU3RyaW5nLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHRvTG9jYWxlU3RyaW5nLCAwLCB0aGlzLmhvc3QudG9Mb2NhbGVTdHJpbmcpKTtcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIG5ldyBWYWx1ZSgndmFsdWVPZicsIGJvdCksIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3QodmFsdWVPZiwgMCwgdGhpcy5ob3N0LnZhbHVlT2YpKTtcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy50b0ZpeGVkLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHRvRml4ZWQsIDAsIHRoaXMuaG9zdC50b0ZpeGVkKSk7XG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMudG9FeHBvbmVudGlhbCwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdCh0b0V4cG9uZW50aWFsLCAwLCB0aGlzLmhvc3QudG9FeHBvbmVudGlhbCkpO1xuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLnRvUHJlY2lzaW9uLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHRvUHJlY2lzaW9uLCAwLCB0aGlzLmhvc3QudG9QcmVjaXNpb24pKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydE51bWJlcih2IDogVmFsdWU8YW55PiwgY2FsbGVyIDogc3RyaW5nKSA6IG51bWJlciB7XG5cbiAgICBpZiAoSXNOdW1iZXJPYmplY3QodikpIHtcbiAgICAgICAgcmV0dXJuIHYudmFsdWUuUHJpbWl0aXZlVmFsdWUudmFsdWVPZigpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygdi52YWx1ZSA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiB2LnZhbHVlO1xuICAgIH1cblxuXG4gICAgICAgIG1vbml0b3IuY29udGV4dC5wdXNoUEModi5sYWJlbCk7XG4gICAgICAgIG1vbml0b3IuVGhyb3coXG4gICAgICAgICAgICBcIlR5cGVFcnJvclwiLFxuICAgICAgICAgICAgY2FsbGVyICsgJyBpcyBub3QgZ2VuZXJpYycsXG4gICAgICAgICAgICBib3RcbiAgICAgICAgKTtcbn1cblxuZnVuY3Rpb24gSXNOdW1iZXJPYmplY3RPck51bWJlcih4IDogVmFsdWU8YW55PikgOiB4IGlzIFZhbHVlPE51bWJlck9iamVjdCB8IG51bWJlcj4ge1xuICAgIHJldHVybiB0eXBlb2YgeC52YWx1ZSA9PT0gJ251bWJlcicgfHwgSXNOdW1iZXJPYmplY3QoeCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdG9TdHJpbmcsIDE1LjcuNC4yXG5mdW5jdGlvbiB0b1N0cmluZyh0aGlzQXJnOiBWYWx1ZTxWYWx1ZVR5cGVzPiwgYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPHN0cmluZz4ge1xuXG4gICAgaWYgKCFJc051bWJlck9iamVjdE9yTnVtYmVyKHRoaXNBcmcpKSB7XG4gICAgICAgIG1vbml0b3IuVGhyb3coXG4gICAgICAgICAgICBcIlR5cGVFcnJvclwiLFxuICAgICAgICAgICAgJ051bWJlci5wcm90b3R5cGUudG9TdHJpbmcgaXMgbm90IGdlbmVyaWMnLFxuICAgICAgICAgICAgdGhpc0FyZy5sYWJlbFxuICAgICAgICApO1xuICAgICAgICB0aHJvdyAnVHlwZVNjcmlwdCc7XG4gICAgfVxuXG4gICAgbGV0IGFyZzAgPSBhcmdzWzBdIHx8IG5ldyBWYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG4gICAgaWYgKGFyZzAudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhcmcwLnZhbHVlID0gMTA7XG4gICAgfVxuXG4gICAgbGV0IHJhZGl4ID0gVG9JbnRlZ2VyKGFyZzApO1xuICAgIGlmICh0eXBlb2YgdGhpc0FyZy52YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXNBcmcudmFsdWUudG9TdHJpbmcocmFkaXgudmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFZhbHVlKHJlc3VsdCwgbHViKHRoaXNBcmcubGFiZWwsIHJhZGl4LmxhYmVsKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpc0FyZy52YWx1ZS5QcmltaXRpdmVWYWx1ZS50b1N0cmluZyhyYWRpeC52YWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgVmFsdWUocmVzdWx0LCBsdWIodGhpc0FyZy52YWx1ZS5QcmltaXRpdmVMYWJlbCwgcmFkaXgubGFiZWwpKTtcbiAgICB9XG5cbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdG9Mb2NhbGVTdHJpbmcsIDE1LjcuNC4zXG5mdW5jdGlvbiB0b0xvY2FsZVN0cmluZyh0aGlzQXJnOiBWYWx1ZTxWYWx1ZVR5cGVzPiwgYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPHN0cmluZz4ge1xuICAgIGxldCBuZXdBcmdzID0gYXJncy5sZW5ndGggPiAwID8gYXJncy5zbGljZSgxKSA6IGFyZ3M7XG4gICAgcmV0dXJuIHRvU3RyaW5nKHRoaXNBcmcsIG5ld0FyZ3MpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHZhbHVlT2YsIDE1LjcuNC40XG5mdW5jdGlvbiB2YWx1ZU9mKHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8bnVtYmVyPiB7XG5cbiAgICBpZiAoIUlzTnVtYmVyT2JqZWN0T3JOdW1iZXIodGhpc0FyZykpIHtcbiAgICAgICAgbW9uaXRvci5UaHJvdyhcbiAgICAgICAgICAgIFwiVHlwZUVycm9yXCIsXG4gICAgICAgICAgICAnTnVtYmVyLnByb3RvdHlwZS50b1N0cmluZyBpcyBub3QgZ2VuZXJpYycsXG4gICAgICAgICAgICB0aGlzQXJnLmxhYmVsXG4gICAgICAgICk7XG4gICAgICAgIHRocm93ICdUeXBlU2NyaXB0JztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRoaXNBcmcudmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmFsdWUodGhpc0FyZy52YWx1ZSwgdGhpc0FyZy5sYWJlbCk7XG4gICAgfVxuXG4gICAgbGV0IHJlc3VsdCA9IHRoaXNBcmcudmFsdWUuUHJpbWl0aXZlVmFsdWUudmFsdWVPZigpO1xuICAgIHJldHVybiBuZXcgVmFsdWUocmVzdWx0LCB0aGlzQXJnLnZhbHVlLlByaW1pdGl2ZUxhYmVsKTtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdG9GaXhlZCwgMTUuNy40LjVcbmZ1bmN0aW9uIHRvRml4ZWQodGhpc0FyZzogVmFsdWU8TnVtYmVyT2JqZWN0PiwgYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPHN0cmluZz4ge1xuICAgIGxldCBwcmltaXRpdmVWYWx1ZSA9IGFzc2VydE51bWJlcih0aGlzQXJnLCAndG9GaXhlZCcpO1xuXG5cbiAgICBsZXQgYXJnMCA9IGFyZ3NbMF0gPyBhcmdzWzBdOiBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgIGxldCBwcmVjaXNpb24gPSBUb0ludGVnZXIoYXJnMCk7XG5cbiAgICByZXR1cm4gbmV3IFZhbHVlKHByaW1pdGl2ZVZhbHVlLnRvRml4ZWQocHJlY2lzaW9uLnZhbHVlKSwgbHViKHByZWNpc2lvbi5sYWJlbCwgdGhpc0FyZy5sYWJlbCkpO1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyB0b0V4cG9uZW50aWFsLCAxNS43LjQuNlxuZnVuY3Rpb24gdG9FeHBvbmVudGlhbCh0aGlzQXJnOiBWYWx1ZTxOdW1iZXJPYmplY3Q+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8c3RyaW5nPiB7XG4gICAgbGV0IHByaW1pdGl2ZVZhbHVlID0gYXNzZXJ0TnVtYmVyKHRoaXNBcmcsICd0b0V4cG9uZW50aWFsJyk7XG5cbiAgICBsZXQgYXJnMCA9IGFyZ3NbMF0gPyBhcmdzWzBdOiBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgIGxldCBwcmVjaXNpb24gPSBUb0ludGVnZXIoYXJnMCk7XG5cbiAgICByZXR1cm4gbmV3IFZhbHVlKHByaW1pdGl2ZVZhbHVlLnRvRXhwb25lbnRpYWwocHJlY2lzaW9uLnZhbHVlKSwgbHViKHByZWNpc2lvbi5sYWJlbCwgdGhpc0FyZy5sYWJlbCkpO1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyB0b1ByZWNpc2lvbiwgMTUuNy40LjdcbmZ1bmN0aW9uIHRvUHJlY2lzaW9uKHRoaXNBcmc6IFZhbHVlPE51bWJlck9iamVjdD4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxzdHJpbmc+IHtcbiAgICBsZXQgcHJpbWl0aXZlVmFsdWUgPSBhc3NlcnROdW1iZXIodGhpc0FyZywgJ3RvUHJlY2lzaW9uJyk7XG5cbiAgICBsZXQgYXJnMCA9IGFyZ3NbMF0gPyBhcmdzWzBdOiBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgIFxuICAgIGxldCBsYmwgPSBsdWIoYXJnMC5sYWJlbCwgdGhpc0FyZy5sYWJlbCk7XG4gICAgaWYgKGFyZzAudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgc3RyWCA9IFRvU3RyaW5nKHRoaXNBcmcpOyAvL3N0ZXAgMlxuICAgICAgICByZXR1cm4gbmV3IFZhbHVlKHN0clgudmFsdWUsIGxibCk7XG4gICAgfVxuXG4gICAgbGV0IHByZWNpc2lvbiA9IFRvSW50ZWdlcihhcmcwKTsgLy9zdGVwIDNcbiAgICBpZiAocHJpbWl0aXZlVmFsdWUgPT09IE5hTikgcmV0dXJuIG5ldyBWYWx1ZSgnTmFOJywgbGJsKTsgLy9zdGVwIDRcblxuXG4gICAgcmV0dXJuIG5ldyBWYWx1ZShwcmltaXRpdmVWYWx1ZS50b1ByZWNpc2lvbihwcmVjaXNpb24udmFsdWUpLCBsYmwpO1xufTtcbiIsImltcG9ydCB7IExhYmVsLCBsdWIsIGxlLCBib3QgfSBmcm9tICcuLi9MYWJlbCc7XG5pbXBvcnQgeyBWYWx1ZSB9IGZyb20gXCIuLi9WYWx1ZVwiO1xuaW1wb3J0IHsgRGVmaW5lVEZUIH0gZnJvbSAnLi4vRGVmaW5lJztcbmltcG9ydCB7IEVjbWFPYmplY3QgfSBmcm9tICcuLi9PYmplY3RzL0VjbWFPYmplY3QnO1xuXG5pbXBvcnQgKiBhcyBjb25zdGFudHMgZnJvbSAnLi4vQ29uc3RhbnRzJztcbmltcG9ydCB7IEJ1aWx0aW5GdW5jdGlvbk9iamVjdCB9IGZyb20gXCIuLi9PYmplY3RzL0J1aWx0aW5GdW5jdGlvbk9iamVjdFwiO1xuaW1wb3J0IHsgTW9uaXRvckJhc2UgfSBmcm9tICcuLi9Nb25pdG9yQmFzZSc7XG5cbmltcG9ydCB7IFRvU3RyaW5nIH0gZnJvbSAnLi4vQ29udmVyc2lvbi9Ub1N0cmluZyc7XG5pbXBvcnQgeyBUb09iamVjdCB9IGZyb20gJy4uL0NvbnZlcnNpb24vVG9PYmplY3QnO1xuaW1wb3J0IHsgSXNDYWxsYWJsZSB9IGZyb20gJy4uL1V0aWxpdHkvSXNDYWxsYWJsZSc7XG5pbXBvcnQgeyBWYWx1ZVR5cGVzIH0gZnJvbSAnLi4vSW50ZXJmYWNlcyc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5kZWNsYXJlIHZhciBtb25pdG9yOiBNb25pdG9yQmFzZTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBUaGUgb2JqZWN0IHByb3RvdHlwZSwgMTUuMi40XG5cbmV4cG9ydCBjbGFzcyBPYmplY3RQcm90b3R5cGUgZXh0ZW5kcyBFY21hT2JqZWN0IHtcblxuICAgIGhvc3QgOiBPYmplY3Q7XG5cbiAgICBjb25zdHJ1Y3Rvcihob3N0IDogT2JqZWN0KSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpcy5Qcm90b3R5cGUgPSBuZXcgVmFsdWUobnVsbCwgYm90KTtcbiAgICAgIHRoaXMuQ2xhc3MgPSAnT2JqZWN0JztcbiAgICAgIHRoaXMuRXh0ZW5zaWJsZSA9IHRydWU7XG4gIFxuICAgICAgdGhpcy5ob3N0ID0gaG9zdDtcbiAgICB9XG4gIFxuICAgIFNldHVwKCkge1xuICAgICAgLy8gMTUuMi40LjFcbiAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuY29uc3RydWN0b3IsIG1vbml0b3IuaW5zdGFuY2VzLk9iamVjdENvbnN0cnVjdG9yKTtcbiAgXG4gICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLnRvU3RyaW5nLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHRvU3RyaW5nLCAwLCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKSk7XG4gICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLnRvTG9jYWxlU3RyaW5nLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHRvTG9jYWxlU3RyaW5nLCAwLCBPYmplY3QucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nKSk7XG4gICAgICBEZWZpbmVURlQodGhpcywgbmV3IFZhbHVlKCd2YWx1ZU9mJywgYm90KSwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdCh2YWx1ZU9mLCAwLCBPYmplY3QucHJvdG90eXBlLnZhbHVlT2YpKTtcbiAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuaGFzT3duUHJvcGVydHksIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3QoaGFzT3duUHJvcGVydHksIDEsIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpKTtcbiAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuaXNQcm90b3R5cGVPZiwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChpc1Byb3RvdHlwZU9mLCAxLCBPYmplY3QucHJvdG90eXBlLmlzUHJvdG90eXBlT2YpKTtcbiAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMucHJvcGVydHlJc0VudW1lcmFibGUsIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3QocHJvcGVydHlJc0VudW1lcmFibGUsIDEsIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUpKTtcbiAgICB9XG4gIFxuICB9XG4gIFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpLCAxNS4yLjQuMlxuICBmdW5jdGlvbiB0b1N0cmluZyh0aGlzQXJnOiBWYWx1ZTxWYWx1ZVR5cGVzPiwgYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPHN0cmluZz4ge1xuICBcbiAgICBpZiAodGhpc0FyZy52YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgcmV0dXJuIG5ldyBWYWx1ZSgnW29iamVjdCBVbmRlZmluZWRdJywgdGhpc0FyZy5sYWJlbCk7XG4gIFxuICAgIGlmICh0aGlzQXJnLnZhbHVlID09PSBudWxsKVxuICAgICAgcmV0dXJuIG5ldyBWYWx1ZSgnW29iamVjdCBOdWxsXScsIHRoaXNBcmcubGFiZWwpO1xuICBcbiAgICBsZXQgTyA9IFRvT2JqZWN0KHRoaXNBcmcpO1xuICAgIHJldHVybiBuZXcgVmFsdWUoJ1tvYmplY3QgJyArIE8udmFsdWUuQ2xhc3MgKyAnXScsIHRoaXNBcmcubGFiZWwpO1xuICB9XG4gIFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gMTUuMi40LjNcbiAgXG4gIGZ1bmN0aW9uIHRvTG9jYWxlU3RyaW5nKHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8c3RyaW5nPiB7XG4gICAgbGV0IE8gPSBUb09iamVjdCh0aGlzQXJnKTtcbiAgICBsZXQgdG9TdHJpbmcgPSBPLkdldChjb25zdGFudHMudG9TdHJpbmcpOyAgXG4gICAgbGV0IHJlc3VsdDtcbiAgXG4gICAgbW9uaXRvci5jb250ZXh0LnB1c2hQQyh0b1N0cmluZy5sYWJlbCk7XG4gICAgaWYgKElzQ2FsbGFibGUodG9TdHJpbmcpKSB7XG4gICAgICByZXN1bHQgPSB0b1N0cmluZy5DYWxsKE8sIFtdKTtcbiAgICAgIHJlc3VsdC5yYWlzZSh0b1N0cmluZy5sYWJlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vbml0b3IuVGhyb3coXG4gICAgICAgIFwiVHlwZUVycm9yXCIsXG4gICAgICAgIFwicHJvcGVydHkgJ3RvU3RyaW5nJyBvZiBvYmplY3QgXCIgKyBPICsgXCIgaXMgbm90IGEgZnVuY3Rpb24gXCIsXG4gICAgICAgIGJvdFxuICAgICAgKTtcbiAgICB9XG4gICAgbW9uaXRvci5jb250ZXh0LnBvcFBDKCk7XG4gIFxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyAxNS4yLjQuNFxuICBcbiAgZnVuY3Rpb24gdmFsdWVPZih0aGlzQXJnOiBWYWx1ZTxWYWx1ZVR5cGVzPiwgYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPEVjbWFPYmplY3Q+IHtcbiAgICBsZXQgbyA9IFRvT2JqZWN0KHRoaXNBcmcpO1xuICAgIHJldHVybiBvO1xuICB9XG4gIFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gMTUuMi40LjVcbiAgXG4gIGZ1bmN0aW9uIGhhc093blByb3BlcnR5KHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8Ym9vbGVhbj4ge1xuICAgIGxldCBWID0gYXJnc1swXSB8fCBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgIGxldCBQID0gVG9TdHJpbmcoVik7XG4gICAgbGV0IE8gPSBUb09iamVjdCh0aGlzQXJnKTtcbiAgXG4gICAgbGV0IGRlc2MgPSBPLkdldE93blByb3BlcnR5KFApO1xuICAgIGxldCByZXN1bHQgPSBkZXNjLnZhbHVlICE9PSB1bmRlZmluZWQ7XG4gIFxuICAgIHJldHVybiBuZXcgVmFsdWUocmVzdWx0LCBkZXNjLmxhYmVsKTtcbiAgfVxuICBcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIDE1LjIuNC42XG4gIFxuICBmdW5jdGlvbiBpc1Byb3RvdHlwZU9mKHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8Ym9vbGVhbj4ge1xuICAgIGxldCBjID0gbW9uaXRvci5jb250ZXh0O1xuICBcbiAgICBsZXQgViA9IGFyZ3NbMF0gfHwgbmV3IFZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgXG4gICAgaWYgKFYudmFsdWUgPT09IG51bGwgfHwgVi52YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBWLnZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIG5ldyBWYWx1ZShmYWxzZSwgVi5sYWJlbCk7XG4gICAgfVxuICAgIFxuICAgIGMucHVzaFBDKFYubGFiZWwpO1xuICAgIGxldCBPID0gVG9PYmplY3QodGhpc0FyZyk7XG4gICAgYy5wb3BQQygpO1xuICBcbiAgICBsZXQgbGJsID0gbHViKFYubGFiZWwpO1xuICBcbiAgICBsZXQgUCA9IFYudmFsdWUuUHJvdG90eXBlO1xuICAgIFxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBsYmwgPSBsdWIobGJsLCBQLmxhYmVsKTtcblxuICAgICAgaWYgKFAudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZShmYWxzZSwgbGJsKTtcbiAgICAgIH1cbiAgXG4gICAgICBpZiAoTy52YWx1ZSA9PT0gUC52YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFZhbHVlKHRydWUsIGxibCk7XG4gICAgICB9XG4gIFxuICAgICAgaWYgKFAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09iamVjdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZjogb2JqZWN0IHdpdGggdW5kZWZpbmVkIHByb3RvdHlwZScpO1xuICAgICAgfVxuXG4gICAgICBQID0gUC52YWx1ZS5Qcm90b3R5cGU7XG4gICAgfVxuICB9XG4gIFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gMTUuMi40LjdcbiAgXG4gIGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8Ym9vbGVhbj4ge1xuICAgIGxldCBWID0gYXJnc1swXSB8fCBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgIGxldCBQID0gVG9TdHJpbmcoVik7XG4gICAgbGV0IE8gPSBUb09iamVjdCh0aGlzQXJnKTtcbiAgXG4gICAgbGV0IGRlc2MgPSBPLkdldE93blByb3BlcnR5KFApO1xuICAgIGlmIChkZXNjLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBuZXcgVmFsdWUoZmFsc2UsIGRlc2MubGFiZWwpO1xuICAgIH1cbiAgXG4gICAgcmV0dXJuIG5ldyBWYWx1ZShkZXNjLnZhbHVlLmVudW1lcmFibGUgPT09IHRydWUsIGx1YihkZXNjLmxhYmVsLCBkZXNjLnZhbHVlLmxhYmVsKSk7XG4gIH0iLCJpbXBvcnQgeyBFcnJvclByb3RvdHlwZSB9IGZyb20gXCIuL0Vycm9yUHJvdG90eXBlXCI7XG5pbXBvcnQgeyBNb25pdG9yQmFzZSB9IGZyb20gXCIuLi9Nb25pdG9yQmFzZVwiO1xuXG5kZWNsYXJlIHZhciBtb25pdG9yOiBNb25pdG9yQmFzZTtcblxuZXhwb3J0IGNsYXNzIFJhbmdlRXJyb3JQcm90b3R5cGUgZXh0ZW5kcyBFcnJvclByb3RvdHlwZSB7XG5cbiAgICBjb25zdHJ1Y3Rvcihob3N0OiBSYW5nZUVycm9yKSB7XG4gICAgICAgIHN1cGVyKGhvc3QpO1xuICAgIH1cblxuICAgIFNldHVwKCk6IHZvaWQge1xuICAgICAgICB0aGlzLlNldHVwQmFzZShtb25pdG9yLmluc3RhbmNlcy5FcnJvckNvbnN0cnVjdG9yLCAnUmFuZ2VFcnJvcicpO1xuICAgIH1cblxufSIsImltcG9ydCB7IEVycm9yUHJvdG90eXBlIH0gZnJvbSBcIi4vRXJyb3JQcm90b3R5cGVcIjtcbmltcG9ydCB7IE1vbml0b3JCYXNlIH0gZnJvbSBcIi4uL01vbml0b3JCYXNlXCI7XG5cbmRlY2xhcmUgdmFyIG1vbml0b3I6IE1vbml0b3JCYXNlO1xuXG5leHBvcnQgY2xhc3MgUmVmZXJlbmNlRXJyb3JQcm90b3R5cGUgZXh0ZW5kcyBFcnJvclByb3RvdHlwZSB7XG5cbiAgICBjb25zdHJ1Y3Rvcihob3N0OiBSZWZlcmVuY2VFcnJvcikge1xuICAgICAgICBzdXBlcihob3N0KTtcbiAgICB9XG5cbiAgICBTZXR1cCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5TZXR1cEJhc2UobW9uaXRvci5pbnN0YW5jZXMuRXJyb3JDb25zdHJ1Y3RvciwgJ1JlZmVyZW5jZUVycm9yJyk7XG4gICAgfVxuXG59IiwiXG5pbXBvcnQgeyBWYWx1ZSB9IGZyb20gXCIuLi9WYWx1ZVwiO1xuaW1wb3J0ICogYXMgY29uc3RhbnRzIGZyb20gJy4uL0NvbnN0YW50cyc7XG5pbXBvcnQgKiBhcyBfIGZyb20gJ3VuZGVyc2NvcmUnO1xuaW1wb3J0IHsgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0IH0gZnJvbSBcIi4uL09iamVjdHMvQnVpbHRpbkZ1bmN0aW9uT2JqZWN0XCI7XG5pbXBvcnQgeyBBcnJheU9iamVjdCB9IGZyb20gJy4uL09iamVjdHMvQXJyYXlPYmplY3QnO1xuaW1wb3J0IHsgVG9JbnRlZ2VyIH0gZnJvbSAnLi4vQ29udmVyc2lvbi9Ub0ludGVnZXInO1xuaW1wb3J0IHsgVG9TdHJpbmcgfSBmcm9tICcuLi9Db252ZXJzaW9uL1RvU3RyaW5nJztcbmltcG9ydCB7IE1vbml0b3JCYXNlIH0gZnJvbSAnLi4vTW9uaXRvckJhc2UnO1xuXG5pbXBvcnQgeyBib3QsIGx1YiB9IGZyb20gJy4uL0xhYmVsJztcbmltcG9ydCB7IERlZmluZUZGRiwgRGVmaW5lVEZULCBEZWZpbmVURkYgfSBmcm9tICcuLi9EZWZpbmUnO1xuaW1wb3J0IHsgRWNtYU9iamVjdCB9IGZyb20gJy4uL09iamVjdHMvRWNtYU9iamVjdCc7XG5pbXBvcnQgeyBWYWx1ZVR5cGVzIH0gZnJvbSBcIi4uL0ludGVyZmFjZXNcIjtcbmltcG9ydCB7IElzUmVnRXhwT2JqZWN0LCBSZWdFeHBPYmplY3QgfSBmcm9tIFwiLi4vT2JqZWN0cy9SZWdFeHBPYmplY3RcIjtcblxuXG5kZWNsYXJlIHZhciBtb25pdG9yOiBNb25pdG9yQmFzZTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBUaGUgUmVnRXhwIFByb3RvdHlwZSwgMTUuMTAuNlxuZXhwb3J0IGNsYXNzIFJlZ0V4cFByb3RvdHlwZSBleHRlbmRzIEVjbWFPYmplY3Qge1xuXG4gICAgaG9zdDogUmVnRXhwO1xuXG4gICAgY29uc3RydWN0b3IoaG9zdCA6IFJlZ0V4cCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLkNsYXNzID0gJ1JlZ0V4cCc7XG5cbiAgICAgICAgdGhpcy5ob3N0ID0gaG9zdDtcbiAgICB9XG5cbiAgICBTZXR1cCgpIDogdm9pZCB7XG4gICAgICAgIHRoaXMuUHJvdG90eXBlID0gbmV3IFZhbHVlKG1vbml0b3IuaW5zdGFuY2VzLk9iamVjdFByb3RvdHlwZSwgYm90KTtcblxuICAgICAgICBEZWZpbmVGRkYodGhpcywgY29uc3RhbnRzLnNvdXJjZSwgJycpO1xuICAgICAgICBEZWZpbmVGRkYodGhpcywgY29uc3RhbnRzLmdsb2JhbCwgZmFsc2UpO1xuICAgICAgICBEZWZpbmVGRkYodGhpcywgY29uc3RhbnRzLmlnbm9yZUNhc2UsIGZhbHNlKTtcbiAgICAgICAgRGVmaW5lRkZGKHRoaXMsIGNvbnN0YW50cy5tdWx0aWxpbmUsIGZhbHNlKTtcbiAgICAgICAgRGVmaW5lVEZGKHRoaXMsIGNvbnN0YW50cy5sYXN0SW5kZXgsIDApO1xuXG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuY29uc3RydWN0b3IsIG1vbml0b3IuaW5zdGFuY2VzLlJlZ0V4cENvbnN0cnVjdG9yKTtcblxuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLmV4ZWMsIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3QoZXhlYywgMSwgUmVnRXhwLnByb3RvdHlwZS5leGVjKSk7XG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMudGVzdCwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdCh0ZXN0LCAxLCBSZWdFeHAucHJvdG90eXBlLnRlc3QpKTtcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy50b1N0cmluZywgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdCh0b1N0cmluZywgMCwgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZykpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0UmVnRXhwKHYgOiBWYWx1ZTxhbnk+LCBjYWxsZXIgOiBzdHJpbmcpIDogdm9pZCB7XG5cbiAgICBpZiAoIUlzUmVnRXhwT2JqZWN0KHYpKSB7XG4gICAgICAgIG1vbml0b3IuY29udGV4dC5wdXNoUEModi5sYWJlbCk7XG4gICAgICAgIG1vbml0b3IuVGhyb3coXG4gICAgICAgICAgICBcIlR5cGVFcnJvclwiLFxuICAgICAgICAgICAgY2FsbGVyICsgJyBpcyBub3QgZ2VuZXJpYycsXG4gICAgICAgICAgICBib3RcbiAgICAgICAgKTtcbiAgICB9XG5cbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBleGVjLCAxNS4xMC42LjJcbmZ1bmN0aW9uIGV4ZWModGhpc0FyZzogVmFsdWU8UmVnRXhwT2JqZWN0PiwgYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPFZhbHVlVHlwZXM+IHtcbiAgICBhc3NlcnRSZWdFeHAodGhpc0FyZywgJ2V4ZWMnKTtcblxuICAgIHZhciBzdHJpbmcgPSBhcmdzWzBdIHx8IG5ldyBWYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG4gICAgdmFyIFMgPSBUb1N0cmluZyhzdHJpbmcpO1xuXG4gICAgdmFyIGxhc3RJbmRleCA9IFRvSW50ZWdlcih0aGlzQXJnLkdldChjb25zdGFudHMubGFzdEluZGV4KSk7XG5cbiAgICB2YXIgcHJlID0gdGhpc0FyZy52YWx1ZS5QcmltaXRpdmVWYWx1ZTtcbiAgICBwcmUubGFzdEluZGV4ID0gbGFzdEluZGV4LnZhbHVlO1xuXG4gICAgdmFyIHJlcyA9IHByZS5leGVjKFMudmFsdWUpO1xuXG4gICAgdmFyIGwgPSBsdWIodGhpc0FyZy5sYWJlbCwgUy5sYWJlbCwgbGFzdEluZGV4LmxhYmVsKTtcblxuICAgIGlmIChyZXMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZShudWxsLCBsKTtcbiAgICB9XG5cbiAgICB0aGlzQXJnLlB1dChjb25zdGFudHMubGFzdEluZGV4LCBuZXcgVmFsdWUocHJlLmxhc3RJbmRleCwgbCkpO1xuXG4gICAgdmFyIGFycmF5ID0gQXJyYXlPYmplY3QuZnJvbUFycmF5KHJlcywgbCwgbCk7XG5cbiAgICBhcnJheS5EZWZpbmVPd25Qcm9wZXJ0eShjb25zdGFudHMuaW5kZXgsXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhbHVlOiByZXMuaW5kZXgsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBsYWJlbDogbFxuICAgICAgICB9XG4gICAgKTtcblxuICAgIGFycmF5LkRlZmluZU93blByb3BlcnR5KGNvbnN0YW50cy5pbnB1dCxcbiAgICAgICAge1xuICAgICAgICAgICAgdmFsdWU6IHJlcy5pbnB1dCxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGxhYmVsOiBsXG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgcmV0dXJuIG5ldyBWYWx1ZShhcnJheSwgYm90KTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyB0ZXN0LCAxNS4xMC42LjNcbmZ1bmN0aW9uIHRlc3QodGhpc0FyZzogVmFsdWU8UmVnRXhwT2JqZWN0PiwgYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPFZhbHVlVHlwZXM+IHtcbiAgICBhc3NlcnRSZWdFeHAodGhpc0FyZywgJ3Rlc3QnKTtcblxuICAgIHZhciByZXMgPSBleGVjKHRoaXNBcmcsIGFyZ3MpO1xuICAgIHJldHVybiBuZXcgVmFsdWUocmVzLnZhbHVlICE9PSBudWxsLCByZXMubGFiZWwpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHRvU3RyaW5nLCAxNS4xMC42LjNcbmZ1bmN0aW9uIHRvU3RyaW5nKHRoaXNBcmc6IFZhbHVlPFJlZ0V4cE9iamVjdD4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxWYWx1ZVR5cGVzPiB7XG4gICAgYXNzZXJ0UmVnRXhwKHRoaXNBcmcsICd0b1N0cmluZycpO1xuXG4gICAgcmV0dXJuIG5ldyBWYWx1ZSh0aGlzQXJnLnZhbHVlLlByaW1pdGl2ZVZhbHVlLnRvU3RyaW5nKCksIHRoaXNBcmcubGFiZWwpO1xufVxuIiwiXG5pbXBvcnQgeyBWYWx1ZSB9IGZyb20gXCIuLi9WYWx1ZVwiO1xuaW1wb3J0ICogYXMgY29uc3RhbnRzIGZyb20gJy4uL0NvbnN0YW50cyc7XG5pbXBvcnQgeyBCdWlsdGluRnVuY3Rpb25PYmplY3QgfSBmcm9tIFwiLi4vT2JqZWN0cy9CdWlsdGluRnVuY3Rpb25PYmplY3RcIjtcbmltcG9ydCB7IEFycmF5T2JqZWN0IH0gZnJvbSAnLi4vT2JqZWN0cy9BcnJheU9iamVjdCc7XG5pbXBvcnQgeyBUb0ludGVnZXIgfSBmcm9tICcuLi9Db252ZXJzaW9uL1RvSW50ZWdlcic7XG5pbXBvcnQgeyBUb1N0cmluZyB9IGZyb20gJy4uL0NvbnZlcnNpb24vVG9TdHJpbmcnO1xuaW1wb3J0IHsgQ2hlY2tPYmplY3RDb2VyY2libGUgfSBmcm9tICcuLi9VdGlsaXR5L0NoZWNrT2JqZWN0Q29lcmNpYmxlJztcbmltcG9ydCB7IE1vbml0b3JCYXNlIH0gZnJvbSAnLi4vTW9uaXRvckJhc2UnO1xuXG5pbXBvcnQgeyBEZWZpbmVURlQgfSBmcm9tICcuLi9EZWZpbmUnO1xuaW1wb3J0IHsgRWNtYU9iamVjdCB9IGZyb20gJy4uL09iamVjdHMvRWNtYU9iamVjdCc7XG5cbmltcG9ydCB7IGJvdCwgTGFiZWwsIGx1YiwgbGUgfSBmcm9tICcuLi9MYWJlbCc7XG5pbXBvcnQgeyBWYWx1ZVR5cGVzIH0gZnJvbSBcIi4uL0ludGVyZmFjZXNcIjtcbmltcG9ydCB7IElzU3RyaW5nT2JqZWN0IH0gZnJvbSBcIi4uL09iamVjdHMvU3RyaW5nT2JqZWN0XCI7XG5pbXBvcnQgeyBJc1JlZ0V4cE9iamVjdCwgUmVnRXhwT2JqZWN0IH0gZnJvbSBcIi4uL09iamVjdHMvUmVnRXhwT2JqZWN0XCI7XG5pbXBvcnQgeyBJc0NhbGxhYmxlIH0gZnJvbSBcIi4uL1V0aWxpdHkvSXNDYWxsYWJsZVwiO1xuaW1wb3J0IHsgVG9JbnQzMiB9IGZyb20gXCIuLi9Db252ZXJzaW9uL1RvSW50MzJcIjtcbmltcG9ydCB7IFRvTnVtYmVyIH0gZnJvbSBcIi4uL0NvbnZlcnNpb24vVG9OdW1iZXJcIjtcblxuZGVjbGFyZSB2YXIgbW9uaXRvcjogTW9uaXRvckJhc2U7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVGhlIFN0cmluZyBQcm90b3R5cGUsIDE1LjUuNFxuZXhwb3J0IGNsYXNzIFN0cmluZ1Byb3RvdHlwZSBleHRlbmRzIEVjbWFPYmplY3Qge1xuXG4gICAgaG9zdDogU3RyaW5nO1xuXG4gICAgUHJpbWl0aXZlVmFsdWU6IHN0cmluZztcbiAgICBQcmltaXRpdmVMYWJlbDogTGFiZWw7XG5cbiAgICBjb25zdHJ1Y3Rvcihob3N0OiBTdHJpbmcpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5DbGFzcyA9ICdTdHJpbmcnO1xuICAgICAgICB0aGlzLlByaW1pdGl2ZVZhbHVlID0gJyc7XG4gICAgICAgIHRoaXMuUHJpbWl0aXZlTGFiZWwgPSBib3Q7XG5cbiAgICAgICAgLy9AdHMtaWdub3JlIFRZUEVTXG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IG5ldyBTdHJpbmcoJycpO1xuICAgICAgICB0aGlzLmxhYmVscy5sZW5ndGggPSB7XG4gICAgICAgICAgICB2YWx1ZTogYm90LFxuICAgICAgICAgICAgZXhpc3RlbmNlOiBib3RcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmhvc3QgPSBob3N0O1xuICAgIH1cblxuICAgIFNldHVwKCk6IHZvaWQge1xuICAgICAgICB0aGlzLlByb3RvdHlwZSA9IG5ldyBWYWx1ZShtb25pdG9yLmluc3RhbmNlcy5PYmplY3RQcm90b3R5cGUsIGJvdCk7XG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuY29uc3RydWN0b3IsIG1vbml0b3IuaW5zdGFuY2VzLlN0cmluZ0NvbnN0cnVjdG9yKTtcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy50b1N0cmluZywgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdCh0b1N0cmluZywgMCwgdGhpcy5ob3N0LnRvU3RyaW5nKSk7XG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMudmFsdWVPZiwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdCh2YWx1ZU9mLCAwLCB0aGlzLmhvc3QudmFsdWVPZikpO1xuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLmNoYXJBdCwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChjaGFyQXQsIDEsIHRoaXMuaG9zdC5jaGFyQXQpKTtcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5jaGFyQ29kZUF0LCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KGNoYXJDb2RlQXQsIDEsIHRoaXMuaG9zdC5jaGFyQ29kZUF0KSk7XG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuY29uY2F0LCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KGNvbmNhdCwgMSwgdGhpcy5ob3N0LmNvbmNhdCkpO1xuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLmluZGV4T2YsIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3QoaW5kZXhPZiwgMSwgdGhpcy5ob3N0LmluZGV4T2YpKTtcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5sYXN0SW5kZXhPZiwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChsYXN0SW5kZXhPZiwgMSwgdGhpcy5ob3N0Lmxhc3RJbmRleE9mKSk7XG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMubG9jYWxlQ29tcGFyZSwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChsb2NhbGVDb21wYXJlLCAxLCB0aGlzLmhvc3QubG9jYWxlQ29tcGFyZSkpO1xuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLm1hdGNoLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KG1hdGNoLCAxLCB0aGlzLmhvc3QubWF0Y2gpKTtcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5yZXBsYWNlLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHJlcGxhY2UsIDIsIHRoaXMuaG9zdC5yZXBsYWNlKSk7XG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuc2VhcmNoLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHNlYXJjaCwgMSwgdGhpcy5ob3N0LnNlYXJjaCkpO1xuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLnNsaWNlLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHNsaWNlLCAyLCB0aGlzLmhvc3Quc2xpY2UpKTtcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5zcGxpdCwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdChzcGxpdCwgMiwgdGhpcy5ob3N0LnNwbGl0KSk7XG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMuc3Vic3RyaW5nLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHN1YnN0cmluZywgMiwgdGhpcy5ob3N0LnN1YnN0cmluZykpO1xuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLnRvTG93ZXJDYXNlLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHRvTG93ZXJDYXNlLCAwLCB0aGlzLmhvc3QudG9Mb3dlckNhc2UpKTtcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy50b0xvY2FsZUxvd2VyQ2FzZSwgbmV3IEJ1aWx0aW5GdW5jdGlvbk9iamVjdCh0b0xvY2FsZUxvd2VyQ2FzZSwgMCwgdGhpcy5ob3N0LnRvTG9jYWxlTG93ZXJDYXNlKSk7XG4gICAgICAgIERlZmluZVRGVCh0aGlzLCBjb25zdGFudHMudG9VcHBlckNhc2UsIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3QodG9VcHBlckNhc2UsIDAsIHRoaXMuaG9zdC50b1VwcGVyQ2FzZSkpO1xuICAgICAgICBEZWZpbmVURlQodGhpcywgY29uc3RhbnRzLnRvTG9jYWxlVXBwZXJDYXNlLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHRvTG9jYWxlVXBwZXJDYXNlLCAwLCB0aGlzLmhvc3QudG9Mb2NhbGVVcHBlckNhc2UpKTtcbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy50cmltLCBuZXcgQnVpbHRpbkZ1bmN0aW9uT2JqZWN0KHRyaW0sIDAsIHRoaXMuaG9zdC50cmltKSk7XG5cbiAgICAgICAgRGVmaW5lVEZUKHRoaXMsIGNvbnN0YW50cy5zdWJzdHIsIG5ldyBCdWlsdGluRnVuY3Rpb25PYmplY3Qoc3Vic3RyLCAyLCB0aGlzLmhvc3Quc3Vic3RyKSk7XG4gICAgfVxufVxuXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdG9TdHJpbmcsIDE1LjUuNC4yXG5mdW5jdGlvbiB0b1N0cmluZyh0aGlzQXJnOiBWYWx1ZTxWYWx1ZVR5cGVzPiwgYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPHN0cmluZz4ge1xuXG4gICAgaWYgKHR5cGVvZiB0aGlzQXJnLnZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gbmV3IFZhbHVlKHRoaXNBcmcudmFsdWUsIHRoaXNBcmcubGFiZWwpO1xuICAgIH1cblxuICAgIGlmICghSXNTdHJpbmdPYmplY3QodGhpc0FyZykpIHtcbiAgICAgICAgbW9uaXRvci5UaHJvdyhcbiAgICAgICAgICAgIFwiVHlwZUVycm9yXCIsXG4gICAgICAgICAgICAnU3RyaW5nLnByb3RvdHlwZS50b1N0cmluZyBpcyBub3QgZ2VuZXJpYycsXG4gICAgICAgICAgICB0aGlzQXJnLmxhYmVsXG4gICAgICAgICk7XG4gICAgICAgIHRocm93ICdUeXBlU2NyaXB0JztcbiAgICB9XG5cbiAgICBsZXQgcmVzdWx0ID0gdGhpc0FyZy52YWx1ZS5QcmltaXRpdmVWYWx1ZS50b1N0cmluZygpO1xuICAgIHJldHVybiBuZXcgVmFsdWUocmVzdWx0LCB0aGlzQXJnLnZhbHVlLlByaW1pdGl2ZUxhYmVsKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyB2YWx1ZU9mLCAxNS41LjQuM1xubGV0IHZhbHVlT2YgPSB0b1N0cmluZztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBjaGFyQXQsIDE1LjUuNC40XG5mdW5jdGlvbiBjaGFyQXQodGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxzdHJpbmc+IHtcbiAgICBsZXQgcG9zID0gYXJnc1swXSB8fCBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgIENoZWNrT2JqZWN0Q29lcmNpYmxlKHRoaXNBcmcpO1xuICAgIGxldCBTID0gVG9TdHJpbmcodGhpc0FyZyk7XG4gICAgbGV0IHBvc2l0aW9uID0gVG9JbnRlZ2VyKHBvcyk7XG5cbiAgICBsZXQgYyA9IFMudmFsdWUuY2hhckF0KHBvc2l0aW9uLnZhbHVlKTtcbiAgICByZXR1cm4gbmV3IFZhbHVlKGMsIGx1Yihwb3NpdGlvbi5sYWJlbCwgUy5sYWJlbCkpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGNoYXJDb2RlQXQsIDE1LjUuNC41XG5mdW5jdGlvbiBjaGFyQ29kZUF0KHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8bnVtYmVyPiB7XG4gICAgbGV0IHBvcyA9IGFyZ3NbMF0gfHwgbmV3IFZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgICBDaGVja09iamVjdENvZXJjaWJsZSh0aGlzQXJnKTtcbiAgICBsZXQgUyA9IFRvU3RyaW5nKHRoaXNBcmcpO1xuICAgIGxldCBwb3NpdGlvbiA9IFRvSW50ZWdlcihwb3MpO1xuXG4gICAgbGV0IGMgPSBTLnZhbHVlLmNoYXJDb2RlQXQocG9zaXRpb24udmFsdWUpO1xuICAgIHJldHVybiBuZXcgVmFsdWUoYywgbHViKHBvc2l0aW9uLmxhYmVsLCB0aGlzQXJnLmxhYmVsKSk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gY29uY2F0LCAxNS41LjQuNlxuZnVuY3Rpb24gY29uY2F0KHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8c3RyaW5nPiB7XG4gICAgQ2hlY2tPYmplY3RDb2VyY2libGUodGhpc0FyZyk7XG4gICAgbGV0IFMgPSBUb1N0cmluZyh0aGlzQXJnKTtcbiAgICBsZXQgbGJsID0gbmV3IExhYmVsKCk7XG4gICAgbGV0IF9hcmdzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBhcmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGxldCBhcmcgPSBUb1N0cmluZyhhcmdzW2ldKTtcbiAgICAgICAgbGJsID0gbHViKGxibCwgYXJnLmxhYmVsKTtcbiAgICAgICAgX2FyZ3NbaV0gPSBhcmcudmFsdWU7XG4gICAgfVxuICAgIGxldCBzdHI6IHN0cmluZyA9IFMudmFsdWUuY29uY2F0LmFwcGx5KFMudmFsdWUsIF9hcmdzKTtcbiAgICBsYmwgPSBsdWIobGJsLCB0aGlzQXJnLmxhYmVsKTtcbiAgICByZXR1cm4gbmV3IFZhbHVlKHN0ciwgbGJsKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBpbmRleE9mLCAxNS41LjQuN1xuZnVuY3Rpb24gaW5kZXhPZih0aGlzQXJnOiBWYWx1ZTxWYWx1ZVR5cGVzPiwgYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPG51bWJlcj4ge1xuICAgIGxldCBzZWFyY2hTdHJpbmcgPSBhcmdzWzBdIHx8IG5ldyBWYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG4gICAgbGV0IHBvc2l0aW9uID0gYXJnc1sxXSB8fCBuZXcgVmFsdWUoMCwgYm90KTtcblxuICAgIENoZWNrT2JqZWN0Q29lcmNpYmxlKHRoaXNBcmcpO1xuICAgIGxldCBTID0gVG9TdHJpbmcodGhpc0FyZyk7XG4gICAgbGV0IHNlYXJjaFN0ciA9IFRvU3RyaW5nKHNlYXJjaFN0cmluZyk7XG4gICAgbGV0IHBvcyA9IFRvSW50ZWdlcihwb3NpdGlvbik7XG5cbiAgICBsZXQgbGJsID0gbHViKFMubGFiZWwsIHNlYXJjaFN0ci5sYWJlbCwgcG9zLmxhYmVsKTtcbiAgICBsZXQgc3RyID0gUy52YWx1ZS5pbmRleE9mKHNlYXJjaFN0ci52YWx1ZSwgcG9zLnZhbHVlKTtcblxuICAgIHJldHVybiBuZXcgVmFsdWUoc3RyLCBsYmwpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGxhc3RJbmRleE9mLCAxNS41LjQuOFxuZnVuY3Rpb24gbGFzdEluZGV4T2YodGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxudW1iZXI+IHtcbiAgICBsZXQgc2VhcmNoU3RyaW5nID0gYXJnc1swXSB8fCBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgIGxldCBwb3NpdGlvbiA9IGFyZ3NbMV0gfHwgbmV3IFZhbHVlKHVuZGVmaW5lZCwgYm90KTtcblxuICAgIENoZWNrT2JqZWN0Q29lcmNpYmxlKHRoaXNBcmcpO1xuICAgIGxldCBTID0gVG9TdHJpbmcodGhpc0FyZyk7XG4gICAgbGV0IHNlYXJjaFN0ciA9IFRvU3RyaW5nKHNlYXJjaFN0cmluZyk7XG5cbiAgICBsZXQgcG9zID0gVG9OdW1iZXIocG9zaXRpb24pO1xuICAgIGlmIChpc05hTihwb3MudmFsdWUpKSB7XG4gICAgICAgIHBvcy52YWx1ZSA9IEluZmluaXR5O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHBvcyA9IFRvSW50ZWdlcihwb3MpXG4gICAgfVxuICAgIFxuICAgIGxldCBsYmwgPSBsdWIoUy5sYWJlbCwgc2VhcmNoU3RyLmxhYmVsLCBwb3MubGFiZWwpO1xuXG4gICAgbGV0IHN0ciA9IFMudmFsdWUubGFzdEluZGV4T2Yoc2VhcmNoU3RyLnZhbHVlLCBwb3MudmFsdWUpO1xuXG4gICAgcmV0dXJuIG5ldyBWYWx1ZShzdHIsIGxibCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gbG9jYWxlQ29tcGFyZSwgMTUuNS40LjlcbmZ1bmN0aW9uIGxvY2FsZUNvbXBhcmUodGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxudW1iZXI+IHtcbiAgICBsZXQgYXJnMCA9IGFyZ3NbMF0gfHwgbmV3IFZhbHVlKHVuZGVmaW5lZCwgYm90KTtcblxuICAgIENoZWNrT2JqZWN0Q29lcmNpYmxlKHRoaXNBcmcpO1xuICAgIGxldCBTID0gVG9TdHJpbmcodGhpc0FyZyk7XG4gICAgbGV0IHRoYXQgPSBUb1N0cmluZyhhcmcwKTtcblxuICAgIGxldCBsYmwgPSBsdWIoUy5sYWJlbCwgdGhhdC5sYWJlbCk7XG4gICAgbGV0IHJlc3VsdCA9IFMudmFsdWUubG9jYWxlQ29tcGFyZSh0aGF0LnZhbHVlKTtcblxuICAgIHJldHVybiBuZXcgVmFsdWUocmVzdWx0LCBsYmwpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIG1hdGNoLCAxNS41LjQuMTBcbmZ1bmN0aW9uIG1hdGNoKHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8QXJyYXlPYmplY3QgfCBudWxsPiB7XG4gICAgbGV0IHJlZ2V4cCA9IGFyZ3NbMF0gfHwgbmV3IFZhbHVlKHVuZGVmaW5lZCwgYm90KTtcblxuICAgIENoZWNrT2JqZWN0Q29lcmNpYmxlKHRoaXNBcmcpO1xuICAgIGxldCBTID0gVG9TdHJpbmcodGhpc0FyZyk7XG5cbiAgICBsZXQgcng6IFZhbHVlPFJlZ0V4cE9iamVjdD47XG4gICAgaWYgKElzUmVnRXhwT2JqZWN0KHJlZ2V4cCkpIHtcbiAgICAgICAgcnggPSByZWdleHA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcnggPSBtb25pdG9yLmluc3RhbmNlcy5SZWdFeHBDb25zdHJ1Y3Rvci5Db25zdHJ1Y3QoW3JlZ2V4cF0pO1xuICAgIH1cblxuICAgIGxldCBsYmwgPSBsdWIoUy5sYWJlbCwgcngudmFsdWUuUHJpbWl0aXZlTGFiZWwpO1xuICAgIG1vbml0b3IuYXNzZXJ0KFxuICAgICAgICBsZShyeC5sYWJlbCwgcngudmFsdWUuUHJpbWl0aXZlTGFiZWwpLFxuICAgICAgICAnU3RyaW5nLnByb3RvdHlwZS5tYXRjaDogbGFiZWwgb2YgcmVndWxhciBleHByZXNzaW9uIG9iamVjdCBub3QgYmVsb3cgcmVndWxhciBleHByZXNzaW9uIGxhYmVsJ1xuICAgICk7XG5cbiAgICByeC52YWx1ZS5QcmltaXRpdmVMYWJlbCA9IGxibDtcbiAgICBsZXQgcHJpbWl0aXZlQXJyYXkgPSBTLnZhbHVlLm1hdGNoKHJ4LnZhbHVlLlByaW1pdGl2ZVZhbHVlKTtcblxuICAgIGlmIChwcmltaXRpdmVBcnJheSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbmV3IFZhbHVlKG51bGwsIGxibCk7XG4gICAgfVxuXG4gICAgbGV0IGFycmF5ID0gQXJyYXlPYmplY3QuZnJvbUFycmF5KHByaW1pdGl2ZUFycmF5LCBsYmwsIGxibCk7XG5cbiAgICBhcnJheS5EZWZpbmVPd25Qcm9wZXJ0eShjb25zdGFudHMuaW5kZXgsXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhbHVlOiBwcmltaXRpdmVBcnJheS5pbmRleCxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGxhYmVsOiBsYmxcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICBhcnJheS5EZWZpbmVPd25Qcm9wZXJ0eShjb25zdGFudHMuaW5wdXQsXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhbHVlOiBwcmltaXRpdmVBcnJheS5pbnB1dCxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGxhYmVsOiBsYmxcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICByZXR1cm4gbmV3IFZhbHVlKGFycmF5LCBib3QpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHJlcGxhY2UsIDE1LjUuNC4xMVxuZnVuY3Rpb24gcmVwbGFjZSh0aGlzQXJnOiBWYWx1ZTxWYWx1ZVR5cGVzPiwgYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPHN0cmluZz4ge1xuICAgIGxldCBhcmcwID0gYXJnc1swXSB8fCBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuICAgIGxldCBhcmcxID0gYXJnc1sxXSB8fCBuZXcgVmFsdWUodW5kZWZpbmVkLCBib3QpO1xuXG4gICAgQ2hlY2tPYmplY3RDb2VyY2libGUodGhpc0FyZyk7XG4gICAgbGV0IFMgPSBUb1N0cmluZyh0aGlzQXJnKTtcblxuICAgIGxldCBzVjogUmVnRXhwIHwgc3RyaW5nLCByVjogKCgpID0+IHN0cmluZykgfCBzdHJpbmc7XG5cbiAgICBsZXQgbGFiZWwgPSBsdWIoYXJnMC5sYWJlbCwgYXJnMS5sYWJlbCk7XG5cbiAgICBpZiAoSXNSZWdFeHBPYmplY3QoYXJnMCkpIHtcbiAgICAgICAgc1YgPSBhcmcwLnZhbHVlLlByaW1pdGl2ZVZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBzZWFyY2hWYWx1ZSA9IFRvU3RyaW5nKGFyZzApO1xuICAgICAgICBsYWJlbCA9IGx1YihsYWJlbCwgc2VhcmNoVmFsdWUubGFiZWwpO1xuICAgICAgICBzViA9IHNlYXJjaFZhbHVlLnZhbHVlO1xuICAgIH1cblxuICAgIGxldCBmTCA9IGJvdDtcblxuICAgIGlmIChJc0NhbGxhYmxlKGFyZzEpKSB7XG4gICAgICAgIHJWID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbGV0IF9hcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIF9hcmdzW2ldID0gbmV3IFZhbHVlKGFyZ3VtZW50c1tpXSwgbGFiZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2FyZ3MubGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCByZXMgPSBhcmcxLkNhbGwoYXJnMSwgX2FyZ3MpO1xuICAgICAgICAgICAgbGV0IHN0clJlcyA9IFRvU3RyaW5nKHJlcylcbiAgICAgICAgICAgIGZMID0gbHViKGZMLCBzdHJSZXMubGFiZWwpO1xuICAgICAgICAgICAgcmV0dXJuIHN0clJlcy52YWx1ZTtcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgcmVwbGFjZVZhbHVlID0gVG9TdHJpbmcoYXJnMSk7XG4gICAgICAgIHJWID0gcmVwbGFjZVZhbHVlLnZhbHVlO1xuICAgIH1cblxuICAgIC8vQHRzLWlnbm9yZSBUWVBFU1xuICAgIGxldCByZXMgPSBTLnZhbHVlLnJlcGxhY2Uoc1YsIHJWKTtcblxuICAgIHJldHVybiBuZXcgVmFsdWUocmVzLCBsdWIobGFiZWwsIGZMKSk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc2VhcmNoLCAxNS41LjQuMTJcbmZ1bmN0aW9uIHNlYXJjaCh0aGlzQXJnOiBWYWx1ZTxWYWx1ZVR5cGVzPiwgYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPG51bWJlcj4ge1xuICAgIGxldCByZWdleHAgPSBhcmdzWzBdIHx8IG5ldyBWYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG5cbiAgICBDaGVja09iamVjdENvZXJjaWJsZSh0aGlzQXJnKTtcbiAgICBsZXQgc3RyaW5nID0gVG9TdHJpbmcodGhpc0FyZyk7XG5cbiAgICBsZXQgcng6IFZhbHVlPFJlZ0V4cE9iamVjdD47XG4gICAgaWYgKElzUmVnRXhwT2JqZWN0KHJlZ2V4cCkpIHtcbiAgICAgICAgcnggPSByZWdleHA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcnggPSBtb25pdG9yLmluc3RhbmNlcy5SZWdFeHBDb25zdHJ1Y3Rvci5Db25zdHJ1Y3QoW3JlZ2V4cF0pO1xuICAgIH1cblxuICAgIGxldCBsYmwgPSBsdWIoc3RyaW5nLmxhYmVsLCByeC52YWx1ZS5QcmltaXRpdmVMYWJlbCk7XG4gICAgbW9uaXRvci5hc3NlcnQoXG4gICAgICAgIGxlKHJ4LmxhYmVsLCByeC52YWx1ZS5QcmltaXRpdmVMYWJlbCksXG4gICAgICAgICdTdHJpbmcucHJvdG90eXBlLm1hdGNoOiBsYWJlbCBvZiByZWd1bGFyIGV4cHJlc3Npb24gb2JqZWN0IG5vdCBiZWxvdyByZWd1bGFyIGV4cHJlc3Npb24gbGFiZWwnXG4gICAgKTtcblxuICAgIHJ4LnZhbHVlLlByaW1pdGl2ZUxhYmVsID0gbGJsO1xuICAgIGxldCByZXN1bHQgPSBzdHJpbmcudmFsdWUuc2VhcmNoKHJ4LnZhbHVlLlByaW1pdGl2ZVZhbHVlKTtcblxuICAgIHJldHVybiBuZXcgVmFsdWUocmVzdWx0LCBsYmwpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHNsaWNlLCAxNS41LjQuMTNcbmZ1bmN0aW9uIHNsaWNlKHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8c3RyaW5nPiB7XG4gICAgbGV0IGMgPSBtb25pdG9yLmNvbnRleHQ7XG5cbiAgICBsZXQgc3RhcnQgPSBhcmdzWzBdIHx8IG5ldyBWYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG4gICAgbGV0IGVuZCA9IGFyZ3NbMV0gfHwgbmV3IFZhbHVlKHVuZGVmaW5lZCwgYm90KTtcblxuICAgIENoZWNrT2JqZWN0Q29lcmNpYmxlKHRoaXNBcmcpO1xuICAgIGxldCBTID0gVG9TdHJpbmcodGhpc0FyZyk7XG4gICAgbGV0IGxlbiA9IFMudmFsdWUubGVuZ3RoO1xuXG4gICAgbGV0IGludFN0YXJ0ID0gVG9JbnRlZ2VyKHN0YXJ0KTtcblxuICAgIGMucHVzaFBDKGVuZC5sYWJlbCk7XG4gICAgbGV0IGludEVuZCA6IFZhbHVlPG51bWJlcj47XG4gICAgaWYgKGVuZC52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGludEVuZCA9IG5ldyBWYWx1ZShsZW4sIGx1YihTLmxhYmVsLCBlbmQubGFiZWwpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpbnRFbmQgPSBUb0ludGVnZXIoZW5kKTtcbiAgICB9XG4gICAgYy5wb3BQQygpO1xuXG4gICAgbGV0IHN0ciA9IFMudmFsdWUuc2xpY2UoaW50U3RhcnQudmFsdWUsIGludEVuZC52YWx1ZSk7XG4gICAgbGV0IGxibCA9IGx1YihTLmxhYmVsLCBpbnRTdGFydC5sYWJlbCwgaW50RW5kLmxhYmVsKTtcbiAgICByZXR1cm4gbmV3IFZhbHVlKHN0ciwgbGJsKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBzcGxpdCwgMTUuNS40LjE0XG5mdW5jdGlvbiBzcGxpdCh0aGlzQXJnOiBWYWx1ZTxWYWx1ZVR5cGVzPiwgYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPEFycmF5T2JqZWN0PiB7XG4gICAgbGV0IGFyZzAgPSBhcmdzWzBdIHx8IG5ldyBWYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG4gICAgbGV0IGFyZzEgPSBhcmdzWzFdIHx8IG5ldyBWYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG5cbiAgICBDaGVja09iamVjdENvZXJjaWJsZSh0aGlzQXJnKTtcbiAgICBsZXQgUyA9IFRvU3RyaW5nKHRoaXNBcmcpO1xuXG4gICAgbGV0IGxpbWl0IDpudW1iZXI7XG4gICAgbGV0IGxibCA9IGx1YihTLmxhYmVsLCBhcmcwLmxhYmVsKTtcbiAgICBpZiAoYXJnMS52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxibCA9IGx1YihsYmwsIGFyZzEubGFiZWwpO1xuICAgICAgICBsaW1pdCA9IDQyOTQ5NjcyOTU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGludExpbWl0ID0gVG9JbnQzMihhcmcxKTtcbiAgICAgICAgbGJsID0gbHViKGxibCwgaW50TGltaXQubGFiZWwpO1xuICAgICAgICBsaW1pdCA9IGludExpbWl0LnZhbHVlO1xuICAgIH1cblxuICAgIGxldCBzZXBhcmF0b3IgOiBSZWdFeHAgfCBzdHJpbmc7XG4gICAgaWYgKGFyZzAudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZXBhcmF0b3IgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmIChJc1JlZ0V4cE9iamVjdChhcmcwKSkge1xuICAgICAgICBzZXBhcmF0b3IgPSBhcmcwLnZhbHVlLlByaW1pdGl2ZVZhbHVlO1xuXG4gICAgICAgIG1vbml0b3IuYXNzZXJ0KFxuICAgICAgICAgICAgbGUoYXJnMC5sYWJlbCwgYXJnMC52YWx1ZS5QcmltaXRpdmVMYWJlbCksXG4gICAgICAgICAgICAnU3RyaW5nLnByb3RvdHlwZS5zcGxpdDogbGFiZWwgb2YgcmVndWxhciBleHByZXNzaW9uIG9iamVjdCBub3QgYmVsb3cgbGFiZWwgb2YgcmVndWxhciBleHByZXNzaW9uJ1xuICAgICAgICApO1xuXG4gICAgICAgIGFyZzAudmFsdWUuUHJpbWl0aXZlTGFiZWwgPSBsYmw7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHN0cmluZ1NlcGFyYXRvciA9IFRvU3RyaW5nKGFyZzApO1xuICAgICAgICBzZXBhcmF0b3IgPSBzdHJpbmdTZXBhcmF0b3IudmFsdWU7XG4gICAgICAgIGxibCA9IGx1YihsYmwsIHN0cmluZ1NlcGFyYXRvci5sYWJlbCk7XG4gICAgfVxuXG4gICAgbGV0IHByaW1pdGl2ZUFycmF5ID0gUy52YWx1ZS5zcGxpdChzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICBsZXQgYXJyYXkgPSBBcnJheU9iamVjdC5mcm9tQXJyYXkocHJpbWl0aXZlQXJyYXksIGxibCwgbGJsKTtcbiAgICByZXR1cm4gbmV3IFZhbHVlKGFycmF5LCBib3QpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHN1YnN0cmluZywgMTUuNS40LjE1XG5mdW5jdGlvbiBzdWJzdHJpbmcodGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxzdHJpbmc+IHtcbiAgICBsZXQgYXJnMCA9IGFyZ3NbMF0gfHwgbmV3IFZhbHVlKHVuZGVmaW5lZCwgYm90KTtcbiAgICBsZXQgYXJnMSA9IGFyZ3NbMV0gfHwgbmV3IFZhbHVlKHVuZGVmaW5lZCwgYm90KTtcblxuICAgIENoZWNrT2JqZWN0Q29lcmNpYmxlKHRoaXNBcmcpO1xuICAgIGxldCBTID0gVG9TdHJpbmcodGhpc0FyZyk7XG4gICAgbGV0IHN0YXJ0ID0gVG9JbnRlZ2VyKGFyZzApO1xuXG4gICAgbGV0IGxlbiA9IFMudmFsdWUubGVuZ3RoO1xuICAgIGxldCBlbmQgOiBWYWx1ZTxudW1iZXI+O1xuXG4gICAgaWYgKGFyZzEudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlbmQgPSBuZXcgVmFsdWUobGVuLCBhcmcxLmxhYmVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBlbmQgPSBUb0ludGVnZXIoYXJnMSk7XG4gICAgfVxuXG4gICAgbGV0IGxibCA9IGx1YihTLmxhYmVsLCBzdGFydC5sYWJlbCwgZW5kLmxhYmVsKTtcbiAgICBsZXQgc3RyID0gUy52YWx1ZS5zdWJzdHJpbmcoc3RhcnQudmFsdWUsIGVuZC52YWx1ZSk7XG4gICAgcmV0dXJuIG5ldyBWYWx1ZShzdHIsIGxibCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gc3Vic3RyKHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8c3RyaW5nPiB7XG4gICAgbGV0IGFyZzAgPSBhcmdzWzBdIHx8IG5ldyBWYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG4gICAgbGV0IGFyZzEgPSBhcmdzWzFdIHx8IG5ldyBWYWx1ZSh1bmRlZmluZWQsIGJvdCk7XG5cbiAgICBDaGVja09iamVjdENvZXJjaWJsZSh0aGlzQXJnKTtcbiAgICBsZXQgUyA9IFRvU3RyaW5nKHRoaXNBcmcpO1xuICAgIGxldCBzdGFydCA9IFRvSW50ZWdlcihhcmcwKTtcblxuICAgIGxldCBsZW4gPSBTLnZhbHVlLmxlbmd0aDtcbiAgICBsZXQgZW5kIDogVmFsdWU8bnVtYmVyPjtcblxuICAgIGlmIChhcmcxLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZW5kID0gbmV3IFZhbHVlKGxlbiwgYXJnMS5sYWJlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZW5kID0gVG9JbnRlZ2VyKGFyZzEpO1xuICAgIH1cblxuICAgIGxldCBsYmwgPSBsdWIoUy5sYWJlbCwgc3RhcnQubGFiZWwsIGVuZC5sYWJlbCk7XG4gICAgbGV0IHN0ciA9IFMudmFsdWUuc3Vic3RyKHN0YXJ0LnZhbHVlLCBlbmQudmFsdWUpO1xuXG4gICAgcmV0dXJuIG5ldyBWYWx1ZShzdHIsIGxibCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdG9Mb3dlckNhc2UsIDE1LjUuNC4xNlxuZnVuY3Rpb24gdG9Mb3dlckNhc2UodGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxzdHJpbmc+IHtcbiAgICBDaGVja09iamVjdENvZXJjaWJsZSh0aGlzQXJnKTtcbiAgICBsZXQgUyA9IFRvU3RyaW5nKHRoaXNBcmcpO1xuICAgIGxldCBMID0gUy52YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiBuZXcgVmFsdWUoTCwgUy5sYWJlbCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdG9Mb2NhbGVMb3dlckNhc2UsIDE1LjUuNC4xN1xuZnVuY3Rpb24gdG9Mb2NhbGVMb3dlckNhc2UodGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxzdHJpbmc+IHtcbiAgICBDaGVja09iamVjdENvZXJjaWJsZSh0aGlzQXJnKTtcbiAgICBsZXQgUyA9IFRvU3RyaW5nKHRoaXNBcmcpO1xuICAgIGxldCBMID0gUy52YWx1ZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgIHJldHVybiBuZXcgVmFsdWUoTCwgUy5sYWJlbCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdG9VcHBlckNhc2UsIDE1LjUuNC4xOFxuZnVuY3Rpb24gdG9VcHBlckNhc2UodGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxzdHJpbmc+IHtcbiAgICBDaGVja09iamVjdENvZXJjaWJsZSh0aGlzQXJnKTtcbiAgICBsZXQgUyA9IFRvU3RyaW5nKHRoaXNBcmcpO1xuICAgIGxldCBMID0gUy52YWx1ZS50b1VwcGVyQ2FzZSgpO1xuICAgIHJldHVybiBuZXcgVmFsdWUoTCwgUy5sYWJlbCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdG9Mb2NhbGVVcHBlckNhc2UsIDE1LjUuNC4xOVxuZnVuY3Rpb24gdG9Mb2NhbGVVcHBlckNhc2UodGhpc0FyZzogVmFsdWU8VmFsdWVUeXBlcz4sIGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxzdHJpbmc+IHtcbiAgICBDaGVja09iamVjdENvZXJjaWJsZSh0aGlzQXJnKTtcbiAgICBsZXQgUyA9IFRvU3RyaW5nKHRoaXNBcmcpO1xuICAgIGxldCBMID0gUy52YWx1ZS50b0xvY2FsZVVwcGVyQ2FzZSgpO1xuICAgIHJldHVybiBuZXcgVmFsdWUoTCwgUy5sYWJlbCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdHJpbSwgMTUuNS40LjIwXG5mdW5jdGlvbiB0cmltKHRoaXNBcmc6IFZhbHVlPFZhbHVlVHlwZXM+LCBhcmdzOiBWYWx1ZTxWYWx1ZVR5cGVzPltdKTogVmFsdWU8c3RyaW5nPiB7XG4gICAgQ2hlY2tPYmplY3RDb2VyY2libGUodGhpc0FyZyk7XG4gICAgbGV0IFMgPSBUb1N0cmluZyh0aGlzQXJnKTtcbiAgICBsZXQgVCA9IFMudmFsdWUudHJpbSgpO1xuICAgIHJldHVybiBuZXcgVmFsdWUoVCwgUy5sYWJlbCk7XG59IiwiaW1wb3J0IHsgRXJyb3JQcm90b3R5cGUgfSBmcm9tIFwiLi9FcnJvclByb3RvdHlwZVwiO1xuaW1wb3J0IHsgTW9uaXRvckJhc2UgfSBmcm9tIFwiLi4vTW9uaXRvckJhc2VcIjtcblxuZGVjbGFyZSB2YXIgbW9uaXRvcjogTW9uaXRvckJhc2U7XG5cbmV4cG9ydCBjbGFzcyBTeW50YXhFcnJvclByb3RvdHlwZSBleHRlbmRzIEVycm9yUHJvdG90eXBlIHtcblxuICAgIGNvbnN0cnVjdG9yKGhvc3QgOiBTeW50YXhFcnJvcikge1xuICAgICAgICBzdXBlcihob3N0KTtcbiAgICB9XG5cbiAgICBTZXR1cCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5TZXR1cEJhc2UobW9uaXRvci5pbnN0YW5jZXMuRXJyb3JDb25zdHJ1Y3RvciwgJ1N5bnRheEVycm9yJyk7XG4gICAgfVxuICAgIFxufSIsImltcG9ydCB7IEVycm9yUHJvdG90eXBlIH0gZnJvbSBcIi4vRXJyb3JQcm90b3R5cGVcIjtcbmltcG9ydCB7IE1vbml0b3JCYXNlIH0gZnJvbSBcIi4uL01vbml0b3JCYXNlXCI7XG5cbmRlY2xhcmUgdmFyIG1vbml0b3I6IE1vbml0b3JCYXNlO1xuXG5leHBvcnQgY2xhc3MgVHlwZUVycm9yUHJvdG90eXBlIGV4dGVuZHMgRXJyb3JQcm90b3R5cGUge1xuXG4gICAgY29uc3RydWN0b3IoaG9zdCA6IFR5cGVFcnJvcikge1xuICAgICAgICBzdXBlcihob3N0KTtcbiAgICB9XG5cbiAgICBTZXR1cCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5TZXR1cEJhc2UobW9uaXRvci5pbnN0YW5jZXMuRXJyb3JDb25zdHJ1Y3RvciwgJ1R5cGVFcnJvcicpO1xuICAgIH1cbiAgICBcbn0iLCJpbXBvcnQgeyBFcnJvclByb3RvdHlwZSB9IGZyb20gXCIuL0Vycm9yUHJvdG90eXBlXCI7XG5pbXBvcnQgeyBNb25pdG9yQmFzZSB9IGZyb20gXCIuLi9Nb25pdG9yQmFzZVwiO1xuXG5kZWNsYXJlIHZhciBtb25pdG9yOiBNb25pdG9yQmFzZTtcblxuZXhwb3J0IGNsYXNzIFVSSUVycm9yUHJvdG90eXBlIGV4dGVuZHMgRXJyb3JQcm90b3R5cGUge1xuXG4gICAgY29uc3RydWN0b3IoaG9zdCA6IFVSSUVycm9yKSB7XG4gICAgICAgIHN1cGVyKGhvc3QpO1xuICAgIH1cblxuICAgIFNldHVwKCk6IHZvaWQge1xuICAgICAgICB0aGlzLlNldHVwQmFzZShtb25pdG9yLmluc3RhbmNlcy5FcnJvckNvbnN0cnVjdG9yLCAnVVJJRXJyb3InKTtcbiAgICB9XG4gICAgXG59IiwiaW1wb3J0IHsgUmVmZXJlbmNlIH0gZnJvbSBcIi4vUmVmZXJlbmNlXCI7XG5pbXBvcnQgeyBUb09iamVjdCB9IGZyb20gJy4vQ29udmVyc2lvbi9Ub09iamVjdCc7XG5pbXBvcnQgeyBsdWIgfSBmcm9tICcuL0xhYmVsJztcbmltcG9ydCB7IElzRGF0YURlc2NyaXB0b3IsIElzQWNjZXNzb3JEZXNjcmlwdG9yIH0gZnJvbSAnLi9Qcm9wZXJ0eURlc2NyaXB0b3InO1xuaW1wb3J0IHsgTW9uaXRvckJhc2UgfSBmcm9tIFwiLi9Nb25pdG9yQmFzZVwiO1xuaW1wb3J0IHsgVmFsdWUgfSBmcm9tIFwiLi9WYWx1ZVwiO1xuaW1wb3J0IHsgVmFsdWVUeXBlcyB9IGZyb20gXCIuL0ludGVyZmFjZXNcIjtcblxuZGVjbGFyZSB2YXIgbW9uaXRvcjogTW9uaXRvckJhc2U7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHV0VmFsdWVcblxuZXhwb3J0IGZ1bmN0aW9uIFB1dFZhbHVlKHIgOiBSZWZlcmVuY2UsIHYgOiBWYWx1ZTxWYWx1ZVR5cGVzPikgOiB2b2lkIHtcbiAgXG4gICAgaWYgKCEociBpbnN0YW5jZW9mIFJlZmVyZW5jZSkpIHtcbiAgICAgIG1vbml0b3IuVGhyb3coXG4gICAgICAgIFwiUmVmZXJlbmNlRXJyb3JcIixcbiAgICAgICAgJ1B1dFZhbHVlOiB0YXJnZXQgaXMgbm90IGEgcmVmZXJlbmNlJyxcbiAgICAgICAgLy9AdHMtaWdub3JlIFRZUEVTXG4gICAgICAgIHIubGFiZWxcbiAgICAgICk7XG5cbiAgICAgIHRocm93IFwiVFMgZG9lc24ndCBrbm93IG1vbml0b3IuVGhyb3cgdGhyb3dzXCI7XG4gICAgfVxuICBcbiAgICBsZXQgcCA9IHIuYmFzZTtcbiAgICBsZXQgcyA9IHIucHJvcGVydHlOYW1lO1xuICBcbiAgICBpZiAoci5Jc1VucmVzb2x2YWJsZVJlZmVyZW5jZSgpKSB7XG4gICAgICBwLnZhbHVlID0gbW9uaXRvci5HbG9iYWxPYmplY3Q7XG4gICAgICBwLlB1dChzLCB2KTtcbiAgICB9IGVsc2UgaWYgKHIuSXNQcm9wZXJ0eVJlZmVyZW5jZSgpKSB7XG4gICAgICBpZiAoci5IYXNQcmltaXRpdmVCYXNlKCkpIHtcbiAgICAgICAgbGV0IG8gPSBUb09iamVjdChwKTtcbiAgICAgICAgaWYgKCFvLkNhblB1dChzKS52YWx1ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICBcbiAgICAgICAgbGV0IG93bkRlc2MgPSBvLkdldE93blByb3BlcnR5KHMpO1xuICAgICAgICBpZiAob3duRGVzYy52YWx1ZSAmJiBJc0RhdGFEZXNjcmlwdG9yKG93bkRlc2MudmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gIFxuICAgICAgICAvLyBUT0RPOiB0aGlzIG11c3QgYmUgd3Jvbmc7IHBhcnQgb2Ygb2xkIGhhbmRsaW5nIG9mIGdldHRlci9zZXR0ZXJzP1xuICAgICAgICBsZXQgZGVzYyA9IG8uR2V0UHJvcGVydHkocyk7XG4gICAgICAgIGlmIChkZXNjLnZhbHVlICYmIElzQWNjZXNzb3JEZXNjcmlwdG9yKGRlc2MudmFsdWUpKSB7XG4gICAgICAgICAgbW9uaXRvci5jb250ZXh0LnB1c2hQQyhsdWIob3duRGVzYy5sYWJlbCwgZGVzYy5sYWJlbCkpOyAvLyBjb250YWlucyBvLmxhYmVsXG4gICAgICAgICAgLy9AdHMtaWdub3JlIFRZUEVTXG4gICAgICAgICAgZGVzYy52YWx1ZS5TZXQuQ2FsbChwLCBbdl0pO1xuICAgICAgICAgIG1vbml0b3IuY29udGV4dC5wb3BQQygpO1xuICAgICAgICB9XG4gIFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcC5QdXQocywgdik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHAuU2V0TXV0YWJsZUJpbmRpbmcocywgdik7XG4gICAgfVxuICB9IiwiaW1wb3J0IHsgVmFsdWUgfSBmcm9tIFwiLi9WYWx1ZVwiO1xuaW1wb3J0IHsgRWNtYU9iamVjdCB9IGZyb20gJy4vT2JqZWN0cy9FY21hT2JqZWN0JztcbmltcG9ydCB7IERlY2xhcmF0aXZlRW52aXJvbm1lbnRSZWNvcmQgfSBmcm9tIFwiLi9EZWNsYXJhdGl2ZUVudmlyb25tZW50UmVjb3JkXCI7XG5pbXBvcnQgeyBPYmplY3RFbnZpcm9ubWVudFJlY29yZCB9IGZyb20gXCIuL09iamVjdEVudmlyb25tZW50UmVjb3JkXCI7XG5cbmV4cG9ydCB0eXBlIFJlZmVyZW5jZVR5cGUgPSB1bmRlZmluZWQgfCBib29sZWFuIHwgc3RyaW5nIHwgbnVtYmVyIHwgRWNtYU9iamVjdCB8IERlY2xhcmF0aXZlRW52aXJvbm1lbnRSZWNvcmQgfCBPYmplY3RFbnZpcm9ubWVudFJlY29yZDtcblxuZXhwb3J0IGNsYXNzIFJlZmVyZW5jZSB7XG5cbiAgICBiYXNlOiBWYWx1ZTxSZWZlcmVuY2VUeXBlPjtcbiAgICBwcm9wZXJ0eU5hbWU6IFZhbHVlPHN0cmluZz47XG5cbiAgICBjb25zdHJ1Y3RvcihiYXNlIDogVmFsdWU8UmVmZXJlbmNlVHlwZT4sIHByb3BlcnR5TmFtZSA6IFZhbHVlPHN0cmluZz4pIHtcbiAgICAgICAgdGhpcy5iYXNlID0gYmFzZTtcbiAgICAgICAgdGhpcy5wcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWU7XG4gICAgfVxuXG4gICAgR2V0QmFzZSgpOiBWYWx1ZTxSZWZlcmVuY2VUeXBlPiB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2U7XG4gICAgfVxuXG4gICAgR2V0UmVmZXJlbmNlZE5hbWUoKTogVmFsdWU8c3RyaW5nPiB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BlcnR5TmFtZTtcbiAgICB9XG5cbiAgICBIYXNQcmltaXRpdmVCYXNlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdHlwZW9mIHRoaXMuYmFzZS52YWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICAgICB0eXBlb2YgdGhpcy5iYXNlLnZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgdHlwZW9mIHRoaXMuYmFzZS52YWx1ZSA9PT0gJ251bWJlcidcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBJc1Byb3BlcnR5UmVmZXJlbmNlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdHlwZW9mIHRoaXMuYmFzZS52YWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICAgICB0eXBlb2YgdGhpcy5iYXNlLnZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgdHlwZW9mIHRoaXMuYmFzZS52YWx1ZSA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgICAgIHRoaXMuYmFzZS52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIFwiQ2xhc3NcIiBpbiB0aGlzLmJhc2UudmFsdWVcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBJc1VucmVzb2x2YWJsZVJlZmVyZW5jZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmJhc2UudmFsdWUgPT09IHVuZGVmaW5lZCk7XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuICgnQCgnICsgdGhpcy5iYXNlICsgJywnICsgdGhpcy5wcm9wZXJ0eU5hbWUgKyAnKScpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IFZhbHVlIH0gZnJvbSBcIi4vVmFsdWVcIjtcbmltcG9ydCB7IFZhbHVlVHlwZXMgfSBmcm9tIFwiLi9JbnRlcmZhY2VzXCI7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVGhlIENvbXBsZXRpb24gU3BlY2lmaWNhdGlvbiBUeXBlLCA4LjlcblxuZXhwb3J0IHR5cGUgUmVzdWx0VHlwZSA9ICdub3JtYWwnIHwgJ2JyZWFrJyB8ICdjb250aW51ZScgfCAncmV0dXJuJyB8ICd0aHJvdydcblxuZXhwb3J0IGNsYXNzIFJlc3VsdCB7XG4gIHR5cGU6IFJlc3VsdFR5cGUgPSAnbm9ybWFsJztcbiAgdmFsdWU6IFZhbHVlPFZhbHVlVHlwZXM+IHwgbnVsbDtcbiAgdGFyZ2V0OiBzdHJpbmcgfCBudWxsID0gbnVsbDtcblxuICBjb25zdHJ1Y3Rvcih2YWx1ZT86IFZhbHVlPFZhbHVlVHlwZXM+KSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlIHx8IG51bGw7XG4gIH1cbn1cbiIsIi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uICovXG5cblxuZXhwb3J0IHR5cGUgU3RhY2tNYXJrZXIgPSB7IGxlbmd0aCA6IG51bWJlciB9O1xuXG4gZXhwb3J0IGNsYXNzIFN0YWNrPFQ+IHtcblxuICBjb250ZW50IDogVFtdO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY29udGVudCA9IFtdO1xuICB9XG5cbiAgcHVzaCh2IDogVCkgOiB2b2lkIHtcblxuICAgIHRoaXMuY29udGVudC5wdXNoKHYpO1xuICB9XG5cbiAgcG9wKCkgOiBUIHtcbiAgICBpZiAodGhpcy5jb250ZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbXB0eSBTdGFjaycpO1xuICAgIH1cblxuICAgIC8vQHRzLWlnbm9yZVxuICAgIHJldHVybiB0aGlzLmNvbnRlbnQucG9wKCk7XG4gIH1cblxuICBwZWVrKCkge1xuICAgIGlmICh0aGlzLmNvbnRlbnQubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VtcHR5IFN0YWNrJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRlbnRbdGhpcy5jb250ZW50Lmxlbmd0aCAtIDFdO1xuICB9XG5cbiAgZHVwKCkge1xuICAgIHRoaXMucHVzaCh0aGlzLnBlZWsoKSk7XG4gIH1cblxuICBtYXJrZXIoKSA6IFN0YWNrTWFya2VyIHtcbiAgICByZXR1cm4geyBsZW5ndGg6IHRoaXMuY29udGVudC5sZW5ndGggfTtcbiAgfVxuXG4gIHJlc2V0KG0gOiBTdGFja01hcmtlcikgOiB2b2lkIHtcbiAgICB0aGlzLmNvbnRlbnQubGVuZ3RoID0gbS5sZW5ndGg7XG4gIH1cblxuICBpdGVyKGY6ICh4OiBUKSA9PiB2b2lkICk6IHZvaWQge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNvbnRlbnQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGYodGhpcy5jb250ZW50W2ldKTtcbiAgICB9XG4gIH1cblxuICBtYXAoZjogKHggOiBUKSA9PiBULCBtIDogU3RhY2tNYXJrZXIpIDogdm9pZCB7XG4gICAgZm9yICh2YXIgaSA9IG0ubGVuZ3RoLCBsZW4gPSB0aGlzLmNvbnRlbnQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRoaXMuY29udGVudFtpXSA9IGYodGhpcy5jb250ZW50W2ldKTtcbiAgICB9XG4gIH1cblxuICBzaXplKCkgOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnQubGVuZ3RoO1xuICB9XG5cbiAgZW1wdHkoKSA6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnQubGVuZ3RoID09PSAwO1xuICB9XG5cbiAgdG9BcnJheSgpIDogVFtdIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50LnNsaWNlKDApO1xuICB9XG59XG4iLCJpbXBvcnQgKiBhcyBlc2NvZGVnZW4gZnJvbSAnZXNjb2RlZ2VuJztcbmltcG9ydCB7IENvbnRleHQgfSBmcm9tICcuL0NvbnRleHQnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gXG5cbmV4cG9ydCBjbGFzcyBTdGFja1RyYWNlIHtcblxuICAgIC8vIFRPRE86IGZpeFxuICAgIHRyYWNlIDogYW55W107XG5cbiAgICBjb25zdHJ1Y3RvcihzdGFjayA6IENvbnRleHRbXSkge1xuICAgICAgICB0aGlzLnRyYWNlID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBzdGFjay5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgbGV0IGNvbnRleHQgPSBzdGFja1tpXTtcblxuICAgICAgICAgICAgbGV0IHN0bXQgPSBjb250ZXh0LmNvZGVTdGFjay5zaXplKCkgPiAwID8gY29udGV4dC5jb2RlU3RhY2sucGVlaygpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHN0bXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGxvYyA9IHN0bXQubG9jO1xuICAgICAgICAgICAgbGV0IHNvdXJjZSA9IGxvYy5zb3VyY2U7XG4gICAgICAgICAgICB0aGlzLnRyYWNlLnB1c2goeyBvd25lcjogY29udGV4dC5vd25lciwgc291cmNlOiBzb3VyY2UsIGxvYzogbG9jLnN0YXJ0LCBzdG10OiBzdG10IH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG5cbiAgICAgICAgaWYgKHRoaXMudHJhY2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVzdWx0IDogc3RyaW5nO1xuXG4gICAgICAgIGxldCBsZW4gPSB0aGlzLnRyYWNlLmxlbmd0aDtcbiAgICAgICAgLy8gbGFzdCBlbnRyeSBjb250YWlucyBvZmZlbmRpbmcgY29tbWFuZFxuICAgICAgICBsZXQgbGFzdCA9IHRoaXMudHJhY2VbbGVuIC0gMV07XG5cbiAgICAgICAgcmVzdWx0ID0gbGFzdC5zb3VyY2UgKyAnOicgKyBsYXN0LmxvYy5saW5lICsgJzonICsgbGFzdC5sb2MuY29sdW1uICsgJ1xcbic7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdCArICcgICAgJyArIGVzY29kZWdlbi5nZW5lcmF0ZShsYXN0LnN0bXQpICsgJ1xcblxcbic7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IGxlbiAtIDI7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgdHIgPSB0aGlzLnRyYWNlW2ldO1xuICAgICAgICAgICAgaWYgKHRyLm93bmVyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ICsgJ2F0ICcgKyB0ci5vd25lciArICcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCArICcoJyArIHRyLnNvdXJjZSArICc6JyArIHRyLmxvYy5saW5lICsgJzonICsgdHIubG9jLmNvbHVtbiArICcpXFxuJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbiIsImltcG9ydCB7IEZ1bmN0aW9uT2JqZWN0IH0gZnJvbSBcIi4vT2JqZWN0cy9GdW5jdGlvbk9iamVjdFwiO1xuaW1wb3J0IHsgVmFsdWUgfSBmcm9tIFwiLi9WYWx1ZVwiO1xuaW1wb3J0IHsgYm90IH0gZnJvbSBcIi4vTGFiZWxcIjtcbmltcG9ydCB7IERlZmluZUZGRiB9IGZyb20gXCIuL0RlZmluZVwiO1xuaW1wb3J0ICogYXMgZXNwcmltYSBmcm9tICdlc3ByaW1hJztcbmltcG9ydCAqIGFzIGNvbnN0YW50cyBmcm9tICcuL0NvbnN0YW50cyc7XG5cbmltcG9ydCB7IE1vbml0b3JCYXNlIH0gZnJvbSBcIi4vTW9uaXRvckJhc2VcIjtcblxuZGVjbGFyZSB2YXIgbW9uaXRvcjogTW9uaXRvckJhc2U7XG5cblxuICAvLyAxMy4yLjNcbiAgZXhwb3J0IGNsYXNzIFRocm93VHlwZUVycm9yIGV4dGVuZHMgRnVuY3Rpb25PYmplY3Qge1xuXG4gICAgc3RhdGljIGluc3RhbmNlIDogVGhyb3dUeXBlRXJyb3I7XG4gICAgc3RhdGljIGdldCBJbnN0YW5jZSgpOiBUaHJvd1R5cGVFcnJvciB7XG4gICAgICAgIGlmIChUaHJvd1R5cGVFcnJvci5pbnN0YW5jZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBUaHJvd1R5cGVFcnJvci5pbnN0YW5jZSA9IG5ldyBUaHJvd1R5cGVFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBUaHJvd1R5cGVFcnJvci5pbnN0YW5jZTtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKFxuICAgICAgICBbXSxcbiAgICAgICAgLy9AdHMtaWdub3JlXG4gICAgICAgIGVzcHJpbWEucGFyc2UoXCIoZnVuY3Rpb24oKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoKTsgfSlcIikuYm9keVswXS5leHByZXNzaW9uLFxuICAgICAgICBuZXcgVmFsdWUobW9uaXRvci5HbG9iYWxFbnZpcm9ubWVudCwgYm90KVxuICAgICAgKTtcbiAgXG4gICAgICBEZWZpbmVGRkYodGhpcywgY29uc3RhbnRzLmxlbmd0aCwgMCk7XG4gICAgICB0aGlzLkV4dGVuc2libGUgPSBmYWxzZTtcbiAgICB9XG4gIH0iLCJpbXBvcnQgeyBNb25pdG9yQmFzZSB9IGZyb20gXCIuLi8uLi9Nb25pdG9yQmFzZVwiO1xuaW1wb3J0IHsgQ3Jhd2xlck1vbml0b3IgfSBmcm9tIFwiLi9DcmF3bGVyTW9uaXRvclwiO1xuXG5leHBvcnQgZnVuY3Rpb24gSXNDcmF3bGVyKG1vbml0b3IgOiBNb25pdG9yQmFzZSkgOiBtb25pdG9yIGlzIENyYXdsZXJNb25pdG9yIHtcbiAgICAvL0B0cy1pZ25vcmUgbW9uaXRvci5jcmF3bGVyIGlzIGEgYm9vbGVhbiBvcHRpb25cbiAgICByZXR1cm4gbW9uaXRvci5vcHRpb25zLmdldChcIm1vbml0b3IuY3Jhd2xlclwiKTtcbn0iLCJpbXBvcnQgeyBKU0Zsb3dNb25pdG9yIH0gZnJvbSAnLi9KU0Zsb3dNb25pdG9yJztcbmltcG9ydCAqIGFzIHNtcyBmcm9tICdzb3VyY2UtbWFwLXN1cHBvcnQnO1xuXG5cbmxldCBzbXMgPSByZXF1aXJlKCdzb3VyY2UtbWFwLXN1cHBvcnQnKTtcbnNtcy5pbnN0YWxsKCk7XG4vL0B0cy1pZ25vcmUgVFlQRVNcbmpzZmxvdy5tb25pdG9yID0gbmV3IEpTRmxvd01vbml0b3Iod2luZG93KTtcbi8vQHRzLWlnbm9yZSBUWVBFU1xuanNmbG93LnZlcnNpb24gPSBcIjEuMlwiO1xuIiwiaW1wb3J0IHsgTW9uaXRvckJhc2UgfSBmcm9tIFwiLi4vLi4vTW9uaXRvckJhc2VcIjtcbmltcG9ydCB7IEdsb2JhbE9iamVjdCB9IGZyb20gXCIuLi8uLi9PYmplY3RzL0dsb2JhbE9iamVjdFwiO1xuaW1wb3J0IHsgSW5zdGFuY2VzIH0gZnJvbSBcIi4uLy4uL0luc3RhbmNlc1wiO1xuaW1wb3J0IHsgVmFsdWUgfSBmcm9tIFwiLi4vLi4vVmFsdWVcIjtcbmltcG9ydCB7IGJvdCwgTGFiZWwgfSBmcm9tIFwiLi4vLi4vTGFiZWxcIjtcbmltcG9ydCB7IE5ld09iamVjdEVudmlyb25tZW50IH0gZnJvbSBcIi4uLy4uL09iamVjdEVudmlyb25tZW50UmVjb3JkXCI7XG5pbXBvcnQgeyBMZXhpY2FsRW52aXJvbm1lbnQgfSBmcm9tIFwiLi4vLi4vTGV4aWNhbEVudmlyb25tZW50XCI7XG5pbXBvcnQgeyBDb21tb25KU01vZHVsZSB9IGZyb20gXCIuLi8uLi9Nb2R1bGUvQ29tbW9uSlMvTW9kdWxlXCI7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjbGFzcyBKU0Zsb3dNb25pdG9yIGV4dGVuZHMgTW9uaXRvckJhc2Uge1xuXG4gICAgaW5zdGFuY2VzOiBJbnN0YW5jZXM7XG4gICAgR2xvYmFsT2JqZWN0OiBHbG9iYWxPYmplY3Q7XG4gICAgR2xvYmFsRW52aXJvbm1lbnQ6IExleGljYWxFbnZpcm9ubWVudDtcblxuICAgIG1vZHVsZSA6IENvbW1vbkpTTW9kdWxlO1xuXG4gICAgbGFiZWxCb3Q6IExhYmVsO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIGdsb2JhbDogYW55LFxuICAgICAgICBwcmludDogKC4uLnJlc3Q6IGFueVtdKSA9PiB2b2lkLFxuICAgICAgICBsb2c6ICguLi5yZXN0OiBhbnlbXSkgPT4gdm9pZCxcbiAgICAgICAgaW5mbzogKC4uLnJlc3Q6IGFueVtdKSA9PiB2b2lkLFxuICAgICAgICB3YXJuOiAoLi4ucmVzdDogYW55W10pID0+IHZvaWQsXG4gICAgICAgIGVycm9yOiAoLi4ucmVzdDogYW55W10pID0+IHZvaWRcbiAgICApIHtcbiAgICAgICAgc3VwZXIoZ2xvYmFsLCBwcmludCwgbG9nLCBpbmZvLCB3YXJuLCBlcnJvcik7XG5cbiAgICAgICAgdGhpcy5pbnN0YW5jZXMgPSBuZXcgSW5zdGFuY2VzKGdsb2JhbCk7XG4gICAgICAgIHRoaXMuaW5zdGFuY2VzLlNldHVwKCk7XG5cbiAgICAgICAgdGhpcy5HbG9iYWxPYmplY3QgPSBuZXcgR2xvYmFsT2JqZWN0KGdsb2JhbCk7XG5cbiAgICAgICAgdGhpcy5HbG9iYWxFbnZpcm9ubWVudCA9IE5ld09iamVjdEVudmlyb25tZW50KG5ldyBWYWx1ZSh0aGlzLkdsb2JhbE9iamVjdCwgYm90KSwgbmV3IFZhbHVlKG51bGwsIGJvdCkpO1xuICAgICAgICB0aGlzLmNvbnRleHQudGhpc1ZhbHVlID0gbmV3IFZhbHVlKHRoaXMuR2xvYmFsT2JqZWN0LCBib3QpO1xuICAgICAgICB0aGlzLmNvbnRleHQudmFyaWFibGVFbnYgPSBuZXcgVmFsdWUodGhpcy5HbG9iYWxFbnZpcm9ubWVudCwgYm90KTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmxleGljYWxFbnYgPSBuZXcgVmFsdWUodGhpcy5HbG9iYWxFbnZpcm9ubWVudCwgYm90KTtcblxuICAgICAgICB0aGlzLm1vZHVsZSA9IG5ldyBDb21tb25KU01vZHVsZSgpO1xuICAgICAgICB0aGlzLkdsb2JhbE9iamVjdC5QdXQobmV3IFZhbHVlKCdtb2R1bGUnLCBib3QpLCBuZXcgVmFsdWUodGhpcy5tb2R1bGUsIGJvdCksIGZhbHNlKTtcbiAgICAgICAgdGhpcy5HbG9iYWxPYmplY3QuUHV0KG5ldyBWYWx1ZSgncmVxdWlyZScsIGJvdCksIG5ldyBWYWx1ZSh0aGlzLm1vZHVsZS5yZXF1aXJlLCBib3QpLCBmYWxzZSk7XG5cbiAgICAgICAgdGhpcy5sYWJlbEJvdCA9IGJvdDtcbiAgICB9XG5cbiAgICBFeGVjdXRlTW9kdWxlKHBhdGggOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgQ29tbW9uSlNNb2R1bGUuTG9hZE1vZHVsZShuZXcgVmFsdWUocGF0aCwgYm90KSk7XG4gICAgfVxuXG59IiwiaW1wb3J0IHsgTW9uaXRvckJhc2UgfSBmcm9tICcuLi9Nb25pdG9yQmFzZSc7XG5pbXBvcnQgeyBWYWx1ZSB9IGZyb20gJy4uL1ZhbHVlJztcbmltcG9ydCB7IFZhbHVlVHlwZXMsIElFY21hT2JqZWN0LCBJRWNtYUZ1bmN0aW9uIH0gZnJvbSAnLi4vSW50ZXJmYWNlcyc7XG5cbmRlY2xhcmUgdmFyIG1vbml0b3I6IE1vbml0b3JCYXNlO1xuIFxuIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gQ2hlY2tPYmplY3RDb2VyY2libGUsIDkuMTBcblxuICBleHBvcnQgZnVuY3Rpb24gQ2hlY2tPYmplY3RDb2VyY2libGUoeCA6IFZhbHVlPFZhbHVlVHlwZXM+KSAgOiB4IGlzIFZhbHVlPGJvb2xlYW4gfCBudW1iZXIgfCBzdHJpbmcgfCBJRWNtYU9iamVjdCB8IElFY21hRnVuY3Rpb24+IHtcbiAgICBpZiAoeC52YWx1ZSA9PT0gbnVsbCB8fCB4LnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIFxuICAgICAgbW9uaXRvci5jb250ZXh0LnJhaXNlUEMoeC5sYWJlbCk7XG5cbiAgICAgIG1vbml0b3IuVGhyb3coXG4gICAgICAgIFwiVHlwZUVycm9yXCIsXG4gICAgICAgIFN0cmluZyh4LnZhbHVlKSArICcgaXMgbm90IGNvZXJjaWJsZScsXG4gICAgICAgIHgubGFiZWxcbiAgICAgICk7XG5cbiAgICAgIHRocm93ICdUeXBlU2NyaXB0JztcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSIsImltcG9ydCB7IFZhbHVlIH0gZnJvbSBcIi4uL1ZhbHVlXCI7XG5pbXBvcnQgeyBWYWx1ZVR5cGVzLCBJRWNtYUZ1bmN0aW9uIH0gZnJvbSBcIi4uL0ludGVyZmFjZXNcIjtcbmltcG9ydCB7IEVjbWFPYmplY3QgfSBmcm9tIFwiLi4vT2JqZWN0cy9FY21hT2JqZWN0XCI7XG5cbiAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIElzQ2FsbGFibGUsIDkuMTFcblxuICBleHBvcnQgZnVuY3Rpb24gSXNDYWxsYWJsZSh4IDogVmFsdWU8VmFsdWVUeXBlcz4pIDogeCBpcyBWYWx1ZTxJRWNtYUZ1bmN0aW9uPiB7XG4gICAgdmFyIGIgPSBmYWxzZTtcbiAgICBpZiAoeC52YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgeC52YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGIgPSAnQ2FsbCcgaW4geC52YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYjtcbiAgfVxuIiwiaW1wb3J0IHsgVmFsdWUgfSBmcm9tIFwiLi4vVmFsdWVcIjtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRVM2OiBJc0NvbnN0cnVjdG9yLCA3LjIuNFxuXG5leHBvcnQgZnVuY3Rpb24gSXNDb25zdHJ1Y3Rvcihhcmd1bWVudCA6IFZhbHVlPGFueT4pOiBib29sZWFuIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50LnZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFyZ3VtZW50LnZhbHVlLkNvbnN0cnVjdCAhPT0gdW5kZWZpbmVkO1xufSBcbiAgIiwiaW1wb3J0IHsgTGFiZWwsIGx1YiB9IGZyb20gXCIuL0xhYmVsXCI7XG5pbXBvcnQgeyBWYWx1ZVR5cGVzLCBQcmltaXRpdmVWYWx1ZVR5cGVzLCBJRWNtYUZ1bmN0aW9uLCBJRW52aXJvbm1lbnRSZWNvcmQsIElFY21hT2JqZWN0IH0gZnJvbSBcIi4vSW50ZXJmYWNlc1wiO1xuaW1wb3J0IHsgTGFiZWxlZFByb3BlcnR5RGVzY3JpcHRvciwgSlNGUHJvcGVydHlEZXNjcmlwdG9yIH0gZnJvbSBcIi4vUHJvcGVydHlEZXNjcmlwdG9yXCI7XG5cbmltcG9ydCB7IE1vbml0b3JCYXNlIH0gZnJvbSBcIi4vTW9uaXRvckJhc2VcIjtcbmRlY2xhcmUgdmFyIG1vbml0b3I6IE1vbml0b3JCYXNlO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFZhbHVlIC0gbGFiZWxlZCB2YWx1ZXNcblxuZXhwb3J0IGNsYXNzIFZhbHVlPFQ+IHtcbiAgcHVibGljIHZhbHVlOiBUO1xuICBwdWJsaWMgbGFiZWw6IExhYmVsO1xuICBjb25zdHJ1Y3Rvcih2YWx1ZTogVCwgbGFiZWw6IExhYmVsKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcbiAgICBpZiAobGFiZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsdWUgd2l0aCB1bmRlZmluZWQgbGFiZWxcIik7XG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgcmFpc2UobDogTGFiZWwpOiB2b2lkIHtcbiAgICB0aGlzLmxhYmVsID0gbHViKHRoaXMubGFiZWwsIGwpO1xuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgY2xvbmUoKTogVmFsdWU8VD4ge1xuICAgIHJldHVybiBuZXcgVmFsdWUodGhpcy52YWx1ZSwgdGhpcy5sYWJlbCk7XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICB0b1N0cmluZygpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMudmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gXCInXCIgKyB0aGlzLnZhbHVlICsgXCInX1wiICsgdGhpcy5sYWJlbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZSArIFwiX1wiICsgdGhpcy5sYWJlbDtcbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gRWNtYVxuICBHZXRPd25Qcm9wZXJ0eShzOiBWYWx1ZTxzdHJpbmcgfCBudW1iZXI+KTogVmFsdWU8TGFiZWxlZFByb3BlcnR5RGVzY3JpcHRvciB8IHVuZGVmaW5lZD4ge1xuICAgIGxldCB2YWx1ZSA9IDxJRWNtYU9iamVjdD48dW5rbm93bj50aGlzLnZhbHVlO1xuICAgIHJldHVybiBJbkNvbnRleHQodGhpcy5sYWJlbCwgKCkgPT4geyByZXR1cm4gdmFsdWUuR2V0T3duUHJvcGVydHkocyk7IH0pO1xuICB9XG4gIEdldFByb3BlcnR5KHM6IFZhbHVlPHN0cmluZyB8IG51bWJlcj4pOiBWYWx1ZTxMYWJlbGVkUHJvcGVydHlEZXNjcmlwdG9yIHwgdW5kZWZpbmVkPiB7XG4gICAgbGV0IHZhbHVlID0gPElFY21hT2JqZWN0Pjx1bmtub3duPnRoaXMudmFsdWU7XG4gICAgcmV0dXJuIEluQ29udGV4dCh0aGlzLmxhYmVsLCAoKSA9PiB7IHJldHVybiB2YWx1ZS5HZXRQcm9wZXJ0eShzKTsgfSk7XG4gIH1cbiAgR2V0KHM6IFZhbHVlPHN0cmluZyB8IG51bWJlcj4pOiBWYWx1ZTxWYWx1ZVR5cGVzPiB7XG4gICAgbGV0IHZhbHVlID0gPElFY21hT2JqZWN0Pjx1bmtub3duPnRoaXMudmFsdWU7XG4gICAgcmV0dXJuIEluQ29udGV4dCh0aGlzLmxhYmVsLCAoKSA9PiB7IHJldHVybiB2YWx1ZS5HZXQocyk7IH0pO1xuICB9XG4gIENhblB1dChwOiBWYWx1ZTxzdHJpbmcgfCBudW1iZXI+KTogVmFsdWU8Ym9vbGVhbj4ge1xuICAgIGxldCB2YWx1ZSA9IDxJRWNtYU9iamVjdD48dW5rbm93bj50aGlzLnZhbHVlO1xuICAgIHJldHVybiBJbkNvbnRleHQodGhpcy5sYWJlbCwgKCkgPT4geyByZXR1cm4gdmFsdWUuQ2FuUHV0KHApOyB9KTtcbiAgfVxuICBQdXQoczogVmFsdWU8c3RyaW5nIHwgbnVtYmVyPiwgdjogVmFsdWU8VmFsdWVUeXBlcz4sIFRocm93PzogYm9vbGVhbik6IHZvaWQge1xuICAgIGxldCB2YWx1ZSA9IDxJRWNtYU9iamVjdD48dW5rbm93bj50aGlzLnZhbHVlO1xuICAgIHJldHVybiBJbkNvbnRleHQodGhpcy5sYWJlbCwgKCkgPT4geyByZXR1cm4gdmFsdWUuUHV0KHMsIHYsIFRocm93KTsgfSk7XG4gIH1cbiAgSGFzUHJvcGVydHkoczogVmFsdWU8c3RyaW5nIHwgbnVtYmVyPik6IFZhbHVlPGJvb2xlYW4+IHtcbiAgICBsZXQgdmFsdWUgPSA8SUVjbWFPYmplY3Q+PHVua25vd24+dGhpcy52YWx1ZTtcbiAgICByZXR1cm4gSW5Db250ZXh0KHRoaXMubGFiZWwsICgpID0+IHsgcmV0dXJuIHZhbHVlLkhhc1Byb3BlcnR5KHMpOyB9KTtcbiAgfVxuICBEZWxldGUoczogVmFsdWU8c3RyaW5nIHwgbnVtYmVyPiwgVGhyb3c/OiBib29sZWFuKTogVmFsdWU8Ym9vbGVhbj4ge1xuICAgIGxldCB2YWx1ZSA9IDxJRWNtYU9iamVjdD48dW5rbm93bj50aGlzLnZhbHVlO1xuICAgIHJldHVybiBJbkNvbnRleHQodGhpcy5sYWJlbCwgKCkgPT4geyByZXR1cm4gdmFsdWUuRGVsZXRlKHMsIFRocm93KTsgfSk7XG4gIH1cbiAgRGVmYXVsdFZhbHVlKGhpbnQ/OiBcInN0cmluZ1wiIHwgXCJudW1iZXJcIik6IFZhbHVlPFByaW1pdGl2ZVZhbHVlVHlwZXM+IHtcbiAgICBsZXQgdmFsdWUgPSA8SUVjbWFPYmplY3Q+PHVua25vd24+dGhpcy52YWx1ZTtcbiAgICByZXR1cm4gSW5Db250ZXh0KHRoaXMubGFiZWwsICgpID0+IHsgcmV0dXJuIHZhbHVlLkRlZmF1bHRWYWx1ZShoaW50KTsgfSk7XG4gIH1cbiAgRGVmaW5lT3duUHJvcGVydHkoczogVmFsdWU8c3RyaW5nPiwgZGVzYzogSlNGUHJvcGVydHlEZXNjcmlwdG9yLCBUaHJvdz86IEJvb2xlYW4pOiBWYWx1ZTxib29sZWFuPiB7XG4gICAgbGV0IHZhbHVlID0gPElFY21hT2JqZWN0Pjx1bmtub3duPnRoaXMudmFsdWU7XG4gICAgcmV0dXJuIEluQ29udGV4dCh0aGlzLmxhYmVsLCAoKSA9PiB7IHJldHVybiB2YWx1ZS5EZWZpbmVPd25Qcm9wZXJ0eShzLCBkZXNjLCBUaHJvdyk7IH0pO1xuICB9XG5cbiAgLy8gLS0tXG4gIC8vIEZ1bmN0aW9uXG4gIEhhc0luc3RhbmNlKFY6IFZhbHVlPFZhbHVlVHlwZXM+KTogVmFsdWU8Ym9vbGVhbj4ge1xuICAgIGxldCB2YWx1ZSA9IDxJRWNtYUZ1bmN0aW9uPjx1bmtub3duPnRoaXMudmFsdWU7XG4gICAgcmV0dXJuIEluQ29udGV4dCh0aGlzLmxhYmVsLCAoKSA9PiB7IHJldHVybiB2YWx1ZS5IYXNJbnN0YW5jZShWKTsgfSk7XG4gIH1cbiAgQ2FsbCh0aGlzQXJnOiBWYWx1ZTxWYWx1ZVR5cGVzPiwgYXJnczogVmFsdWU8VmFsdWVUeXBlcz5bXSk6IFZhbHVlPFZhbHVlVHlwZXM+IHtcbiAgICBsZXQgdmFsdWUgPSA8SUVjbWFGdW5jdGlvbj48dW5rbm93bj50aGlzLnZhbHVlO1xuICAgIHJldHVybiBJbkNvbnRleHQodGhpcy5sYWJlbCwgKCkgPT4geyByZXR1cm4gdmFsdWUuQ2FsbCh0aGlzQXJnLCBhcmdzKTsgfSk7XG4gIH1cbiAgQ29uc3RydWN0KGFyZ3M6IFZhbHVlPFZhbHVlVHlwZXM+W10pOiBWYWx1ZTxJRWNtYU9iamVjdCB8IHVuZGVmaW5lZD4ge1xuICAgIGxldCB2YWx1ZSA9IDxJRWNtYUZ1bmN0aW9uPjx1bmtub3duPnRoaXMudmFsdWU7XG4gICAgcmV0dXJuIEluQ29udGV4dCh0aGlzLmxhYmVsLCAoKSA9PiB7IHJldHVybiB2YWx1ZS5Db25zdHJ1Y3QoYXJncyk7IH0pO1xuICB9XG4gIC8vIC0tLVxuICAvLyBPYmplY3RFbnZpcm9ubWVudFJlY29yZCwgRGVjbGFyYXRpdmVFbnZpcm9ubWVudFJlY29yZFxuICBIYXNCaW5kaW5nKHA6IFZhbHVlPHN0cmluZz4pOiBWYWx1ZTxib29sZWFuPiB7XG4gICAgbGV0IHZhbHVlID0gPElFbnZpcm9ubWVudFJlY29yZD48dW5rbm93bj50aGlzLnZhbHVlO1xuICAgIHJldHVybiBJbkNvbnRleHQodGhpcy5sYWJlbCwgKCkgPT4geyByZXR1cm4gdmFsdWUuSGFzQmluZGluZyhwKTsgfSk7XG4gIH1cbiAgQ3JlYXRlTXV0YWJsZUJpbmRpbmcocDogVmFsdWU8c3RyaW5nPiwgZDogYm9vbGVhbik6IHZvaWQge1xuICAgIGxldCB2YWx1ZSA9IDxJRW52aXJvbm1lbnRSZWNvcmQ+PHVua25vd24+dGhpcy52YWx1ZTtcbiAgICByZXR1cm4gSW5Db250ZXh0KHRoaXMubGFiZWwsICgpID0+IHsgcmV0dXJuIHZhbHVlLkNyZWF0ZU11dGFibGVCaW5kaW5nKHAsIGQpOyB9KTtcbiAgfVxuICBHZXRCaW5kaW5nVmFsdWUocDogVmFsdWU8c3RyaW5nPiwgcz86IGJvb2xlYW4pOiBWYWx1ZTxWYWx1ZVR5cGVzPiB7XG4gICAgbGV0IHZhbHVlID0gPElFbnZpcm9ubWVudFJlY29yZD48dW5rbm93bj50aGlzLnZhbHVlO1xuICAgIHJldHVybiBJbkNvbnRleHQodGhpcy5sYWJlbCwgKCkgPT4geyByZXR1cm4gdmFsdWUuR2V0QmluZGluZ1ZhbHVlKHAsIHMpOyB9KTtcbiAgfVxuICBTZXRNdXRhYmxlQmluZGluZyhwOiBWYWx1ZTxzdHJpbmc+LCB2OiBWYWx1ZTxWYWx1ZVR5cGVzPiwgcz86IGJvb2xlYW4pOiB2b2lkIHtcbiAgICBsZXQgdmFsdWUgPSA8SUVudmlyb25tZW50UmVjb3JkPjx1bmtub3duPnRoaXMudmFsdWU7XG4gICAgcmV0dXJuIEluQ29udGV4dCh0aGlzLmxhYmVsLCAoKSA9PiB7IHJldHVybiB2YWx1ZS5TZXRNdXRhYmxlQmluZGluZyhwLCB2LCBzKTsgfSk7XG4gIH1cbiAgRGVsZXRlQmluZGluZyhwOiBWYWx1ZTxzdHJpbmc+KTogVmFsdWU8Ym9vbGVhbj4ge1xuICAgIGxldCB2YWx1ZSA9IDxJRW52aXJvbm1lbnRSZWNvcmQ+PHVua25vd24+dGhpcy52YWx1ZTtcbiAgICByZXR1cm4gSW5Db250ZXh0KHRoaXMubGFiZWwsICgpID0+IHsgcmV0dXJuIHZhbHVlLkRlbGV0ZUJpbmRpbmcocCk7IH0pO1xuICB9XG4gIEltcGxpY2l0VGhpc1ZhbHVlKCk6IFZhbHVlPElFY21hT2JqZWN0IHwgdW5kZWZpbmVkPiB7XG4gICAgbGV0IHZhbHVlID0gPElFbnZpcm9ubWVudFJlY29yZD48dW5rbm93bj50aGlzLnZhbHVlO1xuICAgIHJldHVybiBJbkNvbnRleHQodGhpcy5sYWJlbCwgKCkgPT4geyByZXR1cm4gdmFsdWUuSW1wbGljaXRUaGlzVmFsdWUoKTsgfSk7XG4gIH1cbiAgLy8gRGVjbGFyYXRpdmVFbnZpcm9ubWVudFJlY29yZFxuICBDcmVhdGVJbW11dGFibGVCaW5kaW5nKHA6IFZhbHVlPHN0cmluZz4pOiB2b2lkIHtcbiAgICBsZXQgdmFsdWUgPSA8YW55PnRoaXMudmFsdWU7XG4gICAgcmV0dXJuIEluQ29udGV4dCh0aGlzLmxhYmVsLCAoKSA9PiB7IHJldHVybiB2YWx1ZS5DcmVhdGVJbW11dGFibGVCaW5kaW5nKHApOyB9KTtcbiAgfVxuICBJbml0aWFsaXplSW1tdXRhYmxlQmluZGluZyhwOiBWYWx1ZTxzdHJpbmc+LCB2OiBWYWx1ZTxWYWx1ZVR5cGVzPik6IHZvaWQge1xuICAgIGxldCB2YWx1ZSA9IDxhbnk+dGhpcy52YWx1ZTtcbiAgICByZXR1cm4gSW5Db250ZXh0KHRoaXMubGFiZWwsICgpID0+IHsgcmV0dXJuIHZhbHVlLkluaXRpYWxpemVJbW11dGFibGVCaW5kaW5nKHAsIHYpOyB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBJbkNvbnRleHQ8VD4obDogTGFiZWwsIGY6ICgpID0+IFQpOiBUIHtcbiAgbW9uaXRvci5jb250ZXh0LnB1c2hQQyhsKTtcbiAgbGV0IHJlcyA9IGYoKTtcbiAgbW9uaXRvci5jb250ZXh0LnBvcFBDKCk7XG5cbiAgaWYgKHJlcyBpbnN0YW5jZW9mIFZhbHVlKSB7XG4gICAgcmVzLnJhaXNlKGwpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn1cbiJdfQ==
